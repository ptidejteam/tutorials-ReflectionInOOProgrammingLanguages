'From Squeak3.9 of 7 November 2006 [latest update: #7067] on 14 April 2014 at 5:09:14 pm'!!ASTCheckAssignment methodsFor: 'visitor-double dispatching' stamp: 'ms 5/8/2007 19:04'!acceptAssignmentNode: anAssignmentNode	anAssignmentNode variable = receiver 		ifTrue:[numberOfAssignment := numberOfAssignment + 1].	super acceptAssignmentNode: anAssignmentNode ! !!ASTCheckAssignment methodsFor: 'initialize-release' stamp: 'ms 5/8/2007 18:57'!initialize	numberOfAssignment := 0! !!ASTCheckAssignment methodsFor: 'initialize-release' stamp: 'ms 5/8/2007 19:05'!isAssagning	^numberOfAssignment > 0! !!ASTCheckAssignment methodsFor: 'accessing' stamp: 'ms 5/8/2007 18:56'!receiver: anObject	receiver := anObject! !!ASTCheckAssignment class methodsFor: 'as yet unclassified' stamp: 'ms 5/8/2007 18:59'!check: aRBNode assagnmentTo: aReceiver	^self new 		receiver: aReceiver;		visitNode: aRBNode; 		isAssagning! !!ASTCheckAssignmentTest methodsFor: 'tests' stamp: 'ms 5/8/2007 19:14'!testIsAssagning	| rbMethod |	rbMethod := SqueakParser parseMethod: 'foo | b | b:= 3'.	self assert: (ASTCheckAssignment check: rbMethod assagnmentTo: rbMethod body temporaries first).	rbMethod := SqueakParser parseMethod: 'foo | b | [b:= 3]'.	self assert: (ASTCheckAssignment check: rbMethod assagnmentTo: rbMethod body temporaries first)! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ajh 2/25/2003 19:43'!acceptArrayNode: anArrayNode 	anArrayNode statements do: [:each | self visitNode: each]! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ajh 3/11/2003 18:21'!acceptAssignmentNode: anAssignmentNode	| var |	self visitNode: anAssignmentNode value.	var _ (scope lookupVar: anAssignmentNode variable name)		ifNil: [self undeclaredVariable: anAssignmentNode variable].	var markWrite.	anAssignmentNode variable binding: var.! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ajh 6/25/2004 17:28'!acceptBlockNode: aBlockNode	aBlockNode isInlined ifTrue: [^ self acceptInlinedBlockNode: aBlockNode].	scope _ scope newFunctionScope.	aBlockNode scope: scope.	(scope addTemp: 'parent env') markArg. "first temp is receiver"	aBlockNode arguments do: [:node | (self declareVariableNode: node) markArg].	self visitNode: aBlockNode body.	scope _ scope popScope.! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'md 6/29/2005 12:20'!acceptDoItNode: aDoItNode	| doItReceiverName |	doItReceiverName := scope isInstanceScope		ifTrue: ['self']		ifFalse: [(scope rawVar: 'theContext')			ifNil: ['theContext']			ifNotNil: ['the context']].	scope := scope newMethodScope.	"hack for Bytesurgeon: inlined code is a doit, yet we want access to self "	aDoItNode byteSurgeon ifTrue: [(scope addTemp: 'self')].	aDoItNode scope: scope.	(scope addTemp: doItReceiverName) markArg. "first temp is receiver"	self visitNode: aDoItNode body.	scope := scope popScope.! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'md 11/11/2004 16:05'!acceptInlinedBlockNode: aBlockNode		aBlockNode arguments do: [:node | (self declareVariableNode: node) markWrite "given"].	self visitNode: aBlockNode body.! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'md 4/14/2007 00:36'!acceptMessageNode: aMessageNode	(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 		ifTrue: [self visitNode: aMessageNode receiver].	aMessageNode arguments do: [:each | self visitNode: each].	"aMessageNode binding:"		((scope lookupSelector: aMessageNode selector asString)			ifNil: [self undeclaredSelector: aMessageNode])! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ms 3/31/2007 18:38'!acceptMethodNode: aMethodNode	scope := scope newMethodScope.	aMethodNode scope: scope.	(scope addTemp: 'self') markArg.  "first temp is receiver"	aMethodNode arguments do: [:node | (self declareVariableNode: node) markArg].		aMethodNode pragmas do: [:each | self visitNode: each].	self visitNode: aMethodNode body.	scope _ scope outerScope.! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ms 11/11/2006 17:43'!acceptPragmaNode: aPragmaNode		aPragmaNode method addPragma: aPragmaNode pragma.	aPragmaNode isPrimitive ifTrue: [		aPragmaNode method primitiveNode: aPragmaNode primitive ]	! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ms 6/17/2007 00:30'!acceptReturnNode: aReturnNode	| var |	self visitNode: aReturnNode value.	var := scope lookupVar: 'top env'.  "nil var means local return"	var ifNotNil: [var markRead].	aReturnNode homeBinding: var.! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ms 7/22/2006 19:11'!acceptSequenceNode: aSequenceNode	aSequenceNode temporaries do: [:node | self declareVariableNode: node].	aSequenceNode statements do: [:each | self visitNode: each].	aSequenceNode temporaries do: [:node |		node binding isUnused ifTrue: [self unusedVariable: node]].! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'md 10/5/2007 14:28'!acceptVariableNode: aVariableNode	| var name |		name := aVariableNode name.	name = 'super' ifTrue: [name := 'self'].	var := (scope lookupVar: name)		ifNil: [self undeclaredVariable: aVariableNode].	var isUndefined		ifTrue: [self uninitializedVariable: aVariableNode].	var markRead.	aVariableNode binding: var.! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'md 11/11/2004 16:22'!declareVariableNode: aVariableNode	| name var |	name := aVariableNode name.	var := scope rawVar: name.	var ifNotNil: [		var scope = scope ifTrue: [			"Reuse same var"			var := scope lookupVar: name.		] ifFalse: [			"Create new var that shadows outer one"			self variable: aVariableNode shadows: var.			var := scope addTemp: name.		]	] ifNil: [		"new var"		var := scope addTemp: name.	].	aVariableNode binding: var.	^ var! !!ASTChecker methodsFor: 'initialize-release' stamp: 'ajh 6/23/2004 20:40'!initialize	scope _ GlobalScope new.  "in case never initialized"! !!ASTChecker methodsFor: 'initialize-release' stamp: 'ajh 2/26/2003 19:58'!scope: aSemScope	scope _ aSemScope! !!ASTChecker methodsFor: 'error handling' stamp: 'ajh 3/11/2003 22:46'!undeclaredSelector: messageNode	^ UndeclaredSelectorWarning new		messageNode: messageNode;		signal! !!ASTChecker methodsFor: 'error handling' stamp: 'ajh 3/11/2003 12:06'!undeclaredVariable: variableNode	^ UndeclaredVariableWarning new		variableNode: variableNode;		signal! !!ASTChecker methodsFor: 'error handling' stamp: 'ajh 3/12/2003 13:35'!uninitializedVariable: variableNode	^ UninitializedVariableWarning new		variableNode: variableNode;		signal! !!ASTChecker methodsFor: 'error handling' stamp: 'ajh 3/12/2003 14:10'!unusedVariable: variableNode	^ UnusedVariableWarning new		variableNode: variableNode;		signal! !!ASTChecker methodsFor: 'error handling' stamp: 'ajh 3/19/2003 13:33'!variable: variableNode shadows: semVar	^ ShadowVariableWarning new		variableNode: variableNode;		shadowedVar: semVar;		signal! !!ASTChecker commentStamp: 'ajh 6/23/2004 19:43' prior: 0!I visit each node in the abstract syntax tree while growing and shrinking a SemScope chain. Each method and block node is linked with its corresponding scope object, and each variable def and ref is linked with its corresponding ScopeVar. Exceptions are raised for undefined variable references and so on (see subclasses of SemanticWarning).!!ASTCommenter methodsFor: 'visitor-double dispatching' stamp: 'ms 9/20/2006 20:19'!acceptArrayNode: anArrayNode 	anArrayNode peekAfterComment.	anArrayNode peekBeforeComment.	super acceptArrayNode: anArrayNode.	anArrayNode peekInsideComment! !!ASTCommenter methodsFor: 'visitor-double dispatching' stamp: 'ms 9/20/2006 20:19'!acceptAssignmentNode: anAssignmentNode 	anAssignmentNode peekAfterComment.	anAssignmentNode peekBeforeComment.	super acceptAssignmentNode: anAssignmentNode.	anAssignmentNode peekInsideComment! !!ASTCommenter methodsFor: 'visitor-double dispatching' stamp: 'ms 9/20/2006 20:19'!acceptBlockNode: aBlockNode 	aBlockNode peekAfterComment.	aBlockNode peekBeforeComment.	super acceptBlockNode: aBlockNode.	aBlockNode peekInsideComment! !!ASTCommenter methodsFor: 'visitor-double dispatching' stamp: 'ms 9/20/2006 20:19'!acceptCascadeNode: aCascadeNode 	aCascadeNode peekAfterComment.	aCascadeNode peekBeforeComment.	aCascadeNode messages 		do: [:each | each arguments do: [:eachArg | self visitNode: eachArg]].	aCascadeNode messages first isBlock 		ifTrue: [self visitNode: aCascadeNode messages first body].	aCascadeNode peekInsideComment! !!ASTCommenter methodsFor: 'visitor-double dispatching' stamp: 'ms 9/20/2006 20:19'!acceptLiteralNode: aLiteralNode 	aLiteralNode peekAfterComment.	aLiteralNode peekBeforeComment.	aLiteralNode peekInsideComment! !!ASTCommenter methodsFor: 'visitor-double dispatching' stamp: 'ms 10/14/2006 15:41'!acceptMessageNode: aMessageNode 	aMessageNode peekAfterComment.	aMessageNode peekBeforeComment.	aMessageNode arguments do: [:each | self visitNode: each].	(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 		ifTrue: [self visitNode: aMessageNode receiver].	aMessageNode peekInsideComment! !!ASTCommenter methodsFor: 'visitor-double dispatching' stamp: 'ms 5/28/2007 11:58'!acceptMethodNode: aMethodNode	super visitMethodArguments: aMethodNode arguments.	aMethodNode peekAfterComment.	aMethodNode pragmas do: [:each | super visitNode: each].	super visitNode: aMethodNode body.	aMethodNode peekInsideComment.	aMethodNode peekBeforeComment! !!ASTCommenter methodsFor: 'visitor-double dispatching' stamp: 'ms 9/20/2006 20:19'!acceptPragmaNode: aPragmaNode 	aPragmaNode peekAfterComment.	aPragmaNode peekBeforeComment.	aPragmaNode peekInsideComment! !!ASTCommenter methodsFor: 'visitor-double dispatching' stamp: 'ms 9/20/2006 20:19'!acceptReturnNode: aReturnNode 	aReturnNode peekAfterComment.	aReturnNode peekBeforeComment.	super acceptReturnNode: aReturnNode.	aReturnNode peekInsideComment! !!ASTCommenter methodsFor: 'visitor-double dispatching' stamp: 'ms 9/20/2006 20:19'!acceptSequenceNode: aSequenceNode 	aSequenceNode peekAfterComment.	aSequenceNode temporaries ifNotEmpty: [aSequenceNode peekBeforeComment].	super acceptSequenceNode: aSequenceNode.	aSequenceNode temporaries ifEmpty: [aSequenceNode peekBeforeComment].	aSequenceNode peekInsideComment! !!ASTCommenter methodsFor: 'visitor-double dispatching' stamp: 'ms 9/20/2006 20:19'!acceptVariableNode: aVariableNode 	aVariableNode peekAfterComment.	aVariableNode peekBeforeComment.	aVariableNode peekInsideComment! !!ASTCommenter methodsFor: 'visitor-double dispatching' stamp: 'ms 9/20/2006 00:14'!visitMethodArguments: aNodeCollection	aNodeCollection reverse do: [:each | self visitNode: each]! !!ASTFixDecompileBlockScope methodsFor: 'visitor-double dispatching' stamp: 'ms 9/8/2007 15:34'!acceptBlockNode: aBlockNode	| tempsIndex tmpVar |	aBlockNode isInlined ifTrue: [		aBlockNode arguments do:[:each | 			tmpVar := each binding scope tempVarAt: each binding index.			tmpVar privUsage: each binding privUsage]].	fixVariables := stackBlock push: Dictionary new.	tempsIndex := IdentityDictionary new.		"Find the parent temporaries"	aBlockNode sequenceDefinedIn temporaries 		do: [:each | tempsIndex at: each binding put: each].		"Remove temporaries used outside the block"	aBlockNode body temporaries do: [:each |		tempsIndex at: each binding ifPresent: [:var |			fixVariables at: each put: var]].	fixVariables keys do: [:each | 		aBlockNode body temporaries: (aBlockNode body temporaries copyWithout: each)].		"Continue and it will fix all the varaibale node"	super acceptBlockNode: aBlockNode.	fixVariables := stackBlock pop.! !!ASTFixDecompileBlockScope methodsFor: 'visitor-double dispatching' stamp: 'ms 6/17/2007 03:05'!acceptVariableNode: aVariableNode		"Change the variable node to use the parent temporaries"	fixVariables at: aVariableNode 		ifPresent:[:newVar | 			aVariableNode identifierToken: (SqueakToken value:  newVar name start: 0).			aVariableNode binding: newVar binding].! !!ASTFixDecompileBlockScope methodsFor: 'initialize-release' stamp: 'ms 6/17/2007 02:28'!initialize	stackBlock := Stack new.	fixVariables := stackBlock push: Dictionary new.! !!ASTReplaceVariableScope methodsFor: 'visitor-double dispatching' stamp: 'ms 6/17/2007 02:37'!acceptBlockNode: aBlockNode	(aBlockNode arguments isEmpty and: [aBlockNode body temporaries isEmpty])		ifTrue: [super acceptBlockNode: aBlockNode]! !!ASTReplaceVariableScope methodsFor: 'visitor-double dispatching' stamp: 'ms 7/14/2007 22:14'!acceptVariableNode: aVariableNode		((scope isChildrenOf:  aVariableNode binding scope) 		or:[aVariableNode binding isContextVar]) ifTrue:[^self].	aVariableNode binding scope: scope.	aVariableNode binding: (scope tempVars 		detect:[:each | each = aVariableNode binding]		ifNone:[self error: aVariableNode name, ' can''t be found in this scope'])! !!ASTReplaceVariableScope methodsFor: 'accessing' stamp: 'ms 6/15/2007 12:12'!scope: aScope	scope := aScope! !!ASTReplaceVariableScope class methodsFor: 'as yet unclassified' stamp: 'ms 6/15/2007 12:13'!replace: aNode scope: aScope	self new		scope: aScope;		visitNode: aNode! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ms 10/30/2006 18:17'!acceptArrayNode: anArrayNode 	| elementNodes |	elementNodes := anArrayNode children.	elementNodes size <= 4 ifTrue: [		"Short form: Array braceWith: a with: b ..."		methodBuilder pushLiteralVariable: Array binding.		elementNodes do: [:node | valueTranslator visitNode: node].		methodBuilder send: (#(braceWithNone braceWith: braceWith:with: braceWith:with:with: braceWith:with:with:with:) at: elementNodes size + 1).	] ifFalse: [		"Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray"		methodBuilder pushLiteralVariable: Array binding.		methodBuilder pushLiteral: elementNodes size.		methodBuilder send: #braceStream:.		elementNodes do: [:node |			methodBuilder pushDup.			valueTranslator visitNode: node.			methodBuilder send: #nextPut:.			methodBuilder popTop.		].		methodBuilder send: #braceArray.	].! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ms 10/30/2006 18:44'!acceptAssignmentNode: anAssignmentNode 	valueTranslator visitNode: anAssignmentNode value.	anAssignmentNode variable binding emitStore: methodBuilder from: anAssignmentNode owningScope.! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ajh 2/25/2003 00:51'!acceptBlockNode: aBlockNode ! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ajh 3/10/2003 14:53'!acceptCascadeNode: aCascadeNode 	valueTranslator visitNode: aCascadeNode receiver.	aCascadeNode messages allButLastDo: [:node |		methodBuilder pushDup.		effectTranslator visitNode: node.	].	valueTranslator visitNode: aCascadeNode messages last.! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ms 7/3/2007 13:40'!acceptDoItNode: aDoItNode 	self emitPrologue: aDoItNode.	valueTranslator visitNode: aDoItNode body.	aDoItNode body lastIsReturn ifFalse: [methodBuilder returnTop]! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ajh 2/25/2003 13:23'!acceptMessageNode: aMessageNode 	aMessageNode isInlineIf ifTrue: [^ self emitIfNode: aMessageNode].	aMessageNode isInlineIfNil ifTrue: [^ self emitIfNilNode: aMessageNode].	aMessageNode isInlineAndOr ifTrue: [^ self emitAndOrNode: aMessageNode].	aMessageNode isInlineWhile ifTrue: [^ self emitWhileNode: aMessageNode].	aMessageNode isInlineToDo ifTrue: [^ self emitToDoNode: aMessageNode].	aMessageNode isInlineCase ifTrue: [^ self emitCaseNode: aMessageNode].	^ self emitMessageNode: aMessageNode! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ms 7/3/2007 13:36'!acceptMethodNode: aMethodNode	methodBuilder properties: aMethodNode properties.	methodBuilder primitiveNode: aMethodNode primitiveNode.	self emitPrologue: aMethodNode.	effectTranslator visitNode: aMethodNode body.	aMethodNode body lastIsReturn ifFalse: 		[methodBuilder pushReceiver; returnTop]! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ajh 7/8/2004 19:01'!acceptReturnNode: aReturnNode	valueTranslator visitNode: aReturnNode value.	aReturnNode homeBinding ifNil: [		methodBuilder returnTop.	] ifNotNil: [		aReturnNode homeBinding emitValue: methodBuilder from: aReturnNode owningScope.		methodBuilder remoteReturn.	].! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'md 3/17/2006 14:17'!acceptSequenceNode: aSequenceNode 	aSequenceNode statements allButLastDo: [:n | effectTranslator visitNode: n].	aSequenceNode statements notEmpty ifTrue: [self visitNode: aSequenceNode statements last].! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ms 7/3/2007 13:35'!emitPrologue: aBlockOrMethodNode	methodBuilder numRargs: aBlockOrMethodNode arguments size + 1.	methodBuilder addTemps: aBlockOrMethodNode scope tempVars.	aBlockOrMethodNode scope emitPrologue: methodBuilder.	! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ms 7/3/2007 13:35'!translateBlockNode: aBlockNode 	self emitPrologue: aBlockNode.	valueTranslator visitNode: aBlockNode body.	aBlockNode body lastIsReturn ifFalse: [methodBuilder returnTop]! !!ASTTranslator methodsFor: 'inline messages' stamp: 'ms 10/31/2006 11:39'!emitAndOrNode: aMessageNode	| arguments isOr |	isOr := aMessageNode selector beginsWith: #or:.	valueTranslator visitNode: aMessageNode receiver.	arguments := aMessageNode arguments.		arguments do: [ :each |		methodBuilder jumpAheadTo: #else if: isOr.		self visitNode: each body ].		self isValueTranslator ifTrue: [		methodBuilder jumpAheadTo: #end].		"there has to be a one-to-one correspondence between every jump and target"		arguments size timesRepeat: [ methodBuilder jumpAheadTarget: #else ].		self isValueTranslator ifTrue: [		methodBuilder pushLiteral: isOr.		methodBuilder jumpAheadTarget: #end.	].! !!ASTTranslator methodsFor: 'inline messages' stamp: 'pmm 7/20/2006 20:51'!emitCaseNode: aMessageNode	| cases assocMessageNode s |	cases _ aMessageNode arguments first statements.	valueTranslator visitNode: aMessageNode receiver.	1 to: cases size - 1 do: [:i |		methodBuilder pushDup.		assocMessageNode _ cases at: i.		valueTranslator visitNode: assocMessageNode receiver body.		methodBuilder send: #=.		methodBuilder jumpAheadTo: #next if: false.		methodBuilder popTop.		self visitNode: assocMessageNode arguments first body.		methodBuilder jumpAheadTo: #end.		methodBuilder jumpAheadTarget: #next.	].	aMessageNode arguments size = 2 ifTrue: [		"last case with otherwise"		assocMessageNode _ cases last.		valueTranslator visitNode: assocMessageNode receiver body.		methodBuilder send: #=.		methodBuilder jumpAheadTo: #next if: false.		self visitNode: assocMessageNode arguments first body.		methodBuilder jumpAheadTo: #end.		methodBuilder jumpAheadTarget: #next.		self visitNode: aMessageNode arguments last body.	] ifFalse: [		"last case without otherwise"		methodBuilder pushDup.		assocMessageNode _ cases last.		valueTranslator visitNode: assocMessageNode receiver body.		methodBuilder send: #=.		methodBuilder jumpAheadTo: #next if: false.		methodBuilder popTop.		self visitNode: assocMessageNode arguments first body.		methodBuilder jumpAheadTo: #end.		methodBuilder jumpAheadTarget: #next.		methodBuilder send: #caseError.		aMessageNode lastIsReturn ifTrue: [			(s _ aMessageNode owningScope) isBlockScope ifTrue: [				(s lookupVar: 'top env') emitValue: methodBuilder from: aMessageNode owningScope.				methodBuilder remoteReturn.			] ifFalse: [				methodBuilder returnTop.			]		] ifFalse: [			self isEffectTranslator ifTrue: [methodBuilder popTop].		].	].	"there has to be a one-to-one correspondence between every jump and target"		cases size timesRepeat: [methodBuilder jumpAheadTarget: #end].! !!ASTTranslator methodsFor: 'inline messages' stamp: 'ms 4/23/2007 17:39'!emitIfNilNode: aMessageNode	| args selector |	valueTranslator visitNode: aMessageNode receiver.	args := aMessageNode arguments.	(selector := aMessageNode selector) caseOf: {		[#ifNil:] -> [self isValueTranslator ifTrue: [methodBuilder pushDup]].		[#ifNil:ifNotNil:] -> [args last arguments ifNotEmpty: [args last arguments first binding emitLocalStore: methodBuilder]].		[#ifNotNil:] -> [args first arguments ifNotEmpty: [args first arguments first binding emitLocalStore: methodBuilder]].		[#ifNotNilDo:] -> [args first arguments ifNotEmpty: [args first arguments first binding emitLocalStore: methodBuilder]].		[#ifNotNil:ifNil:] -> [args first arguments ifNotEmpty: [args first arguments first binding emitLocalStore: methodBuilder]]	}.	methodBuilder pushLiteral: nil.	methodBuilder send: #==.	methodBuilder jumpAheadTo: #else if: (selector beginsWith: #ifNotNil).	(self == valueTranslator and: [selector == #ifNil:])		ifTrue: [methodBuilder popTop].	self visitNode: args first body.	(args size > 1 or: [self == valueTranslator and: [selector == #ifNotNil: or: [selector == #ifNotNilDo:]]])		ifTrue: [methodBuilder jumpAheadTo: #end].	methodBuilder jumpAheadTarget: #else.	(args size > 1 or: [self isValueTranslator and: [selector == #ifNotNil: or: [selector == #ifNotNilDo:]]]) ifTrue: [		args size > 1			ifTrue: [self visitNode: args last body]			ifFalse: [methodBuilder pushLiteral: nil].		methodBuilder jumpAheadTarget: #end.	].! !!ASTTranslator methodsFor: 'inline messages' stamp: 'pmm 7/19/2006 11:55'!emitIfNode: aMessageNode	| args |	valueTranslator visitNode: aMessageNode receiver.	methodBuilder jumpAheadTo: #else if: (aMessageNode selector beginsWith: #ifFalse:).	args _ aMessageNode arguments.	self visitNode: args first body.	(args size > 1 or: [self isValueTranslator]) ifTrue: [		methodBuilder jumpAheadTo: #end].	methodBuilder jumpAheadTarget: #else.	(args size > 1 or: [self isValueTranslator]) ifTrue: [		args size > 1			ifTrue: [self visitNode: args last body]			ifFalse: [methodBuilder pushLiteral: nil].		methodBuilder jumpAheadTarget: #end.	].! !!ASTTranslator methodsFor: 'inline messages' stamp: 'pmm 4/24/2006 22:31'!emitMessageNode: aMessageNode	aMessageNode isCascaded ifFalse: [		valueTranslator visitNode: aMessageNode receiver].	aMessageNode arguments do: [:each | 		valueTranslator visitNode: each].	aMessageNode isSuperSend		ifTrue: [methodBuilder send: aMessageNode selector toSuperOf: aMessageNode owningScope classEncoding]		ifFalse: [methodBuilder send: aMessageNode selector].! !!ASTTranslator methodsFor: 'inline messages' stamp: 'ms 5/8/2007 19:05'!emitToDoNode: aMessageNode	| limit step block iterator limitEmit |	limit := aMessageNode arguments first.	step := 1.	aMessageNode arguments size = 3 ifTrue: [		"to:by:do:"		step := aMessageNode arguments second.		step isLiteral ifFalse: [self error: 'should not have been inlined'].		step := step value.	].	block := aMessageNode arguments last.	"push start. allocate and initialize iterator"	valueTranslator visitNode: aMessageNode receiver.	iterator := block arguments first binding.	iterator emitLocalStore: methodBuilder.	"push limit, store in a temp if it's an expression or a changing variable"	valueTranslator visitNode: limit.	limitEmit := [valueTranslator visitNode: limit].	(limit isLiteral or: 	 [limit isVariable and:	  [ASTCheckAssignment check: block assagnmentTo: limit]]	) ifFalse: [		limit := {iterator. #limit}.  "must be unique throughout method"		methodBuilder addTemp: limit.		methodBuilder storeTemp: limit.		limitEmit := [methodBuilder pushTemp: limit].	].	"loop"	methodBuilder jumpBackTarget: #start.	methodBuilder send: (step > 0 ifTrue: [#<=] ifFalse: [#>=]).	methodBuilder jumpAheadTo: #done if: false.	effectTranslator visitNode: block body.	iterator emitLocalValue: methodBuilder.	methodBuilder pushLiteral: step.	methodBuilder send: #+.	iterator emitLocalStore: methodBuilder.	limitEmit value.	methodBuilder jumpBackTo: #start.	methodBuilder jumpAheadTarget: #done.! !!ASTTranslator methodsFor: 'inline messages' stamp: 'md 10/15/2004 12:37'!emitWhileNode: aMessageNode	methodBuilder jumpBackTarget: #begin.	valueTranslator visitNode: aMessageNode receiver body.	aMessageNode selector caseOf: {		[#whileTrue:]	-> [methodBuilder jumpAheadTo: #end if: false].		[#whileTrue]	-> [methodBuilder jumpAheadTo: #end if: false].		[#whileFalse:]	-> [methodBuilder jumpAheadTo: #end if: true].		[#whileFalse]	-> [methodBuilder jumpAheadTo: #end if: true]	}.	aMessageNode arguments ifNotEmpty: [		effectTranslator visitNode: aMessageNode arguments first body].	methodBuilder jumpBackTo: #begin.	methodBuilder jumpAheadTarget: #end.! !!ASTTranslator methodsFor: 'initialize' stamp: 'ms 10/31/2006 15:06'!initialize	methodBuilder := IRBuilder new.	effectTranslator := self as: ASTTranslatorForEffect.	valueTranslator := self as: ASTTranslatorForValue.	effectTranslator instVarNamed: #effectTranslator put: effectTranslator.	effectTranslator instVarNamed: #valueTranslator put: valueTranslator.	valueTranslator instVarNamed: #valueTranslator put: valueTranslator.! !!ASTTranslator methodsFor: 'accessing' stamp: 'ajh 3/10/2003 17:59'!ir	^ methodBuilder ir! !!ASTTranslator methodsFor: 'testing' stamp: 'pmm 7/19/2006 11:54'!isEffectTranslator	^self == effectTranslator! !!ASTTranslator methodsFor: 'testing' stamp: 'pmm 7/19/2006 11:52'!isValueTranslator	^self == valueTranslator! !!ASTTranslator methodsFor: 'visiting' stamp: 'ajh 3/2/2003 03:31'!visitNode: aNode	methodBuilder mapToNode: aNode.	super visitNode: aNode.	methodBuilder popMap.! !!ASTTranslator methodsFor: '*persephone' stamp: 'md 8/25/2007 16:18'!acceptInstrumentedAssignmentNode: anAssignmentNode 	valueTranslator visitNode: anAssignmentNode value.		self emitBefore: anAssignmentNode.		anAssignmentNode variable binding emitStore: methodBuilder from: anAssignmentNode owningScope.	self popAfterIntrsumentatation.		self emitAfter: anAssignmentNode.! !!ASTTranslator methodsFor: '*persephone' stamp: 'md 8/25/2007 16:10'!acceptInstrumentedMessageNode: aMessageNode	self flag: #todo. "inlining"	^ self emitInstrumentedMessageNode: aMessageNode! !!ASTTranslator methodsFor: '*persephone' stamp: 'md 8/25/2007 16:19'!acceptInstrumentedReturnNode: aReturnNode	valueTranslator visitNode: aReturnNode value.	self emitBefore: aReturnNode.	aReturnNode homeBinding ifNil: [		methodBuilder returnTop.	] ifNotNil: [		aReturnNode homeBinding emitValue: methodBuilder from: aReturnNode owningScope.		methodBuilder remoteReturn.	].! !!ASTTranslator methodsFor: '*persephone' stamp: 'md 8/25/2007 12:37'!emitAfter: anInstrumentedNode 	anInstrumentedNode after do: [ :each |		effectTranslator visitNode: each ]! !!ASTTranslator methodsFor: '*persephone' stamp: 'md 8/25/2007 12:37'!emitBefore: anInstrumentedNode 	anInstrumentedNode before do: [ :each |		effectTranslator visitNode: each ]! !!ASTTranslator methodsFor: '*persephone' stamp: 'md 8/25/2007 16:15'!emitInstrumentedMessageNode: aMessageNode	aMessageNode isCascaded ifFalse: [		valueTranslator visitNode: aMessageNode receiver].		aMessageNode arguments do: [:each | 		valueTranslator visitNode: each].		self emitBefore: aMessageNode.		aMessageNode isSuperSend		ifTrue: [methodBuilder send: aMessageNode selector toSuperOf: aMessageNode owningScope classEncoding]		ifFalse: [methodBuilder send: aMessageNode selector].			self popAfterIntrsumentatation.	self emitAfter: aMessageNode.! !!ASTTranslator methodsFor: '*persephone' stamp: 'md 8/25/2007 12:37'!popAfterIntrsumentatation	methodBuilder popTop! !!ASTTranslator commentStamp: 'ajh 3/24/2003 22:19' prior: 0!I visit an abstract syntax tree and generate IR (intermediate representation) instructions for each node by sending the appropriate message to my methodBuilder (an IRBuilder).  I hold onto my two subclasses one for generating instructions for value, the other for generating instructions for effect.!!ASTTranslatorForEffect methodsFor: 'visitor-double dispatching' stamp: 'ajh 3/10/2003 14:56'!acceptArrayNode: anArrayNode 	super acceptArrayNode: anArrayNode.	methodBuilder popTop.! !!ASTTranslatorForEffect methodsFor: 'visitor-double dispatching' stamp: 'md 7/26/2006 14:45'!acceptAssignmentNode: anAssignmentNode 	super acceptAssignmentNode: anAssignmentNode.	methodBuilder popTop. ! !!ASTTranslatorForEffect methodsFor: 'visitor-double dispatching' stamp: 'ajh 3/10/2003 14:56'!acceptCascadeNode: aCascadeNode 	super acceptCascadeNode: aCascadeNode.	methodBuilder popTop.! !!ASTTranslatorForEffect methodsFor: 'emit messages' stamp: 'ajh 3/10/2003 14:57'!emitMessageNode: aMessageNode 	super emitMessageNode: aMessageNode.	methodBuilder popTop.! !!ASTTranslatorForEffect commentStamp: 'ajh 3/24/2003 22:20' prior: 0!I override some methods in my super to generate instructions for effect only.!!ASTTranslatorForValue methodsFor: 'visitor-double dispatching' stamp: 'md 11/16/2004 15:14'!acceptBlockNode: aBlockNode 	| blockMethod args blockTemps |	Preferences compileBlocksAsClosures ifFalse: [	 		args := aBlockNode arguments collect: [:each | each binding].		blockTemps := aBlockNode body temporaries  collect: [:each | each binding].		methodBuilder addTemps: args.		methodBuilder addTemps: blockTemps.		methodBuilder pushThisContext.		methodBuilder pushLiteral: aBlockNode arguments size.		methodBuilder send: #blockCopy:.		methodBuilder jumpOverBlockTo: #jmp.     		args reverse do: [:arg | methodBuilder storeTemp: arg. methodBuilder popTop].		super visitNode: aBlockNode body.		aBlockNode body lastIsReturn ifFalse: [				methodBuilder blockReturnTop].		methodBuilder jumpAheadTarget: #jmp.	 ^self ].		blockMethod := aBlockNode generateIR.	aBlockNode freeVars isEmpty ifTrue: [		"Create block at compile time"		methodBuilder pushBlock: blockMethod.	] ifFalse: [		"Create block at run time"		| outerScope envVar |		outerScope := aBlockNode scope outerScope.		envVar := outerScope hasEscapingEnv			ifTrue: [outerScope thisEnvVar]			ifFalse: [outerScope receiverVar].		methodBuilder pushBlockMethod: blockMethod.		envVar emitLocalValue: methodBuilder.		methodBuilder send: #createBlock:.	].! !!ASTTranslatorForValue methodsFor: 'visitor-double dispatching' stamp: 'ajh 2/27/2003 18:18'!acceptLiteralNode: aLiteralNode	methodBuilder pushLiteral: aLiteralNode value.! !!ASTTranslatorForValue methodsFor: 'visitor-double dispatching' stamp: 'ajh 2/25/2003 18:21'!acceptSequenceNode: aSequenceNode 	super acceptSequenceNode: aSequenceNode.	aSequenceNode statements isEmpty ifTrue: [		methodBuilder pushLiteral: nil].! !!ASTTranslatorForValue methodsFor: 'visitor-double dispatching' stamp: 'md 10/15/2004 14:49'!acceptVariableNode: aVariableNode		aVariableNode binding emitValue: methodBuilder from: aVariableNode owningScope.		! !!ASTTranslatorForValue methodsFor: 'emit messages' stamp: 'ajh 2/25/2003 16:50'!emitToDoNode: aMessageNode	super emitToDoNode: aMessageNode.	methodBuilder pushLiteral: nil.! !!ASTTranslatorForValue methodsFor: 'emit messages' stamp: 'ajh 2/25/2003 16:49'!emitWhileNode: aMessageNode	super emitWhileNode: aMessageNode.	methodBuilder pushLiteral: nil.! !!ASTTranslatorForValue commentStamp: 'ajh 3/24/2003 22:20' prior: 0!I override some methods in my super to generate instructions for effect and value only.!!ATestCase methodsFor: 'as yet unclassified' stamp: 'dvf 9/18/2006 21:28'!testRequirement  "  self debug: #testRequirement  "  | class |  class := Object            subclass: #AClassForTest            instanceVariableNames: ''            classVariableNames: ''            poolDictionaries: ''            category: self class category.  [   class compile: 'call                    ^ self isCalled'.   self assert: (class requiredSelectors includes: #isCalled).   class compile: 'isCalled                    ^ 1'.   "Fail here:"   self deny: (class requiredSelectors includes: #isCalled)]  ensure: [class removeFromSystem] ! !!AbstractClassVariableRefactoring methodsFor: 'transforming'!abstractClassReferences	| replacer |	replacer := ParseTreeRewriter 				variable: variableName				getter: self accessorsRefactoring getterMethod				setter: self accessorsRefactoring setterMethod.	self 		convertClasses: class metaclass withAllSubclasses		select: 			[:aClass | 			(aClass whichSelectorsReferToClassVariable: variableName) reject: 					[:each | 					aClass == class metaclass and: 							[each == self accessorsRefactoring getterMethod 								or: [each == self accessorsRefactoring setterMethod]]]]		using: replacer! !!AbstractClassVariableRefactoring methodsFor: 'transforming'!abstractInstanceReferences	| replacer |	replacer := ParseTreeRewriter 				classVariable: variableName				getter: self accessorsRefactoring getterMethod				setter: self accessorsRefactoring setterMethod.	self 		convertClasses: class withAllSubclasses		select: [:aClass | aClass whichSelectorsReferToClassVariable: variableName]		using: replacer! !!AbstractClassVariableRefactoring methodsFor: 'transforming'!createAccessors	self performComponentRefactoring: self accessorsRefactoring! !!AbstractClassVariableRefactoring methodsFor: 'transforming'!transform	self createAccessors.	self abstractInstanceReferences.	self abstractClassReferences! !!AbstractClassVariableRefactoring methodsFor: 'private-accessing'!accessorsRefactoring	^accessorsRefactoring isNil 		ifTrue: 			[accessorsRefactoring := CreateAccessorsForVariableRefactoring 						model: self model						variable: variableName asString						class: class						classVariable: true]		ifFalse: [accessorsRefactoring]! !!AbstractClassVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isMetaclass: class) not 		& (RBCondition directlyDefinesClassVariable: variableName asSymbol in: class) 			& ((RBCondition withBlock: 						[(#(#Object #Behavior #ClassDescription #Class) includes: class name) not]) 					errorMacro: 'This refactoring does not work for Object, Behavior, ClassDescription, or Class')! !!AbstractClassVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AbstractClassVariableTest methodsFor: 'tests'!testAbstractClassVariable	| refactoring meta class |	refactoring := AbstractClassVariableRefactoring 				variable: 'RecursiveSelfRule'				class: TransformationRuleTest.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #TransformationRuleTest.	meta := class metaclass.	self assert: (meta parseTreeFor: #recursiveSelfRule) 				= (RBParser parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').	self 		assert: (meta parseTreeFor: #recursiveSelfRule:) = (RBParser 						parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').	self assert: (meta parseTreeFor: #nuke) 				= (RBParser parseMethod: 'nuke							self recursiveSelfRule: nil').	self 		assert: (meta parseTreeFor: #initializeAfterLoad1) = (RBParser 						parseMethod: 'initializeAfterLoad1							self recursiveSelfRule: ParseTreeSearcher new.							self recursiveSelfRule								addMethodSearches: #(''`@methodName: `@args | `@temps | self `@methodName: `@args'' ''`@methodName: `@args | `@temps | ^self `@methodName: `@args'')										-> [:aNode :answer | true]').	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext 							class := aSmalllintContext selectedClass.							(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 									[(self class recursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)										ifFalse: 											[builder compile: rewriteRule tree printString												in: class												classified: aSmalllintContext protocols]]')! !!AbstractClassVariableTest methodsFor: 'tests'!testModelAbstractClassVariable	| refactoring meta class |	class := model classNamed: #Foo.	meta := class metaclass.	refactoring := AbstractClassVariableRefactoring 				model: model				variable: 'ClassVarName1'				class: class.	self executeRefactoring: refactoring.	self assert: (meta parseTreeFor: #classVarName1) 				= (RBParser parseMethod: 'classVarName1 ^ClassVarName1').	self 		assert: (meta parseTreeFor: #classVarName1:) = (RBParser 						parseMethod: 'classVarName1: anObject ^ClassVarName1 := anObject').	self 		assert: (meta parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo					^self classVarName1: self classVarName1 * self classVarName1 * self classVarName1').	self assert: (class parseTreeFor: #classVarName1) 				= (RBParser parseMethod: 'classVarName1							^self class classVarName1').	self 		assert: (class parseTreeFor: #classVarName1:) = (RBParser 						parseMethod: 'classVarName1: anObject							^self class classVarName1: anObject').	self 		assert: (class parseTreeFor: #asdf) = (RBParser 						parseMethod: 'asdf						^self classVarName1: (self class classVarName1: self class classVarName1 + 1)').	self 		assert: ((model classNamed: #Bar) parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo					instVarName1 := instVarName1 + instVarName2 + self class classVarName1').	self 		assert: ((model classNamed: #Bar) parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo						instVarName1 := instVarName1 + instVarName2 + self class classVarName1')! !!AbstractClassVariableTest methodsFor: 'tests'!testModelAbstractClassVariableOverridenMethodsInSubclass	| refactoring meta class |	class := model classNamed: #Foo.	meta := class metaclass.	refactoring := AbstractClassVariableRefactoring 				model: model				variable: 'ClassVarName2'				class: class.	self executeRefactoring: refactoring.	self assert: (meta parseTreeFor: #classVarName21) 				= (RBParser parseMethod: 'classVarName21 ^ClassVarName2').	self 		assert: (meta parseTreeFor: #classVarName21:) = (RBParser 						parseMethod: 'classVarName21: anObject ClassVarName2 := anObject')! !!AbstractClassVariableTest methodsFor: 'failure tests'!testInheritedName	self 		shouldFail: (AbstractClassVariableRefactoring variable: #DependentsFields				class: BasicLintRuleTest)! !!AbstractClassVariableTest methodsFor: 'failure tests'!testMetaClassFailure	self 		shouldFail: (AbstractClassVariableRefactoring variable: #RecursiveSelfRule				class: TransformationRuleTest class)! !!AbstractClassVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (AbstractClassVariableRefactoring variable: #Foo				class: BasicLintRuleTest)! !!AbstractInstanceVariableRefactoring methodsFor: 'transforming'!abstractReferences	| replacer |	replacer := ParseTreeRewriter 				variable: variableName				getter: self accessorsRefactoring getterMethod				setter: self accessorsRefactoring setterMethod.	self 		convertClasses: class withAllSubclasses		select: 			[:aClass | 			(aClass whichSelectorsReferToInstanceVariable: variableName) reject: 					[:each | 					aClass == class and: 							[each == self accessorsRefactoring getterMethod 								or: [each == self accessorsRefactoring setterMethod]]]]		using: replacer! !!AbstractInstanceVariableRefactoring methodsFor: 'transforming'!createAccessors	self performComponentRefactoring: self accessorsRefactoring! !!AbstractInstanceVariableRefactoring methodsFor: 'transforming'!transform	self createAccessors.	self abstractReferences! !!AbstractInstanceVariableRefactoring methodsFor: 'private-accessing'!accessorsRefactoring	^accessorsRefactoring isNil 		ifTrue: 			[accessorsRefactoring := CreateAccessorsForVariableRefactoring 						model: self model						variable: variableName						class: class						classVariable: false]		ifFalse: [accessorsRefactoring]! !!AbstractInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition directlyDefinesInstanceVariable: variableName in: class! !!AbstractInstanceVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AbstractInstanceVariableTest methodsFor: 'tests'!testAbstractInstanceVariable	| refactoring class |	refactoring := AbstractInstanceVariableRefactoring variable: 'class'				class: TransformationRuleTest.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #TransformationRuleTest.	self assert: (class parseTreeFor: #class1) 				= (RBParser parseMethod: 'class1 ^class').	self assert: (class parseTreeFor: #class:) 				= (RBParser parseMethod: 'class: anObject	class := anObject').	self 		assert: (class parseTreeFor: #superSends) = (RBParser 						parseMethod: 'superSends	| rule |	rule := ParseTreeRewriter new.	rule addSearch: ''super `@message: ``@args'' 				-> (					[:aNode | 					(self class1 withAllSubclasses 						detect: [:each | each includesSelector: aNode selector]						ifNone: [nil]) isNil] 							-> ''self `@message: ``@args'').	self rewriteUsing: rule').	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext 	self class: aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) 		ifTrue: 			[(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) 				ifFalse: 					[builder 						compile: rewriteRule tree printString						in: self class1						classified: aSmalllintContext protocols]]')! !!AbstractInstanceVariableTest methodsFor: 'tests'!testAbstractWithAssignmentUsed	| refactoring class |	class := model classNamed: #Foo.	refactoring := AbstractInstanceVariableRefactoring 				model: model				variable: 'instVarName2'				class: class.	self executeRefactoring: refactoring.	self assert: (class parseTreeFor: #foo) 				= (RBParser parseMethod: 'foo						^self instVarName21: 3').	self 		assert: (class parseTreeFor: #instVarName2:) = (RBParser 						parseMethod: 'instVarName2: anObject						self instVarName21: anObject').	self 		assert: (class parseTreeFor: #instVarName21:) = (RBParser 						parseMethod: 'instVarName21: anObject						^instVarName2 := anObject').	self assert: (class parseTreeFor: #instVarName2) 				= (RBParser parseMethod: 'instVarName2						^instVarName2').	self 		assert: ((model classNamed: #Bar) parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo						instVarName1 := instVarName1 + self instVarName2 + ClassVarName1')! !!AbstractInstanceVariableTest methodsFor: 'tests'!testAbstractWithDefaultNamesUsed	| refactoring class |	class := model classNamed: #Foo.	refactoring := AbstractInstanceVariableRefactoring 				model: model				variable: 'instVarName1'				class: class.	self executeRefactoring: refactoring.	self 		assert: (class parseTreeFor: #bar) = (RBParser 						parseMethod: 'bar						"Add one to instVarName1"						self instVarName11: self instVarName11 + 1').	self 		assert: (class parseTreeFor: #instVarName11:) = (RBParser 						parseMethod: 'instVarName11: anObject						instVarName1 := anObject').	self assert: (class parseTreeFor: #instVarName11) 				= (RBParser parseMethod: 'instVarName11						^instVarName1').	self 		assert: ((model classNamed: #Bar) parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo						self instVarName11: self instVarName11 + instVarName2 + ClassVarName1')! !!AbstractInstanceVariableTest methodsFor: 'tests'!testMetaclassInstanceVariables	| refactoring class |	class := model metaclassNamed: #Foo.	class addInstanceVariable: 'foo'.	class compile: 'zzz ^foo := foo + foo * 2' classified: #(#testing).	refactoring := AbstractInstanceVariableRefactoring 				model: model				variable: 'foo'				class: class.	self executeRefactoring: refactoring.	self assert: (class parseTreeFor: #foo1) 				= (RBParser parseMethod: 'foo1						^foo').	self assert: (class parseTreeFor: #foo:) 				= (RBParser parseMethod: 'foo: anObject						^foo := anObject').	self assert: (class parseTreeFor: #zzz) 				= (RBParser parseMethod: 'zzz ^self foo: self foo1 + self foo1 * 2')! !!AbstractInstanceVariableTest methodsFor: 'failure tests'!testInheritedName	self shouldFail: (AbstractInstanceVariableRefactoring variable: 'name'				class: BasicLintRuleTest)! !!AbstractInstanceVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (AbstractInstanceVariableRefactoring variable: 'foo'				class: BasicLintRuleTest)! !!AbstractVariablesRefactoring methodsFor: 'transforming'!abstractClassVariable: aString 	| refactoring rewriter nonMetaClass |	nonMetaClass := fromClass nonMetaclass.	refactoring := CreateAccessorsForVariableRefactoring 				model: self model				variable: aString				class: nonMetaClass				classVariable: true.	self performComponentRefactoring: refactoring.	rewriter := ParseTreeRewriter new.	fromClass isMeta 		ifTrue: 			[rewriter				replace: aString , ' := ``@object'					with: ('self <1s> ``@object' expandMacrosWith: refactoring setterMethod);				replace: aString with: 'self ' , refactoring getterMethod]		ifFalse: 			[rewriter				replace: aString , ' := ``@object'					with: ('self class <1s> ``@object' 							expandMacrosWith: refactoring setterMethod);				replace: aString with: 'self class ' , refactoring getterMethod].	(rewriter executeTree: tree) ifTrue: [tree := rewriter tree]! !!AbstractVariablesRefactoring methodsFor: 'transforming'!abstractClassVariables	| variables |	classVarReaders isEmpty & classVarWriters isEmpty ifTrue: [^self].	variables := Set new.	variables		addAll: classVarReaders;		addAll: classVarWriters.	variables do: [:each | self abstractClassVariable: each]! !!AbstractVariablesRefactoring methodsFor: 'transforming'!abstractInstanceVariable: aString 	| refactoring rewriter |	refactoring := CreateAccessorsForVariableRefactoring 				model: self model				variable: aString				class: fromClass				classVariable: false.	self performComponentRefactoring: refactoring.	rewriter := ParseTreeRewriter new.	rewriter		replace: aString , ' := ``@object'			with: ('self <1s> ``@object' expandMacrosWith: refactoring setterMethod);		replace: aString with: 'self ' , refactoring getterMethod.	(rewriter executeTree: tree) ifTrue: [tree := rewriter tree]! !!AbstractVariablesRefactoring methodsFor: 'transforming'!abstractInstanceVariables	| variables |	instVarReaders isEmpty & instVarWriters isEmpty ifTrue: [^self].	variables := Set new.	variables		addAll: instVarReaders;		addAll: instVarWriters.	variables do: [:each | self abstractInstanceVariable: each]! !!AbstractVariablesRefactoring methodsFor: 'transforming'!classVariableNames	| nonMetaClass |	nonMetaClass := fromClass nonMetaclass.	^(nonMetaClass allClassVariableNames collect: [:each | each asString]) asSet! !!AbstractVariablesRefactoring methodsFor: 'transforming'!computeVariablesToAbstract	| searcher |	instVarReaders := Set new.	instVarWriters := Set new.	classVarReaders := Set new.	classVarWriters := Set new.	searcher := ParseTreeSearcher new.	searcher		matches: '`var := ``@anything'			do: [:aNode :answer | self processAssignmentNode: aNode];		matches: '`var' do: [:aNode :answer | self processReferenceNode: aNode].	searcher executeTree: tree.	self removeDefinedClassVariables! !!AbstractVariablesRefactoring methodsFor: 'transforming'!instanceVariableNames	^fromClass allInstanceVariableNames asSet! !!AbstractVariablesRefactoring methodsFor: 'transforming'!processAssignmentNode: aNode 	| varName |	varName := aNode variable name.	ignore = varName ifTrue: [^self].	(aNode whoDefines: varName) notNil ifTrue: [^self].	(self instanceVariableNames includes: varName) 		ifTrue: [instVarWriters add: varName].	(self classVariableNames includes: varName) 		ifTrue: [classVarWriters add: varName]! !!AbstractVariablesRefactoring methodsFor: 'transforming'!processReferenceNode: aNode 	| varName |	varName := aNode name.	ignore = varName ifTrue: [^self].	(aNode whoDefines: varName) notNil ifTrue: [^self].	(self instanceVariableNames includes: varName) 		ifTrue: [instVarReaders add: varName].	(self classVariableNames includes: varName) 		ifTrue: [classVarReaders add: varName]! !!AbstractVariablesRefactoring methodsFor: 'transforming'!removeDefinedClassVariables	| selectionBlock nonMetaClass |	nonMetaClass := fromClass nonMetaclass.	selectionBlock := 			[:varName | 			(toClasses detect: 					[:each | 					((each nonMetaclass) 						includesClass: (nonMetaClass whoDefinesClassVariable: varName)) not]				ifNone: [nil]) notNil].	classVarReaders := classVarReaders select: selectionBlock.	classVarWriters := classVarWriters select: selectionBlock! !!AbstractVariablesRefactoring methodsFor: 'transforming'!transform	self hasVariablesToAbstract 		ifTrue: 			[self 				refactoringWarning: 'This method has direct variable references which<n>will need to be converted to getter/setters.' 						expandMacros].	self abstractInstanceVariables.	self abstractClassVariables! !!AbstractVariablesRefactoring methodsFor: 'initialize-release'!abstractVariablesIn: aBRProgramNode from: fromBehavior toAll: behaviorCollection ignoring: aVariableName 	| poolRefactoring |	tree := aBRProgramNode.	fromClass := self classObjectFor: fromBehavior.	toClasses := behaviorCollection 				collect: [:each | self classObjectFor: each].	ignore := aVariableName.	poolRefactoring := ExpandReferencedPoolsRefactoring 				model: self model				forMethod: tree				fromClass: fromClass				toClasses: toClasses.	self performComponentRefactoring: poolRefactoring.	self computeVariablesToAbstract! !!AbstractVariablesRefactoring methodsFor: 'testing'!hasVariablesToAbstract	^(instVarReaders isEmpty 		& instVarWriters isEmpty 		& classVarReaders isEmpty 		& classVarWriters isEmpty) 		not! !!AbstractVariablesRefactoring methodsFor: 'accessing'!parseTree	^tree! !!AbstractVariablesRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition empty! !!AbstractVariablesRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk abstractVariablesIn: aBRProgramNode from: fromBehavior toAll: behaviorCollection 	^self 		model: aRBSmalltalk		abstractVariablesIn: aBRProgramNode		from: fromBehavior		toAll: behaviorCollection		ignoring: nil! !!AbstractVariablesRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk abstractVariablesIn: aBRProgramNode from: fromBehavior toAll: behaviorCollection ignoring: aVariableName 	^(self new)		model: aRBSmalltalk;		abstractVariablesIn: aBRProgramNode			from: fromBehavior			toAll: behaviorCollection			ignoring: aVariableName;		yourself! !!AddClassChange methodsFor: 'comparing'!= anAddClassChange 	self class = anAddClassChange class ifFalse: [^false].	^definition = anAddClassChange definition! !!AddClassChange methodsFor: 'comparing'!hash	^definition hash! !!AddClassChange methodsFor: 'converting'!asUndoOperation	| class |	class := Smalltalk at: self changeClassName ifAbsent: [nil].	^class isBehavior 		ifTrue: [AddClassChange definition: class definition]		ifFalse: [RemoveClassChange removeClassName: self changeClassName]! !!AddClassChange methodsFor: 'accessing'!category	category isNil ifTrue: [self fillOutDefinition].	^category! !!AddClassChange methodsFor: 'accessing'!changeClassName	className isNil ifTrue: [self fillOutDefinition].	^className! !!AddClassChange methodsFor: 'accessing'!classVariableNames	classVariableNames isNil ifTrue: [self fillOutDefinition].	^classVariableNames! !!AddClassChange methodsFor: 'accessing'!instanceVariableNames	instanceVariableNames isNil ifTrue: [self fillOutDefinition].	^instanceVariableNames! !!AddClassChange methodsFor: 'accessing'!poolDictionaryNames	poolDictionaryNames isNil ifTrue: [self fillOutDefinition].	^poolDictionaryNames! !!AddClassChange methodsFor: 'accessing'!superclassName	className isNil ifTrue: [self fillOutDefinition].	^superclassName! !!AddClassChange methodsFor: 'printing'!changeString	^'Define ' , self displayClassName! !!AddClassChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: definition;		nextPut: $!!! !!AddClassChange methodsFor: 'private'!controller	^nil! !!AddClassChange methodsFor: 'private'!definingSuperclass	^self class! !!AddClassChange methodsFor: 'private'!definition	^definition! !!AddClassChange methodsFor: 'private'!fillOutDefinition	| parseTree |	parseTree := RBParser parseExpression: definition				onError: [:str :pos | ^self parseDefinitionError].	parseTree isMessage ifFalse: [^self parseDefinitionError].	(self isValidSubclassCreationMessage: parseTree) 		ifFalse: [^self parseDefinitionError].	superclassName := parseTree receiver isVariable 				ifTrue: [parseTree receiver name asSymbol]				ifFalse: [parseTree receiver value].	className := parseTree arguments first value.	instanceVariableNames := self namesIn: (parseTree arguments at: 2) value.	classVariableNames := self namesIn: (parseTree arguments at: 3) value.	poolDictionaryNames := self namesIn: (parseTree arguments at: 4) value.	category := parseTree arguments size < 5 				ifTrue: [#Unknown]				ifFalse: [(parseTree arguments at: 5) value asSymbol]! !!AddClassChange methodsFor: 'private'!namesIn: aString 	| names stream nameStream |	names := OrderedCollection new.	stream := ReadStream on: aString.		[stream skipSeparators.	stream atEnd] whileFalse: 				[nameStream := WriteStream on: (String new: 10).				[stream atEnd or: [stream peek isSeparator]] 					whileFalse: [nameStream nextPut: stream next].				names add: nameStream contents].	^names! !!AddClassChange methodsFor: 'private'!parseDefinitionError	className := #'Unknown Class'.	instanceVariableNames := #().	classVariableNames := #().	poolDictionaryNames := #()! !!AddClassChange methodsFor: 'private'!primitiveExecute	^self definingSuperclass subclassDefinerClass 		evaluate: definition		notifying: self controller		logged: true! !!AddClassChange methodsFor: 'initialize-release'!definition: aString 	definition := aString! !!AddClassChange methodsFor: 'initialize-release'!initialize	super initialize.	isMeta := false! !!AddClassChange methodsFor: 'testing' stamp: 'bh 11/8/2000 12:29'!isValidMessageName: aMessageNode 	^#("#subclass:instanceVariableNames:classVariableNames:poolDictionaries:" #subclass:instanceVariableNames:classVariableNames:poolDictionaries:category: "#variableByteSubclass:classVariableNames:poolDictionaries:" #variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category: "#variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:" #variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:) 		includes: aMessageNode selector! !!AddClassChange methodsFor: 'testing'!isValidSubclassCreationMessage: aMessageNode 	(aMessageNode receiver isVariable or: [aMessageNode receiver isLiteral]) 		ifFalse: [^false].	(self isValidMessageName: aMessageNode) ifFalse: [^false].	^(aMessageNode arguments detect: [:each | each isLiteral not] ifNone: [nil]) 		isNil! !!AddClassChange class methodsFor: 'instance creation' stamp: 'bh 11/8/2000 13:51'!definition: aString 	^self new definition: aString! !!AddClassRefactoring methodsFor: 'initialize-release'!addClass: aName superclass: aClass subclasses: aCollection category: aSymbol 	self className: aName.	superclass := self classObjectFor: aClass.	subclasses := aCollection collect: [:each | self classObjectFor: each].	category := aSymbol! !!AddClassRefactoring methodsFor: 'preconditions'!preconditions	| cond |	cond := ((RBCondition isMetaclass: superclass) 				errorMacro: 'Superclass must not be a metaclass') not.	cond := subclasses inject: cond				into: 					[:sub :each | 					sub 						& ((RBCondition isMetaclass: each) 								errorMacro: 'Subclass must <1?not :>be a metaclass') not 							& (RBCondition isImmediateSubclass: each of: superclass)].	^cond & (RBCondition isValidClassName: className) 		& (RBCondition isGlobal: className in: self model) not 			& (RBCondition isSymbol: category) 			& ((RBCondition withBlock: [category isEmpty not]) 					errorMacro: 'Invalid category name')! !!AddClassRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' addClass: #';		nextPutAll: className;		nextPutAll: ' superclass: '.	superclass storeOn: aStream.	aStream nextPutAll: ' subclasses: '.	subclasses asArray storeOn: aStream.	aStream nextPutAll: ' category: '.	category storeOn: aStream.	aStream nextPut: $)! !!AddClassRefactoring methodsFor: 'transforming' stamp: 'bh 4/10/2001 14:25'!transform	(self model)		defineClass: ('<1p> subclass: #<2s> instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: <3p>' 					expandMacrosWith: superclass					with: className					with: category asString);		reparentClasses: subclasses to: (self model classNamed: className asSymbol)! !!AddClassRefactoring class methodsFor: 'instance creation'!addClass: aName superclass: aClass subclasses: aCollection category: aSymbol	^self new		addClass: aName		superclass: aClass		subclasses: aCollection		category: aSymbol! !!AddClassRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk addClass: aName superclass: aClass subclasses: aCollection category: aSymbol 	^(self new)		model: aRBSmalltalk;		addClass: aName			superclass: aClass			subclasses: aCollection			category: aSymbol;		yourself! !!AddClassTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AddClassTest methodsFor: 'tests'!testAddClass	| refactoring newClass superClass classTest |	refactoring := AddClassRefactoring 				addClass: #FooTest				superclass: RefactoringTest				subclasses: (Array with: self class)				category: #'Refactory-Testing'.	self executeRefactoring: refactoring.	newClass := refactoring model classNamed: #FooTest.	superClass := refactoring model classNamed: #RefactoringTest.	classTest := refactoring model classNamed: self class name.	self assert: newClass superclass = superClass.	self assert: (superClass subclasses includes: newClass).	self assert: newClass metaclass superclass = superClass metaclass.	self 		assert: (superClass metaclass subclasses includes: newClass metaclass).	self assert: classTest superclass = newClass.	self assert: (newClass subclasses includes: classTest).	self assert: classTest metaclass superclass = newClass metaclass.	self assert: (newClass metaclass subclasses includes: classTest metaclass)! !!AddClassTest methodsFor: 'tests' stamp: 'bh 3/27/2000 22:39'!testModelAddClass	| refactoring newClass superClass subclass |	subclass := model classNamed: #Bar.	superClass := model classNamed: #Foo.	refactoring := AddClassRefactoring 				model: model				addClass: #FooTest				superclass: superClass				subclasses: (Array with: subclass)				category: #'Refactory-Testing'.	self executeRefactoring: refactoring.	newClass := model classNamed: #FooTest.	self assert: newClass superclass = superClass.	self assert: (superClass subclasses includes: newClass).	self assert: newClass metaclass superclass = superClass metaclass.	self 		assert: (superClass metaclass subclasses includes: newClass metaclass).	self assert: subclass superclass = newClass.	self assert: (newClass subclasses includes: subclass).	self assert: subclass metaclass superclass = newClass metaclass.	self assert: (newClass metaclass subclasses includes: subclass metaclass)! !!AddClassTest methodsFor: 'failure tests'!testExistingName	self shouldFail: (AddClassRefactoring 				addClass: #Object				superclass: self class				subclasses: #()				category: #'Refactory-Testing')! !!AddClassTest methodsFor: 'failure tests'!testInvalidSubclass	self shouldFail: (AddClassRefactoring 				addClass: #Foo				superclass: CompositeLintRuleTest				subclasses: (Array with: BasicLintRuleTest)				category: #'Refactory-Tesing')! !!AddClassTest methodsFor: 'failure tests'!testMetaClassFailure	self shouldFail: (AddClassRefactoring 				addClass: #Foo				superclass: self class class				subclasses: #()				category: #'Refactory-Testing')! !!AddClassTest methodsFor: 'failure tests'!testModelExistingName	| refactoring |	refactoring := AddClassRefactoring 				model: model				addClass: #Foo				superclass: Object				subclasses: #()				category: #'Refactory-Testing'.	self shouldFail: refactoring! !!AddClassTest methodsFor: 'failure tests'!testModelInvalidSubclass	| refactoring |	refactoring := AddClassRefactoring 				model: model				addClass: #Foo2				superclass: Object				subclasses: (Array with: (model classNamed: #Bar))				category: #'Refactory-Tesing'.	self shouldFail: refactoring! !!AddClassVariableChange methodsFor: 'converting'!asUndoOperation	^RemoveClassVariableChange remove: variable from: self changeClass! !!AddClassVariableChange methodsFor: 'printing'!changeString	^'Add class variable named, <1s>, from <2s>' 		expandMacrosWith: variable		with: self displayClassName! !!AddClassVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' addClassVarNamed: ';		nextPutAll: variable;		nextPut: $!!! !!AddClassVariableChange methodsFor: 'private'!changeSymbol	^#addClassVarName:! !!AddClassVariableChange methodsFor: 'private'!variable	^variable asSymbol! !!AddClassVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isMetaclass: class) not 		& (RBCondition isValidClassVarName: variableName for: class) 			& (RBCondition hierarchyOf: class definesVariable: variableName asString) 					not 			& (RBCondition isGlobal: variableName in: self model) not! !!AddClassVariableRefactoring methodsFor: 'transforming'!transform	class addClassVariable: variableName! !!AddClassVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AddClassVariableTest methodsFor: 'tests'!testAddClassVariable	| refactoring |	refactoring := AddClassVariableRefactoring variable: 'Asdf'				class: TransformationRuleTest.	self executeRefactoring: refactoring.	self assert: ((refactoring model classNamed: #TransformationRuleTest) 				directlyDefinesClassVariable: #Asdf)! !!AddClassVariableTest methodsFor: 'tests'!testModelAddClassVariable	| refactoring |	refactoring := AddClassVariableRefactoring 				model: model				variable: #ClassVarName3				class: (model classNamed: #Bar).	self executeRefactoring: refactoring.	self assert: ((model classNamed: #Bar) 				directlyDefinesClassVariable: #ClassVarName3)! !!AddClassVariableTest methodsFor: 'failure tests'!testAlreadyExistingName	self		shouldFail: (AddClassVariableRefactoring variable: #RecursiveSelfRule					class: TransformationRuleTest);		shouldFail: (AddClassVariableRefactoring variable: self objectClassVariable					class: TransformationRuleTest)! !!AddClassVariableTest methodsFor: 'failure tests'!testMetaClassFailure	self shouldFail: (AddClassVariableRefactoring variable: #VariableName				class: TransformationRuleTest class)! !!AddClassVariableTest methodsFor: 'failure tests'!testMetaclass	| refactoring |	refactoring := AddClassVariableRefactoring variable: #ClassVarName3				class: (model classNamed: #Object) metaclass.	refactoring model: model.	self shouldFail: refactoring! !!AddClassVariableTest methodsFor: 'failure tests'!testModelAlreadyExistingName	| refactoring |	refactoring := AddClassVariableRefactoring 				model: model				variable: #ClassVarName2				class: (model classNamed: #Bar).	self shouldFail: refactoring! !!AddClassVariableTest methodsFor: 'failure tests'!testModelMetaclass	| refactoring |	refactoring := AddClassVariableRefactoring 				model: model				variable: #ClassVarName3				class: (model classNamed: #Bar) metaclass.	self shouldFail: refactoring! !!AddInstanceVariableChange methodsFor: 'converting'!asUndoOperation	^RemoveInstanceVariableChange remove: variable from: self changeClass! !!AddInstanceVariableChange methodsFor: 'printing'!changeString	^'Add instance variable named, <1s>, from <2s>' 		expandMacrosWith: variable		with: self displayClassName! !!AddInstanceVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' addInstVarNamed: ';		nextPutAll: variable;		nextPut: $!!! !!AddInstanceVariableChange methodsFor: 'private'!changeSymbol	^#addInstVarName:! !!AddInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isValidInstanceVariableName: variableName for: class) 		& (RBCondition hierarchyOf: class definesVariable: variableName) not 			& (RBCondition isGlobal: variableName in: self model) not! !!AddInstanceVariableRefactoring methodsFor: 'transforming'!transform	class addInstanceVariable: variableName! !!AddInstanceVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AddInstanceVariableTest methodsFor: 'tests'!testAddInstanceVariable	| refactoring |	refactoring := AddInstanceVariableRefactoring variable: 'asdf'				class: TransformationRuleTest.	self executeRefactoring: refactoring.	self assert: ((refactoring model classNamed: #TransformationRuleTest) 				directlyDefinesInstanceVariable: 'asdf')! !!AddInstanceVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:07'!testAddToModel	| refactoring |	model := RBNamespace new.	model name: 'Add instance variable'.	model 		defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''fdsa'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.	refactoring := AddInstanceVariableRefactoring 				model: model				variable: 'asdf'				class: (model classNamed: #FOOBAR).	self executeRefactoring: refactoring.	self assert: ((refactoring model classNamed: #FOOBAR) 				directlyDefinesInstanceVariable: 'asdf')! !!AddInstanceVariableTest methodsFor: 'failure tests'!testAlreadyExistingName	self		shouldFail: (AddInstanceVariableRefactoring variable: 'class'					class: TransformationRuleTest);		shouldFail: (AddInstanceVariableRefactoring variable: 'name'					class: TransformationRuleTest)! !!AddInstanceVariableTest methodsFor: 'failure tests'!testModelAlreadyExistingName	| refactoring |	refactoring := AddInstanceVariableRefactoring 				model: model				variable: 'instVarName1'				class: (model classNamed: #Bar).	self shouldFail: refactoring! !!AddInstanceVariableTest methodsFor: 'failure tests'!testModelMetaclassAlreadyExistingName	| refactoring |	(model metaclassNamed: #Foo) addInstanceVariable: 'instVarName1'.	refactoring := AddInstanceVariableRefactoring 				model: model				variable: 'instVarName1'				class: (model classNamed: #Bar).	self shouldFail: refactoring! !!AddInstanceVariableTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:07'!testNewExistingName	| refactoring |	model := RBNamespace new.	model name: 'Add instance variable'.	model 		defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''asdf'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.	refactoring := AddInstanceVariableRefactoring 				model: model				variable: 'asdf'				class: (model classNamed: #FOOBAR).	self shouldFail: refactoring! !!AddInstanceVariableTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:07'!testNewHierarchyExistingName	| refactoring |	model := RBNamespace new.	model name: 'Add instance variable'.	model 		defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''asdf'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.	model 		defineClass: 'FOOBAR subclass: #BARFOO 				instanceVariableNames: '''' 					classVariableNames: ''''				poolDictionaries: ''''				category: ''Refactory-Test data'''.	refactoring := AddInstanceVariableRefactoring 				model: model				variable: 'asdf'				class: (model classNamed: #BARFOO).	self shouldFail: refactoring! !!AddMethodChange methodsFor: 'comparing'!= anAddMethodChange 	super = anAddMethodChange ifFalse: [^false].	^self parseTree = anAddMethodChange parseTree! !!AddMethodChange methodsFor: 'comparing'!hash	^self parseTree hash! !!AddMethodChange methodsFor: 'converting'!asUndoOperation	^(self changeClass includesSelector: self selector) 		ifTrue: 			[| oldProtocol |			oldProtocol := BrowserEnvironment new whichProtocolIncludes: self selector						in: self changeClass.			oldProtocol isNil ifTrue: [oldProtocol := #accessing].			AddMethodChange 				compile: (self methodSourceFor: self selector)				in: self changeClass				classified: oldProtocol]		ifFalse: [RemoveMethodChange remove: selector from: self changeClass]! !!AddMethodChange methodsFor: 'accessing'!changeForClass: aSymbol selector: aSelector 	^(isMeta not and: [self selector = aSelector and: [className = aSymbol]])		ifTrue: [self]		ifFalse: [nil]! !!AddMethodChange methodsFor: 'accessing'!changeForMetaclass: aSymbol selector: aSelector 	^(isMeta and: [self selector = aSelector and: [className = aSymbol]])		ifTrue: [self]		ifFalse: [nil]! !!AddMethodChange methodsFor: 'accessing'!protocol	^self protocols first! !!AddMethodChange methodsFor: 'accessing'!protocols	^protocols! !!AddMethodChange methodsFor: 'accessing'!selector	selector isNil 		ifTrue: 			[selector := RBParser parseMethodPattern: source.			selector isNil ifTrue: [selector := #unknown]].	^selector! !!AddMethodChange methodsFor: 'printing'!changeString	^self displayClassName , '>>' , self selector! !!AddMethodChange methodsFor: 'printing' stamp: 'nk 3/5/2005 15:51'!printOn: aStream 	aStream		nextPut: $!!;		nextPutAll: self displayClassName;		nextPutAll: ' methodsFor: ''';		nextPutAll: self protocol;		nextPutAll: ''' stamp: ';		print: Utilities changeStamp;		nextPut: $!!;		cr;		nextPutAll: (source copyReplaceAll: '!!' with: '!!!!');		nextPutAll: '!! !!'! !!AddMethodChange methodsFor: 'initialize-release'!class: aClass protocol: aProtocol source: aString 	self changeClass: aClass.	self protocols: aProtocol.	source := aString! !!AddMethodChange methodsFor: 'initialize-release'!class: aClass source: aString 	self changeClass: aClass.	source := aString.	self protocols: (BrowserEnvironment new whichProtocolIncludes: self selector in: aClass)! !!AddMethodChange methodsFor: 'initialize-release'!protocols: aCollection 	protocols := aCollection isString 				ifTrue: [Array with: aCollection]				ifFalse: [aCollection].	protocols isNil ifTrue: [protocols := #(#accessing)]! !!AddMethodChange methodsFor: 'private'!controller	^nil! !!AddMethodChange methodsFor: 'private'!parseTree	^RBParser parseMethod: source onError: [:str :pos | ^nil]! !!AddMethodChange methodsFor: 'private'!primitiveExecute	^self changeClass 		compile: source		classified: self protocol		notifying: self controller! !!AddMethodChange class methodsFor: 'instance creation'!compile: aString in: aClass 	^self new class: aClass source: aString! !!AddMethodChange class methodsFor: 'instance creation'!compile: aString in: aBehavior classified: aProtocol 	^self new 		class: aBehavior		protocol: aProtocol		source: aString! !!AddMethodRefactoring methodsFor: 'initialize-release'!addMethod: aString toClass: aClass inProtocols: protocolList 	class := self classObjectFor: aClass.	source := aString.	protocols := protocolList! !!AddMethodRefactoring methodsFor: 'preconditions'!preconditions	| selector method |	method := RBParser parseMethod: source				onError: 					[:string :position | 					^RBCondition 						withBlock: [self refactoringError: 'The sources could not be parsed']].	selector := method selector.	selector isNil ifTrue: [self refactoringError: 'Invalid source.'].	^(RBCondition canUnderstand: selector in: class) not! !!AddMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' addMethod: ''';		nextPutAll: source;		nextPutAll: ''' toClass: '.	class storeOn: aStream.	aStream nextPutAll: ' inProtocols: '.	protocols storeOn: aStream.	aStream nextPut: $)! !!AddMethodRefactoring methodsFor: 'transforming'!transform	class compile: source classified: protocols! !!AddMethodRefactoring class methodsFor: 'instance creation'!addMethod: aString toClass: aClass inProtocols: protocolList 	^self new addMethod: aString		toClass: aClass		inProtocols: protocolList! !!AddMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk addMethod: aString toClass: aClass inProtocols: protocolList 	^(self new)		model: aRBSmalltalk;		addMethod: aString			toClass: aClass			inProtocols: protocolList;		yourself! !!AddMethodTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AddMethodTest methodsFor: 'tests'!testAddMethod	| refactoring |	refactoring := AddMethodRefactoring 				addMethod: 'printString1 ^super printString'				toClass: BasicLintRuleTest				inProtocols: #(#accessing).	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #BasicLintRuleTest) 				parseTreeFor: #printString1) 					= (RBParser parseMethod: 'printString1 ^super printString')! !!AddMethodTest methodsFor: 'tests'!testModelAddMethod	| refactoring class |	class := model metaclassNamed: #Bar.	refactoring := AddMethodRefactoring 				model: model				addMethod: 'printString1 ^super printString'				toClass: class				inProtocols: #(#accessing).	self executeRefactoring: refactoring.	self assert: (class parseTreeFor: #printString1) 				= (RBParser parseMethod: 'printString1 ^super printString')! !!AddMethodTest methodsFor: 'failure tests'!testBadMethod	self shouldFail: (AddMethodRefactoring 				addMethod: 'asdf ^super ^printString'				toClass: BasicLintRuleTest				inProtocols: #(#accessing))! !!AddMethodTest methodsFor: 'failure tests'!testExistingSelector	self shouldFail: (AddMethodRefactoring 				addMethod: 'printString ^super printString'				toClass: BasicLintRuleTest				inProtocols: #(#accessing))! !!AddMethodTest methodsFor: 'failure tests'!testModelExistingSelector	| refactoring |	refactoring := AddMethodRefactoring 				model: model				addMethod: 'classVarName1 ^super printString'				toClass: (model classNamed: #Bar)				inProtocols: #(#accessing).	self shouldFail: refactoring! !!AddMethodTest methodsFor: 'failure tests'!testModelInheritedSelector	| refactoring |	refactoring := AddMethodRefactoring 				model: model				addMethod: 'printString ^super printString'				toClass: (model classNamed: #Bar)				inProtocols: #(#accessing).	self shouldFail: refactoring! !!AddParameterRefactoring methodsFor: 'initialize-release' stamp: 'md 3/15/2006 17:28'!addParameterToMethod: aSelector in: aClass newSelector: newSel initializer: init 	self 		renameMethod: aSelector		in: aClass		to: newSel		permutation: (1 to: newSel numArgs).	initializer := init! !!AddParameterRefactoring methodsFor: 'preconditions'!checkSendersAccessTo: name 	| violatorClass |	(#('self' 'super') includes: name) ifTrue: [^self].	violatorClass := self senders 				detect: [:each | (self canReferenceVariable: name in: each) not]				ifNone: [nil].	violatorClass notNil 		ifTrue: 			[self refactoringError: ('<1s> doesn''t appear to be defined in <2p>' 						expandMacrosWith: name						with: violatorClass)]! !!AddParameterRefactoring methodsFor: 'preconditions'!checkVariableReferencesIn: aParseTree 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '`var'		do: 			[:aNode :answer | 			| name |			name := aNode name.			(aNode whoDefines: name) isNil ifTrue: [self checkSendersAccessTo: name]].	searcher executeTree: aParseTree! !!AddParameterRefactoring methodsFor: 'preconditions'!myConditions	^RBCondition withBlock: 			[oldSelector numArgs + 1 = newSelector numArgs 				ifFalse: 					[self refactoringError: newSelector printString 								, ' doesn''t have the proper number of arguments.'].			self verifyInitializationExpression.			true]! !!AddParameterRefactoring methodsFor: 'preconditions'!verifyInitializationExpression	| tree |	tree := RBParser parseExpression: initializer				onError: 					[:msg :index | 					self refactoringError: 'Illegal initialization code because:.' , msg].	tree isValue 		ifFalse: 			[self 				refactoringError: 'The initialization code cannot be a return node or a list of statements'].	self checkVariableReferencesIn: tree! !!AddParameterRefactoring methodsFor: 'private'!modifyImplementorParseTree: parseTree in: aClass 	| name newArg allTempVars |	allTempVars := parseTree allDefinedVariables.	name := self safeVariableNameFor: aClass temporaries: allTempVars.	newArg := RBVariableNode named: name.	parseTree arguments: parseTree arguments , (Array with: newArg).	super modifyImplementorParseTree: parseTree in: aClass! !!AddParameterRefactoring methodsFor: 'private'!newSelectorString	| stream keywords |	stream := WriteStream on: String new.	keywords := newSelector keywords.	1 to: keywords size		do: 			[:i | 			stream nextPutAll: (keywords at: i).			i == keywords size 				ifTrue: 					[stream						nextPut: $(;						nextPutAll: initializer;						nextPut: $)]				ifFalse: 					[stream						nextPutAll: ' ``@arg';						nextPutAll: i printString].			stream nextPut: $ ].	^stream contents! !!AddParameterRefactoring methodsFor: 'private'!parseTreeRewriter	| rewriteRule oldString newString |	rewriteRule := ParseTreeRewriter new.	oldString := self buildSelectorString: oldSelector.	newString := self newSelectorString.	rewriteRule replace: '``@object ' , oldString		with: '``@object ' , newString.	^rewriteRule! !!AddParameterRefactoring methodsFor: 'private'!safeVariableNameFor: aClass temporaries: allTempVars 	| baseString i newString |	newString := baseString := 'anObject'.	i := 0.		[(allTempVars includes: newString) 		or: [aClass definesInstanceVariable: newString]] 			whileTrue: 				[i := i + 1.				newString := baseString , i printString].	^newString! !!AddParameterRefactoring methodsFor: 'private'!senders	senders isNil 		ifTrue: 			[senders := Set new.			self model allReferencesTo: oldSelector				do: [:each | senders add: each modelClass]].	^senders! !!AddParameterRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' addParameterToMethod: #';		nextPutAll: oldSelector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' newSelector: #';		nextPutAll: newSelector;		nextPutAll: ' initializer: ''';		nextPutAll: initializer;		nextPutAll: ''')'! !!AddParameterRefactoring class methodsFor: 'instance creation'!addParameterToMethod: aSelector in: aClass newSelector: newSelector initializer: init 	^self new addParameterToMethod: aSelector		in: aClass		newSelector: newSelector		initializer: init! !!AddParameterRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk addParameterToMethod: aSelector in: aClass newSelector: newSelector initializer: init 	^(self new)		model: aRBSmalltalk;		addParameterToMethod: aSelector			in: aClass			newSelector: newSelector			initializer: init;		yourself! !!AddParameterTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AddParameterTest methodsFor: 'tests'!testAddParameterForTwoArgumentMessage	| refactoring class |	refactoring := AddParameterRefactoring 				addParameterToMethod: ('called:' , 'on:') asSymbol				in: RefactoryTestDataApp				newSelector: #called:bar:on:				initializer: '#(1.0)'.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: #called:bar:on:) = (RBParser 						parseMethod: 'called: anObject bar: aBlock on: anObject1							Transcript								show: anObject printString;								cr.								aBlock value').	self 		assert: (class parseTreeFor: #caller) = (RBParser 						parseMethod: 'caller							| anObject |							anObject := 5.							self 								called: anObject + 1								bar: [^anObject] on: #(1.0)').	self deny: (class directlyDefinesMethod: ('called:' , 'on:') asSymbol)! !!AddParameterTest methodsFor: 'tests'!testAddParameterThatReferencesGlobalAndLiteral	| refactoring class |	refactoring := AddParameterRefactoring 				addParameterToMethod: ('test' , 'Foo:') asSymbol				in: RefactoryTestDataApp				newSelector: #testFoo:bar:				initializer: 'OrderedCollection new: 5'.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: #testFoo:bar:) = (RBParser 						parseMethod: 'testFoo: anObject bar: anObject1								^self class + anObject').	self 		assert: (class parseTreeFor: #callFoo) = (RBParser 						parseMethod: 'callFoo ^self testFoo: 5 bar: (OrderedCollection new: 5)').	self deny: (class directlyDefinesMethod: ('test' , 'Foo:') asSymbol)! !!AddParameterTest methodsFor: 'tests'!testAddParameterThatReferencesModelGlobal	| refactoring class |	refactoring := AddParameterRefactoring 				model: model				addParameterToMethod: ('test' , 'Foo:') asSymbol				in: RefactoryTestDataApp				newSelector: #testFoo:bar:				initializer: 'Bar new'.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: #testFoo:bar:) = (RBParser 						parseMethod: 'testFoo: anObject bar: anObject1								^self class + anObject').	self assert: (class parseTreeFor: #callFoo) 				= (RBParser parseMethod: 'callFoo ^self testFoo: 5 bar: (Bar new)').	self deny: (class directlyDefinesMethod: ('test' , 'Foo:') asSymbol)! !!AddParameterTest methodsFor: 'tests' stamp: 'bh 3/14/2000 18:15'!testAddParameterThatReferencesSelf	| refactoring class |	refactoring := AddParameterRefactoring				addParameterToMethod: ('test' , 'Foo:') asSymbol				in: RefactoryTestDataApp				newSelector: #testFoo:bar:				initializer: 'self printString'.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self assert: (class parseTreeFor: #testFoo:bar:)			= (RBParser parseMethod: 'testFoo: anObject bar: anObject1								^self class + anObject').	self assert: (class parseTreeFor: #callFoo)			= (RBParser parseMethod: 'callFoo ^self testFoo: 5 bar: (self printString)').	self deny: (class directlyDefinesMethod: ('test' , 'Foo:') asSymbol)! !!AddParameterTest methodsFor: 'failure tests'!testBadInitializationCode	self		shouldFail: (AddParameterRefactoring 					addParameterToMethod: #name					in: LintRuleTest					newSelector: #name:					initializer: 'foo:');		shouldFail: (AddParameterRefactoring 					addParameterToMethod: #name					in: LintRuleTest					newSelector: #name:					initializer: 'foo')! !!AddParameterTest methodsFor: 'failure tests'!testModelBadInitializationCode	| refactoring |	model removeClassNamed: #Refactoring.	refactoring := AddParameterRefactoring 				model: model				addParameterToMethod: #name1				in: LintRuleTest				newSelector: #name1:				initializer: 'AddParameterRefactoring new'.	self shouldFail: refactoring! !!AddParameterTest methodsFor: 'failure tests'!testModelNonExistantName	| refactoring |	(model classNamed: #LintRuleTest) removeMethod: #name.	refactoring := AddParameterRefactoring 				model: model				addParameterToMethod: #name				in: LintRuleTest				newSelector: #nameNew:				initializer: 'nil'.	self shouldFail: refactoring! !!AddParameterTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (AddParameterRefactoring 				addParameterToMethod: #name1				in: LintRuleTest				newSelector: #name1:				initializer: 'nil')! !!AddParameterTest methodsFor: 'failure tests'!testPrimitiveMethods	| refactoring |	(model classNamed: #Object) 		compile: 'foo <primitive: 100> ^#() primitiveFailed'		classified: #(#accessing).	refactoring := AddParameterRefactoring 				model: model				addParameterToMethod: #foo				in: Object				newSelector: #foo123124321s:				initializer: '1'.	self shouldFail: refactoring.	refactoring := AddParameterRefactoring 				addParameterToMethod: #at:				in: Object				newSelector: #at:foo:				initializer: '1'.	self shouldFail: refactoring.	! !!AddPoolVariableChange methodsFor: 'converting'!asUndoOperation	^RemovePoolVariableChange remove: variable from: self changeClass! !!AddPoolVariableChange methodsFor: 'private' stamp: 'nk 7/31/2004 09:22'!changeObject	| dictionary |	dictionary := variable isString 				ifTrue: [Smalltalk classNamed: variable]				ifFalse: [variable].	^dictionary! !!AddPoolVariableChange methodsFor: 'private'!changeSymbol	^#addSharedPool:! !!AddPoolVariableChange methodsFor: 'private'!changesFileTemplate	^'<1p> <2s> <3s>'! !!AddPoolVariableChange methodsFor: 'private'!variable	^variable isString 		ifTrue: [variable]		ifFalse: 			[Smalltalk keyAtValue: variable ifAbsent: [self error: 'Cannot find value']]! !!AddPoolVariableChange methodsFor: 'printing'!changeString	^'Add pool variable named, <1s>, from <2s>' 		expandMacrosWith: self variable		with: self displayClassName! !!AddPoolVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' addSharedPool: ';		nextPutAll: self variable;		nextPut: $!!! !!AndEnvironment methodsFor: 'private'!andedEnvironment	^andedEnvironment! !!AndEnvironment methodsFor: 'initialize-release'!andedEnvironment: aBrowserEnvironment 	andedEnvironment := aBrowserEnvironment! !!AndEnvironment methodsFor: 'accessing'!classesDo: aBlock 	environment 		classesDo: [:each | (self includesClass: each) ifTrue: [aBlock value: each]]! !!AndEnvironment methodsFor: 'accessing'!numberSelectors	| total |	total := 0.	environment classesAndSelectorsDo: 			[:each :sel | 			(andedEnvironment includesSelector: sel in: each) 				ifTrue: [total := total + 1]].	^total! !!AndEnvironment methodsFor: 'accessing'!problemCount	^environment isClassEnvironment 		ifTrue: [self numberClasses]		ifFalse: [super problemCount]! !!AndEnvironment methodsFor: 'accessing' stamp: 'bh 5/8/2000 21:01'!selectionIntervalFor: aString 	| interval |	interval := super selectionIntervalFor: aString.	interval notNil ifTrue: [^interval].	^andedEnvironment selectionIntervalFor: aString! !!AndEnvironment methodsFor: 'accessing'!selectorsForClass: aClass do: aBlock 	environment selectorsForClass: aClass		do: 			[:each | 			(andedEnvironment includesSelector: each in: aClass) 				ifTrue: [aBlock value: each]]! !!AndEnvironment methodsFor: 'testing'!includesCategory: aCategory 	^(self classNamesFor: aCategory) isEmpty not! !!AndEnvironment methodsFor: 'testing'!includesClass: aClass 	| doesntHaveSelectors |	(environment includesClass: aClass) ifFalse: [^false].	(andedEnvironment includesClass: aClass) ifFalse: [^false].	doesntHaveSelectors := true.	environment selectorsForClass: aClass		do: 			[:each | 			doesntHaveSelectors := false.			(andedEnvironment includesSelector: each in: aClass) ifTrue: [^true]].	^doesntHaveSelectors! !!AndEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass 	^(self selectorsFor: aProtocol in: aClass) isEmpty not! !!AndEnvironment methodsFor: 'testing'!includesSelector: aSelector in: aClass 	^(environment includesSelector: aSelector in: aClass) 		and: [andedEnvironment includesSelector: aSelector in: aClass]! !!AndEnvironment methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	environment storeOn: aStream.	aStream nextPutAll: ' & '.	andedEnvironment storeOn: aStream.	aStream nextPut: $)! !!AndEnvironment class methodsFor: 'instance creation'!onEnvironment: anEnvironment and: anotherEnvironment 	^(self onEnvironment: anEnvironment)		andedEnvironment: anotherEnvironment;		yourself! !!Annotation methodsFor: 'adding' stamp: 'pmm 9/29/2005 08:28'!addValue: anObject	self subclassResponsibility ! !!Annotation methodsFor: 'adding' stamp: 'pmm 6/9/2006 10:18'!addValues: aCollection	aCollection do: [ :each |		self addValue: each ]! !!Annotation methodsFor: 'adding' stamp: 'pmm 6/11/2006 15:07'!mergeValueOf: anAnnotation	self subclassResponsibility ! !!Annotation methodsFor: 'enumerating' stamp: 'pmm 10/9/2005 20:14'!do: aBlock	self subclassResponsibility ! !!Annotation methodsFor: 'testing' stamp: 'pmm 6/12/2006 08:34'!evaluateAtCompiletime	^false! !!Annotation methodsFor: 'testing' stamp: 'pmm 10/9/2005 20:14'!hasValue	self subclassResponsibility ! !!Annotation methodsFor: 'testing' stamp: 'pmm 6/7/2006 09:21'!isBinary	^self hasValue and: [ self isKeyword not ]! !!Annotation methodsFor: 'testing' stamp: 'pmm 6/5/2006 13:04'!isEmpty	^self size isZero! !!Annotation methodsFor: 'testing' stamp: 'pmm 6/7/2006 09:20'!isKeyword	^self key includes: $:! !!Annotation methodsFor: 'testing' stamp: 'pmm 9/29/2005 08:27'!isMultivalued	self subclassResponsibility ! !!Annotation methodsFor: 'testing' stamp: 'pmm 10/9/2005 20:13'!isSourceVisible	self subclassResponsibility! !!Annotation methodsFor: 'testing' stamp: 'pmm 6/7/2006 09:21'!isUnary	^self hasValue not! !!Annotation methodsFor: 'testing' stamp: 'pmm 6/3/2006 14:35'!notEmpty	^self isEmpty not! !!Annotation methodsFor: 'convenience' stamp: 'pmm 6/7/2006 09:23'!ifUnary: anUnaryBlock ifBinary: aBinaryBlock ifKeyword: aKeywordBlock	^self isUnary		ifTrue: anUnaryBlock		ifFalse: [			self isKeyword				ifTrue:aKeywordBlock				ifFalse: aBinaryBlock ]! !!Annotation methodsFor: 'accessing' stamp: 'pmm 9/29/2005 08:28'!key	^key! !!Annotation methodsFor: 'accessing' stamp: 'pmm 6/11/2006 21:49'!key: aSymbol 	key := aSymbol! !!Annotation methodsFor: 'accessing' stamp: 'pmm 10/9/2005 20:13'!size	self subclassResponsibility ! !!Annotation class methodsFor: 'instance creation' stamp: 'pmm 9/24/2006 13:43'!forKey: aSymbol	^self forKey: aSymbol default: GenericNoValueAnnotation! !!Annotation class methodsFor: 'instance creation' stamp: 'pmm 9/24/2006 13:43'!forKey: aSymbol default: defaultClass	| class |	class := self allSubclasses		detect: [ :each | each keys includes: aSymbol ]		ifNone: [			^defaultClass new				sourceVisible: true;				yourself ].	^class key: aSymbol! !!Annotation class methodsFor: 'instance creation' stamp: 'pmm 12/23/2006 15:41'!forKey: aSymbol values: aCollection	| annotation |	annotation := self		forKey: aSymbol		default: (aCollection isEmpty			ifTrue: [ GenericNoValueAnnotation ]			ifFalse: [  GenericMultiValuedAnnotation ]).	annotation addValue: (annotation evaluateAtCompiletime		ifTrue: [ aCollection collect: [ :each | each evaluate ] ]		ifFalse: [ aCollection ]).	^annotation! !!Annotation class methodsFor: 'instance creation' stamp: 'pmm 10/9/2005 20:35'!key: aSymbol	^self new		key: aSymbol;		yourself! !!Annotation class methodsFor: 'accessing' stamp: 'pmm 10/9/2005 23:08'!keys	^#()! !!AssertionAnnotation methodsFor: 'testing' stamp: 'pmm 10/9/2005 23:50'!isSourceVisible	^true! !!AssertionAnnotation class methodsFor: 'accessing' stamp: 'pmm 10/9/2005 20:31'!assertionAnnotationKey	^#assertion! !!AssertionAnnotation class methodsFor: 'accessing' stamp: 'pmm 10/9/2005 20:32'!keys	^Array with: self assertionAnnotationKey ! !!AssertionTransformer methodsFor: 'accessing' stamp: 'pmm 9/16/2005 09:12'!addAssertedNode: aNode	^self assertedNodes add: aNode! !!AssertionTransformer methodsFor: 'accessing' stamp: 'pmm 9/16/2005 09:12'!assertedNodes	^assertedNodes! !!AssertionTransformer methodsFor: 'accessing' stamp: 'pmm 9/16/2005 09:12'!assertedNodes: aSet 	assertedNodes := aSet! !!AssertionTransformer methodsFor: 'accessing' stamp: 'pmm 10/9/2005 22:33'!assertionAnnotationKey	^AssertionAnnotation assertionAnnotationKey ! !!AssertionTransformer methodsFor: 'testing' stamp: 'pmm 9/16/2005 09:17'!alreadyAsserted: aNode	^self assertedNodes includes: aNode! !!AssertionTransformer methodsFor: 'testing' stamp: 'pmm 9/16/2005 09:17'!notAlreadyAsserted: aNode	^(self alreadyAsserted: aNode) not! !!AssertionTransformer methodsFor: 'testing' stamp: 'pmm 10/27/2005 11:08'!shouldAssert: aNode	^(aNode hasAnnotation: self assertionAnnotationKey)		and: [ self notAlreadyAsserted: aNode ]		and: [ self useAssertions ]! !!AssertionTransformer methodsFor: 'testing' stamp: 'pmm 9/19/2005 16:52'!shouldRemove: aNode	^(aNode hasAnnotation: self assertionAnnotationKey)		and: [ self notAlreadyAsserted: aNode ]		and: [ self useAssertions not ]! !!AssertionTransformer methodsFor: 'testing' stamp: 'pmm 9/16/2005 09:17'!useAssertions	^ Preferences useAssertions! !!AssertionTransformer methodsFor: 'initialize-release' stamp: 'pmm 9/16/2005 09:11'!initialize	super initialize.	self assertedNodes: IdentitySet new! !!AssertionTransformer methodsFor: 'private' stamp: 'pmm 9/19/2005 11:05'!removeNode: aNode	aNode parent removeNode: aNode! !!AssertionTransformer methodsFor: 'transforming' stamp: 'pmm 11/27/2006 16:21'!transformAssertedNode: aNode	| selfVar message oldParent |	self addAssertedNode: aNode. 	oldParent := aNode parent.	selfVar := 'self' asVariableNode.	message := RBMessageNode		receiver: selfVar		selector: #assert:		argument: aNode.	selfVar parent: message.	aNode parent: message.	oldParent replaceNodeAndSetParent: aNode withNode: message.	self visitNode: message! !!AssertionTransformer methodsFor: 'visiting' stamp: 'pmm 9/19/2005 17:23'!visitNode: aNode	^(self shouldAssert: aNode)		ifTrue: [ self transformAssertedNode: aNode ]		ifFalse: [ 			(self shouldRemove: aNode)				ifTrue: [ self removeNode: aNode ]				ifFalse: [ super visitNode: aNode ] ]! !!AssertionTransformer class methodsFor: 'class initialization' stamp: 'md 12/16/2007 21:39'!initialize	"self initialize"	Preferences		addBooleanPreference: #useAssertions		category: #reflectivitydemo		default: false		balloonHelp: 'If selected assertions get compiled in.'! !!AssertionTransformer class methodsFor: 'accessing' stamp: 'pmm 6/11/2006 10:41'!priority	^16rFF! !!AssertionTransformer class methodsFor: 'plugin interface' stamp: 'md 12/16/2007 21:44'!isActive	 ^Preferences useAssertions! !!AtomMorph methodsFor: 'private' stamp: 'Y.-G.G. 4/3/2014 17:20'!bounceIn: aRect	"Move this atom one step along its velocity vector and make it bounce if it goes outside the given rectangle. Return true if it is bounced."	| p vx vy px py bounced |	p := self position.	vx := velocity x.		vy := velocity y.	px := p x + vx.		py := p y + vy.	bounced := false.	px > aRect right ifTrue: [		px := aRect right - (px - aRect right).		vx := velocity x negated.		bounced := true].	py > aRect bottom ifTrue: [		py :=  aRect bottom - (py - aRect bottom).		vy := velocity y negated.		bounced := true].	px < aRect left ifTrue: [		px := aRect left - (px - aRect left).		vx := velocity x negated.		bounced := true].	py < aRect top ifTrue: [		py :=  aRect top - (py - aRect top).		vy := velocity y negated.		bounced := true].	self position: px @ py.	bounced ifTrue: [self velocity: vx @ vy].	^ bounced! !!BasicLintRule methodsFor: 'private'!defaultResultClass	^SelectorEnvironment! !!BasicLintRule methodsFor: 'private' stamp: 'md 3/26/2007 12:18'!openWithFilters	| |	self needsWork.	"browser := self filteredResult openEditor.	navigator := browser navigator.	filter := navigator environment andedEnvironment environment.	(filter isClassEnvironment or: [filter isSelector]) 		ifTrue: 			[menuItem := MenuItem labeled: 'add filter for class'.			menuItem value: 					[(BasicLintRule filterFor: self name) addClass: navigator selectedClass.					filter addClass: navigator selectedClass.					navigator updateCategoryList].			navigator classMenu value addItemGroup: (Array with: menuItem).			navigator updateClassMenu].	filter isSelector 		ifTrue: 			[menuItem := MenuItem labeled: 'add filter for selector'.			menuItem value: 					[(BasicLintRule filterFor: self name) addClass: navigator selectedClass						selector: navigator selector.					filter addClass: navigator selectedClass selector: navigator selector.					navigator updateCategoryList].			navigator selectorMenu value addItemGroup: (Array with: menuItem).			navigator updateSelectorMenu].	^browser"! !!BasicLintRule methodsFor: 'private' stamp: 'bh 5/9/2000 00:16'!openWithoutFilters	^self result openEditor! !!BasicLintRule methodsFor: 'private' stamp: 'bh 5/9/2000 00:16'!viewResults	^self perform: openSymbol! !!BasicLintRule methodsFor: 'accessing'!filteredResult	^(result 		& (self class filterDictionary at: self name ifAbsent: [result copyEmpty]) 				copy not)		label: result label;		yourself! !!BasicLintRule methodsFor: 'accessing'!problemCount	^self result problemCount! !!BasicLintRule methodsFor: 'accessing'!result	^(self class filterDictionary includesKey: self name) 		ifTrue: [self filteredResult]		ifFalse: [result]! !!BasicLintRule methodsFor: 'initialize-release'!initialize	super initialize.	openSymbol := #openWithFilters.	self resultClass: self defaultResultClass! !!BasicLintRule methodsFor: 'initialize-release'!openUsing: aSymbol 	openSymbol := aSymbol! !!BasicLintRule methodsFor: 'initialize-release'!resetResult	result := result copyEmpty.	result label: name! !!BasicLintRule methodsFor: 'initialize-release'!result: aResult 	result := aResult copyEmpty! !!BasicLintRule methodsFor: 'initialize-release'!resultClass: aClass 	result := aClass new! !!BasicLintRule methodsFor: 'testing'!isEmpty	^self result isEmpty! !!BasicLintRule class methodsFor: 'accessing'!addFilter: anEnvironment for: aString 	self filterDictionary at: aString put: anEnvironment copy! !!BasicLintRule class methodsFor: 'accessing'!filterDictionary	^FilterDictionary isNil 		ifTrue: [FilterDictionary := Dictionary new]		ifFalse: [FilterDictionary]! !!BasicLintRule class methodsFor: 'accessing'!filterDictionary: aDictionary 	FilterDictionary := aDictionary! !!BasicLintRule class methodsFor: 'accessing'!filterFor: aName 	^self filterDictionary at: aName ifAbsentPut: [SelectorEnvironment new]! !!BasicLintRule class methodsFor: 'accessing'!protocols	^#('bugs' 'possible bugs' 'unnecessary code' 'intention revealing' 'miscellaneous')! !!BasicLintRule class methodsFor: 'storing'!storeFiltersOn: aStream 	aStream		nextPut: $(;		nextPutAll: self name;		nextPutAll: ' filterDictionary: (Dictionary new'.	self filterDictionary keysAndValuesDo: 			[:key :value | 			aStream nextPutAll: ' at: '.			key storeOn: aStream.			aStream nextPutAll: ' put: '.			value storeOn: aStream.			aStream				nextPutAll: ';';				cr].	aStream		tab;		nextPutAll: 'yourself))'! !!BasicLintRuleTest methodsFor: 'accessing'!checkClass: aSmalllintContext 	^classBlock value: aSmalllintContext value: result! !!BasicLintRuleTest methodsFor: 'accessing'!checkMethod: aSmalllintContext 	^methodBlock value: aSmalllintContext value: result! !!BasicLintRuleTest methodsFor: 'accessing' stamp: 'bh 4/3/2000 10:19'!foobar	^#( true false )! !!BasicLintRuleTest methodsFor: 'accessing'!problemCount	^result problemCount! !!BasicLintRuleTest methodsFor: 'accessing'!result	^result! !!BasicLintRuleTest methodsFor: 'initialize-release'!classBlock: aBlock	classBlock := aBlock testMethod1! !!BasicLintRuleTest methodsFor: 'initialize-release'!initialize	super initialize.	classBlock := [:context :aResult | ].	methodBlock := [:context :aResult | ].	self resultClass: SelectorEnvironment! !!BasicLintRuleTest methodsFor: 'initialize-release'!methodBlock: aBlock	methodBlock := aBlock! !!BasicLintRuleTest methodsFor: 'initialize-release'!resetResult	result := result copyEmpty.	result label: name! !!BasicLintRuleTest methodsFor: 'initialize-release'!result: aResult 	result := aResult copyEmpty! !!BasicLintRuleTest methodsFor: 'initialize-release'!resultClass: aClass 	result := aClass new! !!BasicLintRuleTest methodsFor: 'testing'!isEmpty	^result isEmpty! !!BasicLintRuleTest methodsFor: 'private'!viewResults	result openEditor! !!BasicLintRuleTest class methodsFor: 'possible bugs'!abstractClass	| detector subclassResponsibilitySymbol |	detector := self new.	detector name: 'References an abstract class'.	detector resultClass: ClassEnvironment.	subclassResponsibilitySymbol := 'subclassResponsibility' asSymbol.	detector classBlock: 			[:context :result | 			(context selectedClass whichSelectorsReferTo: subclassResponsibilitySymbol)				isEmpty ifFalse: 						[(context							uses: (Smalltalk associationAt: context selectedClass name ifAbsent: [nil]))								ifTrue: [result addClass: context selectedClass]]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!addRemoveDependents	| detector |	detector := self new.	detector resultClass: ClassEnvironment.	detector name: 'Number of addDependent: messages > removeDependent:'.	detector classBlock: 			[:context :result | 			| count |			count := 0.			((Set				withAll: (context selectedClass whichSelectorsReferTo: #addDependent:))					addAll: (context selectedClass whichSelectorsReferTo: #removeDependent:);				yourself) do: 					[:sel | 					(context selectedClass compiledMethodAt: sel) messagesDo: 							[:each | 							each == #addDependent: ifTrue: [count := count + 1].							each == #removeDependent: ifTrue: [count := count - 1]]].			count > 0 ifTrue: [result addClass: context selectedClass]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!collectionCopyEmpty	| detector |	detector := self new.	detector		name: 'Subclass of collection that has instance variable but doesn''t define copyEmpty'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			(context selectedClass isVariable 					and: [(context selectedClass includesSelector: #copyEmpty:) not 						and: [context selectedClass instVarNames isEmpty not							and: [context selectedClass inheritsFrom: Collection]]])				ifTrue: [result addClass: context selectedClass]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!definesEqualNotHash	| detector |	detector := self new.	detector name: 'Defines = but not hash'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			((context selectedClass includesSelector: #=)				and: [(context selectedClass includesSelector: #hash) not])				ifTrue: [result addClass: context selectedClass]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!fileBlocks	^self createParseTreeRule: 				#('[| `@temps | 					`var := `@object.  					`@.statements] 							valueNowOrOnUnwindDo: 								[`var `@messages: `@args]' 				'[| `@temps | 					`var := `@object.  					`@.statements] 							valueOnUnwindDo: 								[`var `@messages: `@args]') 		name: 'Assignment inside unwind blocks should be outside.'! !!BasicLintRuleTest class methodsFor: 'possible bugs'!missingYourself	| detector matcher |	detector := self new.	detector name: 'Possible missing "; yourself"'.	matcher := ParseTreeSearcher new.	matcher		addSearch: '``@xobject `@messages: ``@args' -> 					[:aNode :answer | 					answer or: 							[aNode parent isCascade								and: [aNode isDirectlyUsed and: [aNode selector ~~ #yourself]]]].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs' stamp: 'nk 2/24/2005 13:31'!modifiesCollection	| detector addSearcher |	detector := self new.	detector name: 'Modifies collection while iterating over it'.	addSearcher := ParseTreeLintRule modifiesCollection.	detector methodBlock: 			[:context :result | 			addSearcher executeTree: context parseTree initialAnswer: false.			addSearcher answer 				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs' stamp: 'bh 4/3/2000 11:54'!returnsBooleanAndOther	| detector matcher |	detector := self new.	detector name: 'Returns a boolean and non boolean'.	matcher := ParseTreeSearcher new.	matcher addSearch: '^``@xObject' -> 					[:aNode :answer | 					answer add: aNode value;						yourself].	detector methodBlock: 			[:context :result | 			| hasBool hasSelf |			hasBool := false.			hasSelf := context parseTree lastIsReturn not.			(matcher executeTree: context parseTree initialAnswer: Set new) do: 					[:each | 					hasBool := hasBool or: 									[(each isLiteral and: [{true. false} includes: each value])										or: [each isMessage and: [#(#and: #or:) includes: each selector]]].					hasSelf := hasSelf or: 									[(each isVariable and: [each name = 'self'])										or: [each isLiteral and: [({true. false} includes: each value) not]]]].			hasSelf & hasBool				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!returnsIfTrue	^self createParseTreeRule: 				#('^`@condition ifTrue: [| `@temps | `@.statements]' 				'^`@condition ifFalse: [| `@temps | `@.statements]') 		name: 'Returns value of ifTrue:/ifFalse: without ifFalse:/ifTrue: block'! !!BasicLintRuleTest class methodsFor: 'possible bugs'!sendsDifferentSuper	| detector |	detector := self new.	detector name: 'Sends different super message'.	detector methodBlock: 			[:context :result | 			| message |			(message := context superMessages detect: [:each | each ~= context selector]						ifNone: [nil]) notNil ifTrue: 					[result addSearchString: message.					result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!sentNotImplementedInApplication	| detector |	detector := self new.	detector name: 'Messages sent but not implemented in application'.	detector methodBlock: 			[:context :result | 			| message class block |			message := context messages						detect: [:each | (context isItem: each in: context application) not]						ifNone: [nil].			class := context selectedClass.			block := 					[:each | 					| app |					app := context application.					(self canCall: each						in: class						from: app) not].			message isNil ifTrue: [message := context selfMessages detect: block ifNone: [nil]].			message isNil ifTrue: 					[class := class superclass.					class isNil						ifTrue: 							[context superMessages isEmpty ifFalse: [message := context superMessages asArray first]]						ifFalse: [message := context superMessages detect: block ifNone: [nil]]].			message notNil ifTrue: 					[result addSearchString: message.					result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!superSends	| detector |	detector := self new.	detector name: 'Missing super sends'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMetaclass not				and: [self superMessages includes: context selector]) ifTrue: 						[(context selectedClass superclass notNil							and: [context selectedClass superclass canUnderstand: context selector])								ifTrue: 									[(context superMessages includes: context selector)										ifFalse: [result addClass: context selectedClass selector: context selector]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!tempVarOverridesInstVar	| detector matcher vars varName |	detector := self new.	detector name: 'Instance variable overridden by temporary variable'.	matcher := (ParseTreeSearcher new) addArgumentSearch: '`xxxvar' -> 								[:aNode :answer | 								answer or: 										[varName := aNode name.										vars includes: varName]];				yourself.	detector methodBlock: 			[:context :result | 			vars := context instVarNames.			(matcher executeTree: context parseTree initialAnswer: false) ifTrue: 					[result addClass: context selectedClass selector: context selector.					result addSearchString: varName]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!tempsReadBeforeWritten	| detector |	detector := self new.	detector name: 'Temporaries read before written'.	detector methodBlock: 			[:context :result | 			| variables |			variables := ParseTreeSearcher nonBlockTempsIn: context parseTree.			variables isEmpty 				ifFalse: 					[(RBReadBeforeWrittenTester variablesReadBeforeWrittenIn: context parseTree) 						do: 							[:each | 							result addClass: context selectedClass selector: context selector.							result addSearchString: each]]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!threeElementPoint	| detector matcher |	detector := self new.	detector name: 'Possible three element point (e.g., x @ y + q @ r)'.	matcher := (ParseTreeSearcher new) addSearch: '``@x @ ``@y' -> 								[:aNode :answer | 								answer or: 										[| current |										current := aNode parent.										[current isNil or: 												[current isMessage													and: [current selector == #@ or: [current selector isInfix not]]]]											whileFalse: [current := current parent].										(current isNil or: [current isMessage and: [current selector isInfix not]])											not]];				yourself.	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!usesAdd	| detector addSearcher |	detector := self new.	detector name: 'Uses the result of an add: message'.	addSearcher := ParseTreeSearcher usesResultOfAdd.	detector methodBlock: 			[:context :result | 			(addSearcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!assignmentInBlock	^self createParseTreeRule: #(			'`@cursor showWhile: [| `@temps | `@.Statements1. `var := `@object]' 			'`@cursor showWhile: [| `@temps | `@.Statements1. ^`@object]' 			'[| `@temps | `@.Statements. `var := `@object] valueNowOrOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. ^`@object] valueNowOrOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. `var := `@object] valueOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. ^`@object] valueOnUnwindDo: `@block' ) 		name: 'Unnecessary assignment or return in block'! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!badMessage	| detector badMessages |	detector := self new.	detector name: 'Sends "questionable" message'.	badMessages := self badSelectors.	detector classBlock: 			[:context :result | 			| selectors |			selectors := badMessages inject: Set new						into: 							[:set :each | 							set addAll: (context selectedClass whichSelectorsReferTo: each);								yourself].			selectors do: [:each | result addClass: context selectedClass selector: each].			selectors isEmpty ifFalse: [result searchStrings: badMessages]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!classNameInSelector	| detector |	detector := self new.	detector name: 'Redundant class name in selector'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMetaclass and: 					[(context selector						indexOfSubCollection: context selectedClass primaryInstance name						startingAt: 1) > 0])				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous' stamp: 'bh 4/8/2000 19:05'!fullBlocks"skip this test in squeak.""	| detector |	detector := self new.	detector name: 'Method with full blocks'.	detector methodBlock: 			[:context :result | 			context compiledMethod withAllBlockMethodsDo: 					[:method | 					method needsHybridFrame						ifTrue: [result addClass: context selectedClass selector: context selector]]].	^detector"! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!ifTrueBlocks	| detector matcher |	detector := self new.	detector name: 'Non-blocks in ifTrue:/ifFalse: messages'.	matcher := ParseTreeSearcher new.	matcher		addSearches: #('``@condition ifTrue: ``@block' '``@condition ifFalse: ``@block' '``@condition ifTrue: ``@block1 ifFalse: ``@block2' '``@condition ifFalse: ``@block1 ifTrue: ``@block2')				-> 					[:aNode :answer | 					answer or: 							[(aNode arguments detect: [:each | each isBlock not] ifNone: [nil]) notNil]].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!instVarInSubclasses	| detector |	detector := self new.	detector name: 'Instance variables defined in all subclasses'.	detector result: nil pullUpInstVar.	detector classBlock: 			[:context :result | 			| subs |			subs := context selectedClass subclasses.			subs size > 1 ifTrue: 					[| sels |					sels := Bag new.					subs do: [:each | sels addAll: each instVarNames].					sels asSet do: 							[:val | 							(sels occurrencesOf: val) == subs size								ifTrue: [result addInstVar: val for: context selectedClass]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!longMethods	| detector matcher |	detector := self new.	detector name: 'Long methods'.	matcher := ParseTreeSearcher new.	matcher		addSearch: '`.Stmt' -> 					[:aNode :answer | 					(aNode children inject: answer						into: [:sum :each | matcher executeTree: each initialAnswer: sum]) + 1].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: 0)				>= self longMethodSize					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!precedence	| detector matcher |	detector := self new.	detector name: 'Inspect instances of "A + B * C" might be "A + (B * C)"'.	matcher := ParseTreeSearcher new.	matcher addSearches: #('``@A + ``@B * ``@C' '``@A - ``@B * ``@C')				-> [:aNode :answer | answer or: [aNode receiver parentheses isEmpty]].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!refersToClass	| detector |	detector := self new.	detector name: 'Refers to class name instead of "self class"'.	detector classBlock: 			[:context :result | 			| sels className |			className := (context selectedClass isMetaclass						ifTrue: [context selectedClass primaryInstance]						ifFalse: [context selectedClass]) name.			sels := context selectedClass						whichSelectorsReferTo: (Smalltalk associationAt: className).			sels isEmpty ifFalse: 					[result addSearchString: className.					sels do: [:each | result addClass: context selectedClass selector: each]]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!stringConcatenation	| detector matcher concatenationMatcher |	detector := self new.	detector name: 'String concatenation instead of streams'.	matcher := ParseTreeSearcher new.	concatenationMatcher := ParseTreeSearcher new.	concatenationMatcher		addSearch: '`@receiver , `@argument' -> [:aNode :answer | true].	matcher		addSearches: #('``@collection do: [:`each | | `@temps | ``@.Statements]' '``@collection do: [:`each | | `@temps | ``@.Statements] separatedBy: [| `@temps1 | ``@.Statements1]' '``@number to: ``@endNumber do: [:`i | | `@temps | ``@.Statements]' '``@collection detect: [:`each | | `@temps | ``@.Statements]' '``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [| `@temps1 | ``@.Statements1]' '``@collection select: [:`each | | `@temps | ``@.Statements]' '``@collection inject: ``@value into: [:`each | | `@temps | ``@.Statements]')				-> 					[:aNode :answer | 					answer or: 							[(aNode arguments detect: 									[:each | 									each isBlock										and: [concatenationMatcher executeTree: each initialAnswer: false]]								ifNone: [nil]) notNil]].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!utilityMethods	| detector |	detector := self new.	detector name: 'Utility methods'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMetaclass | (context selector numArgs == 0) or: 					[(context protocols detect: 							[:each | 							(self utilityProtocols detect: [:protocol | protocol match: each]								ifNone: [nil]) notNil]						ifNone: [nil]) notNil])				ifFalse: 					[(self subclassOf: context selectedClass overrides: context selector)						ifFalse: 							[(context superMessages isEmpty and: [context selfMessages isEmpty]) ifTrue: 									[(ParseTreeSearcher										references: context selectedClass allInstVarNames												, context selectedClass allClassVarNames asArray , #('self')										in: context parseTree) isEmpty										ifTrue: [result addClass: context selectedClass selector: context selector]]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!variableAssignedLiteral	| detector |	detector := self new.	detector name: 'Variable is only assigned a single literal value'.	detector result: nil references.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| defClass selector |					(allSubclasses inject: 0						into: 							[:sum :class | 							| sels |							sels := class whichSelectorsWrite: each.							sels size == 1 ifTrue: 									[selector := sels asArray first.									defClass := class].							sum + sels size])							== 1 ifTrue: 								[| tree searcher |								searcher := ParseTreeSearcher new.								searcher addSearch: (each , ' := ``@object')											-> [:aNode :answer | answer isNil and: [aNode value isLiteral]].								tree := defClass parseTreeFor: selector.								tree notNil ifTrue: 										[(searcher executeTree: tree initialAnswer: nil) == true											ifTrue: [result addInstVar: each for: context selectedClass]]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!yourselfNotUsed	| detector addSearcher |	detector := self new.	detector name: 'Doesn''t use the result of a yourself message'.	addSearcher := ParseTreeSearcher new.	addSearcher addSearch: '`@object yourself'				-> [:aNode :answer | answer or: [aNode isUsed not]].	detector methodBlock: 			[:context :result | 			(addSearcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!assignmentInIfTrue	^self createParseTreeRule: 			#('`@boolean 					ifTrue: [| `@temps1 | `@.Statements1. `var := `@object1] 					ifFalse: [| `@temps2 | `@.Statements2. `var := `@object2]' 			'`@boolean 					ifFalse: [| `@temps1 | `@.Statements1. `var := `@object1] 					ifTrue: [| `@temps2 | `@.Statements2. `var := `@object2]') 		name: 'Assignment to same variable and end of ifTrue:ifFalse: blocks'! !!BasicLintRuleTest class methodsFor: 'intention revealing'!atIfAbsent	^self createParseTreeRule: 				#('`@object 						at: `@atArg 						ifAbsent: [| `@temps | `@.Statements. `@object at: `@atArg put: `@putArg]' 				'`@object 						at: `@atArg 						ifAbsent: [| `@temps | 								`@.Statements. 								`@object at: `@atArg put: `@putArg. 								`@.xStatements1. 								`@putArg]') 		name: 'Uses at:ifAbsent: instead of at:ifAbsentPut:'! !!BasicLintRuleTest class methodsFor: 'intention revealing'!collectionMessagesToExternalObject	| detector matcher |	detector := self new.	detector name: 'Sends add:/remove: to external collection'.	matcher := ParseTreeSearcher new.	matcher		addSearches: (#(#add: #remove: #addAll: #removeAll:)				collect: [:each | ('(`@Object `@message: `@args) <1s> `@Arg' expandMacrosWith: each) asString])					-> 						[:aNode :answer | 						answer or: 								[(aNode receiver selector copyFrom: 1 to: (aNode receiver selector size min: 2))									~= 'as' and: 											[| receiver |											receiver := aNode receiver receiver.											receiver isVariable not or: 													[((#('self' 'super') includes: receiver name)														or: [Smalltalk includesKey: receiver name asSymbol]) not]]]].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!collectionProtocol	^self createParseTreeRule: 			#('`@collection do: [:`each | | `@temps | `@.Statements1. `@object add: `@arg. `@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@blockTemps | 							`@.BlockStatements1. 							`@object add: `each. 							`@.BlockStatements2]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@blockTemps | 							`@.BlockStatements1. 							`@object add: `each. 							`@.BlockStatements2]. 					`@.Statements2]') 		name: 'Uses do: instead of collect: or select:''s'! !!BasicLintRuleTest class methodsFor: 'intention revealing'!consistencyCheck	^self createParseTreeRule: 				#('`@object size == 0' 				'`@object size = 0' 				'`@object size > 0' 				'`@object size >= 1' 				'`@object == nil' 				'`@object = nil') 		name: 'Uses "size = 0" or "= nil" instead of "isEmpty" or "isNil"'! !!BasicLintRuleTest class methodsFor: 'intention revealing'!contains	^self createParseTreeRule: 			#('(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) isNil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) notNil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) = nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) == nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) ~= nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) ~~ nil' 			'`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [| `@temps1 | `@.Statements2. ^`@anything]') 		name: 'Uses detect:ifNone: instead of contains:'! !!BasicLintRuleTest class methodsFor: 'intention revealing'!detectContains	^self createParseTreeRule: 			#('`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^`each]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^`each]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^true]. 					`@.Statements2]' 			'`@Collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^true]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^false]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^false]. 					`@.Statements2]') 		name: 'Uses do: instead of contains: or detect:''s'! !!BasicLintRuleTest class methodsFor: 'intention revealing'!guardingClause	^self		createParseTreeRule: 				#('`@MethodName: `@args 						| `@temps | 						`@.Statements. 						`@condition ifTrue: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]' 				'`@MethodName: `@args 						| `@temps | 						`@.Statements. 						`@condition ifFalse: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]')		method: true		name: 'Guarding clauses'! !!BasicLintRuleTest class methodsFor: 'intention revealing' stamp: 'bh 4/3/2000 11:51'!ifTrueReturns	| detector matcher |	detector := self new.	detector name: 'ifTrue:/ifFalse: returns instead of and:/or:''s'.	matcher := ParseTreeSearcher new.	matcher addSearches:		#('| `@temps | ``@.Statements. ``@object ifTrue: [^``@value1]. ^``@value2' 		'| `@temps | ``@.Statements. ``@object ifFalse: [^``@value1]. ^``@value2') 			-> [:aNode :answer | answer				or: 					[| node |					node := (aNode statements at: aNode statements size - 1) arguments first body statements last value. "``@value1"					(node isLiteral and: [{true. false} includes: node value])						or: 							[node := aNode statements last value.							node isLiteral and: [{true. false} includes: node value]]]].	detector methodBlock: [:context :result | (matcher executeTree: context parseTree initialAnswer: false)			ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!minMax	| detector matcher |	detector := self new.	detector name: 'Uses ifTrue:/ifFalse: instead of min: or max:'.	matcher := ParseTreeSearcher new.	matcher		addSearches: #('(`x `message: `@y) `ifTrue: [`x := `@y]' '(`@x `message: `@y) `ifTrue: [`@x] `ifFalse: [`@y]')				-> 					[:aNode :answer | 					answer or: 							[(#(#ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue:)								includes: aNode selector)									and: [#(#< #<= #> #>=) includes: aNode receiver selector]]].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!missingSubclassResponsibility	| detector |	detector := self new.	detector name: 'Method defined in all subclasses, but not in superclass'.	detector resultClass: MultiEnvironment.	detector classBlock: 			[:context :result | 			| subs |			subs := context selectedClass subclasses.			subs size > 1 & context selectedClass isMetaclass not ifTrue: 					[| sels |					sels := Bag new.					subs do: [:each | sels addAll: each selectors].					sels asSet do: 							[:each | 							((sels occurrencesOf: each) == subs size								and: [(context selectedClass canUnderstand: each) not]) ifTrue: 										[| envName |										envName := context selectedClass name , '>>', each.										subs do: 												[:subClass | 												result addClass: subClass													selector: each													into: envName]]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!sizeCheck	^self createParseTreeRule: (#(#do: #collect: #reject: #select:) collect: 					[:each | 					'`@object size > 0 ifTrue: [`@object ' , each						, ' [:`each | | `@temps | `@.Statements1]. `@.Statements2]'])				, (#(#do: #collect: #reject: #select:) collect: 							[:each | 							'`@object isEmpty ifFalse: [`@object ' , each								, ' [:`each | | `@temps | `@.Statements1]. `@.Statements2]'])		name: 'Unnecessary size check'! !!BasicLintRuleTest class methodsFor: 'intention revealing'!toDo	| detector matcher |	detector := self new.	detector name: 'Uses to:do: instead of do:, with:do: or timesRepeat:'.	matcher := ParseTreeSearcher new.	matcher		addSearch: '1 to: ``@object size do: [:`each | | `@temps | `@.Statements]' -> 					[:aNode :answer | 					answer or: 							[| varName variableMatcher |							varName := aNode arguments last arguments first name. "`each"							variableMatcher := ParseTreeSearcher new.							variableMatcher addSearch: varName										-> [:node :ans | ans and: [node parent isMessage and: [node parent selector == #at:]]].							variableMatcher executeTree: aNode arguments last body initialAnswer: true]].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!whileTrue	^self createParseTreeRule: 			#('| `@temps | 				`@.Statements1. 				[`index <= `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index + 1].				`@.Statements2' 			'| `@temps | 				`@.Statements1. 				[`index < `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index + 1].				`@.Statements2'			'| `@temps | 				`@.Statements1. 				[`index >= `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index - 1].				`@.Statements2' 			'| `@temps | 				`@.Statements1. 				[`index > `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index - 1].				`@.Statements2') 		name: 'Uses whileTrue: instead of to:do:'! !!BasicLintRuleTest class methodsFor: 'private'!badSelectors	^#(#become: #isKindOf: #changeClassToThatOf: #respondsTo: #isMemberOf: #performMethod: #performMethod:arguments: #performMethod:with: #performMethod:with:with: #performMethod:with:with:with: #allOwners #allOwnersWeakly: #firstOwner #instVarAt: #instVarAt:put: #nextInstance #nextObject #ownerAfter: #primBecome:  #halt)! !!BasicLintRuleTest class methodsFor: 'private'!canCall: aSelector in: aClass from: anApplication 	| methodApp root |	(aClass canUnderstand: aSelector) ifFalse: [^false].	root := anApplication rootApplication.	methodApp := ((aClass whichClassIncludesSelector: aSelector) compiledMethodAt: aSelector)				application rootApplication.	^methodApp == root or: [root isBasedOn: methodApp]! !!BasicLintRuleTest class methodsFor: 'private'!classShouldNotOverride	^#(#== #class)! !!BasicLintRuleTest class methodsFor: 'private'!createMatcherFor: codeStrings method: aBoolean 	| matcher |	matcher := ParseTreeSearcher new.	aBoolean		ifTrue: [matcher addMethodSearches: codeStrings -> [:aNode :answer | true]]		ifFalse: [matcher addSearches: codeStrings -> [:aNode :answer | true]].	^matcher! !!BasicLintRuleTest class methodsFor: 'private'!longMethodSize	^10! !!BasicLintRuleTest class methodsFor: 'private'!metaclassShouldNotOverride	^#(#name #comment)! !!BasicLintRuleTest class methodsFor: 'private' stamp: 'nk 2/23/2005 16:09'!new	^super new! !!BasicLintRuleTest class methodsFor: 'private'!subclassOf: aClass overrides: aSelector 	| subs |	subs := aClass subclasses.	1 to: subs size		do: 			[:i | 			| each |			each := subs at: i.			(each includesSelector: aSelector) ifTrue: [^true].			(self subclassOf: each overrides: aSelector) ifTrue: [^true]].	^false! !!BasicLintRuleTest class methodsFor: 'private'!superMessages	^#(#release #postCopy #postBuildWith: #preBuildWith: #postOpenWith: #noticeOfWindowClose: #initialize)! !!BasicLintRuleTest class methodsFor: 'private'!utilityProtocols	"If a method is defined in one of these protocols, then don't check if its a utility method."	^#('*utilit*')! !!BasicLintRuleTest class methodsFor: 'bugs'!booleanPrecedence	^self createParseTreeRule: 			#('`@object1 | `@object2 = `@object3'			'`@object1 | `@object2 == `@object3'			'`@object1 & `@object2 = `@object3'			'`@object1 & `@object2 == `@object3'			'`@object1 | `@object2 ~= `@object3'			'`@object1 | `@object2 ~~ `@object3'			'`@object1 & `@object2 ~= `@object3'			'`@object1 & `@object2 ~~ `@object3')		name: 'Uses A | B = C instead of A | (B = C)'! !!BasicLintRuleTest class methodsFor: 'bugs'!overridesSpecialMessage	| detector |	detector := self new.	detector name: 'Overrides a "special" message'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			((context selectedClass isMetaclass				ifTrue: [self metaclassShouldNotOverride]				ifFalse: [self classShouldNotOverride]) detect: 						[:each | 						context selectedClass superclass notNil and: 								[(context selectedClass superclass canUnderstand: each)									and: [context selectedClass includesSelector: each]]]					ifNone: [nil]) notNil ifTrue: [result addClass: context selectedClass]].	^detector! !!BasicLintRuleTest class methodsFor: 'bugs'!sentNotImplemented	| detector |	detector := self new.	detector name: 'Messages sent but not implemented'.	detector methodBlock: 			[:context :result | 			| message |			message := context messages detect: [:each | (context implements: each) not]						ifNone: [nil].			message isNil ifTrue: 					[message := context superMessages detect: 									[:each | 									context selectedClass superclass isNil										or: [(context selectedClass superclass canUnderstand: each) not]]								ifNone: [nil].					message isNil ifTrue: 							[message := context selfMessages										detect: [:each | (context selectedClass canUnderstand: each) not]										ifNone: [nil]]].			message notNil ifTrue: 					[result addSearchString: message.					result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'bugs'!subclassResponsibilityNotDefined	| detector subclassResponsibilitySymbol |	detector := self new.	subclassResponsibilitySymbol := 'subclassResponsibility' asSymbol.	detector name: 'Subclass responsibility not defined'.	detector classBlock: 			[:context :result | 			(context selectedClass whichSelectorsReferTo: subclassResponsibilitySymbol)				do: 					[:each | 					(context selectedClass withAllSubclasses detect: 							[:class | 							class subclasses isEmpty								and: [(class whichClassIncludesSelector: each) == context selectedClass]]						ifNone: [nil]) notNil						ifTrue: [result addClass: context selectedClass selector: each]]].	^detector! !!BasicLintRuleTest class methodsFor: 'bugs'!usesTrue	| detector trueBinding falseBinding |	detector := self new.	trueBinding := Smalltalk associationAt: #True.	falseBinding := Smalltalk associationAt: #False.	detector name: 'Uses True/False instead of true/false'.	detector methodBlock: 			[:context :result | 			| method |			method := context compiledMethod.			((method referencesLiteral: trueBinding)				or: [method referencesLiteral: falseBinding]) ifTrue: 						[result addClass: context selectedClass selector: context selector.						result searchStrings: #('True' 'False')]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!classNotReferenced	| detector |	detector := self new.	detector name: 'Class not referenced'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			(context selectedClass isMetaclass				or: [context isApplication				or: [context selectedClass subclasses isEmpty not]])					ifFalse: 						[| assoc |						assoc := Smalltalk associationAt: context selectedClass name.						((context uses: assoc) or: [context uses: context selectedClass name])							ifFalse: 								[result addClass: context selectedClass;									addClass: context selectedClass class]]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!endTrueFalse	| detector matcher |	detector := self new.	detector name: 'Check for same statements at end of ifTrue:ifFalse: blocks'.	matcher := (ParseTreeSearcher new) addSearches: 				#('`@object 						ifTrue: [| `@temps1 | `@.Statements1. `.Statement] 						ifFalse: [| `@temps2 | `@.Statements2. `.Statement]' 				'`@object 						ifTrue: [| `@temps1 | `.Statement. `@.Statements1] 						ifFalse: [| `@temps2 | `.Statement. `@.Statements2]' 				'`@object 						ifFalse: [| `@temps1 | `@.Statements1. `.Statement] 						ifTrue: [| `@temps2 | `@.Statements2. `.Statement]' 				'`@object 						ifFalse: [| `@temps1 | `.Statement. `@.Statements1] 						ifTrue: [| `@temps2 | `.Statement. `@.Statement2]') 			-> [:aNode :answer | answer						or: 							[| node |							node := aNode arguments first body statements last.							(node isVariable and: [node = aNode arguments last body statements last]) not]]; yourself.	detector methodBlock: [:context :result | (matcher executeTree: context parseTree initialAnswer: false)			ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!equalsTrue	| detector matcher |	detector := self new.	detector name: 'Unnecessary "= true"'.	matcher := (ParseTreeSearcher new) addSearches: #('true' 'false') -> 								[:aNode :answer | 								answer or: 										[aNode parent isMessage											and: [#(#= #== #~= #~~) includes: aNode parent selector]]];				yourself.	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!equivalentSuperclassMethods	| detector |	detector := self new.	detector name: 'Methods equivalently defined in superclass'.	detector methodBlock: 			[:context :result | 			context selectedClass superclass notNil ifTrue: 					[(context selectedClass superclass canUnderstand: context selector)						ifTrue: 							[(((context selectedClass superclass								whichClassIncludesSelector: context selector)									compiledMethodAt: context selector)									equivalentTo: context compiledMethod)									ifTrue: [result addClass: context selectedClass selector: context selector]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!extraBlock	^self		createParseTreeRule: (#('value' 'value: `@value' 'value: `@value1 value: `@value2' 'value: `@value1 value: `value2 value: `@value3' 'valueWithArguments: `@values')				collect: [:each | '[:`@params | | `@temps | `@.statements] ' , each])		name: 'Block immediately evaluated'! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!implementedNotSent	| detector |	detector := self new.	detector name: 'Methods implemented but not sent'.	detector methodBlock: 			[:context :result | 			(context uses: context selector)				ifFalse: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!justSendsSuper	| detector matcher |	detector := self new.	detector name: 'Method just sends super message'.	matcher := ParseTreeSearcher justSendsSuper.	detector methodBlock: 			[:context :result | 			(context parseTree tag isNil				and: [matcher executeMethod: context parseTree initialAnswer: false])					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!onlyReadOrWritten	| detector |	detector := self new.	detector name: 'Instance variables not read AND written'.	detector result: nil references.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| reads writes |					reads := false.					writes := false.					allSubclasses detect: 							[:class | 							reads ifFalse: [reads := (class whichSelectorsRead: each) isEmpty not].							writes ifFalse: [writes := (class whichSelectorsWrite: each) isEmpty not].							reads & writes]						ifNone: [result addInstVar: each for: context selectedClass]]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!unreferencedVariables	| detector |	detector := self new.	detector name: 'Variables not referenced'.	detector result: nil unreferenced.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					allSubclasses						detect: [:class | (class whichSelectorsAccess: each) isEmpty not]						ifNone: [result addInstVar: each for: context selectedClass]].			context selectedClass isMetaclass ifFalse: 					[context selectedClass classPool associationsDo: 							[:each | 							(context uses: each)								ifFalse: [result addClassVar: each key for: context selectedClass]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!variableReferencedOnce	| detector |	detector := self new.	detector 		name: 'Variable referenced in only one method and always assigned first'.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| defClass selector |					(allSubclasses inject: 0						into: 							[:sum :class | 							| sels |							sels := class whichSelectorsAccess: each.							sels size == 1 								ifTrue: 									[selector := sels asArray first.									defClass := class].							sum + sels size]) 							== 1 							ifTrue: 								[| tree |								tree := defClass parseTreeFor: selector.								tree notNil 									ifTrue: 										[(RBReadBeforeWrittenTester readBeforeWritten: (Array with: each) in: tree) 											isEmpty 												ifTrue: 													[result addClass: defClass selector: selector.													result addSearchString: each]]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'instance creation'!createParseTreeRule: codeStrings method: aBoolean name: aName 	| detector matcher |	detector := self new.	detector name: aName.	matcher := self createMatcherFor: codeStrings method: aBoolean.	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'instance creation'!createParseTreeRule: codeStrings name: aName 	^self createParseTreeRule: codeStrings		method: false		name: aName! !!BasicLintRuleTest class methodsFor: 'accessing'!protocols	^#('bugs' 'possible bugs' 'unnecessary code' 'intention revealing' 'miscellaneous')! !!Behavior methodsFor: '*ast-override' stamp: 'md 7/13/2006 15:56' prior: 17342556!formatterClass	^Preferences useRBASTForPrettyPrint		ifFalse: [ self compilerClass ]		ifTrue: [ RBParser ]! !!Behavior methodsFor: '*ast-override' stamp: 'md 7/13/2006 15:56' prior: 31945128!prettyPrinterClass	^Preferences useRBASTForPrettyPrint		ifFalse: [ self compilerClass ]		ifTrue: [ RBParser ]! !!Behavior methodsFor: '*ast' stamp: 'md 4/16/2007 10:41'!parseTreeFor: aSymbol		self flag: #FIXME.	"UGLY hack for beeing able to share AST package with Persephone... this	 needs to be fixed later".		Smalltalk at: #ReflectiveMethod ifPresent: [:cls | 	| method |		method := self compiledMethodAt: aSymbol.		method hasReflectiveMethod ifTrue: [^method reflectiveMethod methodNode].	].	^RBParser parseMethod: (self sourceCodeAt: aSymbol)		onError: [:aString :pos | ^nil]! !!Behavior methodsFor: '*persephone-override' stamp: 'md 3/31/2007 19:14' prior: 31890399!compilerClass	"Answer a compiler class appropriate for source methods of this class."	^(Preferences compileReflectiveMethods) ifTrue: [PECompiler] ifFalse: [Compiler]. ! !!Behavior methodsFor: '*persephone-override' stamp: 'md 3/31/2007 19:13' prior: 33699911!compilerClass	"Answer a compiler class appropriate for source methods of this class."	^(Preferences compileReflectiveMethods) ifTrue: [PECompiler] ifFalse: [Compiler]. ! !!Behavior methodsFor: '*persephone-override' stamp: 'md 3/21/2007 14:04' prior: 31894942!recompile: selector from: oldClass	"Compile the method associated with selector in the receiver's method dictionary."	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"	| method trailer methodNode rMethod |		Preferences compileReflectiveMethods ifTrue: [		self flag: #FIXME. "This needs to be checked and removed".		rMethod := (oldClass >> selector) reflectiveMethodOrNil.		(rMethod notNil and: [ rMethod hasMethodClass not ]) 			ifTrue: [ rMethod methodClass: oldClass ].	].	method _ oldClass compiledMethodAt: selector.	trailer _ method trailer.	methodNode _ self compilerClass new				compile: (oldClass sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	self basicAddSelector: selector withMethod: (methodNode generate: trailer).! !!Behavior methodsFor: '*persephone-override' stamp: 'md 3/21/2007 14:04' prior: 33700443!recompile: selector from: oldClass	"Compile the method associated with selector in the receiver's method dictionary."	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"	| method trailer methodNode rMethod |		Preferences compileReflectiveMethods ifTrue: [		self flag: #FIXME. "This needs to be checked and removed".		rMethod := (oldClass >> selector) reflectiveMethodOrNil.		(rMethod notNil and: [ rMethod hasMethodClass not ]) 			ifTrue: [ rMethod methodClass: oldClass ].	].	method _ oldClass compiledMethodAt: selector.	trailer _ method trailer.	methodNode _ self compilerClass new				compile: (oldClass sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	self basicAddSelector: selector withMethod: (methodNode generate: trailer).! !!Behavior methodsFor: '*persephone' stamp: 'md 8/10/2007 15:47'!invalidate	"does not use methodsDo:, as we change the dictionary while iteraring and thus	 need a copy, which #methods will provide"	self methods do: [:each | each invalidate].! !!BlockClosure methodsFor: '*newcompiler' stamp: 'ms 7/31/2007 00:24'!isBlockClosure	^true! !!BlockClosure methodsFor: '*context' stamp: 'ms 10/31/2007 14:28'!valueWithContext: aContext 	| oldActive r |	oldActive := aContext current isActive.	aContext current activate.	[r := self value] ensure: [aContext current setActive: oldActive. ^ r]! !!BlockClosure methodsFor: '*context' stamp: 'ms 10/31/2007 14:28'!valueWithoutContext: aContext	| oldActive r |	oldActive := aContext current isActive.	aContext current deactivate.	[r := self value]		ensure:[aContext current setActive: oldActive. ^r]! !!BlockContext methodsFor: 'accessing' stamp: 'md 2/9/2007 19:11'!tempNamed: aName	^self home tempNamed: aName! !!BlockContext methodsFor: 'accessing' stamp: 'md 2/9/2007 19:12'!tempNamed: aName put: anObject	^self home tempNamed: aName put: anObject! !!BlockContext methodsFor: '*context' stamp: 'ms 11/1/2007 16:57'!ctxtEnsure: aBlock	"Evaluate a termination block after evaluating the receiver, regardless of whether the receiver's evaluation completes."	| returnValue b |	<primitive: 198>	returnValue := self value.	"aBlock wasn't nil when execution of this method began; it is nil'd out by the unwind machinery, and that's how we know it's already been evaluated ... otherwise, obviously, it needs to be evaluated"	aBlock == nil ifFalse: [		"nil out aBlock temp before evaluating aBlock so it is not executed again if aBlock remote returns"		b _ aBlock.		thisContext ctxtTempAt: 1 put: nil.  "aBlock _ nil"		b value.	].	^ returnValue! !!BlockContext methodsFor: '*context' stamp: 'ms 11/1/2007 16:57'!ctxtTempAt: index put: value 	"Refer to the comment in ContextPart|tempAt:put:."	^home ctxtAt: index put: value! !!BlockContext methodsFor: '*context' stamp: 'ms 11/1/2007 16:55'!valueWithContext: aContext 	| oldActive r |	oldActive := aContext current isActive.	aContext current activate.	[r := self value] ctxtEnsure: [aContext current setActive: oldActive. ^ r]! !!BlockContext methodsFor: '*context' stamp: 'ms 11/1/2007 16:55'!valueWithoutContext: aContext	| oldActive r |	oldActive := aContext current isActive.	aContext current deactivate.	[r := self value]		ctxtEnsure:[aContext current setActive: oldActive. ^r]	! !!BlockContext methodsFor: '*geppetto2' stamp: 'md 2/21/2007 09:46'!blockArgNames	| stream myClient |		stream := (InstructionStream on: self home method) pc: self startpc.	myClient := GPBlockTempDecompiler new.	self numArgs timesRepeat: [stream interpretNextInstructionFor: myClient].	^myClient offsets reversed collect: [:offset |  self home methodNode tempNames at: offset + 1].	! !!BlockContext methodsFor: '*geppetto2' stamp: 'md 2/23/2007 12:15'!link	^GPLink metaObject: self.					! !!BlockContext methodsFor: '*geppetto2' stamp: 'md 2/18/2007 00:30'!valueSelector	self numArgs = 0 ifTrue: [^#value].		^(String streamContents: [:stream | 		stream nextPutAll: 'value:'.		(self numArgs - 1) timesRepeat: [stream nextPutAll: 'value:']]) asSymbol.! !!BlockContextTest methodsFor: 'tests' stamp: 'md 2/9/2007 19:11'!testTempNamed		| block |	block := [ | oneTemp | oneTemp := 1. oneTemp].	self assert: block value = 1.		self assert: (block tempNamed: 'oneTemp') =  1.	! !!BlockContextTest methodsFor: 'tests' stamp: 'md 2/9/2007 19:13'!testTempNamedPut	| block |	block := [ | oneTemp | oneTemp := 1. oneTemp].	self assert: block value = 1.	self assert: (block tempNamed: 'oneTemp') =  1.	block tempNamed: 'oneTemp' put: 2.	self assert: (block tempNamed: 'oneTemp')  = 2.		! !!BlockLintRule methodsFor: 'accessing'!checkClass: aSmalllintContext 	^classBlock value: aSmalllintContext value: result! !!BlockLintRule methodsFor: 'accessing'!checkMethod: aSmalllintContext 	^methodBlock value: aSmalllintContext value: result! !!BlockLintRule methodsFor: 'initialize-release'!classBlock: aBlock	classBlock := aBlock! !!BlockLintRule methodsFor: 'initialize-release'!initialize	super initialize.	classBlock := [:context :aResult | ].	methodBlock := [:context :aResult | ]! !!BlockLintRule methodsFor: 'initialize-release'!methodBlock: aBlock	methodBlock := aBlock! !!BlockLintRule class methodsFor: 'possible bugs'!abstractClass	| detector subclassResponsibilitySymbol |	detector := self new.	detector name: 'References an abstract class'.	detector resultClass: ClassEnvironment.	subclassResponsibilitySymbol := 'subclassResponsibility' asSymbol.	detector classBlock: 			[:context :result | 			(context selectedClass whichSelectorsReferTo: subclassResponsibilitySymbol)				isEmpty ifFalse: 						[(context							uses: (Smalltalk associationAt: context selectedClass name ifAbsent: [nil]))								ifTrue: [result addClass: context selectedClass]]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs'!addRemoveDependents	| detector |	detector := self new.	detector resultClass: ClassEnvironment.	detector name: 'Number of addDependent: messages > removeDependent:'.	detector classBlock: 			[:context :result | 			| count |			count := 0.			((Set				withAll: (context selectedClass whichSelectorsReferTo: #addDependent:))					addAll: (context selectedClass whichSelectorsReferTo: #removeDependent:);				yourself) do: 					[:sel | 					(context selectedClass compiledMethodAt: sel) messagesDo: 							[:each | 							each == #addDependent: ifTrue: [count := count + 1].							each == #removeDependent: ifTrue: [count := count - 1]]].			count > 0 ifTrue: [result addClass: context selectedClass]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs'!classInstVarNotInitialized	| detector |	detector := self new.	detector name: 'Has class instance variables but no initialize method'.	detector resultClass: ClassEnvironment.	detector classBlock: 		[:context :result | 		| definesVar class |		context selectedClass isMeta			ifTrue: 				[class := context selectedClass.				definesVar := false.				[definesVar or: [class isNil or: [class isMeta not]]]					whileFalse: 						[definesVar := class instVarNames isEmpty not.						class := class superclass].				(definesVar and: [(context selectedClass includesSelector: #initialize) not])					ifTrue: [result addClass: context selectedClass]]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs'!collectionCopyEmpty	| detector |	detector := self new.	detector		name: 'Subclass of collection that has instance variable but doesn''t define copyEmpty'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			(context selectedClass isVariable 					and: [(context selectedClass includesSelector: #copyEmpty:) not 						and: [context selectedClass instVarNames isEmpty not							and: [context selectedClass inheritsFrom: Collection]]])				ifTrue: [result addClass: context selectedClass]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'nk 2/25/2005 11:37'!definesEqualNotHash	| detector |	detector := self new.	detector name: 'Defines = but not hash'.	detector rationale: 'If objects of a class redefine equality, then to work properly in hashed collections like Sets or Dictionaries they must also have a hash method that returns equal hashes for each pair of objects for which = returns true.'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			((context selectedClass includesSelector: #=)				and: [(context selectedClass includesSelector: #hash) not])				ifTrue: [result addClass: context selectedClass]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'md 8/2/2005 23:20'!literalArrayContainsComma	| detector |	detector := self new.	detector name: 'Literal array contains a #,'.	detector methodBlock: 			[:context :result | 			(context compiledMethod allLiterals inject: false				into: [:sum :each | sum or: [self doesLiteralArrayContainComma: each]]) 					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'md 8/2/2005 23:20'!literalArrayContainsSuspiciousTrueFalseOrNil	| detector searcher |	detector := self new.	detector 		name: 'Literal array contains a #true, #false, or #nil but the source doesn''t.'.	detector 		rationale: 'With ANSI changes, #(true false nil) now is equal to {true. false. nil} not {#true. #false. #nil} as it used to be.This may be a bug.'.	searcher := ParseTreeSearcher new.	searcher 		matches: '`{ :n | n isLiteral and: [ n token realValue isKindOf: Array ] }'		do: 			[:aNode :answer | 			answer 				addAll: (self literalTrueFalseOrNilSymbolsIn: aNode token realValue);				yourself].	detector methodBlock: 			[:context :result | 			| compiledLits parsedLits |			compiledLits := self 						literalTrueFalseOrNilSymbolsIn: context compiledMethod allLiterals.			compiledLits size > 0 				ifTrue: 					[parsedLits := OrderedCollection new.					searcher executeTree: context parseTree initialAnswer: parsedLits.					compiledLits size ~= parsedLits size 						ifTrue: 							[ result addClass: context selectedClass selector: context selector]]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'nk 7/30/2004 12:18'!overridesSuper	| detector definer superMethod |	detector := self new.	detector name: 'Overrides super method without calling it'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMeta not				and: [true "self superMessages includes: context selector"]) ifTrue: [					definer := context selectedClass superclass ifNotNilDo: [ :sc | sc whichClassIncludesSelector: context selector ].					definer ifNotNil: [ "super defines same method"						(context superMessages includes: context selector) ifFalse: [ "but I don't call it"							superMethod := (definer compiledMethodAt: context selector ifAbsent: []).							(superMethod isReturnSelf or: [ superMethod sendsSelector: #subclassResponsibility ])										ifFalse: [result addClass: context selectedClass selector: context selector] ]]]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'bh 4/2/2000 22:09'!returnsBooleanAndOther	| detector matcher |	detector := self new.	detector name: 'Returns a boolean and non boolean'.	matcher := ParseTreeSearcher new.	matcher matches: '^``@xObject'		do: 			[:aNode :answer | 			answer				add: aNode value;				yourself].	detector methodBlock: 			[:context :result | 			| hasBool hasSelf |			hasBool := false.			hasSelf := context parseTree lastIsReturn not.			(matcher executeTree: context parseTree initialAnswer: Set new) do: 					[:each | 					hasBool := hasBool or: 									[(each isLiteral and: [{true. false} includes: each value]) 										or: [each isMessage and: [#(#and: #or:) includes: each selector]]].					hasSelf := hasSelf or: 									[(each isVariable and: [each name = 'self']) 										or: [each isLiteral and: [({true. false} includes: each value) not]]]].			hasSelf & hasBool 				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs'!sendsDifferentSuper	| detector |	detector := self new.	detector name: 'Sends different super message'.	detector methodBlock: 			[:context :result | 			| message |			(message := context superMessages detect: [:each | each ~= context selector]						ifNone: [nil]) notNil ifTrue: 					[result addSearchString: message.					result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'nk 7/30/2004 12:20'!superSends	| detector definer superMethod |	detector := self new.	detector name: 'Missing super sends in selected methods.'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMeta not				and: [ self superMessages includes: context selector ]) ifTrue: [					definer := context selectedClass superclass ifNotNilDo: [ :sc | sc whichClassIncludesSelector: context selector ].					definer ifNotNil: [ "super defines same method"						(context superMessages includes: context selector) ifFalse: [ "but I don't call it"							superMethod := (definer compiledMethodAt: context selector ifAbsent: []).							(superMethod isReturnSelf or: [ superMethod sendsSelector: #subclassResponsibility ])										ifFalse: [result addClass: context selectedClass selector: context selector] ]]]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs'!tempVarOverridesInstVar	| detector matcher vars varName |	detector := self new.	detector name: 'Instance variable overridden by temporary variable'.	matcher := (ParseTreeSearcher new)				matchesArgument: '`xxxvar'					do: 						[:aNode :answer | 						answer or: 								[varName := aNode name.								vars includes: varName]];				yourself.	detector methodBlock: 			[:context :result | 			vars := context instVarNames.			(matcher executeTree: context parseTree initialAnswer: false) 				ifTrue: 					[result addClass: context selectedClass selector: context selector.					result addSearchString: varName]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'bh 3/16/2000 12:07'!tempsReadBeforeWritten	| detector |	detector := self new.	detector name: 'Temporaries read before written'.	detector methodBlock: 			[:context :result | 			(RBReadBeforeWrittenTester variablesReadBeforeWrittenIn: context parseTree) 				do: 					[:each | 					result addClass: context selectedClass selector: context selector.					result addSearchString: each]].	^detector! !!BlockLintRule class methodsFor: 'miscellaneous'!badMessage	| detector badMessages |	detector := self new.	detector name: 'Sends "questionable" message'.	badMessages := self badSelectors.	detector classBlock: 			[:context :result | 			| selectors |			selectors := badMessages inject: Set new						into: 							[:set :each | 							set addAll: (context selectedClass whichSelectorsReferTo: each);								yourself].			selectors do: [:each | result addClass: context selectedClass selector: each].			selectors isEmpty ifFalse: [result searchStrings: badMessages]].	^detector! !!BlockLintRule class methodsFor: 'miscellaneous'!classNameInSelector	| detector |	detector := self new.	detector name: 'Redundant class name in selector'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMeta and: 					[(context selector						indexOfSubCollection: context selectedClass soleInstance name						startingAt: 1) > 0])				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'miscellaneous'!instVarInSubclasses	| detector |	detector := self new.	detector		name: 'Instance variables defined in all subclasses';		resultClass: VariableEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| subs |			subs := context selectedClass subclasses.			subs size > 1 				ifTrue: 					[| sels |					sels := Bag new.					subs do: [:each | sels addAll: each instVarNames].					sels asSet do: 							[:val | 							| count |							count := sels occurrencesOf: val.							count == subs size 								ifTrue: [result addClass: context selectedClass instanceVariable: val]]]].	^detector! !!BlockLintRule class methodsFor: 'miscellaneous' stamp: 'bh 3/16/2000 12:06'!longMethods	| detector matcher |	detector := self new.	detector name: 'Long methods'.	matcher := ParseTreeSearcher new.	matcher matches: '`.Stmt'		do: 			[:aNode :answer | 			(aNode children inject: answer				into: [:sum :each | matcher executeTree: each initialAnswer: sum]) + 1].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: 0) 				>= self longMethodSize 					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'miscellaneous'!refersToClass	| detector |	detector := self new.	detector name: 'Refers to class name instead of "self class"'.	detector classBlock: 			[:context :result | 			| sels className |			className := (context selectedClass isMeta						ifTrue: [context selectedClass soleInstance]						ifFalse: [context selectedClass]) name.			sels := context selectedClass						whichSelectorsReferTo: (Smalltalk associationAt: className).			sels do: [:each | result addClass: context selectedClass selector: each].			sels isEmpty ifFalse: [result addSearchString: className]].	^detector! !!BlockLintRule class methodsFor: 'miscellaneous' stamp: 'bh 4/29/2000 23:31'!utilityMethods	| detector |	detector := self new.	detector name: 'Utility methods'.	self needsWork."	detector methodBlock: 			[:context :result | 			(context selectedClass isMeta | (context selector numArgs == 0) or: 					[(context protocols detect: 							[:each | 							(self utilityProtocols detect: [:protocol | protocol match: each]								ifNone: [nil]) notNil]						ifNone: [nil]) notNil]) 				ifFalse: 					[(self subclassOf: context selectedClass overrides: context selector) 						ifFalse: 							[(context superMessages isEmpty and: [context selfMessages isEmpty]) 								ifTrue: 									[(context selectedClass allInstVarNames 										, context selectedClass allClassVarNames asArray , #('self') 										detect: [:each | context parseTree references: each]										ifNone: [nil]) isNil 										ifTrue: [result addClass: context selectedClass selector: context selector]]]]]."	^detector! !!BlockLintRule class methodsFor: 'miscellaneous'!variableAssignedLiteral	| detector |	detector := self new.	detector		name: 'Variable is only assigned a single literal value';		resultClass: VariableEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| defClass selector |					(allSubclasses inject: 0						into: 							[:sum :class | 							| sels |							sels := class whichSelectorsAssign: each.							sels size == 1 								ifTrue: 									[selector := sels asArray first.									defClass := class].							sum + sels size]) 							== 1 							ifTrue: 								[| tree searcher |								searcher := ParseTreeSearcher new.								searcher matches: each , ' := ``@object'									do: [:aNode :answer | answer isNil and: [aNode value isLiteral]].								tree := defClass parseTreeFor: selector.								tree notNil 									ifTrue: 										[(searcher executeTree: tree initialAnswer: nil) == true 											ifTrue: [result addClass: context selectedClass instanceVariable: each]]]]].	^detector! !!BlockLintRule class methodsFor: 'private'!badSelectors	^#(#become: #isKindOf: #changeClassToThatOf: #respondsTo: #isMemberOf: #performMethod: #performMethod:arguments: #performMethod:with: #performMethod:with:with: #performMethod:with:with:with: #allOwners #allOwnersWeakly: #firstOwner #instVarAt: #instVarAt:put: #nextInstance #nextObject #ownerAfter: #primBecome:  #halt)! !!BlockLintRule class methodsFor: 'private'!classShouldNotOverride	^#(#== #class)! !!BlockLintRule class methodsFor: 'private'!doesLiteralArrayContainComma: aLiteral 	aLiteral class == Array ifFalse: [^false].	(aLiteral includes: #,) ifTrue: [^true].	^aLiteral inject: false		into: [:sum :each | sum or: [self doesLiteralArrayContainComma: each]]! !!BlockLintRule class methodsFor: 'private' stamp: 'nk 3/4/2005 16:32'!literalTrueFalseOrNilSymbolsIn: aLiteral 	| retval |	aLiteral class == Array ifFalse: [^#()].	retval := OrderedCollection withAll: (aLiteral select: [:ea | ea isSymbol and: [#(#true #false #nil ) includes: ea]]).	aLiteral do: [ :each | retval addAll: (self literalTrueFalseOrNilSymbolsIn: each) ].	^retval.! !!BlockLintRule class methodsFor: 'private'!longMethodSize	^10! !!BlockLintRule class methodsFor: 'private'!metaclassShouldNotOverride	^#(#name #comment)! !!BlockLintRule class methodsFor: 'private'!subclassOf: aClass overrides: aSelector 	^(aClass subclasses detect: 			[:each | 			(each includesSelector: aSelector)				or: [self subclassOf: each overrides: aSelector]]		ifNone: [nil]) notNil! !!BlockLintRule class methodsFor: 'private'!superMessages	^#(#release #postCopy #postBuildWith: #preBuildWith: #postOpenWith: #noticeOfWindowClose: #initialize)! !!BlockLintRule class methodsFor: 'private'!utilityProtocols	"If a method is defined in one of these protocols, then don't check if its a utility method."	^#('*utilit*')! !!BlockLintRule class methodsFor: 'unnecessary code'!classNotReferenced	| detector |	detector := self new.	detector name: 'Class not referenced'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			(context selectedClass isMeta				or: [context selectedClass subclasses isEmpty not])					ifFalse: 						[| assoc |						assoc := Smalltalk associationAt: context selectedClass name.						((context uses: assoc) or: [context uses: context selectedClass name])							ifFalse: 								[result addClass: context selectedClass;									addClass: context selectedClass class]]].	^detector! !!BlockLintRule class methodsFor: 'unnecessary code'!equivalentSuperclassMethods	| detector |	detector := self new.	detector name: 'Methods equivalently defined in superclass'.	detector methodBlock: 			[:context :result | 			context selectedClass superclass notNil ifTrue: 					[(context selectedClass superclass canUnderstand: context selector)						ifTrue: 							[(((context selectedClass superclass								whichClassIncludesSelector: context selector)									compiledMethodAt: context selector)									equivalentTo: context compiledMethod)									ifTrue: [result addClass: context selectedClass selector: context selector]]]].	^detector! !!BlockLintRule class methodsFor: 'unnecessary code'!implementedNotSent	| detector |	detector := self new.	detector name: 'Methods implemented but not sent'.	detector methodBlock: 			[:context :result | 			(context uses: context selector)				ifFalse: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'unnecessary code'!justSendsSuper	| detector matcher |	detector := self new.	detector name: 'Method just sends super message'.	matcher := ParseTreeSearcher justSendsSuper.	detector methodBlock: 			[:context :result | 			(context parseTree isPrimitive not 				and: [matcher executeMethod: context parseTree initialAnswer: false]) 					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'unnecessary code'!onlyReadOrWritten	| detector |	detector := self new.	detector		name: 'Instance variables not read AND written';		resultClass: VariableEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| isRead isWritten |					isRead := false.					isWritten := false.					allSubclasses detect: 							[:class | 							isRead ifFalse: [isRead := (class whichSelectorsRead: each) isEmpty not].							isWritten 								ifFalse: [isWritten := (class whichSelectorsAssign: each) isEmpty not].							isRead & isWritten]						ifNone: [result addClass: context selectedClass instanceVariable: each]]].	^detector! !!BlockLintRule class methodsFor: 'unnecessary code'!unreferencedVariables	| detector |	detector := self new.	detector		name: 'Variables not referenced';		resultClass: VariableEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					allSubclasses 						detect: [:class | (class whichSelectorsAccess: each) isEmpty not]						ifNone: [result addClass: context selectedClass instanceVariable: each]].			context selectedClass isMeta 				ifFalse: 					[context selectedClass classPool associationsDo: 							[:each | 							(context uses: each) 								ifFalse: [result addClass: context selectedClass classVariable: each key]]]].	^detector! !!BlockLintRule class methodsFor: 'unnecessary code'!variableReferencedOnce	| detector |	detector := self new.	detector 		name: 'Variable referenced in only one method and always assigned first'.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| defClass selector |					(allSubclasses inject: 0						into: 							[:sum :class | 							| sels |							sels := class whichSelectorsAccess: each.							sels size == 1 								ifTrue: 									[selector := sels asArray first.									defClass := class].							sum + sels size]) 							== 1 							ifTrue: 								[| tree |								tree := defClass parseTreeFor: selector.								tree notNil 									ifTrue: 										[(RBReadBeforeWrittenTester isVariable: each writtenBeforeReadIn: tree) 											ifTrue: 												[result addClass: defClass selector: selector.												result addSearchString: each]]]]].	^detector! !!BlockLintRule class methodsFor: 'squeak bugs' stamp: 'nk 2/26/2005 10:05'!methodHasNoTimeStamp	| detector |	detector := self new.	detector name: 'Method has no timeStamp'.	detector rationale: 'For proper versioning, every method should have a timestamp.'.	detector methodBlock: 			[:context :result | 			context compiledMethod timeStamp isEmpty					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'squeak bugs' stamp: 'nk 2/26/2005 10:19'!methodSourceContainsLinefeeds	| detector |	detector := self new.	detector name: 'Method source contains linefeeds'.	detector rationale: 'Squeak code should not contain linefeed characters.'.	detector methodBlock: 			[:context :result | 			(context sourceCode includes: Character lf)					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'squeak bugs' stamp: 'nk 7/30/2004 11:44'!superSendsNew	| detector matcher |	detector := self new.	detector name: 'Sends super new initialize'.	matcher := ParseTreeSearcher new.	matcher matchesAnyOf: #('super new initialize' '(super new: `@expr) initialize' 'self new initialize' '(self new: `@expr) initialize')		do: [ :aNode :answer | answer + 1 ].	detector methodBlock: [:context :result |		context selectedClass isMeta ifTrue: [			(matcher executeTree: context parseTree initialAnswer: 0) > 0 ifTrue: [ result addClass: context selectedClass selector: context selector]]].	^detector! !!BlockLintRule class methodsFor: 'intention revealing'!missingSubclassResponsibility	| detector |	detector := self new.	detector		name: 'Method defined in all subclasses, but not in superclass';		resultClass: MultiEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| subs |			subs := context selectedClass subclasses.			subs size > 1 & context selectedClass isMeta not 				ifTrue: 					[| sels |					sels := Bag new.					subs do: [:each | sels addAll: each selectors].					sels asSet do: 							[:each | 							((sels occurrencesOf: each) == subs size 								and: [(context selectedClass canUnderstand: each) not]) 									ifTrue: 										[| envName |										envName := context selectedClass name , '>>' , each.										subs do: 												[:subClass | 												result 													addClass: subClass													selector: each													into: envName]]]]].	^detector! !!BlockLintRule class methodsFor: 'bugs'!overridesSpecialMessage	| detector |	detector := self new.	detector name: 'Overrides a "special" message'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			((context selectedClass isMeta				ifTrue: [self metaclassShouldNotOverride]				ifFalse: [self classShouldNotOverride]) detect: 						[:each | 						context selectedClass superclass notNil and: 								[(context selectedClass superclass canUnderstand: each)									and: [context selectedClass includesSelector: each]]]					ifNone: [nil]) notNil ifTrue: [result addClass: context selectedClass]].	^detector! !!BlockLintRule class methodsFor: 'bugs'!sentNotImplemented	| detector |	detector := self new.	detector name: 'Messages sent but not implemented'.	detector methodBlock: 			[:context :result | 			| message |			message := context messages detect: [:each | (context implements: each) not]						ifNone: [nil].			message isNil ifTrue: 					[message := context superMessages detect: 									[:each | 									context selectedClass superclass isNil										or: [(context selectedClass superclass canUnderstand: each) not]]								ifNone: [nil].					message isNil ifTrue: 							[message := context selfMessages										detect: [:each | (context selectedClass canUnderstand: each) not]										ifNone: [nil]]].			message notNil ifTrue: 					[result addSearchString: message.					result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'bugs'!subclassResponsibilityNotDefined	| detector subclassResponsibilitySymbol |	detector := self new.	detector name: 'Subclass responsibility not defined'.	subclassResponsibilitySymbol := 'subclassResponsibility' asSymbol.	detector classBlock: 			[:context :result | 			(context selectedClass whichSelectorsReferTo: subclassResponsibilitySymbol)				do: 					[:each | 					(context selectedClass withAllSubclasses detect: 							[:class | 							class subclasses isEmpty								and: [(class whichClassIncludesSelector: each) == context selectedClass]]						ifNone: [nil]) notNil						ifTrue: [result addClass: context selectedClass selector: each]]].	^detector! !!BlockLintRule class methodsFor: 'bugs'!undeclaredReference	| detector |	detector := self new.	detector name: 'References an undeclared variable'.	detector methodBlock: 			[:context :result | 			| undeclared |			undeclared := Undeclared associations detect: 							[:each | 							(context uses: each)								and: [context compiledMethod refersToLiteral: each]]						ifNone: [nil].			undeclared notNil ifTrue: 					[result addSearchString: undeclared key.					result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'bugs'!usesTrue	| detector trueBinding falseBinding |	detector := self new.	trueBinding := Smalltalk associationAt: #True.	falseBinding := Smalltalk associationAt: #False.	detector name: 'Uses True/False instead of true/false'.	detector methodBlock: 			[:context :result | 			| method |			method := context compiledMethod.			((method refersToLiteral: trueBinding)				or: [method refersToLiteral: falseBinding]) ifTrue: 						[result addClass: context selectedClass selector: context selector.						result searchStrings: #('True' 'False')]].	^detector! !!BlockLintRule class methodsFor: 'bugs' stamp: 'bh 5/1/2000 16:56'!variableNotDefined	| detector |	detector := self new.	detector name: 'Variable used, but not defined anywhere'.self needsWork."	detector methodBlock: [:context :result | context compiledMethod withAllBlockMethodsDo: [:each | each				literalsDo: [:lit | lit isVariableBinding						ifTrue: [((Smalltalk associationAt: lit key ifAbsent: [])								== lit or: [(Undeclared associationAt: lit key ifAbsent: [])									== lit])								ifFalse: [(context selectedClass fullBindingFor: lit key)										== lit										ifFalse: 											[result addClass: context selectedClass selector: context selector.											result addSearchString: lit key]]]]]]."	^ detector	! !!Boolean methodsFor: '*geppetto2' stamp: 'md 2/12/2007 11:00'!isBoolean	^true! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:36'!addCornerGrips	self		addMorphBack: (TopLeftGripMorph new target: self; position: self position).	self		addMorphBack: (TopRightGripMorph new target: self; position: self position).	self		addMorphBack: (BottomLeftGripMorph new target: self;position: self position).	self		addMorphBack: (BottomRightGripMorph new target: self;position: self position)! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:36'!addPaneHSplitterBetween: topMorph and: bottomMorphs	| targetY minX maxX splitter |	targetY _ topMorph layoutFrame bottomFraction.	minX _ (bottomMorphs detectMin: [:each | each layoutFrame leftFraction]) layoutFrame leftFraction.	maxX _ (bottomMorphs detectMax: [:each | each layoutFrame rightFraction]) layoutFrame rightFraction.	splitter _ ProportionalSplitterMorph new beSplitsTopAndBottom; yourself.	splitter layoutFrame: (LayoutFrame		fractions: (minX @ targetY corner: maxX @ targetY)		offsets: (((topMorph layoutFrame leftOffset ifNil: [0]) @ 0 corner: (topMorph layoutFrame rightOffset ifNil: [0]) @ 4) translateBy: 0 @ (topMorph layoutFrame bottomOffset ifNil: [0]))).	self addMorphBack: (splitter position: self position).! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:34'!addPaneSplitters	| splitter remaining target targetX sameX minY maxY targetY sameY minX maxX |	self removePaneSplitters.	self removeCornerGrips.	remaining _ submorphs reject: [:each | each layoutFrame rightFraction = 1].	[remaining notEmpty] whileTrue:		[target _ remaining first.		targetX _ target layoutFrame rightFraction.		sameX _ submorphs select: [:each | each layoutFrame rightFraction = targetX].		minY _ (sameX detectMin: [:each | each layoutFrame topFraction]) layoutFrame topFraction.		maxY _ (sameX detectMax: [:each | each layoutFrame bottomFraction]) layoutFrame bottomFraction.		splitter _ ProportionalSplitterMorph new.		splitter layoutFrame: (LayoutFrame			fractions: (targetX @ minY corner: targetX @ maxY)			offsets: ((0 @ (target layoutFrame topOffset ifNil: [0]) corner: 4 @ (target layoutFrame bottomOffset ifNil: [0])) translateBy: (target layoutFrame rightOffset ifNil: [0]) @ 0)).		self addMorphBack: (splitter position: self position).		remaining _ remaining copyWithoutAll: sameX].	remaining _ submorphs copy reject: [:each | each layoutFrame bottomFraction = 1].	[remaining notEmpty]		whileTrue: [target _ remaining first.			targetY _ target layoutFrame bottomFraction.			sameY _ submorphs select: [:each | each layoutFrame bottomFraction = targetY].			minX _ (sameY detectMin: [:each | each layoutFrame leftFraction]) layoutFrame leftFraction.			maxX _ (sameY detectMax: [:each | each layoutFrame rightFraction]) layoutFrame rightFraction.			splitter _ ProportionalSplitterMorph new beSplitsTopAndBottom; yourself.			splitter layoutFrame: (LayoutFrame				fractions: (minX @ targetY corner: maxX @ targetY)				offsets: (((target layoutFrame leftOffset ifNil: [0]) @ 0 corner: (target layoutFrame rightOffset ifNil: [0]) @ 4) translateBy: 0 @ (target layoutFrame bottomOffset ifNil: [0]))).			self addMorphBack: (splitter position: self position).			remaining _ remaining copyWithoutAll: sameY].	self linkSubmorphsToSplitters.	self splitters do: [:each | each comeToFront].! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:37'!addPaneVSplitterBetween: leftMorph and: rightMorphs 	| targetX minY maxY splitter |	targetX _ leftMorph layoutFrame rightFraction.	minY _ (rightMorphs detectMin: [:each | each layoutFrame topFraction]) layoutFrame topFraction.	maxY _ (rightMorphs detectMax: [:each | each layoutFrame bottomFraction]) layoutFrame bottomFraction.		splitter _ ProportionalSplitterMorph new.	splitter layoutFrame: (LayoutFrame		fractions: (targetX @ minY corner: targetX @ maxY)		offsets: ((0 @ (leftMorph layoutFrame topOffset ifNil: [0]) corner: (4@ (leftMorph layoutFrame bottomOffset ifNil: [0]))) translateBy: (leftMorph layoutFrame rightOffset ifNil: [0]) @ 0)).	self addMorphBack: (splitter position: self position).! !!BreakpointManager class methodsFor: 'install-uninstall' stamp: 'tpr 9/26/2006 16:14'!installInClass: aClass selector: aSymbol 	"Install a new method containing a breakpoint.	The receiver will remember this for unstalling it later"	| breakMethod |	breakMethod _ self compilePrototype: aSymbol in: aClass.	breakMethod isNil		ifTrue: [^ nil].	self installed at: breakMethod put: aClass >> aSymbol. "old method"	aClass class basicAddSelector: aSymbol withMethod: breakMethod.! !!BrowserEnvironment methodsFor: 'environments'!& anEnvironment 	"If we or anEnvironment includes everything, then just include the other environment (optimization)"	self isSystem ifTrue: [^anEnvironment].	anEnvironment isSystem ifTrue: [^self].	^AndEnvironment onEnvironment: self and: anEnvironment! !!BrowserEnvironment methodsFor: 'environments'!forCategories: categoryList 	^CategoryEnvironment onEnvironment: self categories: categoryList! !!BrowserEnvironment methodsFor: 'environments'!forClass: aClass protocols: protocolCollection 	^ProtocolEnvironment onEnvironment: self		class: aClass		protocols: protocolCollection! !!BrowserEnvironment methodsFor: 'environments'!forClass: aClass selectors: selectorCollection 	^(SelectorEnvironment 		onMethods: selectorCollection		forClass: aClass		in: self)		label: aClass name , '>>' 					, (selectorCollection detect: [:each | true] ifNone: ['']);		yourself! !!BrowserEnvironment methodsFor: 'environments'!forClasses: classCollection 	| classes |	classes := OrderedCollection new: classCollection size * 2.	classCollection do: 			[:each | 			classes add: each;				add: each class].	^ClassEnvironment onEnvironment: self classes: classes! !!BrowserEnvironment methodsFor: 'environments' stamp: 'lr 1/3/2006 12:14'!forPackage: aPackageInfo	^ PackageEnvironment onEnvironment: self package: aPackageInfo.! !!BrowserEnvironment methodsFor: 'environments' stamp: 'lr 1/3/2006 12:14'!forPackageContainingClassCategory: aClassCategory	| package |	package := PackageInfo allPackages 		detect: [ :each | each includesSystemCategory: aClassCategory ]		ifNone: [ self inform: 'no package for this category'. ^nil ].	^ self forPackage: package.! !!BrowserEnvironment methodsFor: 'environments' stamp: 'lr 1/3/2006 12:14'!forPackageNamed: aString	^ PackageEnvironment onEnvironment: self packageNamed: aString.! !!BrowserEnvironment methodsFor: 'environments'!implementorsMatching: aString 	^SelectorEnvironment implementorsMatching: aString in: self! !!BrowserEnvironment methodsFor: 'environments'!implementorsOf: aSelector 	^SelectorEnvironment implementorsOf: aSelector in: self! !!BrowserEnvironment methodsFor: 'environments'!instVarReadersTo: instVarName in: aClass 	^VariableEnvironment 		on: self		readersOfInstanceVariable: instVarName		in: aClass! !!BrowserEnvironment methodsFor: 'environments'!instVarRefsTo: instVarName in: aClass 	^VariableEnvironment 		on: self		referencesToInstanceVariable: instVarName		in: aClass! !!BrowserEnvironment methodsFor: 'environments'!instVarWritersTo: instVarName in: aClass 	^VariableEnvironment 		on: self		writersOfInstanceVariable: instVarName		in: aClass! !!BrowserEnvironment methodsFor: 'environments'!matches: aString 	^SelectorEnvironment matches: aString in: self! !!BrowserEnvironment methodsFor: 'environments'!not	self isSystem ifTrue: [^SelectorEnvironment new].	^NotEnvironment onEnvironment: self! !!BrowserEnvironment methodsFor: 'environments'!referencesTo: aLiteral 	^SelectorEnvironment referencesTo: aLiteral in: self! !!BrowserEnvironment methodsFor: 'environments'!referencesTo: aLiteral in: aClass 	| classes |	classes := aClass withAllSuperclasses asSet.	classes		addAll: aClass allSubclasses;		addAll: aClass class withAllSuperclasses;		addAll: aClass class allSubclasses.	^(self forClasses: classes) referencesTo: aLiteral! !!BrowserEnvironment methodsFor: 'environments'!selectMethods: aBlock 	| env |	env := SelectorEnvironment onEnvironment: self.	self classesAndSelectorsDo: 			[:each :sel | 			(aBlock value: (each compiledMethodAt: sel)) 				ifTrue: [env addClass: each selector: sel]].	^env! !!BrowserEnvironment methodsFor: 'environments'!| anEnvironment 	"If we or anEnvironment includes everything, then return it instead of creating 	an or that will include everything."	self isSystem ifTrue: [^self].	anEnvironment isSystem ifTrue: [^anEnvironment].	^(self not & anEnvironment not) not! !!BrowserEnvironment methodsFor: 'accessing'!addSearchString: aString 	searchStrings isNil ifTrue: 			[searchStrings := SortedCollection sortBlock: 							[:a :b | 							(a indexOf: $: ifAbsent: [a size]) > (b indexOf: $: ifAbsent: [b size])]].	searchStrings add: aString! !!BrowserEnvironment methodsFor: 'accessing' stamp: 'nk 3/4/2005 12:41'!asSelectorEnvironment	^(ClassEnvironment onEnvironment: self classes: self classes) asSelectorEnvironment! !!BrowserEnvironment methodsFor: 'accessing'!categories	^Smalltalk organization categories select: [:each | self includesCategory: each]! !!BrowserEnvironment methodsFor: 'accessing'!classNamesFor: aCategoryName	^(Smalltalk organization listAtCategoryNamed: aCategoryName)		select:			[:each |			| class |			class := Smalltalk at: each ifAbsent: [nil].			class notNil and: [(self includesClass: class)					or: [self includesClass: class class]]]! !!BrowserEnvironment methodsFor: 'accessing'!classVariablesFor: aClass 	^aClass classVarNames! !!BrowserEnvironment methodsFor: 'accessing'!classesAndSelectorsDo: aBlock 	self classesDo: 			[:class | 			self selectorsForClass: class do: [:sel | aBlock value: class value: sel]]! !!BrowserEnvironment methodsFor: 'accessing'!instanceVariablesFor: aClass 	^aClass instVarNames! !!BrowserEnvironment methodsFor: 'accessing'!numberClasses	^self classNames size! !!BrowserEnvironment methodsFor: 'accessing'!numberSelectors	| total |	total := 0.	self 		allClassesDo: [:each | self selectorsForClass: each do: [:sel | total := total + 1]].	^total! !!BrowserEnvironment methodsFor: 'accessing'!problemCount	^self numberSelectors! !!BrowserEnvironment methodsFor: 'accessing'!protocolsFor: aClass	^aClass organization categories select: [:each | self includesProtocol: each in: aClass]! !!BrowserEnvironment methodsFor: 'accessing'!searchStrings	^searchStrings isNil		ifTrue: [#()]		ifFalse: [searchStrings]! !!BrowserEnvironment methodsFor: 'accessing'!searchStrings: aCollection 	searchStrings := aCollection! !!BrowserEnvironment methodsFor: 'accessing' stamp: 'bh 5/8/2000 21:02'!selectionIntervalFor: aString 	| interval |	self searchStrings isEmpty ifTrue: [^nil].	interval := self selectionParseTreeIntervalFor: aString.	interval notNil ifTrue: [^interval].	self searchStrings do: 			[:each | 			| search index |			search := each isSymbol ifTrue: [each keywords first] ifFalse: [each].			index := aString indexOfSubCollection: search startingAt: 1.			index > 0 ifTrue: [^index to: index + search size - 1]].	^nil! !!BrowserEnvironment methodsFor: 'accessing' stamp: 'bh 5/8/2000 21:03'!selectionParseTreeIntervalFor: aString 	| parseTree answerBlock |	parseTree := RBParser parseMethod: aString onError: [:str :pos | ^nil].	answerBlock := [:aNode :answer | ^aNode sourceInterval].	self searchStrings do: 			[:each | 			| matcher tree |			matcher := ParseTreeSearcher new.			each isSymbol 				ifTrue: 					[matcher matchesTree: (RBLiteralNode value: each) do: answerBlock.					tree := ParseTreeSearcher buildSelectorTree: each.					tree notNil ifTrue: [matcher matchesTree: tree do: answerBlock]]				ifFalse: 					[tree := RBVariableNode named: each.					matcher						matchesTree: tree do: answerBlock;						matchesArgumentTree: tree do: answerBlock].			matcher executeTree: parseTree].	^nil! !!BrowserEnvironment methodsFor: 'accessing'!selectorsFor: aProtocol in: aClass	^(aClass organization listAtCategoryNamed: aProtocol)		select: [:each | self includesSelector: each in: aClass]! !!BrowserEnvironment methodsFor: 'accessing'!selectorsForClass: aClass 	| selectors |	selectors := Set new: 50.	self selectorsForClass: aClass do: [:each | selectors add: each].	^selectors! !!BrowserEnvironment methodsFor: 'accessing'!selectorsForClass: aClass do: aBlock 	aClass selectorsAndMethodsDo: 			[:each :meth | 			(self includesSelector: each in: aClass) ifTrue: [aBlock value: each]]! !!BrowserEnvironment methodsFor: 'accessing'!whichCategoryIncludes: aClassName	^Smalltalk organization categoryOfElement: aClassName! !!BrowserEnvironment methodsFor: 'accessing'!whichProtocolIncludes: aSelector in: aClass	^aClass organization categoryOfElement: aSelector! !!BrowserEnvironment methodsFor: 'private' stamp: 'nk 8/8/2003 09:07'!allClassesDo: aBlock 	self systemNavigation allBehaviorsDo: aBlock! !!BrowserEnvironment methodsFor: 'private'!defaultLabel	^'Smalltalk'! !!BrowserEnvironment methodsFor: 'private'!label	^label isNil		ifTrue: [self defaultLabel]		ifFalse: [label]! !!BrowserEnvironment methodsFor: 'accessing-classes' stamp: 'dvf 10/9/2001 16:14'!associationAt: aKey	| association class |	association := Smalltalk associationAt: aKey ifAbsent: [^nil].	class := association value isBehavior				ifTrue: [association value]				ifFalse: [association value class].	^((self includesClass: class) or: [self includesClass: class class])		ifTrue: [association]		ifFalse: [nil]! !!BrowserEnvironment methodsFor: 'accessing-classes' stamp: 'md 8/2/2005 23:26'!at: aKey	^self at: aKey ifAbsent: [self error:'key ',aKey printString,' was not found'.]! !!BrowserEnvironment methodsFor: 'accessing-classes'!at: aKey ifAbsent: aBlock	| assoc |	assoc := self associationAt: aKey.	^assoc isNil		ifTrue: [aBlock value]		ifFalse: [assoc value]! !!BrowserEnvironment methodsFor: 'accessing-classes'!classNames	| names |	names := Set new.	self classesDo: 			[:each | 			names add: (each isMeta ifTrue: [each soleInstance] ifFalse: [each]) name].	^names! !!BrowserEnvironment methodsFor: 'accessing-classes'!classes	| classes |	classes := Set new.	self classesDo: [:each | classes add: each].	^classes! !!BrowserEnvironment methodsFor: 'accessing-classes' stamp: 'md 2/26/2006 15:11'!classesDo: aBlock 	self allClassesDo: [:each | (self includesClass: each) ifTrue: [aBlock value: each]]! !!BrowserEnvironment methodsFor: 'accessing-classes'!keys	| keys |	keys := Set new.	Smalltalk keysAndValuesDo: 			[:key :value | 			| class |			value isBehavior 				ifTrue: [(self includesClass: value) ifTrue: [keys add: key]].			class := value class.			(self includesClass: class) ifTrue: [keys add: key]].	^keys! !!BrowserEnvironment methodsFor: 'copying' stamp: 'bh 3/16/2000 23:24'!copy	^self shallowCopy postCopy! !!BrowserEnvironment methodsFor: 'copying'!copyEmpty	^self class new! !!BrowserEnvironment methodsFor: 'copying' stamp: 'dvf 9/12/2003 13:21'!postCopy	^self! !!BrowserEnvironment methodsFor: 'testing'!definesClass: aClass	^true! !!BrowserEnvironment methodsFor: 'testing'!includesCategory: aCategory	^true! !!BrowserEnvironment methodsFor: 'testing'!includesClass: aClass	^true! !!BrowserEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass	^true! !!BrowserEnvironment methodsFor: 'testing'!includesSelector: aSelector in: aClass	^true! !!BrowserEnvironment methodsFor: 'testing'!isClassEnvironment	^false! !!BrowserEnvironment methodsFor: 'testing'!isEmpty	^false! !!BrowserEnvironment methodsFor: 'testing'!isSelector	^false! !!BrowserEnvironment methodsFor: 'testing'!isSystem	^true! !!BrowserEnvironment methodsFor: 'initialize-release'!initialize! !!BrowserEnvironment methodsFor: 'initialize-release'!label: aString	label := aString! !!BrowserEnvironment methodsFor: 'SqueakRB-UserInterface' stamp: 'nk 3/4/2005 12:41'!openEditor	^self asSelectorEnvironment openEditor! !!BrowserEnvironment methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self label! !!BrowserEnvironment methodsFor: 'printing'!storeOn: aStream 	aStream		nextPutAll: self class name;		nextPutAll: ' new'! !!BrowserEnvironmentTest methodsFor: 'universal tests'!categoriesFor: anEnvironment 	| allCategories |	allCategories := Set withAll: BrowserEnvironment new categories.	allCategories removeAll: anEnvironment categories.	anEnvironment not categories 		do: [:each | allCategories remove: each ifAbsent: []].	allCategories 		do: [:each | self assert: (BrowserEnvironment new classNamesFor: each) isEmpty]! !!BrowserEnvironmentTest methodsFor: 'universal tests'!copyFor: aBrowserEnvironment 	| newEnvironment |	newEnvironment := aBrowserEnvironment copy.	self assert: newEnvironment numberSelectors 				= aBrowserEnvironment numberSelectors.	self 		assert: (newEnvironment not & aBrowserEnvironment) numberSelectors = 0! !!BrowserEnvironmentTest methodsFor: 'universal tests'!keysFor: aBrowserEnvironment 	| allKeys |	allKeys := Set withAll: aBrowserEnvironment keys.	allKeys addAll: aBrowserEnvironment not keys.	allKeys removeAll: Smalltalk keys.	self assert: allKeys isEmpty! !!BrowserEnvironmentTest methodsFor: 'universal tests'!numberSelectorsFor: aBrowserEnvironment 	self 		assert: aBrowserEnvironment numberSelectors 				+ aBrowserEnvironment not numberSelectors 					= BrowserEnvironment new numberSelectors.	self 		assert: (aBrowserEnvironment & aBrowserEnvironment not) numberSelectors = 0.	self assert: (universalEnvironment & aBrowserEnvironment) numberSelectors 				= aBrowserEnvironment numberSelectors.	self assert: (aBrowserEnvironment & universalEnvironment) numberSelectors 				= aBrowserEnvironment numberSelectors! !!BrowserEnvironmentTest methodsFor: 'universal tests'!storeStringFor: aBrowserEnvironment	| newEnvironment |	newEnvironment := Compiler evaluate: aBrowserEnvironment storeString.	self assert: newEnvironment numberSelectors = aBrowserEnvironment numberSelectors.	self assert: (newEnvironment not & aBrowserEnvironment) numberSelectors = 0	! !!BrowserEnvironmentTest methodsFor: 'universal tests'!uniqueClassesIn: aBrowserEnvironment 	| allClasses |	allClasses := Set new.	aBrowserEnvironment 		classesDo: [:each | self deny: (allClasses includes: each)]! !!BrowserEnvironmentTest methodsFor: 'universal tests'!universalTestFor: aBrowserEnvironment 	self uniqueClassesIn: aBrowserEnvironment.	self numberSelectorsFor: aBrowserEnvironment.	self storeStringFor: aBrowserEnvironment.	self classNamesFor: aBrowserEnvironment.	self copyFor: aBrowserEnvironment.	self categoriesFor: aBrowserEnvironment.	self classesFor: aBrowserEnvironment.	self keysFor: aBrowserEnvironment.	self 		assert: aBrowserEnvironment problemCount = 0 = aBrowserEnvironment isEmpty! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!classNamesFor: anEnvironment 	| classNames |	classNames := (anEnvironment classNames asSet)				addAll: anEnvironment not classNames;				yourself.	self assert: classNames asSortedCollection 				= BrowserEnvironment new classNames asSortedCollection.	self assert: (anEnvironment & anEnvironment not) classNames isEmpty.	self 		assert: (anEnvironment | anEnvironment not) classNames asSortedCollection 				= BrowserEnvironment new classNames asSortedCollection! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!classesFor: aBrowserEnvironment 	| allClasses |	allClasses := aBrowserEnvironment classes asSet.	allClasses addAll: aBrowserEnvironment not classes.	BrowserEnvironment new classesDo: [:each | allClasses remove: each].	self assert: allClasses isEmpty! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests' stamp: 'dvf 8/27/2003 15:02'!testAllClassesDo	| allClasses aBrowserEnvironment |	aBrowserEnvironment := BrowserEnvironment new.	allClasses := Set new.	aBrowserEnvironment classesDo: [:each | allClasses add: each].	SystemNavigation new allBehaviorsDo: [:each | allClasses remove: each].	self assert: allClasses isEmpty! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testBrowserEnvironment	self universalTestFor: BrowserEnvironment new! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testCategoryEnvironment	| aCategoryEnvironment |	aCategoryEnvironment := CategoryEnvironment 				onEnvironment: BrowserEnvironment new				categories: #(#'Kernel-Objects').	self universalTestFor: aCategoryEnvironment.	self assert: (aCategoryEnvironment implementorsOf: #printString) numberSelectors = 1! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testClassEnvironment	| aClassEnvironment |	aClassEnvironment := ClassEnvironment 				onEnvironment: BrowserEnvironment new				classes: (Array with: Object with: Object class).	self universalTestFor: aClassEnvironment.	self assert: (aClassEnvironment implementorsOf: #printString) numberSelectors = 1! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testConstructedClassEnvironment	| environment |	environment := ClassEnvironment new.	environment		addClass: Object;		addClass: OrderedCollection;		addClass: Collection.	self assert: (environment includesClass: Object).	self assert: (environment includesClass: OrderedCollection).	self assert: (environment includesClass: Collection).	self deny: (environment includesClass: Object class).	environment removeClass: Collection.	self assert: (environment includesClass: Object).	self assert: (environment includesClass: OrderedCollection).	self deny: (environment includesClass: Collection).	self assert: environment numberClasses = 2.	environment addClass: Object class.	self assert: environment numberClasses = 2.	self assert: (environment includesClass: Object class).	environment removeClass: self class.	self assert: environment numberClasses = 2! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testConstructedSelectorEnvironment	| environment newEnvironment |	environment := SelectorEnvironment new.	environment		addClass: Object selector: #printString;		addClass: OrderedCollection selector: #add:;		addClass: Collection.	self assert: (environment includesClass: Object).	self assert: (environment selectorsForClass: Object) size = 1.	self assert: (environment includesClass: OrderedCollection).	self assert: (environment selectorsForClass: OrderedCollection) size = 1.	self assert: (environment includesClass: Collection).	self assert: (environment selectorsForClass: Collection) size 				= Collection selectors size.	self deny: (environment includesClass: Object class).	newEnvironment := environment copy.	newEnvironment		removeClass: OrderedCollection;		addClass: Object selector: #printOn:;		removeClass: Object selector: #printString.	self assert: (newEnvironment includesClass: Object).	self deny: (newEnvironment includesSelector: #printString in: Object).	self deny: (newEnvironment includesClass: OrderedCollection).	self assert: (newEnvironment includesClass: Collection).	self assert: newEnvironment numberClasses = 2.	self 		assert: newEnvironment numberSelectors + 1 = environment numberSelectors.	newEnvironment addClass: Object class.	self assert: newEnvironment numberClasses = 2.	self assert: (newEnvironment includesClass: Object class).	newEnvironment removeClass: self class.	self assert: newEnvironment numberClasses = 2! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testEnvironmentWrapper	| printString wrapper |	printString := BrowserEnvironment new referencesTo: #printString.	wrapper := BrowserEnvironmentWrapper onEnvironment: printString.	self assert: wrapper numberSelectors = printString numberSelectors.	self assert: wrapper numberClasses = printString numberClasses.	self assert: wrapper environment == printString! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testImplementorsMatching	| print |	print := BrowserEnvironment new implementorsMatching: '*print*'.	self universalTestFor: print.	self assert: (print implementorsOf: #printString) numberSelectors 				= (BrowserEnvironment new implementorsOf: #printString) numberSelectors.	print 		classesAndSelectorsDo: [:class :sel | self assert: ('*print*' match: sel)]! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testMatches	| envEnvironment environmentEnvironment |	envEnvironment := BrowserEnvironment new matches: '*env*'.	environmentEnvironment := BrowserEnvironment new 				referencesTo: #environment.	self assert: (envEnvironment referencesTo: #environment) numberSelectors 				= environmentEnvironment numberSelectors! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testProtocolEnvironment	| aProtocolEnvironment size |	aProtocolEnvironment := ProtocolEnvironment 				onEnvironment: BrowserEnvironment new				class: Object				protocols: #(#printing #testing).	self universalTestFor: aProtocolEnvironment.	self 		assert: (aProtocolEnvironment implementorsOf: #printString) numberSelectors 				= 1.	size := 0.	aProtocolEnvironment classesDo: [:each | size := size + 1].	self assert: size = 1.	aProtocolEnvironment selectorsForClass: Object		do: 			[:each | 			self assert: (#(#printing #testing) 						includes: (BrowserEnvironment new whichProtocolIncludes: each in: Object))]! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testRemoveSelectorByAndAndNot	| aBrowserEnvironment objectPrintString |	aBrowserEnvironment := BrowserEnvironment new.	objectPrintString := SelectorEnvironment 				onEnvironment: aBrowserEnvironment.	objectPrintString addClass: Object selector: #printString.	self assert: aBrowserEnvironment numberSelectors - 1 				= (aBrowserEnvironment & objectPrintString not) numberSelectors.	self universalTestFor: aBrowserEnvironment & objectPrintString not! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testSelectMethods	| environment |	environment := BrowserEnvironment new selectMethods: [:each | false].	self assert: environment numberSelectors = 0.	self assert: environment numberClasses = 0.	environment := BrowserEnvironment new selectMethods: [:each | true].	self assert: environment numberSelectors 				= BrowserEnvironment new numberSelectors.	environment := BrowserEnvironment new 				selectMethods: [:each | each refersToLiteral: #environment].	self assert: environment numberSelectors 				= (BrowserEnvironment new referencesTo: #environment) numberSelectors! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testSelectorEnvironment	| printString |	printString := BrowserEnvironment new referencesTo: #printString.	self universalTestFor: printString.	self assert: printString numberSelectors 				= (printString referencesTo: #printString) numberSelectors.	self assert: printString numberClasses 				= (printString referencesTo: #printString) numberClasses! !!BrowserEnvironmentTest methodsFor: 'set up'!setUp	super setUp.	universalEnvironment := BrowserEnvironment new! !!BrowserEnvironmentTest methodsFor: 'AndEnvironment tests' stamp: 'bh 4/10/2001 16:29'!testAndEnvironment	| originalEnvironment objectPrintStringEnvironment andEnvironment |	originalEnvironment := universalEnvironment referencesTo: #printOn:.	objectPrintStringEnvironment := universalEnvironment forClass: Object				selectors: #(#fullPrintString).	andEnvironment := objectPrintStringEnvironment & originalEnvironment.	self universalTestFor: andEnvironment.	self assert: andEnvironment numberSelectors = 1.	self assert: andEnvironment classNames asArray = #(#Object).	self assert: (andEnvironment protocolsFor: Object) size = 1.	andEnvironment := originalEnvironment 				& (universalEnvironment referencesTo: #printString).	self assert: andEnvironment numberSelectors 				= (originalEnvironment referencesTo: #printString) numberSelectors.	self assert: andEnvironment classNames asSortedCollection 				= (originalEnvironment referencesTo: #printString) classNames 						asSortedCollection! !!BrowserEnvironmentTest methodsFor: 'NotEnvironment tests' stamp: 'dvf 9/19/2001 20:41'!testNotEnvironment	| notPrintStringEnvironment printStringEnvironment |	printStringEnvironment := universalEnvironment referencesTo: #printString.	notPrintStringEnvironment := printStringEnvironment not.	self universalTestFor: notPrintStringEnvironment.	self 		assert: (notPrintStringEnvironment referencesTo: #printString) isEmpty.	self assert: (notPrintStringEnvironment not includesClass: BrowserEnvironmentTest).	self assert: (notPrintStringEnvironment not 				includesSelector: #testNotEnvironment				in: BrowserEnvironmentTest)! !!BrowserEnvironmentTest methodsFor: 'OrEnvironment tests' stamp: 'bh 9/17/2001 02:02'!testOrEnvironment	| env1 env2 orEnvironment |	self needsWork. "the following line is temporary, to help a SUnit test pass.  Literal strings withing literal arrays don't show up as references for some reason."	env2 := #printOn:.	env2 := universalEnvironment forClass: Object selectors: #(#fullPrintString).	env1 := universalEnvironment forClass: Object selectors: #(#printOn:).	self assert: (env1 | env2) numberSelectors = 2.	self assert: (env2 | env1) numberSelectors = 2.	self universalTestFor: env1 | env2.	self assert: (env1 | env1) numberSelectors = 1.	orEnvironment := env1 | env1 not.	self universalTestFor: orEnvironment.	self assert: orEnvironment numberSelectors 				= universalEnvironment numberSelectors.	self assert: orEnvironment classNames asSortedCollection 				= universalEnvironment classNames asSortedCollection.	self assert: (orEnvironment protocolsFor: Object) 				= ((universalEnvironment protocolsFor: Object) reject: [:each| (Object allMethodsInCategory: each) isEmpty ])! !!BrowserEnvironmentWrapper methodsFor: 'private'!environment	^environment! !!BrowserEnvironmentWrapper methodsFor: 'testing'!includesCategory: aCategory	^environment includesCategory: aCategory! !!BrowserEnvironmentWrapper methodsFor: 'testing'!includesClass: aClass	^environment includesClass: aClass! !!BrowserEnvironmentWrapper methodsFor: 'testing'!includesProtocol: aProtocol in: aClass	^(self includesClass: aClass)		and: [environment includesProtocol: aProtocol in: aClass]! !!BrowserEnvironmentWrapper methodsFor: 'testing'!includesSelector: aSelector in: aClass	^(self includesClass: aClass)		and: [environment includesSelector: aSelector in: aClass]! !!BrowserEnvironmentWrapper methodsFor: 'testing'!isEmpty	self classesDo: [:each | ^false].	^true! !!BrowserEnvironmentWrapper methodsFor: 'testing'!isSystem	^false! !!BrowserEnvironmentWrapper methodsFor: 'initialize-release'!onEnvironment: anEnvironment	environment := anEnvironment! !!BrowserEnvironmentWrapper methodsFor: 'accessing' stamp: 'bh 5/8/2000 21:03'!selectionIntervalFor: aString 	| interval |	interval := super selectionIntervalFor: aString.	^interval notNil 		ifTrue: [interval]		ifFalse: [environment selectionIntervalFor: aString]! !!BrowserEnvironmentWrapper methodsFor: 'printing'!storeOn: aStream 	aStream		nextPutAll: '(';		nextPutAll: self class name;		nextPutAll: ' onEnvironment: '.	environment storeOn: aStream.	aStream nextPut: $)! !!BrowserEnvironmentWrapper class methodsFor: 'instance creation'!new	^self onEnvironment: BrowserEnvironment new! !!BrowserEnvironmentWrapper class methodsFor: 'instance creation'!onEnvironment: anEnvironment 	^(self basicNew)		initialize;		onEnvironment: anEnvironment;		yourself! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 10/1/2005 13:19'!appendTextAnswer: aString	answer nextPutAll: aString! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 8/3/2005 09:52'!getAnyVariable	"answers the selected temporary or instance variable, or prompts the user for one"	| tree |	tree := self getParseTree.	^ self getVariableIn: (tree allDefinedVariables union: self getClass instVarNames)		string: 'please choose a variable'! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 9/7/2004 18:14'!getArgOrTempNode	"answers the selected temporary variable, or prompts the user for one"	| tree node vars |	tree := self getParseTree.	node := self getNode.	vars := tree allDefinedVariables.	(node isVariable and: [vars includes: node name]) ifTrue: [^ node].	^ nil! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 9/7/2004 18:15'!getArgumentVariable	"answers the selected temporary variable, or prompts the user for one"	| tree |	tree := self getParseTree.	^self getVariableIn: tree allArgumentVariables		string: 'please choose an argument'! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 9/7/2004 18:15'!getAssignmentNode	"answers the selected message : the one on which the caret is, or the browser's selected one"	| node |	node := self getNode.	[node isNil or: [node isAssignment]] whileFalse: [node := node parent].	^ node! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 11/14/2005 11:47'!getCategoryName	self caption:'Enter class category'.	^ self getSymbol! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 9/7/2004 18:19'!getClassVariable	"answers the selected instance variable, or prompts the user for one"	| class |	class := self getClass.	^ self getVariableIn: class theNonMetaClass classVarNames			string: 'please choose a class var'! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 10/1/2005 13:58'!getClassVariableName	^ self getClassVariable! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 7/6/2005 16:18'!getInstanceVariable	"answers the selected temporary variable, or prompts the user for one"	^ self getVariableIn: self getClass instVarNames		string: 'please choose an instance variable'! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 8/3/2005 09:38'!getInstanceVariableName	^ self getInstanceVariable! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 10/1/2005 13:33'!getInstanceVariablesToMoveInTheNewClassCollection	self getClass instVarNames		do: [:iv | self appendTextAnswer: iv]		separatedBy: [self appendTextAnswer: ' '].	self caption: 'Enter the list of instance variables to be moved to the new superclass'.	^ self getStringCollection		! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 1/4/2006 16:02'!getMessage	"answers the selected message : the one on which the caret is, or the browser's selected one"	| node |		(self  isSymbol: (node := self getNode) ) ifTrue: [^ node value].	[node isNil  or:[node isMessage]]  whileFalse:[node _ node parent].	^ node  ifNil:[self getSelector]  ifNotNil:[node selector]! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 9/7/2004 18:21'!getMessageNode	"answers the selected message : the one on which the caret is, or the browser's selected one"	| node |	node := self getNode.	[node isNil or: [node isMessage]] whileFalse: [node := node parent].	^ node! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 3/8/2006 11:40'!getMethodCategoryName	^ self getReference category! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 11/14/2005 11:47'!getNewClassName	self caption:'Enter new class name'.	^ self getSymbol! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 11/14/2005 11:47'!getNewSuperClassName	self caption:'Enter new (super)class name'.	^ self getSymbol! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 10/1/2005 13:43'!getNewVariableWhereRequestsWillBeForwarded	self caption: 'Enter the name of the (new) variable 	where all requests will be forwarded to'.	^ self getString! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 8/27/2005 15:51'!getNode	| n |	n := self getBrowser findNodeUnderCaret.	n ifNil: [^RBProgramNode new].	^n! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 8/27/2005 15:51'!getParseTree	^ self getBrowser parseTree! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 2/20/2007 18:45'!getRBEnv	"overriden in browserbooster to have real environments"		^ nil! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 8/27/2005 15:51'!getReference	^ self getBrowser methodReference! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 8/27/2005 15:51'!getSelectedInterval	^ self getBrowser selectedInterval! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 8/27/2005 15:51'!getSelectedText	^ self getBrowser selectedText! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 8/27/2005 15:51'!getSelectionNode	^ self getBrowser findSelectionNode! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 11/14/2005 11:48'!getSubclasses	self caption:'Enter (existing) subclasses of the new class'.	^ self getClassCollection! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 10/1/2005 13:22'!getSubclassesToMoveCollection	self getClass subclasses do: [:sc | self appendTextAnswer: sc name asString]			separatedBy: [self appendTextAnswer: ' '].	self caption: 'Enter the list of subclasses to be moved to the new superclass'.	^ self getSymbolCollection		! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 9/7/2004 18:22'!getTempNode	"answers the selected temporary variable, or prompts the user for one"	| tree node vars |	tree := self getParseTree.	node := self getNode.	vars := tree allDefinedVariables difference: tree allArgumentVariables.	(node isVariable and: [vars includes: node name]) ifTrue: [^ node].	^ nil! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 9/7/2004 18:22'!getTemporaryVariable	"answers the selected temporary variable, or prompts the user for one"	| tree |	tree := self getParseTree.	^ self getVariableIn: (tree allDefinedVariables difference: tree allArgumentVariables)		string: 'please choose a temporary variable'! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 9/7/2004 18:23'!getVariableIn: varList string: str 	| node |	node := self getNode.	(node isVariable and: [varList includes: node name]) ifTrue: [^node name].	^varList chooseOne: str! !!BrowserRequestor methodsFor: '*refactoringengine' stamp: 'rr 1/4/2006 16:01'!isSymbol: node 	^ node isLiteral  and:[node value isSymbol]! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 10/11/2004 15:21'!blockReturnTop	irBuilder blockReturnTop! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/10/2003 14:53'!doDup	irBuilder pushDup! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/10/2003 14:55'!doPop	irBuilder popTop! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 8/2/2005 17:11'!interpretNextInstructionFor: client	| byteIndex |	byteIndex := pc - self method initialPC + 1.	irBuilder mapToByteIndex: byteIndex.	irBuilder testJumpAheadTarget: byteIndex.	super interpretNextInstructionFor: client.! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 9/29/2005 11:24'!jump: dist	| index seq instr newSeq seqs |	index := pc + dist - self method initialPC + 1.	dist >= 0 ifTrue: [		"Maybe we are jumping over a non-closure Block." 		(irBuilder currentSequence notEmpty and: [irBuilder currentSequence last isSend] and: [			irBuilder currentSequence last selector == #blockCopy:]) ifTrue:						[^irBuilder jumpOverBlockTo: index].		"jump forward"		^ irBuilder jumpAheadTo: index].	"jump backward"	seqs := irBuilder ir allSequences.	seq := seqs findLast: [:s | s notEmpty and: [s first bytecodeIndex <= index]].	seq := seqs at: seq.	seq first bytecodeIndex = index ifTrue: [		newSeq := seq.	] ifFalse: [		instr := seq detect: [:i | (seq after: i) bytecodeIndex = index].		newSeq := seq splitAfter: instr.	].	irBuilder addJumpBackTarget: index to: newSeq.	irBuilder jumpBackTo: index.! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 13:59'!jump: dist if: bool	| index |	index _ pc + dist - self method initialPC + 1.	dist >= 0 ifTrue: [		"jump forward"		^ irBuilder jumpAheadTo: index if: bool].	self error: 'can only conditional jump forward'! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:34'!methodReturnConstant: value	self		pushConstant: value;		methodReturnTop! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:33'!methodReturnReceiver	self		pushReceiver;		methodReturnTop! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:31'!methodReturnTop	irBuilder returnTop! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 7/7/2005 14:12'!popIntoLiteralVariable: offset	self		storeIntoLiteralVariable: offset;		doPop! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:33'!popIntoReceiverVariable: offset	self		storeIntoReceiverVariable: offset;		doPop! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:34'!popIntoTemporaryVariable: offset	self		storeIntoTemporaryVariable: offset;		doPop! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:34'!pushActiveContext	irBuilder pushThisContext! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ms 8/20/2007 02:58'!pushConstant: value	value isBlockClosure ifTrue: [^irBuilder pushBlock: value method ir].	value isCompiledMethod ifTrue: [^irBuilder pushBlockMethod: value ir].	irBuilder pushLiteral: value! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 7/9/2005 22:28'!pushLiteralVariable: assoc	irBuilder pushLiteralVariable: assoc.! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:35'!pushReceiver	irBuilder pushReceiver! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 6/13/2005 13:58'!pushReceiverVariable: offset	Preferences compileBlocksAsClosures ifTrue: [self pushReceiver].	irBuilder pushInstVar: offset + 1.! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:36'!pushTemporaryVariable: offset	irBuilder pushTemp: offset + 1! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 6/20/2005 11:50'!send: selector super: superFlag numArgs: numArgs	selector == #privRemoteReturnTo: ifTrue: [^ irBuilder remoteReturn].	superFlag		ifTrue: [irBuilder send: selector toSuperOf: self method literals last value]		ifFalse: [irBuilder send: selector]! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 7/7/2005 14:14'!storeIntoLiteralVariable: value	irBuilder storeIntoLiteralVariable: value! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 6/13/2005 14:01'!storeIntoReceiverVariable: offset	Preferences compileBlocksAsClosures ifTrue: [self pushReceiver].	irBuilder storeInstVar: offset + 1.! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:39'!storeIntoTemporaryVariable: offset	irBuilder storeTemp: offset + 1! !!BytecodeDecompiler methodsFor: 'public access' stamp: 'md 2/25/2006 16:20'!decompile: aCompiledMethod	| ir |	self method: aCompiledMethod pc: aCompiledMethod initialPC.	irBuilder := IRBuilder new.	irBuilder primitiveNode: aCompiledMethod primitiveNode.	irBuilder numRargs: aCompiledMethod numArgs + 1.	irBuilder addTemps: (0 to: aCompiledMethod numTemps).	irBuilder properties: aCompiledMethod properties copy.	aCompiledMethod isQuick		ifTrue: [self quickMethod]		ifFalse: [self interpret].	ir := irBuilder ir.	ir privCompiledMethod: aCompiledMethod.	^ ir! !!BytecodeDecompiler methodsFor: 'private' stamp: 'ajh 3/15/2003 15:43'!quickMethod	self method primitive = 256 ifTrue: [		^ self methodReturnReceiver	].	self method isReturnSpecial ifTrue: [		^ self methodReturnConstant: (BytecodeGenerator specialConstants at: self method primitive - 256)	].	self method isReturnField ifTrue: [		self pushReceiverVariable: self method returnField.		^ self methodReturnTop	].	self halt: 'quick method inconsistency'! !!BytecodeDecompiler commentStamp: 'ajh 3/25/2003 00:26' prior: 0!I interpret bytecode instructions, sending the appropriate instruction messages to my IRBuilder, resulting in an IRMethod.!!BytecodeDecompilerTest methodsFor: 'examples' stamp: 'md 2/24/2005 15:04'!exampleWhileTrue	"Override the superclass for performance reasons."	| index firstIndex lastIndex aBlock array |	index _ firstIndex.  	[index <= lastIndex]		whileTrue:			[aBlock value: (array at: index).			index _ index + 1]! !!BytecodeDecompilerTest methodsFor: 'tests' stamp: 'md 3/22/2005 15:01'!testDecompileObject	self shouldnt: [			Object methodDict values do: [:meth |					meth ir.			]	] raise: Error.! !!BytecodeDecompilerTest methodsFor: 'tests' stamp: 'md 2/24/2005 15:20'!testDecompilerOrderedCollectionDo	| cm decompiledIR  |	cm := OrderedCollection>>#do:.	decompiledIR := BytecodeDecompiler new decompile: cm.	self shouldnt: [decompiledIR compiledMethodWith: #(0)] raise: Error.! !!BytecodeDecompilerTest methodsFor: 'tests' stamp: 'md 3/22/2005 15:55'!testRecompileIRObject	self shouldnt: [			Object methodDict values do: [:meth |					(meth ir) compiledMethodWith: #(0).			] displayingProgress: 'recompiling'	] raise: Error.! !!BytecodeDecompilerTest methodsFor: 'tests' stamp: 'md 2/24/2005 15:26'!testWhileTrue	| cm decompiledIR aCompiledMethod |	cm := (self class)>>#testWhileTrue.	decompiledIR := BytecodeDecompiler new decompile: cm.		self shouldnt: [aCompiledMethod := decompiledIR compiledMethodWith: #(0)] raise: Error.! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 3/6/2003 22:48'!addLastLiteral: object	lastLiteral ifNil: [^ lastLiteral _ object].	(lastLiteral literalEqual: object)		ifFalse: [self error: 'there can only be one last literal'].! !!BytecodeGenerator methodsFor: 'private' stamp: 'kwl 6/25/2006 20:06'!addLiteral: object	literals add: object.	^ literals identityIndexOf: object! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 5/22/2003 13:00'!from: fromSeqId goto: toSeqId	| distance from to |	from _ seqOrder at: fromSeqId.	to _ seqOrder at: toSeqId ifAbsent: [^ self].	from + 1 = to ifTrue: [^ self].  "fall through, no jump needed"	from < to ifTrue: [ "jump forward"		distance _ (from + 1 to: to - 1) inject: 0 into: [:size :i | 				size + (seqBytes at: (orderSeq at: i)) size].		self jumpForward: distance.	] ifFalse: [ "jump backward"		distance _ ((to to: from - 1) inject: 0 into: [:size :i |				size + (seqBytes at: (orderSeq at: i)) size])			+ bytes size.		self jumpBackward: distance.	].! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 5/22/2003 13:22'!from: fromSeqId if: bool goto: toSeqId otherwise: otherwiseSeqId	| distance from to otherwise |	from _ seqOrder at: fromSeqId.	to _ seqOrder at: toSeqId ifAbsent: [^ self jump: 0 if: bool].  "not done yet"	otherwise _ seqOrder at: otherwiseSeqId ifAbsent: [^ self jump: 0 if: bool].  "not done yet"	from < to ifFalse: [self errorConditionalJumpBackwards].	from + 1 = otherwise ifFalse: [self errorFallThroughSequenceNotNext].	distance _ (from + 1 to: to - 1)		inject: 0		into: [:size :i | size + (seqBytes at: (orderSeq at: i)) size].	self jump: distance if: bool.! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 3/24/2003 17:48'!jump: distance if: condition	| hi |	distance = 0 ifTrue: [		"jumps to fall through, no-op"		^ self nextPut: (Bytecodes at: #popStackBytecode)].	condition ifTrue: [		hi _ distance // 256.		hi < 8 ifFalse: [self error: 'true jump too big'].		self nextPut: (Bytecodes at: #longJumpIfTrue) first + hi.		self nextPut: distance \\ 256.	] ifFalse: [		distance <= 8 ifTrue: [			self nextPut: (Bytecodes at: #shortConditionalJump) first + distance - 1.		] ifFalse: [			hi _ distance // 256.			hi < 8 ifFalse: [self error: 'false jump too big'].			self nextPut: (Bytecodes at: #longJumpIfFalse) first + hi.			self nextPut: distance \\ 256.		].	]	! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 7/19/2004 12:12'!jumpBackward: distance	| dist |	distance = 0 ifTrue: [^ self].  "no-op"	dist _ 1024 - distance - 2.	dist < 0 ifTrue: [self error: 'back jump too big'].	self nextPut: (Bytecodes at: #longUnconditionalJump) first + (dist // 256).	self nextPut: dist \\ 256.! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 3/24/2003 17:46'!jumpForward: distance	distance = 0 ifTrue: [^ self].  "no-op"	distance <= 8 ifTrue: [		self nextPut: (Bytecodes at: #shortUnconditionalJump) first + distance - 1.	] ifFalse: [		distance > 1023 ifTrue: [self error: 'forward jump too big'].		self nextPut: (Bytecodes at: #longUnconditionalJump) first + (distance // 256) + 4.		self nextPut: distance \\ 256.	].! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 5/22/2003 13:28'!newDummySeqId	^ Object new! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 3/13/2003 13:00'!nextPut: byte	bytes add: byte! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 5/22/2003 12:23'!saveLastJump: message	jumps at: currentSeqId put: {bytes size. message}.! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 6/22/2003 14:41'!updateJump: seqId	"Recalculate final jump bytecodes.  Return true if jump bytecodes SIZE has changed, otherwise return false"	| pair s1 |	pair _ jumps at: seqId.	pair last == #return ifTrue: [^ false].  "no jump, a return"	bytes _ seqBytes at: seqId.	s1 _ bytes size.	bytes removeLast: (bytes size - pair first).	pair last sendTo: self.	^ s1 ~= bytes size! !!BytecodeGenerator methodsFor: 'old style blocks' stamp: 'md 10/8/2004 16:01'!blockReturnTop	self saveLastJump: #return.	self nextPut: (Bytecodes at: #returnTopFromBlock).! !!BytecodeGenerator methodsFor: 'old style blocks' stamp: 'md 10/8/2004 16:01'!fromBlock: curId goto: seqId	| distance from to |	from _ seqOrder at: curId.	to _ seqOrder at: seqId ifAbsent: [^ self].	distance _ (from + 1 to: to - 1) inject: 0 into: [:size :i | 				size + (seqBytes at: (orderSeq at: i)) size].	distance > 1023 ifTrue: [self error: 'forward jump too big'].	self nextPut: (Bytecodes at: #longUnconditionalJump) first + (distance // 256) + 4.	self nextPut: distance \\ 256.! !!BytecodeGenerator methodsFor: 'old style blocks' stamp: 'md 10/8/2004 16:01'!jumpOverBlock: seqId	stacks at: seqId put: (stack linkTo: (stacks at: seqId ifAbsentPut: [nil])).			self saveLastJump: (Message		selector: #fromBlock:goto:		arguments: {currentSeqId. seqId}).		self fromBlock: currentSeqId goto: seqId.! !!BytecodeGenerator methodsFor: 'results' stamp: 'ajh 5/22/2003 13:06'!bytecodes	| stream |	[ orderSeq		inject: false		into: [:changed :seqId | (self updateJump: seqId) | changed]	] whileTrue.	stream _ (ByteArray new: 100) writeStream.	orderSeq do: [:seqId |		(instrMaps at: seqId) do: [:assoc |			assoc key "instr" bytecodeIndex: stream position + assoc value.		].		stream nextPutAll: (seqBytes at: seqId).	].	^ stream contents! !!BytecodeGenerator methodsFor: 'results' stamp: 'md 2/21/2006 14:14'!compiledMethod	^ self compiledMethodWith: #(0 0 0 0)! !!BytecodeGenerator methodsFor: 'results' stamp: 'pmm 8/16/2006 20:51'!compiledMethodWith: trailer	^self compiledMethodWith: trailer using: CompiledMethod! !!BytecodeGenerator methodsFor: 'results' stamp: 'pmm 8/16/2006 20:51'!compiledMethodWith: trailer using: aCompiledMethodClass	| cm |	cm := (aCompiledMethodClass		primitive: (self primNum > 0			ifTrue: [self primNum]			ifFalse: [self quickMethodPrim])		numArgs: self numArgs		numTemps: (self numTemps max: self numArgs)		stackSize: self stackSize		literals: self literals		bytecodes: self bytecodes		trailer: trailer).	cm isClosureCompiled: Preferences compileBlocksAsClosures.	cm properties: self properties.	^cm.! !!BytecodeGenerator methodsFor: 'results' stamp: 'md 2/21/2006 14:14'!literals	literals := literals asArray copyWith: MethodProperties new.	^ lastLiteral 		ifNil: [literals copyWith: nil ] 		ifNotNil: [literals copyWith: lastLiteral]! !!BytecodeGenerator methodsFor: 'results' stamp: 'ajh 3/13/2003 18:27'!numArgs	^ numArgs! !!BytecodeGenerator methodsFor: 'results' stamp: 'ajh 3/13/2003 18:03'!numTemps	^ maxTemp! !!BytecodeGenerator methodsFor: 'results' stamp: 'ajh 3/13/2003 18:27'!primNum	^ primNum! !!BytecodeGenerator methodsFor: 'results' stamp: 'md 10/6/2005 16:50'!quickMethodPrim	| i |	self numArgs = 0 ifFalse: [^ 0].	lastSpecialReturn ifNil: [^ 0].	(seqBytes  size <= 2) ifFalse: [^ 0].	"seqBytes  size = 1 ifFalse: [^ 0]."	^ lastSpecialReturn selector caseOf: {		[#returnReceiver] -> [256].		[#returnConstant:] -> [			(i := SpecialConstants indexOf: lastSpecialReturn argument) > 0				ifTrue: [256 + i] ifFalse: [0]].		[#returnInstVar:] -> [263 + lastSpecialReturn argument]	  }! !!BytecodeGenerator methodsFor: 'results' stamp: 'ajh 3/13/2003 18:03'!stackSize	^ (stacks collect: [:s | s length]) max! !!BytecodeGenerator methodsFor: 'accessing default' stamp: 'ms 4/20/2007 13:49'!defaultStackCounter		^StackCount! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 5/22/2003 12:22'!goto: seqId	stacks at: seqId put: (stack linkTo: (stacks at: seqId ifAbsentPut: [nil])).	self saveLastJump: (Message		selector: #from:goto:		arguments: {currentSeqId. seqId}).	self from: currentSeqId goto: seqId.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 5/22/2003 13:26'!if: bool goto: seqId	| otherwiseSeqId |	otherwiseSeqId _ self newDummySeqId.	self if: bool goto: seqId otherwise: otherwiseSeqId.	self label: otherwiseSeqId.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 5/22/2003 12:26'!if: bool goto: seqId1 otherwise: seqId2	stack pop.	stacks at: seqId1 put: (stack linkTo: (stacks at: seqId1 ifAbsentPut: [nil])).	stacks at: seqId2 put: (stack linkTo: (stacks at: seqId2 ifAbsentPut: [nil])).	self saveLastJump: (Message		selector: #from:if:goto:otherwise:		arguments: {currentSeqId. bool. seqId1. seqId2}).	self from: currentSeqId if: bool goto: seqId1 otherwise: seqId2.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ms 4/20/2007 13:53'!initializeStackCounter	^ self defaultStackCounter new! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ms 4/20/2007 13:53'!label: seqId 	(currentSeqId notNil and: [(jumps at: currentSeqId) isNil]) 		ifTrue: 			["make previous implicit goto explicit"			self goto: seqId].	lastSpecialReturn := nil.	currentSeqId := seqId.	currentSeqNum := currentSeqNum + 1.	seqOrder at: seqId put: currentSeqNum.	orderSeq at: currentSeqNum ifAbsentPut: [seqId].	bytes := seqBytes at: seqId ifAbsentPut: [OrderedCollection new].	jumps at: seqId ifAbsentPut: [nil].	instrMap := instrMaps at: seqId ifAbsentPut: [OrderedCollection new].	stack := stacks at: seqId ifAbsentPut: [self initializeStackCounter]! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 17:48'!popTop	stack pop.	self nextPut: (Bytecodes at: #popStackBytecode).! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 17:48'!pushDup	stack push.	self nextPut: (Bytecodes at: #duplicateTopBytecode).! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 17:49'!pushInstVar: instVarIndex	| interval |	stack push.	interval _ Bytecodes at: #pushReceiverVariableBytecode.	instVarIndex <= interval size ifTrue: [		^ self nextPut: (interval at: instVarIndex).	].	instVarIndex <= 64 ifTrue: [		self nextPut: (Bytecodes at: #extendedPushBytecode).		^ self nextPut: (0 "instVar" << 6) + instVarIndex - 1.	].	instVarIndex <= 256 ifFalse: [self error: 'can''t reference more than 256 inst vars'].	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: 2 "pushInstVar" << 5.	self nextPut: instVarIndex - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'kwl 6/25/2006 19:56'!pushLiteral: object	| index interval |	stack push.	(index _ SpecialConstants identityIndexOf: object ifAbsent: 0) > 0 ifTrue: [		^ self nextPut: (Bytecodes at: #pushConstantTrueBytecode) + index - 1].	(index _ literals literalIndexOf: object ifAbsent: 0) > 0 ifFalse: [		index _ self addLiteral: object].	interval _ Bytecodes at: #pushLiteralConstantBytecode.	(index <= interval size) ifTrue: [		^ self nextPut: (interval at: index)	].	index <= 64 ifTrue: [		self nextPut: (Bytecodes at: #extendedPushBytecode).		^ self nextPut: 2 "lit constant" << 6 + index - 1	].	index > 256 ifTrue: [self error: 'too many literals (>256)'].	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: 3 "lit constant" << 5.	self nextPut: index - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'kwl 6/25/2006 19:58'!pushLiteralVariable: object	| index interval |	stack push.	object isVariableBinding		ifFalse: [self error: 'not a literal variable'].	(index _ literals literalIndexOf: object ifAbsent: 0) > 0 ifFalse: [		index _ self addLiteral: object].	interval _ Bytecodes at: #pushLiteralVariableBytecode.	(index <= interval size) ifTrue: [		^ self nextPut: (interval at: index)	].	index <= 64 ifTrue: [		self nextPut: (Bytecodes at: #extendedPushBytecode).		^ self nextPut: 3 "literal variable" << 6 + index - 1	].	index > 256 ifTrue: [self error: 'too many literals (>256)'].	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: 1 "lit variable" << 7.	self nextPut: index - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 17:50'!pushReceiver	stack push.	self nextPut: (Bytecodes at: #pushReceiverBytecode)! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 17:51'!pushTemp: index	| interval |	stack push.	maxTemp _ index max: maxTemp.	interval _ Bytecodes at: #pushTemporaryVariableBytecode.	index <= interval size ifTrue: [		^ self nextPut: (interval at: index).	].	index <= 64 ifFalse: [self error: 'too many temp vars (>64)'].	self nextPut: (Bytecodes at: #extendedPushBytecode).	self nextPut: (1 "temp" << 6) + index - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 17:51'!pushThisContext	stack push.	self nextPut: (Bytecodes at: #pushActiveContextBytecode).! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 7/2/2004 13:44'!remoteReturn	self saveLastJump: #return.	self send: #privRemoteReturnTo:.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'md 7/19/2005 23:11'!returnConstant: obj	self saveLastJump: #return.		bytes size = 0 ifTrue: [		lastSpecialReturn := Message selector: #returnConstant: argument: obj]. 		obj caseOf: {		[true] -> [self nextPut: (Bytecodes at: #returnTrue)].		[false] -> [self nextPut: (Bytecodes at: #returnFalse)].		[nil] -> [self nextPut: (Bytecodes at: #returnNil)]	} otherwise: [		self pushLiteral: obj.		self returnTop.	]! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'md 7/19/2005 23:29'!returnInstVar: index	self saveLastJump: #return.		bytes size = 0 ifTrue: [		lastSpecialReturn := Message selector: #returnInstVar: argument: index].	self pushInstVar: index.	self returnTop.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 5/22/2003 14:02'!returnReceiver	self saveLastJump: #return.	bytes size = 0 ifTrue: [		lastSpecialReturn _ Message selector: #returnReceiver].	self nextPut: (Bytecodes at: #returnReceiver).! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 5/22/2003 14:02'!returnTop	self saveLastJump: #return.	self nextPut: (Bytecodes at: #returnTopFromMethod).! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/16/2003 14:43'!send: selector	| index nArgs |	nArgs _ selector numArgs.	stack pop: nArgs.	SpecialSelectors at: selector ifPresent: [:i |		^ self nextPut: (Bytecodes at: #bytecodePrimAdd) + i].	index _ self addLiteral: selector.	(index <= 16 and: [nArgs <= 2]) ifTrue: [		"short send"		^ self nextPut: (Bytecodes at: #sendLiteralSelectorBytecode) first + (nArgs * 16) + index - 1	].	(index <= 32 and: [nArgs <= 7]) ifTrue: [		"extended (2-byte) send"		self nextPut: (Bytecodes at: #singleExtendedSendBytecode).		^ self nextPut: nArgs * 32 + index - 1	].	(index <= 64 and: [nArgs <= 3]) ifTrue: [		"new extended (2-byte)"		self nextPut: (Bytecodes at: #secondExtendedSendBytecode).		^ self nextPut: nArgs * 64 + index - 1	].	"long (3-byte) send"	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: nArgs.	self nextPut: index - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'md 2/27/2006 17:03'!send: selector toSuperOf: behavior	| index nArgs |	nArgs := selector numArgs.	stack pop: nArgs.	self addLastLiteral: behavior binding.  	index := self addLiteral: selector.	(index <= 32 and: [nArgs <= 7]) ifTrue: [		"extended (2-byte) send"		self nextPut: (Bytecodes at: #singleExtendedSuperBytecode).		^ self nextPut: nArgs * 32 + index - 1	].	"long (3-byte) send"	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: 1 << 5 "super" + nArgs.	self nextPut: index - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/9/2003 20:36'!storeInstVar: index	index <= 64 ifTrue: [		self nextPut: (Bytecodes at: #extendedStoreBytecode).		^ self nextPut: (0 "instVar" << 6) + index - 1.	].	index <= 256 ifFalse: [self error: 'can''t reference more than 256 inst vars'].	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: 5 "storeInstVar" << 5.	self nextPut: index - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'md 10/4/2005 17:42'!storeIntoLiteralVariable: object	| index |		index := self addLiteral: object.   	index <= 64 ifTrue: [		self nextPut: (Bytecodes at: #extendedStoreBytecode).		^ self nextPut: (3 "instVar" << 6) + index - 1.	].	index <= 256 ifFalse: [self error: 'can''t reference more than 256 inst vars'].	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: 7 "storeLiteralVar" << 5.	self nextPut: index - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 18:00'!storePopInstVar: index	| interval |	stack pop.	interval _ Bytecodes at: #storeAndPopReceiverVariableBytecode.	index <= interval size ifTrue: [		^ self nextPut: (interval at: index)	].	index <= 64 ifTrue: [		self nextPut: (Bytecodes at: #extendedStoreAndPopBytecode).		^ self nextPut: (0 "instVar" << 6) + index - 1.	].	index <= 256 ifFalse: [		self error: 'can''t reference more than 256 inst vars'].	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: 6 "storePopInstVar" << 5.	self nextPut: index - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ms 12/3/2006 20:17'!storePopIntoLiteralVariable: assoc	| index |		index := self addLiteral: assoc.		index <= 64 ifTrue: [		stack pop.		self nextPut: (Bytecodes at: #extendedStoreAndPopBytecode).		^ self nextPut: (3 "temp" << 6) + index - 1.	].	index <= 256 ifFalse: [self error: 'can''t reference more than 256 inst vars'].	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: 7 "storeLiteralVar" << 5.	self nextPut: index - 1.	self popTop! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 18:01'!storePopTemp: index	| interval |	stack pop.	maxTemp _ index max: maxTemp.	interval _ Bytecodes at: #storeAndPopTemporaryVariableBytecode.	index <= interval size ifTrue: [		^ self nextPut: (interval at: index)	].	index <= 64 ifTrue: [		self nextPut: (Bytecodes at: #extendedStoreAndPopBytecode).		^ self nextPut: (1 "temp" << 6) + index - 1.	].	self error: 'too many temps (>64)'! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 18:01'!storeTemp: index	maxTemp _ index max: maxTemp.	index <= 64 ifFalse: [self error: 'too many temps (>64)'].	self nextPut: (Bytecodes at: #extendedStoreBytecode).	self nextPut: (1 "temp" << 6) + index - 1.! !!BytecodeGenerator methodsFor: 'initialize' stamp: 'md 2/21/2006 14:27'!initialize	literals _ LiteralList new.	"The following dicts are keyed by sequence id given by client in label: (and gotos)."	seqOrder _ IdentityDictionary new.  "seqId -> seq order num"	seqBytes _ IdentityDictionary new.  "seqId -> seq bytecodes"	jumps _ IdentityDictionary new.  "seqId -> last jump instr"	instrMaps _ IdentityDictionary new.  "seqId -> (clientInstr -> bytecode pos)"	stacks _ IdentityDictionary new.  "seqId -> stackCount"	maxTemp _ 0.	primNum _ 0.	numArgs _ 0.	currentSeqNum _ 0.	orderSeq _ OrderedCollection new.  "reverse map of seqOrder"	"starting label in case one is not provided by client"	self label: self newDummySeqId.! !!BytecodeGenerator methodsFor: 'initialize' stamp: 'ajh 3/13/2003 18:21'!numArgs: n	numArgs _ n! !!BytecodeGenerator methodsFor: 'initialize' stamp: 'ajh 3/13/2003 18:21'!primitiveNode: aPrimitiveNode	literals isEmpty ifFalse: [self error: 'init prim before adding instructions'].	aPrimitiveNode spec ifNotNil: [literals add: aPrimitiveNode spec].	primNum _ aPrimitiveNode num.! !!BytecodeGenerator methodsFor: 'mapping' stamp: 'ajh 3/13/2003 13:00'!mapBytesTo: instr	"Associate next byte with instr"	instrMap add: instr -> (bytes size + 1)! !!BytecodeGenerator methodsFor: 'accessing' stamp: 'md 7/12/2006 16:40'!properties	^ properties ifNil: [ properties := MethodProperties new ].! !!BytecodeGenerator methodsFor: 'accessing' stamp: 'md 7/10/2005 22:21'!properties: propDict	properties := propDict.! !!BytecodeGenerator commentStamp: 'ajh 5/23/2003 10:59' prior: 0!I generate bytecodes in response to 'instructions' messages being sent to me.  I rewrite jumps at the end so their jump offsets are correct (see #bytecodes).  For example, to create a compiled method that compares first instVar to first arg and returns 'yes' or 'no' (same example as in IRBuilder), do:	BytecodeGenerator new		numArgs: 1;		pushInstVar: 1;		pushTemp: 1;		send: #>;		if: false goto: #else;		pushLiteral: 'yes';		returnTop;		label: #else;		pushLiteral: 'no';		returnTop;		compiledMethodYou can send #ir to the compiledMethod to decompile to its IRMethod, and you can send #methodNode to either to decompile to its parse tree.!!BytecodeGenerator class methodsFor: 'initialize' stamp: 'ajh 3/6/2003 22:44'!bytecodeTableFrom: specArray	"SpecArray is an array of either	(index selector) or	(index1 index2 selector)."	| contiguous |	Bytecodes _ IdentityDictionary new: 256.	BytecodeTable _ Array new: 256.	contiguous _ 0.	specArray do: [ :spec |		(spec at: 1) = contiguous ifFalse: [self error: 'Non-contiguous table entry'].		spec size = 2 ifTrue: [			Bytecodes at: (spec at: 2) put: (spec at: 1).			BytecodeTable at: (spec at: 1) + 1 put: (spec at: 2).			contiguous _ contiguous + 1.		] ifFalse: [			spec size = 3 ifFalse: [self error: 'bad spec size'].			Bytecodes at: (spec at: 3) put: ((spec at: 1) to: (spec at: 2)).			(spec at: 1) to: (spec at: 2) do: [ :i |				BytecodeTable at: i + 1 put: (spec at: 3).			].			contiguous _ contiguous + ((spec at: 2) - (spec at: 1)) + 1.		].	].	^ BytecodeTable! !!BytecodeGenerator class methodsFor: 'initialize' stamp: 'ajh 3/6/2003 22:40'!initialize	self initializeBytecodeTable.	self initializeSpecialSelectors.	self initializeSpecialConstants.! !!BytecodeGenerator class methodsFor: 'initialize' stamp: 'ajh 3/6/2003 22:42'!initializeBytecodeTable	"BytecodeWriteStream initialize"	"Defines all the bytecode instructions for the Compiler and the Interpreter.	The following bytecode tuple format is:	#(bytecode bytecodeSelector)	bytecodeSelector is the method in the Interpreter that gets executed for the given bytecode.	Common Send selector position within the specialSelectorsArray is hard code in the Interpreter, see senders of Interpreter specialSelector:."	^ self bytecodeTableFrom:	#(		(  0  15 pushReceiverVariableBytecode)		( 16  31 pushTemporaryVariableBytecode)		( 32  63 pushLiteralConstantBytecode)		( 64  95 pushLiteralVariableBytecode)		( 96 103 storeAndPopReceiverVariableBytecode)		(104 111 storeAndPopTemporaryVariableBytecode)		(112 pushReceiverBytecode)		(113 pushConstantTrueBytecode)		(114 pushConstantFalseBytecode)		(115 pushConstantNilBytecode)		(116 pushConstantMinusOneBytecode)		(117 pushConstantZeroBytecode)		(118 pushConstantOneBytecode)		(119 pushConstantTwoBytecode)		(120 returnReceiver)		(121 returnTrue)		(122 returnFalse)		(123 returnNil)		(124 returnTopFromMethod)		(125 returnTopFromBlock)		(126 unknownBytecode)		(127 unknownBytecode)		(128 extendedPushBytecode)		(129 extendedStoreBytecode)		(130 extendedStoreAndPopBytecode)		(131 singleExtendedSendBytecode)		(132 doubleExtendedDoAnythingBytecode)		(133 singleExtendedSuperBytecode)		(134 secondExtendedSendBytecode)		(135 popStackBytecode)		(136 duplicateTopBytecode)		(137 pushActiveContextBytecode)		(138 143 experimentalBytecode)		(144 151 shortUnconditionalJump)		(152 159 shortConditionalJump)		(160 167 longUnconditionalJump)		(168 171 longJumpIfTrue)		(172 175 longJumpIfFalse)		"176-191 were sendArithmeticSelectorBytecode"		(176 bytecodePrimAdd)		(177 bytecodePrimSubtract)		(178 bytecodePrimLessThan)		(179 bytecodePrimGreaterThan)		(180 bytecodePrimLessOrEqual)		(181 bytecodePrimGreaterOrEqual)		(182 bytecodePrimEqual)		(183 bytecodePrimNotEqual)		(184 bytecodePrimMultiply)		(185 bytecodePrimDivide)		(186 bytecodePrimMod)		(187 bytecodePrimMakePoint)		(188 bytecodePrimBitShift)		(189 bytecodePrimDiv)		(190 bytecodePrimBitAnd)		(191 bytecodePrimBitOr)			"192-207 were sendCommonSelectorBytecode"		(192 bytecodePrimAt)		(193 bytecodePrimAtPut)		(194 bytecodePrimSize)		(195 bytecodePrimNext)		(196 bytecodePrimNextPut)		(197 bytecodePrimAtEnd)		(198 bytecodePrimEquivalent)		(199 bytecodePrimClass)		(200 bytecodePrimBlockCopy)		(201 bytecodePrimValue)		(202 bytecodePrimValueWithArg)		(203 bytecodePrimDo)		(204 bytecodePrimNew)		(205 bytecodePrimNewWithArg)		(206 bytecodePrimPointX)		(207 bytecodePrimPointY)		(208 255 sendLiteralSelectorBytecode)	)! !!BytecodeGenerator class methodsFor: 'initialize' stamp: 'ajh 3/6/2003 22:45'!initializeSpecialConstants	SpecialConstants _ {true. false. nil. -1. 0. 1. 2}! !!BytecodeGenerator class methodsFor: 'initialize' stamp: 'ajh 3/6/2003 22:40'!initializeSpecialSelectors	"Create a map from specialSelector -> bytecode offset from sendAdd (the first one)"	| array |	SpecialSelectors _ IdentityDictionary new.	array _ self specialSelectorsArray.  "Smalltalk specialObjectsArray at: 24"	1 to: array size by: 2 "skip numArgs" do: [:i |		SpecialSelectors at: (array at: i) put: i - 1 / 2].! !!BytecodeGenerator class methodsFor: 'initialize' stamp: 'ajh 3/15/2003 15:43'!specialConstants	^ SpecialConstants! !!BytecodeGenerator class methodsFor: 'initialize' stamp: 'ajh 3/6/2003 22:45'!specialSelectorsArray	^ #(#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1 #* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1 #at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0 #blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0)! !!BytecodeGeneratorTest methodsFor: 'setup' stamp: 'md 10/13/2004 14:16'!setUp	a := 2! !!BytecodeGeneratorTest methodsFor: 'tests' stamp: 'md 10/13/2004 14:20'!testExample	| cm |		cm := BytecodeGenerator new		numArgs: 1;		pushInstVar: 2;		pushTemp: 1;		send: #>;		if: false goto: #else;		pushLiteral: 'yes';		returnTop;		label: #else;		pushLiteral: 'no';		returnTop;		compiledMethod.	self assert: (cm isKindOf: CompiledMethod).	self assert: (cm valueWithReceiver: self arguments: #(1)) = 'yes' .	self assert: (cm valueWithReceiver: self arguments: #(3)) = 'no' .		^cm	! !!C methodsFor: 'as yet unclassified' stamp: 'Y.-G.G. 4/4/2014 14:50'!foo: aText    Transcript show: aText.    Transcript show: i.    Transcript cr.! !!C methodsFor: 'as yet unclassified' stamp: 'Y.-G.G. 4/3/2014 16:27'!i: anInt	"A setter for the instance variable i."	i := anInt.	^self.! !!C commentStamp: 'Y.-G.G. 4/14/2014 16:06' prior: 0!Class use as example for the Reflection Scenarios 1, 2, 3, and 4.!!C class methodsFor: 'as yet unclassified' stamp: 'Y.-G.G. 4/14/2014 16:19'!individualClassNumberOfInstances    ^ IndividualClassNumberOfInstances.! !!C class methodsFor: 'as yet unclassified' stamp: 'Y.-G.G. 4/14/2014 16:16'!initialize    NumberOfInstances := 0.    IndividualClassNumberOfInstances := 0.! !!C class methodsFor: 'as yet unclassified' stamp: 'Y.-G.G. 4/14/2014 16:17'!new    NumberOfInstances := NumberOfInstances + 1.    IndividualClassNumberOfInstances := IndividualClassNumberOfInstances + 1.    ^ self basicNew initialize.! !!C class methodsFor: 'as yet unclassified' stamp: 'Y.-G.G. 4/3/2014 16:11'!newWithi: anInt    ^(self new) i: anInt ; yourself.! !!C class methodsFor: 'as yet unclassified' stamp: 'Y.-G.G. 4/3/2014 16:46'!numberOfInstances    ^ NumberOfInstances.! !!CLBlockInterpreter methodsFor: 'accessing' stamp: 'pmm 4/28/2006 19:57'!blockInterpreterClass	^CLBlockInterpreter! !!CLBlockInterpreter methodsFor: 'visiting' stamp: 'pmm 4/28/2006 20:45'!visitNode: aNode	aNode markExecuted.	^super visitNode: aNode! !!CLCodePiece methodsFor: 'comparing' stamp: 'pmm 8/4/2006 16:15'!<= other	^(other isKindOf: CLCodePiece)		and: [			self start = other start				ifTrue: [ self end > other end ]				ifFalse: [ self start < other start ] ]! !!CLCodePiece methodsFor: 'accessing' stamp: 'pmm 4/28/2006 23:18'!attributes	^attributes! !!CLCodePiece methodsFor: 'accessing' stamp: 'pmm 4/28/2006 23:19'!attributes: aCollection 	attributes := aCollection! !!CLCodePiece methodsFor: 'accessing' stamp: 'pmm 4/28/2006 23:18'!end	^end! !!CLCodePiece methodsFor: 'accessing' stamp: 'pmm 4/28/2006 23:19'!end: anInteger 	end := anInteger! !!CLCodePiece methodsFor: 'accessing' stamp: 'pmm 4/28/2006 23:18'!start	^start! !!CLCodePiece methodsFor: 'accessing' stamp: 'pmm 4/28/2006 23:18'!start: anInteger 	start := anInteger! !!CLCodePiece methodsFor: 'copying' stamp: 'pmm 4/30/2006 12:07'!copyWithSizeIncrement: anInteger	| copy |	copy := self copy.	copy start: copy start + anInteger.	copy end: copy end + anInteger.	^copy! !!CLCodePiece methodsFor: 'printing' stamp: 'pmm 4/28/2006 23:49'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self start printOn: aStream.	aStream nextPutAll: ', '.	self end printOn: aStream.	aStream nextPut: $)	! !!CLExecutedAnnotation methodsFor: 'actions' stamp: 'pmm 4/28/2006 19:14'!increment	self timesExecuted: self timesExecuted + 1! !!CLExecutedAnnotation methodsFor: 'actions' stamp: 'pmm 4/28/2006 19:14'!reset	self timesExecuted: 0! !!CLExecutedAnnotation methodsFor: 'initialize-release' stamp: 'pmm 4/28/2006 19:15'!initialize	super initialize.	self timesExecuted: 0! !!CLExecutedAnnotation methodsFor: 'testing' stamp: 'pmm 4/28/2006 19:11'!isSourceVisible	^false! !!CLExecutedAnnotation methodsFor: 'testing' stamp: 'pmm 4/28/2006 19:18'!wasExecuted	^self timesExecuted > 0! !!CLExecutedAnnotation methodsFor: 'printing' stamp: 'pmm 6/26/2006 12:16'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: self timesExecuted;		nextPut: $)! !!CLExecutedAnnotation methodsFor: 'accessing' stamp: 'pmm 4/28/2006 19:13'!timesExecuted	^value! !!CLExecutedAnnotation methodsFor: 'accessing' stamp: 'pmm 4/28/2006 19:14'!timesExecuted: anInteger	self value: anInteger! !!CLExecutedAnnotation class methodsFor: 'accessing' stamp: 'pmm 4/28/2006 19:17'!key	^#executionCount! !!CLExecutedAnnotation class methodsFor: 'accessing' stamp: 'pmm 4/28/2006 19:17'!keys	^Array with: self key! !!CLExecutionFormatter methodsFor: 'visitor-double dispatching' stamp: 'pmm 4/30/2006 11:01'!acceptArrayNode: anArrayNode 	self maybeJoinLinesFrom: [		codeStream nextPutAll: '{ '.		self indent: 1 while: [			self indent.			self formatStatementsFor: anArrayNode.		].		self indent.		codeStream nextPutAll: ' }'.	]! !!CLExecutionFormatter methodsFor: 'visitor-double dispatching' stamp: 'pmm 4/30/2006 11:10'!acceptAssignmentNode: anAssignmentNode 	self visitNode: anAssignmentNode variable.	codeStream nextPutAll: ' := '.	self visitNode: anAssignmentNode value! !!CLExecutionFormatter methodsFor: 'visitor-double dispatching' stamp: 'pmm 4/30/2006 11:39'!acceptBlockNode: aBlockNode 	| seqNode multiline formattedBody formatter |	seqNode := aBlockNode body.	formatter := self copy lineStart: 0;				yourself.	formattedBody := formatter format: seqNode.	multiline := self lineLength + formattedBody size > self maxLineSize				or: [formatter isMultiLine].	multiline ifTrue: [self indent].	codeStream nextPutAll: '[ '.	aBlockNode arguments do: 			[:each | 			codeStream nextPutAll: ': '.			self visitBlockArgument: each.			codeStream space ].	aBlockNode arguments isEmpty ifFalse: 			[codeStream nextPutAll: '| '.			multiline ifTrue: [self indent]].			formatter := self copy lineStart: 0;				yourself.	formattedBody := formatter format: seqNode.	pieces addAll: formatter pieces.	codeStream nextPutAll: formattedBody;		nextPutAll: ' ]'! !!CLExecutionFormatter methodsFor: 'visitor-double dispatching' stamp: 'pmm 4/30/2006 11:09'!acceptCascadeNode: aCascadeNode 	| messages |	messages := aCascadeNode messages.	self visitNode: messages first receiver.	self indentWhile: 			[messages				do: 					[:each | 					self						indent;						indentWhile: [self formatMessage: each cascade: true]]				separatedBy: [codeStream nextPutAll: ' ;' ]]! !!CLExecutionFormatter methodsFor: 'visitor-double dispatching' stamp: 'pmm 4/30/2006 11:40'!acceptMessageNode: aMessageNode 	| formatter code |	formatter := self copy.	code := formatter format: aMessageNode receiver.	pieces addAll: formatter pieces.	codeStream nextPutAll: code.	codeStream nextPut: $ .	formatter isMultiLine		ifTrue: [lineStart := codeStream position - formatter lastLineLength].	self indent: ((self shouldIndent: aMessageNode selector) ifTrue: [1] ifFalse: [0]) 		while: [self formatMessage: aMessageNode cascade: false]! !!CLExecutionFormatter methodsFor: 'visitor-double dispatching' stamp: 'pmm 4/30/2006 11:03'!acceptReturnNode: aReturnNode 	codeStream nextPutAll: '^ '.	self visitNode: aReturnNode value! !!CLExecutionFormatter methodsFor: 'private' stamp: 'pmm 8/4/2006 16:18'!executedAttributes	^Array		with: (TextColor color: Color green)		with: TextEmphasis normal! !!CLExecutionFormatter methodsFor: 'private' stamp: 'pmm 8/4/2006 16:18'!notExecutedAttributes	^Array		with: (TextColor color: Color red)		with: TextEmphasis normal! !!CLExecutionFormatter methodsFor: 'public' stamp: 'pmm 4/30/2006 11:54'!format: aNode	pieces := SortedCollection new.	self visitNode: aNode.	aNode isMethod ifTrue: [		"self halt."		"pieces select: [ :each |			each attributes first color = Color red ]."		pieces do: [ :each |			codeStream colorCodePiece: each ] ].	^codeStream contents! !!CLExecutionFormatter methodsFor: 'private-formatting' stamp: 'pmm 4/30/2006 12:00'!formatMessage: aMessageNode cascade: cascadeBoolean 	| selectorParts arguments multiLine formattedArgs indentFirst length |	selectorParts := aMessageNode selectorParts.	arguments := aMessageNode arguments.	formattedArgs := OrderedCollection new.	multiLine := (aMessageNode selector numArgs > self maximumArgumentsPerLine)		or: [ self selectorsToStartOnNewLine includes: aMessageNode selector ].	length := aMessageNode selector size + arguments size + 1.	1 to: arguments size do:  [:i | 					| formatter string start |					formatter := self copy								lineStart: (selectorParts at: i) length negated;								yourself.					start := self fullPosition.					string := formatter format: (arguments at: i).					(multiLine and: [ formatter isMultiLine ]) ifTrue: [						"redo it with a pre-indent first"						formatter := (self copy) 							lineStart: (selectorParts at: i) length negated;							yourself.						formatter indentWhile: [							start := self fullPosition.							string := formatter format: (arguments at: i) ] ].					formattedArgs add: (CLFormattingInfo start: start string: string pieces: formatter pieces).					length := length + string size.					multiLine := multiLine or: [formatter isMultiLine]].	multiLine := multiLine or: [length + self lineLength > self maxLineSize].	indentFirst := cascadeBoolean not and: [ multiLine ].	(indentFirst and: [ aMessageNode selector numArgs > self maximumArgumentsPerLine ])		ifTrue: [self indent].	self 		formatMessageSelector: selectorParts		withArguments: formattedArgs		multiline: multiLine! !!CLExecutionFormatter methodsFor: 'private-formatting' stamp: 'pmm 4/30/2006 12:08'!formatMessageSelector: selectorParts withArguments: formattedArgs multiline: multiLine	| selectorPart argStarts startDifference nextArgument |	argStarts := Array new: formattedArgs size.	formattedArgs isEmpty 		ifTrue: [			selectorParts first start ifNil: [				selectorParts first start: self fullPosition + 1].			codeStream nextPutAll: selectorParts first value]		ifFalse: [1 to: formattedArgs size do: [:i | 					i ~~ 1 & multiLine not ifTrue: [codeStream space ].					selectorPart := selectorParts at: i.					selectorPart start ifNil: [selectorPart start: self fullPosition + 1].					self formatMessageSelectorPart: selectorPart.					codeStream nextPut: $ .					argStarts at: i put: self fullPosition.					nextArgument := formattedArgs at: i.					startDifference := self fullPosition - nextArgument start.					pieces addAll: (nextArgument pieces collect: [ :each |						each copyWithSizeIncrement: startDifference ]).					codeStream nextPutAll: nextArgument string.					(multiLine and: [i < formattedArgs size]) ifTrue: [self indent]]].	^ argStarts! !!CLExecutionFormatter methodsFor: 'private-formatting' stamp: 'pmm 4/30/2006 11:05'!formatMethodCommentFor: aNode indentBefore: aBoolean 	| source |	source := aNode source.	source isNil ifTrue: [^self].	aNode comments do: 			[:each | 			aBoolean ifTrue: [self indent].			codeStream nextPutAll: (aNode source copyFrom: each first to: each last).			aBoolean ifFalse: [self indent]]! !!CLExecutionFormatter methodsFor: 'private-formatting' stamp: 'pmm 4/30/2006 11:06'!maximumArgumentsPerLine	^ 1! !!CLExecutionFormatter methodsFor: 'private-formatting' stamp: 'pmm 4/30/2006 11:06'!selectorsToLeaveOnLine	^#()! !!CLExecutionFormatter methodsFor: 'private-formatting' stamp: 'pmm 4/30/2006 11:06'!selectorsToStartOnNewLine	^#(and: or:)! !!CLExecutionFormatter methodsFor: 'private-formatting' stamp: 'pmm 4/30/2006 11:05'!shouldIndent: selectorSymbol	^ (#(and: or:) includes: selectorSymbol) not! !!CLExecutionFormatter methodsFor: 'initialize-release' stamp: 'pmm 4/28/2006 19:25'!initialize	super initialize.	codeStream := TextStream on: (Text new: 400).! !!CLExecutionFormatter methodsFor: 'accessing' stamp: 'pmm 4/30/2006 11:39'!pieces	^pieces! !!CLExecutionFormatter methodsFor: 'visiting' stamp: 'pmm 8/4/2006 16:18'!visitNode: aNode	| start attributes result end |	start := self fullPosition + 1.	attributes := aNode wasExecuted		ifTrue: [ self executedAttributes ]		ifFalse: [ self notExecutedAttributes ].	result := super visitNode: aNode.	end := self fullPosition.	pieces add: (CLCodePiece new		start: start;		end: end;		attributes: attributes;		yourself).	^result! !!CLExecutionFormatter commentStamp: 'md 7/25/2007 15:15' prior: 0!To show the colored text:	(TextMorph new contents: (CLExecutionFormatter new format: (GPExamples>>#example) methodNode  ) ) openInWorld!!CLExecutionRemover methodsFor: 'visiting' stamp: 'pmm 4/28/2006 20:45'!visitNode: aNode	aNode resetExecutionCount.	^super visitNode: aNode! !!CLFormattingInfo methodsFor: 'accessing' stamp: 'pmm 4/30/2006 11:57'!pieces	^pieces! !!CLFormattingInfo methodsFor: 'accessing' stamp: 'pmm 4/30/2006 11:58'!pieces: aCollection 	pieces := aCollection! !!CLFormattingInfo methodsFor: 'accessing' stamp: 'pmm 4/30/2006 11:57'!start	^start! !!CLFormattingInfo methodsFor: 'accessing' stamp: 'pmm 4/30/2006 11:57'!start: anInteger 	start := anInteger! !!CLFormattingInfo methodsFor: 'accessing' stamp: 'pmm 4/30/2006 11:57'!string	^string! !!CLFormattingInfo methodsFor: 'accessing' stamp: 'pmm 4/30/2006 11:57'!string: aString 	string := aString! !!CLFormattingInfo class methodsFor: 'instance creation' stamp: 'pmm 4/30/2006 11:59'!start: anInteger string: aString pieces: aCollection	^self new		start: anInteger;		string: aString;		pieces: aCollection;		yourself! !!CLMethodInterpreter methodsFor: 'accessing' stamp: 'pmm 4/28/2006 19:57'!blockInterpreterClass	^CLBlockInterpreter! !!CLMethodInterpreter methodsFor: 'visiting' stamp: 'pmm 4/28/2006 20:45'!visitNode: aNode	aNode markExecuted.	^super visitNode: aNode! !!CapturedVar methodsFor: 'emitting' stamp: 'md 6/13/2005 14:01'!emitEnvStore: methodBuilder	self scope isDoItScope ifTrue: [self scope emitMyEnv: methodBuilder].	methodBuilder storeInstVar: self index! !!CapturedVar methodsFor: 'emitting' stamp: 'md 6/13/2005 13:58'!emitEnvValue: methodBuilder	self scope isDoItScope ifTrue: [self scope emitMyEnv: methodBuilder].	methodBuilder pushInstVar: self index.! !!CapturedVar methodsFor: 'emitting' stamp: 'md 3/10/2006 16:31'!emitLocalStore: methodBuilder	Preferences compileBlocksAsClosures ifTrue: [			self scope emitMyEnv: methodBuilder.		].	methodBuilder storeInstVar: self index.			! !!CapturedVar methodsFor: 'emitting' stamp: 'md 3/10/2006 16:31'!emitLocalValue: methodBuilder	Preferences compileBlocksAsClosures ifTrue: [			self scope emitMyEnv: methodBuilder.	].	methodBuilder pushInstVar: self index.! !!CapturedVar methodsFor: 'accessing' stamp: 'ajh 6/24/2004 15:15'!isCaptured	^ true! !!CapturedVar methodsFor: 'accessing' stamp: 'ajh 6/25/2004 22:18'!sourceTemp	^ sourceTemp! !!CapturedVar methodsFor: 'initializing' stamp: 'ajh 6/25/2004 22:18'!sourceTemp: tempVarOrNil	sourceTemp _ tempVarOrNil! !!CapturedVar commentStamp: 'ajh 3/24/2003 21:52' prior: 0!I'm a field var of some receiverVar.  if receiverVar is 'self' than I am an instance variable.  If receiverVar is a closure than I am a free variable (outer temp reference) and my outerVar is the outer reference var.!!CategoryAndClassSelector methodsFor: 'button actions' stamp: 'nk 2/25/2005 09:11'!accept	done := true! !!CategoryAndClassSelector methodsFor: 'button actions' stamp: 'nk 2/27/2005 13:38'!cancel	self deselectAll.	done := true! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 13:45'!categoryAndClassChooserMorph	^(Morph new)		color: Color transparent;		borderWidth: 0;		layoutPolicy: ProportionalLayout new;		addMorph: self classCategoryMorph			fullFrame: (LayoutFrame fractions: (0 @ 0 extent: 0.5 @ 1));		addMorph: self classMorph			fullFrame: (LayoutFrame fractions: (0.5 @ 0 extent: 0.5 @ 1));		yourself! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 13:45'!classCategoryMorph	^self listMorphFor: classCategories! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 13:45'!classMorph	^self listMorphFor: classes! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 15:02'!getClassEnvironmentFromUser	"Wait for the user to choose classes, then accept or cancel.	Answers a (possibly empty) ClassEnvironment."	| m |	m := self morphicDialog.	self runModal: ((SystemWindow labelled: 'Select classes')				model: self;				addMorph: m frame: (0 @ 0 corner: 1 @ 1);				yourself).	^self selectedClassEnvironment! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/25/2005 09:24'!getSelectorEnvironmentFromUser	^self getClassEnvironmentFromUser asSelectorEnvironment! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 13:41'!listMorphFor: aPluggableListOfManyArray 	^aPluggableListOfManyArray listMorph! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 15:49'!morphicDialog	| m |	m := AlignmentMorph newColumn.	m		extent: 400 @ 400;		borderWidth: 2;		color: Color white.	m addMorphBack: ((self categoryAndClassChooserMorph)				vResizing: #spaceFill;				hResizing: #spaceFill;				yourself).	m 		addMorphBack: (((AlignmentMorph inARow: { 						(SimpleButtonMorph newWithLabel: 'OK')							color: self defaultBackgroundColor darker;							cornerStyle: #square;							target: self;							actionSelector: #accept;							yourself.						m transparentSpacerOfSize: 40 @ 1.						(SimpleButtonMorph newWithLabel: 'Cancel')							color: self defaultBackgroundColor darker;							cornerStyle: #square;							target: self;							actionSelector: #cancel;							yourself})				hResizing: #spaceFill;				borderWidth: 0;				yourself)				listCentering: #center;				yourself).	^m! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 14:50'!runModal: m 	done := false.	World addMorph: m centeredNear: ActiveHand position.	m openInWorld.	[done] whileFalse: [World doOneCycle].	m delete.	World doOneCycle! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:30'!classCategoryMenuFor: aMenuMorph in: aMultipleSelectionModel 	| package category |	category := aMultipleSelectionModel selectedItem ifNil: [^aMenuMorph].	aMenuMorph 		add: 'Select category'		target: self		selector: #selectCategory:		argument: category.	package := self packageForSystemCategory: category.	package ifNotNil: 			[aMenuMorph 				add: 'Select package'				target: self				selector: #selectPackage:				argument: package].	^aMenuMorph! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:43'!classMenuFor: aMenuMorph in: aMultipleSelectionModel 	| package class |	class := aMultipleSelectionModel selectedItem ifNil: [^aMenuMorph].	aMenuMorph 		add: 'Select category'		target: self		selector: #selectCategory:		argument: (self class environment organization categoryOfElement: class).	package := self packageForClassNamed: class.	package ifNotNil: 			[aMenuMorph 				add: 'Select package'				target: self				selector: #selectPackage:				argument: package].	^aMenuMorph! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:43'!packageForClassNamed: aClass	^PackageInfo allPackages detect: [ :p | p includesClassNamed: aClass ]		ifNone: [ ^nil ].! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:30'!packageForSystemCategory: aClassCategory	^PackageInfo allPackages detect: [ :p | p includesSystemCategory: aClassCategory ]		ifNone: [ ^nil ].! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:50'!selectCategory: cat 	| classList |	classCategories listSelectionAt: (classCategories list indexOf: cat asString) put: true.	classList := classes list.	(SystemOrganization listAtCategoryNamed: cat) do: [ :clsName |		classes listSelectionAt: (classList indexOf: clsName asString) put: true	].! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:50'!selectPackage: aPackage 	classCategories list withIndexDo: 			[:catName :i | 			(aPackage includesSystemCategory: catName) 				ifTrue: 					[ self selectCategory: catName]]! !!CategoryAndClassSelector methodsFor: 'accessing' stamp: 'nk 2/27/2005 13:36'!classesFromCategories	^classCategories trueIndexes inject: SortedCollection new into:		[:partialList :each | partialList addAll: (SystemOrganization listAtCategoryNumber: each).		partialList].! !!CategoryAndClassSelector methodsFor: 'accessing' stamp: 'nk 3/1/2005 07:41'!defaultClassCategoriesModel	^(MultipleSelectionModel withModel: self		withList: SystemOrganization categories)		menuGetter: #classCategoryMenuFor:in:;		yourself! !!CategoryAndClassSelector methodsFor: 'accessing' stamp: 'nk 3/1/2005 07:42'!defaultClassesModel	^(MultipleSelectionModel 		withModel: self		withList: #()		withMessage: #classesFromCategories)		menuGetter: #classMenuFor:in:;		yourself! !!CategoryAndClassSelector methodsFor: 'accessing' stamp: 'nk 2/27/2005 13:37'!deselectAll	classes selectNone.! !!CategoryAndClassSelector methodsFor: 'accessing' stamp: 'nk 2/27/2005 13:37'!selectedClassEnvironment	| cls |	^ClassEnvironment new		classes: (Array streamContents: [ :s |			classes selectedItems do: [:clsName |				cls := Smalltalk at: clsName.				s nextPut: cls; nextPut: cls class ]]);		yourself! !!CategoryAndClassSelector methodsFor: 'initialize-release' stamp: 'nk 2/27/2005 13:37'!initialize	done := false.	classCategories := self defaultClassCategoriesModel.	classCategories addDependent: self.	classes := self defaultClassesModel.	self addDependent: classes! !!CategoryAndClassSelector methodsFor: 'updating' stamp: 'nk 2/27/2005 14:18'!update: aSelector	self changed: #classesFromCategories! !!CategoryAndClassSelector class methodsFor: 'dialogs' stamp: 'nk 2/27/2005 14:11'!getClassEnvironmentFromUser	"	CategoryAndClassSelector getClassEnvironmentFromUser	"	^self new getClassEnvironmentFromUser! !!CategoryAndClassSelector class methodsFor: 'dialogs' stamp: 'nk 2/27/2005 14:09'!getSelectorEnvironmentFromUser	"	CategoryAndClassSelector getSelectorEnvironmentFromUser	"	^self new getSelectorEnvironmentFromUser! !!CategoryAndClassSelector class methodsFor: 'dialogs' stamp: 'nk 2/27/2005 15:03'!windowColorSpecification	^  WindowColorSpec classSymbol: self name  wording: 'Class chooser' brightColor: #lightGreen pastelColor: #paleGreen helpMessage: 'A dialog to select classes'! !!CategoryEnvironment methodsFor: 'accessing'!categories	^categories select: [:each | self includesCategory: each]! !!CategoryEnvironment methodsFor: 'accessing'!numberSelectors	| total |	total := 0.	self 		classesDo: [:each | self selectorsForClass: each do: [:sel | total := total + 1]].	^total! !!CategoryEnvironment methodsFor: 'initialize-release'!categories: aCollection	categories := aCollection! !!CategoryEnvironment methodsFor: 'initialize-release'!initialize	super initialize.	categories := Set new! !!CategoryEnvironment methodsFor: 'accessing-classes'!classNames	^self categories inject: OrderedCollection new into: [:col :each | col addAll: (self classNamesFor: each); yourself]! !!CategoryEnvironment methodsFor: 'private'!defaultLabel	| stream |	stream := String new writeStream.	categories do: [:each | stream nextPutAll: each; nextPut: $ ].	^stream contents! !!CategoryEnvironment methodsFor: 'testing'!includesCategory: aCategory	^(categories includes: aCategory)		and: [super includesCategory: aCategory]! !!CategoryEnvironment methodsFor: 'testing'!includesClass: aClass 	^(super includesClass: aClass) and: 			[| nonMetaClass |			nonMetaClass := aClass isMeta 						ifTrue: [aClass soleInstance]						ifFalse: [aClass].			categories 				includes: (environment whichCategoryIncludes: nonMetaClass name)]! !!CategoryEnvironment methodsFor: 'testing'!isEmpty	^categories isEmpty! !!CategoryEnvironment methodsFor: 'as yet unclassified' stamp: 'nk 3/4/2005 12:43'!openEditor	^(ClassEnvironment onEnvironment: self classes: self classes) openEditor! !!CategoryEnvironment methodsFor: 'copying'!postCopy	categories := categories copy.	^super postCopy! !!CategoryEnvironment methodsFor: 'printing'!storeOn: aStream	aStream nextPut: $(.	super storeOn: aStream.	aStream nextPutAll: ' categories: '.	categories asArray storeOn: aStream.	aStream nextPut: $)! !!CategoryEnvironment class methodsFor: 'instance creation'!onEnvironment: anEnvironment categories: aCollection	^(self onEnvironment: anEnvironment)		categories: aCollection; yourself! !!ChangeMethodNameRefactoring methodsFor: 'testing'!hasPermutedArguments	oldSelector numArgs = newSelector numArgs ifFalse: [^true].	1 to: oldSelector numArgs		do: [:i | (permutation at: i) = i ifFalse: [^true]].	^false! !!ChangeMethodNameRefactoring methodsFor: 'testing'!implementorsCanBePrimitives	^false! !!ChangeMethodNameRefactoring methodsFor: 'private'!implementors	implementors isNil 		ifTrue: [implementors := self model allImplementorsOf: oldSelector].	^implementors! !!ChangeMethodNameRefactoring methodsFor: 'private'!modifyImplementorParseTree: parseTree in: aClass 	| oldArgs |	oldArgs := parseTree arguments.	parseTree arguments: (permutation collect: [:each | oldArgs at: each]).	parseTree selector: newSelector! !!ChangeMethodNameRefactoring methodsFor: 'private'!parseTreeRewriter	| rewriteRule oldString newString |	rewriteRule := ParseTreeRewriter new.	oldString := self buildSelectorString: oldSelector.	newString := self buildSelectorString: newSelector				withPermuteMap: permutation.	rewriteRule replace: '``@object ' , oldString		with: '``@object ' , newString.	^rewriteRule! !!ChangeMethodNameRefactoring methodsFor: 'preconditions'!myConditions	^self subclassResponsibility! !!ChangeMethodNameRefactoring methodsFor: 'preconditions'!preconditions	"This refactoring only preserves behavior if all implementors are renamed."	| conditions |	conditions := self myConditions 				& (RBCondition definesSelector: oldSelector in: class) 					& (RBCondition isValidMethodName: newSelector for: class).	conditions := self implementors inject: conditions				into: 					[:condition :each | 					condition & (RBCondition hierarchyOf: each canUnderstand: newSelector) not].	^conditions 		& (RBCondition withBlock: 					[self implementors size > 1 						ifTrue: 							[self refactoringWarning: ('This will modify all <1p> implementors.' 										expandMacrosWith: self implementors size)].					true])! !!ChangeMethodNameRefactoring methodsFor: 'accessing'!newSelector	^newSelector! !!ChangeMethodNameRefactoring methodsFor: 'transforming'!removeRenamedImplementors	self implementors do: [:each | each removeMethod: oldSelector]! !!ChangeMethodNameRefactoring methodsFor: 'transforming'!renameImplementors	self implementors do: 			[:each | 			| parseTree |			parseTree := each parseTreeFor: oldSelector.			parseTree isNil 				ifTrue: [self refactoringError: 'Could not parse source code.'].			self implementorsCanBePrimitives 				ifFalse: 					[parseTree isPrimitive 						ifTrue: 							[self refactoringError: ('<1p>''s implementation of #<2s> is a primitive' 										expandMacrosWith: each										with: oldSelector)]].			self modifyImplementorParseTree: parseTree in: each.			each compileTree: parseTree classified: (each protocolsFor: oldSelector)]! !!ChangeMethodNameRefactoring methodsFor: 'transforming'!renameMessageSends	self convertAllReferencesTo: oldSelector using: self parseTreeRewriter! !!ChangeMethodNameRefactoring methodsFor: 'transforming'!transform	self renameImplementors.	self renameMessageSends.	oldSelector == newSelector ifTrue: [^self].	self removeRenamedImplementors! !!ChangeMethodNameRefactoring methodsFor: 'initialize-release' stamp: 'md 3/15/2006 17:27'!renameMethod: aSelector in: aClass to: newSel permutation: aMap 	oldSelector := aSelector asSymbol.	newSelector := newSel asSymbol.	class := self classObjectFor: aClass.	permutation := aMap! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/17/2006 22:26'!event: anEvent	"Hook for SystemChangeNotifier"	anEvent itemKind = SystemChangeNotifier classKind ifTrue: [		anEvent isRemoved 			ifTrue: [self noteRemovalOf: anEvent item].		anEvent isAdded 			ifTrue: [self addClass: anEvent item].		anEvent isModified 			ifTrue: [anEvent anyChanges ifTrue: [self changeClass: anEvent item from: anEvent oldItem]].		anEvent isCommented 			ifTrue: [self commentClass: anEvent item].		anEvent isRenamed 			ifTrue: [self renameClass: anEvent item from: anEvent oldName to: anEvent newName].		anEvent isReorganized			ifTrue: [self reorganizeClass: anEvent item].		anEvent isRecategorized			ifTrue: [self changeClass: anEvent item from: anEvent item].	].	anEvent itemKind = SystemChangeNotifier methodKind ifTrue: [		anEvent isAdded			ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: nil].		anEvent isModified			ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: anEvent oldItem].		anEvent isRemoved			ifTrue: [self removeSelector: anEvent itemSelector class: anEvent itemClass priorMethod: anEvent item lastMethodInfo: {anEvent item sourcePointer. anEvent itemProtocol}].		anEvent isRecategorized			ifTrue: [self reorganizeClass: anEvent itemClass].	].! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/19/2006 17:52'!renameClass: class from: oldName to: newName 	"Include indication that a class has been renamed."	| recorder oldMetaClassName newMetaClassName |	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet renameClass: class as: newName].	(recorder _ self changeRecorderFor: oldName)		noteChangeType: #rename;		noteNewName: newName asSymbol.			"store under new name (metaclass too)"	changeRecords at: newName put: recorder.	changeRecords removeKey: oldName.	self noteClassStructure: class.	newMetaClassName := newName, ' class'.	oldMetaClassName := oldName, ' class'.	recorder _ changeRecords at: oldMetaClassName ifAbsent: [^ nil].	changeRecords at: newMetaClassName put: recorder.	changeRecords removeKey: oldMetaClassName.	recorder noteNewName: newMetaClassName! !!ChangeSet class methodsFor: 'current changeset' stamp: 'wiz 9/19/2006 03:21'!current	"return the current changeset	assure first that we have a named changeset. To cure mantis #4535. "	current isMoribund		ifTrue: [(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed'))] .	^ current! !!ChangeSet class methodsFor: 'current changeset' stamp: 'sd 9/8/2006 21:05'!resetCurrentToNewUnnamedChangeSet 	current := self new.  	self newChanges: current ! !!ChangeSetClassChangesTest methodsFor: 'testing' stamp: 'wiz 8/13/2006 17:55'!testInitialChangeSet	"Run this to assure the initial changeset is named. Checks bug found in 3.9 7052."	"self new testInitialChangeSet"	"self run:  #testInitialChangeSet"	self deny: (ChangeSet current printString = 'a ChangeSet named <no name -- garbage?>') .	^true! !!Character methodsFor: '*network-IRC-Model' stamp: 'ls 9/5/1998 01:18'!asIRCLowercase	"convert to lowercase, using IRC's rules"	self == $[ ifTrue: [ ^ ${ ].	self == $] ifTrue: [ ^ $} ].	self == $\ ifTrue: [ ^ $| ].	^self asLowercase! !!ChildrenToSiblingsRefactoring methodsFor: 'private-accessing'!abstractSuperclass	^self model classNamed: className asSymbol! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!addSuperclass	self performComponentRefactoring: (AddClassRefactoring 				model: self model				addClass: className				superclass: parent superclass				subclasses: (Array with: parent)				category: parent category)! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!changeIsKindOfReferences	| replacer |	replacer := ParseTreeRewriter new.	replacer replace: '``@object isKindOf: ' , parent name		with: '``@object isKindOf: ' , className.	self convertAllReferencesToClass: parent using: replacer! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!pushUpMethods	self pushUpMethodsFrom: parent.	self pushUpMethodsFrom: parent metaclass! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!pushUpVariables	self pullUpInstanceVariables.	self pullUpClassInstanceVariables.	self pullUpClassVariables.	self pullUpPoolVariables! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!reparentSubclasses	self model reparentClasses: subclasses to: self abstractSuperclass! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!transform	self		addSuperclass;		pushUpVariables;		pushUpMethods;		changeIsKindOfReferences;		reparentSubclasses! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!computeSubclassSupersOf: aClass 	| selectors |	selectors := Set new.	aClass subclasses do: 			[:each | 			each selectors 				do: [:sel | selectors addAll: (each parseTreeFor: sel) superMessages]].	^selectors! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!createSubclassResponsibilityFor: aSelector in: aClass 	| source |	(aClass superclass definesMethod: aSelector) ifTrue: [^self].	source := self subclassResponsibilityFor: aSelector in: aClass.	source isNil ifTrue: [^self].	aClass superclass compile: source		classified: (aClass protocolsFor: aSelector)! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!pushUp: aSelector in: aClass 	| source |	source := aClass sourceCodeFor: aSelector.	source isNil 		ifFalse: 			[aClass superclass compile: source				classified: (aClass protocolsFor: aSelector)]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!pushUpMethodsFrom: aClass 	| selectorsToPushUp |	selectorsToPushUp := self selectorsToPushUpFrom: aClass.	aClass selectors do: 			[:each | 			(selectorsToPushUp includes: each) 				ifTrue: [self pushUp: each in: aClass]				ifFalse: [self createSubclassResponsibilityFor: each in: aClass]].	selectorsToPushUp do: [:each | aClass removeMethod: each]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!selectorsToPushUpFrom: aClass 	| superSelectors |	superSelectors := self computeSubclassSupersOf: aClass.	^aClass selectors select: 			[:each | 			(superSelectors includes: each) or: [self shouldPushUp: each from: aClass]]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!shouldPushUp: aSelector from: aClass 	^((aClass isMeta 		ifTrue: [subclasses collect: [:each | each metaclass]]		ifFalse: [subclasses]) 			detect: [:each | (each directlyDefinesMethod: aSelector) not]			ifNone: [nil]) notNil! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!subclassResponsibilityFor: aSelector in: aClass 	| methodNode position source |	source := aClass sourceCodeFor: aSelector.	methodNode := RBParser parseMethod: source onError: [:err :pos | ^nil].	position := methodNode arguments isEmpty 				ifTrue: [methodNode selectorParts last stop]				ifFalse: [methodNode arguments last stop].	^'<1s><n><t>self subclassResponsibility' 		expandMacrosWith: (source copyFrom: 1 to: position)! !!ChildrenToSiblingsRefactoring methodsFor: 'initialize-release'!name: aClassName class: aClass subclasses: subclassCollection 	className := aClassName asSymbol.	parent := self model classFor: aClass.	subclasses := subclassCollection 				collect: [:each | self model classFor: each]! !!ChildrenToSiblingsRefactoring methodsFor: 'preconditions'!preconditions	^subclasses 		inject: ((RBCondition isMetaclass: parent) 				errorMacro: 'Superclass must not be a metaclass') not 				& (RBCondition isValidClassName: className) 					& (RBCondition isGlobal: className in: self model) not		into: 			[:sub :each | 			sub 				& ((RBCondition isMetaclass: each) 						errorMacro: 'Subclass must <1?not :>be a metaclass') not 					& (RBCondition isImmediateSubclass: each of: parent)]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-variables'!pullUpClassInstanceVariables	| newSuperclass |	newSuperclass := self abstractSuperclass metaclass.	parent metaclass instanceVariableNames do: 			[:each | 			self performComponentRefactoring: (PullUpInstanceVariableRefactoring 						model: self model						variable: each						class: newSuperclass)]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-variables'!pullUpClassVariables	| newSuperclass |	newSuperclass := self abstractSuperclass.	parent classVariableNames do: 			[:each | 			self performComponentRefactoring: (PullUpClassVariableRefactoring 						model: self model						variable: each						class: newSuperclass)]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-variables'!pullUpInstanceVariables	| newSuperclass |	newSuperclass := self abstractSuperclass.	parent instanceVariableNames do: 			[:each | 			self performComponentRefactoring: (PullUpInstanceVariableRefactoring 						model: self model						variable: each						class: newSuperclass)]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-variables'!pullUpPoolVariables	"Don't remove the pool variables from the subclass since they might be referenced there."	| newSuperclass |	newSuperclass := self abstractSuperclass.	parent poolDictionaryNames 		do: [:each | newSuperclass addPoolDictionary: each]! !!ChildrenToSiblingsRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' name: #';		nextPutAll: className;		nextPutAll: ' class: '.	parent storeOn: aStream.	aStream nextPutAll: ' subclasses: '.	subclasses asArray storeOn: aStream.	aStream nextPut: $)! !!ChildrenToSiblingsRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk name: aClassName class: aClass subclasses: subclassCollection 	^(self new)		model: aRBSmalltalk;		name: aClassName			class: aClass			subclasses: subclassCollection;		yourself! !!ChildrenToSiblingsRefactoring class methodsFor: 'instance creation'!name: aClassName class: aClass subclasses: subclassCollection 	^(self new)		name: aClassName			class: aClass			subclasses: subclassCollection;		yourself! !!ChildrenToSiblingsTest methodsFor: 'set up' stamp: 'md 7/25/2005 18:08'!setUp	super setUp.	model :=  Compiler evaluate: self childrenToSiblingTestData.! !!ChildrenToSiblingsTest methodsFor: 'failure tests'!testBadName	self shouldFail: (ChildrenToSiblingsRefactoring 				name: #'Obje ct'				class: LintRuleTest				subclasses: (Array with: BasicLintRuleTest with: CompositeLintRuleTest))! !!ChildrenToSiblingsTest methodsFor: 'failure tests'!testExistingName	self		shouldFail: (ChildrenToSiblingsRefactoring 					name: #Object					class: LintRuleTest					subclasses: (Array with: BasicLintRuleTest with: CompositeLintRuleTest));		shouldFail: (ChildrenToSiblingsRefactoring 					name: #Processor					class: LintRuleTest					subclasses: (Array with: BasicLintRuleTest with: CompositeLintRuleTest))! !!ChildrenToSiblingsTest methodsFor: 'failure tests'!testInvalidSubclass	self shouldFail: (ChildrenToSiblingsRefactoring 				name: #Foo				class: LintRuleTest				subclasses: (Array with: BasicLintRule with: CompositeLintRule))! !!ChildrenToSiblingsTest methodsFor: 'failure tests'!testMetaClassFailure	self shouldFail: (ChildrenToSiblingsRefactoring 				name: #Foo				class: LintRuleTest class				subclasses: (Array with: BasicLintRuleTest class						with: CompositeLintRuleTest class))! !!ChildrenToSiblingsTest methodsFor: 'tests'!testModelChildrenToSibling	| refactoring class subclass superclass |	class := model classNamed: #ConcreteSuperclass.	subclass := model classNamed: #ConcreteSubclass.	refactoring := ChildrenToSiblingsRefactoring 				model: model				name: #AbstractSuperclass				class: class				subclasses: (Array with: subclass).	self executeRefactoring: refactoring.	superclass := refactoring model classNamed: #AbstractSuperclass.	self assert: class superclass = superclass.	self assert: class metaclass superclass = superclass metaclass.	self assert: subclass superclass = superclass.	self assert: subclass metaclass superclass = superclass metaclass.	self 		assert: (superclass parseTreeFor: #same) = (RBParser 						parseMethod: 'same ^self initialize isKindOf: AbstractSuperclass').	self assert: (superclass parseTreeFor: #different) 				= (RBParser parseMethod: 'different self subclassResponsibility').	self 		assert: (superclass parseTreeFor: #initialize) = (RBParser 						parseMethod: 'initialize							instVarName1 := instVarName2 := ClassVarName1 := ClassVarName2 := 0').	self assert: (superclass directlyDefinesInstanceVariable: 'instVarName1').	self assert: (superclass directlyDefinesInstanceVariable: 'instVarName2').	self assert: (superclass directlyDefinesClassVariable: 'ClassVarName1').	self assert: (superclass directlyDefinesClassVariable: 'ClassVarName2').	self assert: (superclass metaclass 				directlyDefinesInstanceVariable: 'classInstVarName1').	self 		assert: (superclass metaclass parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo							^classInstVarName1 + ClassVarName1 + ClassVarName2').	self assert: (superclass metaclass parseTreeFor: #new) 				= (RBParser parseMethod: 'new							^super new initialize').	self assert: (superclass metaclass parseTreeFor: #bar) 				= (RBParser parseMethod: 'bar							self subclassResponsibility').	self deny: (class directlyDefinesInstanceVariable: 'instVarName1').	self deny: (class directlyDefinesInstanceVariable: 'instVarName2').	self deny: (class directlyDefinesClassVariable: 'ClassVarName1').	self deny: (class directlyDefinesClassVariable: 'ClassVarName2').	self 		deny: (class metaclass directlyDefinesInstanceVariable: 'classInstVarName1').	self deny: (class directlyDefinesMethod: #same).	self deny: (class directlyDefinesMethod: #initialize).	self deny: (class metaclass directlyDefinesMethod: #new).	self assert: (class parseTreeFor: #different) 				= (RBParser parseMethod: 'different							^instVarName1 + instVarName2').	self assert: (class metaclass parseTreeFor: #bar) 				= (RBParser parseMethod: 'bar							^self printString')! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/30/2001 02:08'!accept	response := OrderedCollection new.	listSelections 		doWithIndex: [:selection :index | selection ifTrue: [response add: (values at: index)]].	response := response asArray.	isMultipleSelect 		ifFalse: [response := response ifEmpty: [nil] ifNotEmpty: [:col | col first]].	done := true! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/8/2001 02:13'!addButtonRow	| b spacer buttonRow |	b := SimpleButtonMorph new target: self; color: Color veryLightGray.	spacer := AlignmentMorph newSpacer: self color.	buttonRow := AlignmentMorph newRow		borderWidth: 1;		color: self color;		width: self innerBounds width;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		position: self innerBounds left@self lastSubmorph bottom.	buttonRow		addMorphBack: spacer fullCopy;		addMorphBack: (b fullCopy label: 'OK'; actionSelector: #accept);		addMorphBack: spacer fullCopy;		addMorphBack: (b fullCopy label: 'Cancel'; actionSelector: #cancel);		addMorphBack: spacer fullCopy.	self addMorphBack: buttonRow.! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/8/2001 02:12'!addLabel: queryString	| lines queryMorph |	lines := queryString asString findTokens: String cr.	queryMorph := AlignmentMorph newColumn		borderWidth: 1;		color: self color;		width: self innerBounds width;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		position: self innerBounds topLeft.	lines do: [:s | queryMorph addMorphBack: (StringMorph contents: s)].	self addMorph: queryMorph.! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:29'!addLine	| line |	line := RectangleMorph new color: Color black;		extent: self width@borderWidth;		position: self left@self lastSubmorph bottom.	self addMorphBack: line.! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:30'!cancel	response := cancelBlock value.	done := true.! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/8/2001 15:25'!choose: messageString multipleSelect: multiSelectBoolean fromList: listCollection values: listValues cancel: aBlock 	^self 		choose: messageString		multipleSelect: multiSelectBoolean		fromList: listCollection		values: listValues		cancel: aBlock		initialSelections: #()! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/30/2001 01:57'!choose: messageString multipleSelect: multiSelectBoolean fromList: listCollection values: listValues cancel: aBlock initialSelections: initialSelectionCollection 	isMultipleSelect := multiSelectBoolean.	listSelections := listCollection collect: [:each | false].	values := listValues.	list := listCollection collect: [:each | each asString].	cancelBlock := aBlock.	done := false.	self openShowing: messageString.	self setInitialSelections: initialSelectionCollection.	^self getUserResponse! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/30/2001 01:58'!getUserResponse	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."	| w |	w := self world.	w ifNil: [^response].	done := false.	[done] whileFalse: [w doOneCycle].	self delete.	w doOneCycle.	^response! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:31'!list	^ list! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 08:07'!listIndex	^ listIndex! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:31'!listSelectionAt: anInteger	^listSelections at: anInteger.! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 08:03'!listSelectionAt: anInteger put: aBoolean	listSelections at: anInteger put: aBoolean.	self changed: #listSelectionAt:! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 08:35'!openShowing: messageString 	| listPane |	self removeAllMorphs.	listIndex := 0.	self addLabel: messageString.	self width: (self width max: self firstSubmorph width + (2 * borderWidth)).	listPane := isMultipleSelect 				ifTrue: 					[PluggableListMorphOfMany 						on: self						list: #list						primarySelection: #listIndex						changePrimarySelection: #toggleListIndex:						listSelection: #listSelectionAt:						changeListSelection: #listSelectionAt:put:						menu: nil						keystroke: nil]				ifFalse: 					[PluggableListMorph 						on: self						list: #list						selected: #listIndex						changeSelected: #toggleListIndex:						menu: nil						keystroke: nil].	listPane		color: self color;		hResizing: #spaceFill; vResizing: #spaceFill;		position: self innerBounds left @ self lastSubmorph bottom.	self addMorphBack: listPane.	self addButtonRow.	self height: ((((self list size * listPane font height) + submorphs first height + submorphs last height) min: Display height * 2 / 3) max: 100).	World addMorph: self centeredNear: ActiveHand position! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:32'!response	^ response! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:32'!response: aText	"Sent when text pane accepts."	response := aText asString.	done := true.	^ true! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 08:09'!setInitialSelections: aCollection 	list 		doWithIndex: [:item :index | self listSelectionAt: index put: (aCollection includes: item)].	listIndex := 0.	self changed: #listIndex.	self changed: #listIndexAt:! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 08:08'!toggleListIndex: newListIndex	newListIndex isZero ifFalse: [		listSelections at: newListIndex put: (listSelections at: newListIndex) not.		self changed: #listSelectionAt: ].	listIndex := newListIndex.	self changed: #listIndex.! !!ChooserMorph methodsFor: 'accessing' stamp: 'bh 11/8/2000 16:30'!color	^Color white.! !!ChooserMorph methodsFor: 'submorphs-add/remove' stamp: 'bh 11/8/2000 16:30'!delete	self breakDependents.	^ super delete! !!ChooserMorph methodsFor: 'initialization' stamp: 'nk 2/25/2005 08:33'!initialize	super initialize.	self borderWidth: 0.	self layoutPolicy: TableLayout new.	self		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	self color: Color black.	self		layoutInset: 1;		cellInset: 0.	self extent: 200 @ 200.	listIndex := 0.! !!ChooserMorph class methodsFor: 'as yet unclassified' stamp: 'dvf 9/8/2001 15:25'!choose: messageString multipleSelect: multiSelectBoolean fromList: listCollection values: listValues cancel: aBlock 	^self 		choose: messageString		multipleSelect: multiSelectBoolean		fromList: listCollection		values: listValues		cancel: aBlock		initialSelections: #()! !!ChooserMorph class methodsFor: 'as yet unclassified' stamp: 'dvf 9/8/2001 15:24'!choose: messageString multipleSelect: multiSelectBoolean fromList: listCollection values: listValues cancel: aBlock initialSelections: initialSelectionCollection 	^self new 		choose: messageString		multipleSelect: multiSelectBoolean		fromList: listCollection		values: listValues		cancel: aBlock		initialSelections: initialSelectionCollection! !!Class methodsFor: 'class name' stamp: 'rw 10/7/2006 08:30'!rename: aString 	"The new name of the receiver is the argument, aString."	| oldName newName |	(newName _ aString asSymbol) = (oldName _ self name)		ifTrue: [^ self].	(self environment includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	name _ newName.	self environment renameClass: self from: oldName! !!Class methodsFor: '*persephone' stamp: 'md 10/1/2007 15:26'!asLiteralNode	"self name asString asVariableNode"	^PEObjectLiteralNode value: self.! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 23:37'!chooseClassVarAlphabeticallyThenDo: aBlock	| allVars index |	allVars := self allClassVarNames asSortedArray.	allVars isEmpty ifTrue: [^ self inform: 'There are noclass variables'].	index := (PopUpMenu labelArray: allVars lines: #()) startUpWithCaption: 'Class variables in', self name.	index = 0 ifTrue: [^ self].	aBlock value: (allVars at: index)! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 23:36'!chooseClassVarThenDo: aBlock 	| lines labelStream vars allVars index count offerAlpha |	(count := self allClassVarNames size) = 0 ifTrue: 		[^ self inform: 'There are noclass variables.'].	allVars := OrderedCollection new.	lines := OrderedCollection new.	labelStream := WriteStream on: (String new: 200).	(offerAlpha := count > 5)		ifTrue:			[lines add: 1.			allVars add: 'show alphabetically'.			labelStream nextPutAll: allVars first; cr].	self withAllSuperclasses reverseDo:		[:class |		vars := class classVarNames.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream skip: -1 "cut last CR".	(lines size > 0 and: [lines last = allVars size]) ifTrue:		[lines removeLast].  "dispense with inelegant line beneath last item"	index := (PopUpMenu labels: labelStream contents lines: lines)startUpWithCaption: 'Class variables in', self name.	index = 0 ifTrue: [^ self].	(index = 1 and: [offerAlpha]) ifTrue: [^ selfchooseClassVarAlphabeticallyThenDo: aBlock].	aBlock value: (allVars at: index)! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 23:38'!chooseSubclassesClassVarThenDo: aBlock 	| allVars index labelStream |	allVars := self allSubclasses inject:SortedCollection new into:		[:answer :each|		answer addAll:each classVarNames; yourself.].	allVars isEmpty ifTrue:[^self inform: 'There are no class variables in subclasses.'].	labelStream := WriteStream on: (String new: 200).	allVars do: [:var| labelStream nextPutAll:var;cr].		index := (PopUpMenu labels: labelStream contents lines: #()) startUpWithCaption: 'Select class variable:'.	index = 0 ifTrue: [^ self].	aBlock value:(allVars at: index).! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 22:25'!chooseSubclassesInstVarThenDo: aBlock 	"Put up a menu of all the instance variables in the receiver, and whenthe user chooses one, evaluate aBlock with the chosen variable as itsparameter.  If the list is 6 or larger, then offer an alphabeticalformulation as an alternative. triggered by a 'show alphabetically' itemat the top of the list."	| allVars index labelStream |	allVars := self allSubclasses inject:SortedCollection new into:		[:answer :each|		answer addAll:each instVarNames; yourself.].	allVars isEmpty ifTrue:[^self inform: 'There are no instance variables in subclasses.'].	labelStream := WriteStream on: (String new: 200).	allVars do: [:var| labelStream nextPutAll:var;cr].		index := (PopUpMenu labels: labelStream contents lines: #()) startUpWithCaption: 'Select instance variable:'.	index = 0 ifTrue: [^ self].	aBlock value:(allVars at: index).! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 23:39'!chooseThisClassClassVarThenDo: aBlock 	| allVars index labelStream |	allVars := self classVarNames asSortedCollection.	allVars isEmpty ifTrue:[^self inform: 'There are no class variables.'].	labelStream := WriteStream on: (String new: 200).	allVars do: [:var| labelStream nextPutAll:var;cr].		index := (PopUpMenu labels: labelStream contents lines: #()) startUpWithCaption: 'Select class variable:'.	index = 0 ifTrue: [^ self].	aBlock value:(allVars at: index).! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 22:45'!chooseThisClassInstVarThenDo: aBlock 	"Put up a menu of all the instance variables in the receiver, and whenthe user chooses one, evaluate aBlock with the chosen variable as itsparameter.  If the list is 6 or larger, then offer an alphabeticalformulation as an alternative. triggered by a 'show alphabetically' itemat the top of the list."	| allVars index labelStream |	allVars := self instVarNames asSortedCollection.	allVars isEmpty ifTrue:[^self inform: 'There are no instance variables.'].	labelStream := WriteStream on: (String new: 200).	allVars do: [:var| labelStream nextPutAll:var;cr].		index := (PopUpMenu labels: labelStream contents lines: #()) startUpWithCaption: 'Select instance variable:'.	index = 0 ifTrue: [^ self].	aBlock value:(allVars at: index).! !!ClassDescription methodsFor: '*persephone' stamp: 'md 3/5/2007 15:44'!methods	^methodDict values! !!ClassEnvironment methodsFor: 'adding'!addClass: aClass 	aClass isMeta		ifTrue: [metaClasses add: aClass soleInstance name]		ifFalse: [classes add: aClass name]! !!ClassEnvironment methodsFor: 'accessing' stamp: 'bh 6/10/2000 17:05'!asSelectorEnvironment	^SelectorEnvironment new		searchStrings:#();		label:self label;		onEnvironment: self environment;		classSelectors: self classSelectorDictionary metaClassSelectors: self metaClassSelectorDictionary;		yourself.! !!ClassEnvironment methodsFor: 'accessing'!problemCount	^self numberClasses! !!ClassEnvironment methodsFor: 'accessing-classes'!classNames	^(Set withAll: classes) addAll: metaClasses;		yourself! !!ClassEnvironment methodsFor: 'accessing-classes'!classesDo: aBlock 	classes		do: 			[:each | 			| class |			class := Smalltalk at: each ifAbsent: [nil].			(class notNil and: [environment includesClass: class])				ifTrue: [aBlock value: class]].	metaClasses		do: 			[:each | 			| class |			class := Smalltalk at: each ifAbsent: [nil].			(class notNil and: [environment includesClass: class class])				ifTrue: [aBlock value: class class]]! !!ClassEnvironment methodsFor: 'printing' stamp: 'bh 6/10/2000 17:39'!classSelectorDictionary	^classes inject:Dictionary new into:		[:answer :class |		answer at:class put:(Smalltalk at:class) selectors;			yourself].	! !!ClassEnvironment methodsFor: 'printing' stamp: 'bh 4/29/2000 17:53'!logOrInspect	Transcript cr; cr; show:self name.	(classes asArray, metaClasses asArray) asSet do: 		[:class | 		Transcript cr; show: '     ',class asString].! !!ClassEnvironment methodsFor: 'printing' stamp: 'bh 6/10/2000 17:39'!metaClassSelectorDictionary	^metaClasses inject:Dictionary new into:		[:answer :class |		answer at:class put:(Smalltalk at:class) class selectors;			yourself].	! !!ClassEnvironment methodsFor: 'printing'!storeOn: aStream	aStream nextPut: $(.	super storeOn: aStream.	aStream nextPutAll: ' classes: (('.	classes asArray storeOn: aStream.	aStream nextPutAll: ' inject: OrderedCollection new into: [:sum :each | 				| class |				class := Smalltalk at: each ifAbsent: [nil].				class notNil ifTrue: [sum add: class].				sum]) , ('.	metaClasses asArray storeOn: aStream.	aStream nextPutAll: ' inject: OrderedCollection new into: [:sum :each | 				| class |				class := Smalltalk at: each ifAbsent: [nil].				class notNil ifTrue: [sum add: class class].				sum])))'! !!ClassEnvironment methodsFor: 'initialize-release'!classes: aCollection 	aCollection do: [:each | self addClass: each]! !!ClassEnvironment methodsFor: 'initialize-release'!initialize	super initialize.	classes := Set new.	metaClasses := Set new! !!ClassEnvironment methodsFor: 'private'!defaultLabel	| stream |	stream := String new writeStream.	classes do: 			[:each | 			stream nextPutAll: each;				nextPut: $ ].	^stream contents! !!ClassEnvironment methodsFor: 'testing'!includesCategory: aCategory	^(super includesCategory: aCategory)		and: [(environment classNamesFor: aCategory)				inject: false into: [:bool :each | bool					or:						[| class |						class := Smalltalk at: each ifAbsent: [nil].						class notNil and: [(self includesClass: class)								or: [self includesClass: class class]]]]]! !!ClassEnvironment methodsFor: 'testing'!includesClass: aClass 	^(aClass isMeta		ifTrue: [metaClasses includes: aClass soleInstance name]		ifFalse: [classes includes: aClass name])			and: [super includesClass: aClass]! !!ClassEnvironment methodsFor: 'testing'!isClassEnvironment	^true! !!ClassEnvironment methodsFor: 'testing'!isEmpty	^classes isEmpty and: [metaClasses isEmpty]! !!ClassEnvironment methodsFor: '*RefactoringEngine' stamp: 'dvf 10/3/2001 01:32'!openEditor	^(ClassEnvironmentBrowser openOnEnvironment: self) openInWorld.! !!ClassEnvironment methodsFor: 'copying'!postCopy	classes := classes copy.	metaClasses := metaClasses copy.	^super postCopy! !!ClassEnvironment methodsFor: 'removing'!removeClass: aClass 	aClass isMeta		ifTrue: [metaClasses remove: aClass soleInstance name ifAbsent: []]		ifFalse: [classes remove: aClass name ifAbsent: []]! !!ClassEnvironment class methodsFor: 'instance creation'!onEnvironment: anEnvironment classes: aCollection	^(self onEnvironment: anEnvironment)		classes: aCollection; yourself! !!ClassEnvironmentBrowser methodsFor: 'initialize-release' stamp: 'nk 3/4/2005 10:27'!initializeOnEnvironment: aBrowserEnvironment 	super initializeOnEnvironment: aBrowserEnvironment asSelectorEnvironment! !!ClassRefactoring methodsFor: 'initialize-release'!className: aName	className := aName! !!ClassRefactoring class methodsFor: 'instance creation'!className: aName	^self new className: aName! !!ClassRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk className: aName 	^(self new)		model: aRBSmalltalk;		className: aName;		yourself! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'cmm 8/7/2005 18:20'!setUp	previousChangeSet := ChangeSet current.	testsChangeSet := ChangeSet new.	ChangeSet newChanges: testsChangeSet.	SystemChangeNotifier uniqueInstance		notify: self		ofSystemChangesOfItem: #class		change: #Renamed		using: #verifyRenameEvent:.	super setUp! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'cmm 8/7/2005 18:21'!tearDown	self removeEverythingInSetFromSystem: testsChangeSet.	ChangeSet newChanges: previousChangeSet.	ChangeSorter removeChangeSet: testsChangeSet.	previousChangeSet := nil.	testsChangeSet := nil.	SystemChangeNotifier uniqueInstance noMoreNotificationsFor: self.	super tearDown.! !!ClassRenameFixTest methodsFor: 'Tests' stamp: 'cmm 8/7/2005 18:21'!renameClassUsing: aBlock	| createdClass foundClasses |	originalName := self newUniqueClassName.	createdClass := Object 		subclass: originalName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'ClassRenameFix-GeneradClass'.	newClassName := self newUniqueClassName.	aBlock value: createdClass value: newClassName.	self assert: (Smalltalk classNamed: originalName) isNil.	self assert: (Smalltalk classNamed: newClassName) notNil.	foundClasses := Smalltalk organization listAtCategoryNamed: 'ClassRenameFix-GeneradClass'.	self assert: (foundClasses notEmpty).	self assert: (foundClasses includes: newClassName).	self assert: (createdClass name = newClassName).! !!ClassScope methodsFor: 'initializing' stamp: 'ajh 2/25/2003 20:10'!class: aBehavior	class _ aBehavior! !!ClassScope methodsFor: 'lookup' stamp: 'ajh 2/25/2003 20:10'!classEncoding	^ class! !!ClassScope methodsFor: 'lookup' stamp: 'md 2/21/2006 14:10'!lookupVar: name	"Return a SemVar for my pool var with this name.  Return nil if none found"	(class bindingOf: name asSymbol) ifNotNilDo: [:assoc | 		^ GlobalVar new assoc: assoc; scope: self].	^ nil! !!ClassScope methodsFor: 'lookup' stamp: 'ajh 3/18/2003 15:42'!possibleVarsFor: name continued: listOrNil	"Return my pool var names that are close to name"	name first isUppercase ifFalse: [^ listOrNil].	^ class possibleVariablesFor: name continuedFrom: listOrNil! !!ClassScope methodsFor: 'lookup' stamp: 'md 2/21/2006 14:10'!rawVar: name	"Return a SemVar for my pool var with this name.  Return nil if none found"	(class bindingOf: name asSymbol) ifNotNilDo: [:assoc | 		^ GlobalVar new assoc: assoc; scope: self].	^ nil! !!ClassScope methodsFor: 'levels' stamp: 'ajh 6/24/2004 04:03'!instanceScope	^ InstanceScope new		vars: class allInstVarNames;		outerScope: self! !!ClassScope methodsFor: 'levels' stamp: 'ajh 6/26/2004 17:56'!newFunctionScope	^ self instanceScope newFunctionScope! !!ClassScope methodsFor: 'printing' stamp: 'ajh 2/25/2003 20:10'!printOn: stream	class printOn: stream.	stream nextPutAll: ' parseScope'.! !!ClassScope methodsFor: '*geppetto2' stamp: 'md 2/24/2007 09:42'!theClass	^class! !!ClassScope commentStamp: 'ajh 3/24/2003 21:44' prior: 0!I include all variable enries for class, pool and global vars.!!ClassTest methodsFor: 'setup' stamp: 'rw 10/7/2006 08:57'!deleteClass	| cl |	cl := Smalltalk at: className ifAbsent: [^self].	cl removeFromChanges; removeFromSystemUnlogged 	! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/7/2006 08:57'!deleteRenamedClass	| cl |	cl := Smalltalk at: renamedName ifAbsent: [^self].	cl removeFromChanges; removeFromSystemUnlogged 	! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/17/2006 22:05'!setUp	className := #TUTU.	renamedName := #RenamedTUTU.	self deleteClass.	self deleteRenamedClass.	Object subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'KernelTests-Classes'! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/17/2006 22:08'!tearDown	self deleteClass.	self deleteRenamedClass! !!ClassTest methodsFor: 'testing' stamp: 'rw 10/17/2006 22:13'!testRenaming	"self debug: #testRenaming"	"self run: #testRenaming"		| oldName newMetaclassName class |	oldName := className.	newMetaclassName := (renamedName, #' class') asSymbol.	class := Smalltalk at: oldName.	class class compile: 'dummyMeth'.	class rename: renamedName.	self assert: class name = renamedName.	self assert: (ChangeSet current changedClassNames includes: renamedName). 	self assert: (ChangeSet current changedClassNames includes: newMetaclassName).	! !!ClassToRename methodsFor: 'performing'!method1	^self method2! !!ClassToRename methodsFor: 'performing'!method2	^self method1! !!ClassTrait methodsFor: '*refactoringEngine' stamp: 'md 3/14/2006 16:45'!includesBehavior: aClass	^false! !!ClassTrait methodsFor: '*refactoringEngine' stamp: 'md 3/14/2006 16:37'!soleInstance	^baseTrait! !!ClosureCompiledObject class methodsFor: 'compiling' stamp: 'md 11/23/2005 11:49'!compile: code classified: cat notifying: requestor trailer: bytes ifFail: failBlock	"Compile code without logging the source in the changes file"	| methodNode |	methodNode  := self compilerClass new				compile: code				in: self				classified: category 				notifying: requestor				ifFail: failBlock.	^ CompiledMethodWithNode generateMethodFromNode: methodNode trailer: bytes.! !!ClosureCompiledObject class methodsFor: 'compiling' stamp: 'md 7/16/2003 15:57'!compilerClass	^ClosureCompiler! !!ClosureCompiler methodsFor: 'public access' stamp: 'pmm 2/2/2007 18:07'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock	"Compiles the sourceStream into a parse tree, then generates code into a 	method. This method is then installed in the receiver's class so that it 	can be invoked. In other words, if receiver is not nil, then the text can 	refer to instance variables of that receiver (the Inspector uses this). If 	aContext is not nil, the text can refer to temporaries in that context (the 	Debugger uses this). If aRequestor is not nil, then it will receive a 	notify:at: message before the attempt to evaluate is aborted. Finally, the 	compiled method is invoked from here as DoIt or (in the case of 	evaluation in aContext) DoItIn:. The method is subsequently removed 	from the class, but this will not get done if the invocation causes an 	error which is terminated. Such garbage can be removed by executing: 	Smalltalk allBehaviorsDo: [:cl | cl removeSelector: #DoIt; removeSelector: 	#DoItIn:]."			^ self evaluate2: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock! !!ClosureCompiler methodsFor: 'examples' stamp: 'md 10/14/2004 17:47'!exampleReturn1	^1! !!ClosureCompiler methodsFor: 'as yet unclassified' stamp: 'md 11/18/2003 16:18'!parseClosure: textOrStream in: aClass notifying: req        "Compile the argument, textOrStream, with respect to the class, aClass,         and answer the MethodNode that is the root of the resulting parse tree.         Notify the argument, req, if an error occurs. The failBlock is defaulted to         an empty block."        self from: textOrStream class: aClass context: nil notifying: req.        ^ Parser2 new                        parse: sourceStream                        class: class                        noPattern: false                        context: context                        notifying: requestor                        ifFail: []! !!ClosureCompiler methodsFor: 'private' stamp: 'md 7/15/2003 12:24'!parserClass	^Parser2! !!ClosureCompiler class methodsFor: 'initialization' stamp: 'md 11/12/2004 11:44'!initialize		"self initialize"	Preferences		addPreference: #compileBlocksAsClosures		category: #compiler		default: false		balloonHelp: 'If true, blocks ([...]) will be compiled as BlockClosures instead of BlockContexts.  BlockClosures are independent of their home context but are a little slower (for now).  Only newly compiled methods will be affected by this preference. This requires the use of the new compiler, see Preference compileUsingNewCompiler'.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 21:04'!exampleAndAnd1	^1 = 1 and: [ 2 = 2 ] and: [ 3 = 3 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 20:57'!exampleAndAnd2	^1 = 1 and: [ 2 = 2 ] and: [ 2 = 3 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 20:58'!exampleAndAnd3	^1 = 2 and: [ 2 = 2 ] and: [ 3 = 3 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 20:59'!exampleAndAnd4	^1 = 1 and: [ 2 = 3 ] and: [ 3 = 3 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 20:58'!exampleAndAnd5	^1 = 2 and: [ 2 = 3 ] and: [ 3 = 4 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/24/2006 20:17'!exampleAndAnd6	^1 = 2 and: [ 2 = 3 ] and: [ 3 = 4 ] and: [ 1 / 0 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 11:15'!exampleBlockExternal	| t |	t := 1.	^[t] value.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 15:39'!exampleBlockExternal2	| t1 t2 |	t1 :=  t2 := 1.	^[t1 + t2] value.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 15:38'!exampleBlockExternalArg	| t  |	t := 1.	^[:a | t + a] value: 1.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 15:40'!exampleBlockExternalNested	| t s |	t := s := 1.	^[[s] value +   t   ] value.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'ms 7/31/2007 00:30'!exampleBlockInternal		^[ | t | t := 1. t] value! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/19/2006 13:30'!exampleIfNotNilDo	^1 even ifNotNilDo: [ :arg | arg not ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/19/2006 13:32'!exampleIfNotNilDoReturnNil	^nil ifNotNilDo: [ :arg | arg not ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 7/25/2006 15:24'!exampleIfNotNilReturnNil	^"nil ifNotNil: [ :arg | arg not ]"self! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 21:00'!exampleOrOr1	^1 = 1 or: [ 2 = 2 ] or: [ 3 = 3 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 21:00'!exampleOrOr2	^1 = 1 or: [ 2 = 2 ] or: [ 2 = 3 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 21:00'!exampleOrOr3	^1 = 2 or: [ 2 = 2 ] or: [ 3 = 3 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 21:00'!exampleOrOr4	^1 = 1 or: [ 2 = 3 ] or: [ 3 = 3 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 21:00'!exampleOrOr5	^1 = 2 or: [ 2 = 3 ] or: [ 3 = 4 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/24/2006 20:17'!exampleOrOr6	^1 = 2 or: [ 2 = 3 ] or: [ 3 = 4 ] or: [ 4 = 4 ] or: [ 1 / 0 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/14/2004 17:45'!exampleReturn1	^1! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 09:21'!exampleSimpleBlock	^[1].! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 11:08'!exampleSimpleBlockArgument1	^[:a | a ] value: 1.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 11:09'!exampleSimpleBlockArgument2	^[:a :b | a + b ] value: 1 value: 1.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 11:09'!exampleSimpleBlockArgument3	^[:a :b :c | a + b + c ] value: 1 value: 1 value: 1.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 11:09'!exampleSimpleBlockArgument4	^[:a :b :c :d | a + b + c  + d] value: 1 value: 1 value: 1 value: 1. ! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 11:11'!exampleSimpleBlockArgument5	^[:a :b :c :d :e| a + b + c  + d + e] valueWithArguments: #(1 1 1 1 1). ! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 11/11/2004 14:22'!exampleSimpleBlockLocal	^[ :each | | t |  t:= each. t   ] value: 5.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 11/11/2004 14:42'!exampleSimpleBlockLocalIf	^true ifTrue: [ | hallo |  hallo := 1 . hallo].! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 11/11/2004 14:56'!exampleSimpleBlockLocalIfNested	^true ifTrue: [| hallo |  [  hallo := 1 . hallo] value] .! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 11/11/2004 15:47'!exampleSimpleBlockLocalWhile	|a|	a := true.	^[: b | [a] whileTrue: [ | hallo |  a := false. hallo := 1 . hallo]]value: 1.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 11/11/2004 17:37'!exampleSimpleBlockNested	| a match dict | 	a  := #(a b c d).	dict := Dictionary new.	a doWithIndex: [:each :index |		(match := a indexOf: each) > 0 ifTrue:			[dict at: index put: (a at: match)]].	^ dict.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/16/2004 21:26'!exampleSimpleBlockiVar	^[iVar] value.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/16/2004 20:20'!exampleiVar	iVar := 1.	^iVar.! !!ClosureCompilerTest methodsFor: 'running' stamp: 'md 10/16/2004 21:28'!setUp	iVar := 1.! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'pmm 7/24/2006 20:18'!testAndAnd	self assert: self exampleAndAnd1.	self deny: self exampleAndAnd2.	self deny: self exampleAndAnd3.	self deny: self exampleAndAnd4.	self deny: self exampleAndAnd5.	self shouldnt: [ self exampleAndAnd6 ] raise: ZeroDivide! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'md 10/27/2004 17:02'!testCompile	| src ast ir method |	src :=  self class sourceCodeAt: #exampleReturn1.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: nil arguments: #()) = 1.! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'pmm 7/19/2006 13:31'!testIfNotNilDo	self assert: self exampleIfNotNilDo! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'pmm 7/19/2006 13:33'!testIfNotNilDoReturnNil	self assert: self exampleIfNotNilDoReturnNil isNil! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'pmm 7/19/2006 13:33'!testIfNotNilReturnNil	self assert: self exampleIfNotNilReturnNil isNil! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'pmm 7/24/2006 20:19'!testOrOr	self assert: self exampleOrOr1.	self assert: self exampleOrOr2.	self assert: self exampleOrOr3.	self assert: self exampleOrOr4.	self deny: self exampleOrOr5.	self shouldnt: [ self exampleOrOr6 ] raise: ZeroDivide! !!ClosureCompilerTest methodsFor: 'tests - bugs' stamp: 'md 10/19/2004 12:32'!testBackJump	| src ast method |	src :=  JPEGReadWriter  sourceCodeAt: #idctBlockInt:qt:.		ast := ClosureCompiler new parseClosure: src in: JPEGReadWriter notifying: nil.	method := ast ir compiledMethod.! !!ClosureCompilerTest methodsFor: 'tests - bugs' stamp: 'md 10/19/2004 14:20'!testClassVar	| src ast method |	src :=  Float class sourceCodeAt: #nan.		ast := ClosureCompiler new parseClosure: src in: Float class notifying: nil.	self shouldnt: [ method := ast ir compiledMethod] raise: Error.	self assert: (method valueWithReceiver: nil arguments: #()) isNaN.! !!ClosureCompilerTest methodsFor: 'tests - bugs' stamp: 'md 10/17/2004 16:25'!testMinusEndOfLine	| src  |	src :=  'test ^#-'.	self shouldnt: [ ClosureCompiler new parseClosure: src in: self class notifying: nil] raise: Error.	! !!ClosureCompilerTest methodsFor: 'tests - bugs' stamp: 'md 10/19/2004 14:57'!testParseSymbolColon	| src  |	src :=  'test ^#:'.	self shouldnt: [Compiler new parse: src in: self class notifying: nil] raise: Error.	self shouldnt: [ClosureCompiler new parseClosure: src in: self class notifying: nil] raise: Error.	! !!ClosureCompilerTest methodsFor: 'tests - bugs' stamp: 'md 10/17/2004 16:31'!testScannExponent	| src  |	src :=  'test ^1.0e-14'.	self shouldnt: [Compiler new parse: src in: self class notifying: nil] raise: Error.	self shouldnt: [ClosureCompiler new parseClosure: src in: self class notifying: nil] raise: Error.	! !!ClosureCompilerTest methodsFor: 'tests - bugs' stamp: 'md 10/17/2004 16:31'!testScannExponent2	| src  |	src :=  'test ^#(2r1e26 2r111e26)'.	self shouldnt: [Compiler new parse: src in: self class notifying: nil] raise: Error.	self shouldnt: [ClosureCompiler new parseClosure: src in: self class notifying: nil] raise: Error.	! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:18'!testBlockExternal	| src ast ir method |	src :=  self class sourceCodeAt: #exampleBlockExternal.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 1.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:18'!testBlockExternal2	| src ast ir method |	src :=  self class sourceCodeAt: #exampleBlockExternal2.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 2.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:18'!testBlockExternalArg	| src ast ir method |	src :=  self class sourceCodeAt: #exampleBlockExternalArg.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 2.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:18'!testBlockExternalNested	| src ast ir method |	src :=  self class sourceCodeAt: #exampleBlockExternalNested.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 2.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:18'!testBlockInternal	| src ast ir method |	src :=  self class sourceCodeAt: #exampleBlockInternal.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 1.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 11/11/2004 17:31'!testSimpleBloccNested	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockNested.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = ClosureCompilerTest new exampleSimpleBlockNested.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:18'!testSimpleBlock	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlock.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) value = 1.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:18'!testSimpleBlockArgument1	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockArgument1.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 1.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:17'!testSimpleBlockArgument2	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockArgument2.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 2.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:17'!testSimpleBlockArgument3	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockArgument3.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 3.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:17'!testSimpleBlockArgument4	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockArgument4.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 4.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:17'!testSimpleBlockArgument5	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockArgument5.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 5.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 11/11/2004 14:21'!testSimpleBlockLocal	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockLocal.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 5.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 11/11/2004 14:42'!testSimpleBlockLocalIf	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockLocalIf.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 1.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 11/11/2004 14:53'!testSimpleBlockLocalIfNested	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockLocalIfNested.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 1.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 11/11/2004 15:55'!testSimpleBlockLocalWhile	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockLocalWhile.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = nil.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/16/2004 21:27'!testSimpleBlockiVar	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockiVar.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 1.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 11/10/2004 15:43'!testSimpleiVar	| src ast ir method |	src :=  self class sourceCodeAt: #exampleiVar.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.		self assert: (method valueWithReceiver: self arguments: #()) = 1.! !!ClosureCompilerTest class methodsFor: 'as yet unclassified' stamp: 'md 10/19/2004 12:24'!Test	^Test! !!ClosureEnvInspector methodsFor: 'selecting' stamp: 'ajh 7/7/2004 16:50'!accept: aString	| result |	selectionIndex <= 2 ifTrue: [^ false].	context ifNil: [^ super accept: aString].	self eval: self selectedSlotName , ' _ ' , aString ifFail: [^ false].	self update.	^ true! !!ClosureEnvInspector methodsFor: 'selecting' stamp: 'ajh 7/7/2004 16:57'!eval: string ifFail: block	^ self doItReceiver class evaluatorClass new		evaluate2: (ReadStream on: string)		in: self doItContext		to: self doItReceiver		notifying: nil	"fix this"		ifFail:  block		logged: false! !!ClosureEnvInspector methodsFor: 'selecting' stamp: 'ajh 7/7/2004 16:46'!replaceSelectionValue: anObject 	"Refer to the comment in Inspector|replaceSelectionValue:."	object at: selectionIndex - 2 put: anObject! !!ClosureEnvInspector methodsFor: 'selecting' stamp: 'ajh 7/7/2004 17:41'!selection 	"Refer to the comment in Inspector|selection."	selectionIndex = 0 ifTrue:[^ ''].	selectionIndex = 1 ifTrue: [^ object].	selectionIndex = 2 ifTrue: [^ self freeNamesAndValues].	context ifNil: [^ object at: selectionIndex - 2].	^ self eval: (self freeNames at: selectionIndex - 2)		ifFail: [self error: 'bug']! !!ClosureEnvInspector methodsFor: 'accessing' stamp: 'ajh 7/7/2004 16:13'!doItContext	"Use my context. May be nil, in which case doItReceiver will be the context"	^ context! !!ClosureEnvInspector methodsFor: 'accessing' stamp: 'ajh 7/7/2004 16:05'!fieldList 	"Refer to the comment in Inspector|fieldList."	object == nil ifTrue: [^ #('thisEnv')].	^ #('thisEnv' 'all free vars'), self freeNames! !!ClosureEnvInspector methodsFor: 'accessing' stamp: 'ajh 7/7/2004 16:35'!freeNames	context ifNil: [^ (1 to: object size) collect: [:i | i printString]].	^ context freeNames! !!ClosureEnvInspector methodsFor: 'accessing' stamp: 'ajh 7/7/2004 16:34'!freeNamesAndValues	context ifNil: [		| stream |		stream _ '' writeStream.		1 to: object size do: [:i |			stream print: i; nextPut: $:; space; tab.			(object at: i) printOn: stream.			stream cr].		^ stream contents	].	^ context freeNamesAndValues! !!ClosureEnvInspector methodsFor: 'accessing' stamp: 'ajh 7/8/2004 20:12'!object: anObject 	"Same as super, except always update fields even if the object is the same, because the same closureEnvironment (object) can have different free vars depending on the context."	| oldIndex |	oldIndex _ selectionIndex <= 2 ifTrue: [selectionIndex] ifFalse: [0].	self inspect: anObject.	oldIndex _ oldIndex min: self fieldList size.	self changed: #inspectObject.	oldIndex > 0		ifTrue: [self toggleIndex: oldIndex].	self changed: #fieldList.	self changed: #contents.! !!ClosureEnvironment methodsFor: '*newcompiler' stamp: 'ajh 7/7/2004 16:53'!inspectorClass	^ ClosureEnvInspector! !!ClosureRuntimeStats methodsFor: 'arithmetic' stamp: 'ajh 7/1/2004 15:33'!+ stat	| agg |	(stat isKindOf: self class) ifFalse: [self error: 'can''t add stats'].	agg _ self class basicNew.	#(envCreationCount closureCreationCount closureCallCount milliseconds) do: [:var |		agg instVarNamed: var put:			(self instVarNamed: var) + (stat instVarNamed: var)].	^ agg! !!ClosureRuntimeStats methodsFor: 'as yet unclassified' stamp: 'ajh 5/21/2004 15:00'!closureCallsPerSecond	^ ((closureCallCount first: 6) / (milliseconds / 1000)) truncated! !!ClosureRuntimeStats methodsFor: 'as yet unclassified' stamp: 'ajh 7/1/2004 15:35'!closureCreationPerSecond	^ (closureCreationCount / (milliseconds / 1000)) truncated! !!ClosureRuntimeStats methodsFor: 'as yet unclassified' stamp: 'ajh 7/1/2004 15:33'!copyResults	milliseconds _ Time millisecondClockValue - StartTime.	envCreationCount _ EnvCreationCount.	closureCreationCount _ ClosureCreationCount.	closureCallCount _ ClosureCallCount.	newObjectCount _ NewObjectCount.! !!ClosureRuntimeStats methodsFor: 'as yet unclassified' stamp: 'ajh 7/1/2004 15:34'!envCreationPerSecond	^ ((envCreationCount first: 6) / (milliseconds / 1000)) truncated! !!ClosureRuntimeStats methodsFor: 'as yet unclassified' stamp: 'ajh 5/21/2004 16:09'!newObjectsPerSecond	^ (newObjectCount / (milliseconds / 1000)) truncated! !!ClosureRuntimeStats methodsFor: 'as yet unclassified' stamp: 'ajh 5/21/2004 13:54'!sendsPerSecond	^ sendsPerSecond ifNil: [sendsPerSecond _ 0 tinyBenchmarks]! !!ClosureRuntimeStats methodsFor: 'printing' stamp: 'ajh 7/1/2004 18:03'!longPrintOn: stream	stream print: testName; cr; cr.	stream nextPutAll: 'New objects per sec: '.	stream print: self newObjectsPerSecond; cr; cr.	stream nextPutAll: 'New envs per sec: '.	stream print: self envCreationPerSecond sum; cr.	stream nextPutAll: 'by num free vars: '.	stream print: self envCreationPerSecond; cr; cr.	stream nextPutAll: 'New closures per sec: '.	stream print: self closureCreationPerSecond; cr; cr.	stream nextPutAll: 'Closure calls per sec: '.	stream print: self closureCallsPerSecond sum; cr.	stream nextPutAll: 'by num free vars: '.	stream print: self closureCallsPerSecond; cr; cr.	stream nextPutAll: self sendsPerSecond; cr.! !!ClosureRuntimeStats methodsFor: 'printing' stamp: 'ajh 5/21/2004 13:45'!printOn: stream	stream print: self class; space.	stream print: testName.! !!ClosureRuntimeStats methodsFor: 'printing' stamp: 'ajh 5/21/2004 13:58'!testName	"Just for documentation to distinguish multiple instances"	^ testName! !!ClosureRuntimeStats methodsFor: 'printing' stamp: 'ajh 5/21/2004 11:45'!testName: name	"Just to document for when you have multiple instances"	testName _ name! !!ClosureRuntimeStats methodsFor: 'accessing' stamp: 'ajh 5/21/2004 14:03'!sendsPerSecond: string	sendsPerSecond _ string! !!ClosureRuntimeStats commentStamp: 'ajh 5/21/2004 17:39' prior: 0!Count the number of closure creations and calls while executing a given block. ClosureRuntimeStats on. ClosureRuntimeStats off inspect. (Closure measure: [...]) inspect. ClosureRuntimeStats testResults asArray. (ClosureRuntimeStats testResults allButFirst	inject: ClosureRuntimeStats testResults first	into: [:agg :stat | agg + stat])	testName: 'Aggregate'!!ClosureRuntimeStats class methodsFor: 'tracing methods' stamp: 'ajh 7/1/2004 17:32'!blockClosureNew	ClosureCreationCount _ ClosureCreationCount + 1.	^ self basicNew! !!ClosureRuntimeStats class methodsFor: 'tracing methods' stamp: 'ajh 7/1/2004 17:32'!envNew: size	| array n |	array _ EnvCreationCount.	n _ size + 1.	array at: n put: (array at: n) + 1.	^ self basicNew: size! !!ClosureRuntimeStats class methodsFor: 'tracing methods' stamp: 'ajh 5/21/2004 15:49'!traceBasicNew	NewObjectCount _ NewObjectCount + 1.	^ self primBasicNew! !!ClosureRuntimeStats class methodsFor: 'tracing methods' stamp: 'ajh 5/21/2004 15:49'!traceBasicNew: size	NewObjectCount _ NewObjectCount + 1.	^ self primBasicNew: size! !!ClosureRuntimeStats class methodsFor: 'tracing methods' stamp: 'ajh 7/1/2004 18:00'!valueWithArguments: args	| n array e |	e _ self env.	n _ e class == ClosureEnvironment		ifTrue: [e size]		ifFalse: [1].	n _ n + 1.	(array _ ClosureCallCount) at: n put: (array at: n) + 1.	^ self primValueWithArguments: args! !!ClosureRuntimeStats class methodsFor: 'initialize' stamp: 'ajh 7/1/2004 15:28'!initCounters	Smalltalk at: #ClosureCreationCount put: 0.		"indexed by number of free vars"	Smalltalk at: #EnvCreationCount put: (Array new: 100 withAll: 0).	Smalltalk at: #ClosureCallCount put: (Array new: 100 withAll: 0).		Smalltalk at: #NewObjectCount put: 0.	StartTime _ Time millisecondClockValue.! !!ClosureRuntimeStats class methodsFor: 'initialize' stamp: 'ajh 5/21/2004 13:43'!initialize	Tests _ OrderedCollection new.	self initCounters.! !!ClosureRuntimeStats class methodsFor: 'initialize' stamp: 'ajh 5/21/2004 16:06'!installCountObjectMethods	{{Behavior. #primBasicNew. #primBasicNew}.	 {Behavior. #primBasicNew:. #primBasicNew:}.	 {Behavior. #basicNew. #traceBasicNew}.	 {Behavior. #basicNew:. #traceBasicNew:}	} do: [:triple |		triple first			addSelectorSilently: triple second			withMethod: (self class compiledMethodAt: triple third)].	self installTracingMethods.! !!ClosureRuntimeStats class methodsFor: 'initialize' stamp: 'ajh 7/1/2004 15:20'!installOriginalMethods	{{BlockClosure. #valueWithArguments:. #primValueWithArguments:}.	} do: [:triple |		triple first			addSelectorSilently: triple second			withMethod: (self class compiledMethodAt: triple third)].	{{ClosureEnvironment class. #new:}.	 {BlockClosure class. #new}.	 {BlockClosure. #primValueWithArguments:}.	} do: [:pair |		pair first removeSelectorSimply: pair second].! !!ClosureRuntimeStats class methodsFor: 'initialize' stamp: 'ajh 5/21/2004 16:06'!installOriginalObjectMethods	{{Behavior. #basicNew. #primBasicNew}.	 {Behavior. #basicNew:. #primBasicNew:}	} do: [:triple |		triple first			addSelectorSilently: triple second			withMethod: (self class compiledMethodAt: triple third)].	{{Behavior. #primBasicNew}.	 {Behavior. #primBasicNew:}	} do: [:pair |		pair first removeSelectorSimply: pair second].	self installOriginalMethods.! !!ClosureRuntimeStats class methodsFor: 'initialize' stamp: 'ajh 7/1/2004 15:06'!installTracingMethods	{{BlockClosure class. #new. #blockClosureNew}.	 {BlockClosure. #primValueWithArguments:. #primValueWithArguments:}.	 {BlockClosure. #valueWithArguments:. #valueWithArguments:}.	 {ClosureEnvironment class. #new:. #envNew:}.	} do: [:triple |		triple first			addSelectorSilently: triple second			withMethod: (self class compiledMethodAt: triple third)].	self initCounters.! !!ClosureRuntimeStats class methodsFor: 'run' stamp: 'ajh 5/21/2004 00:05'!measure: block	self on.	block value.	^ self off! !!ClosureRuntimeStats class methodsFor: 'run' stamp: 'ajh 5/21/2004 16:07'!off	| stats |	stats _ self new copyResults.	self installOriginalObjectMethods.	stats sendsPerSecond: 0 tinyBenchmarks.	^ stats! !!ClosureRuntimeStats class methodsFor: 'run' stamp: 'ajh 5/21/2004 16:06'!on	self installCountObjectMethods.! !!ClosureRuntimeStats class methodsFor: 'original methods' stamp: 'ajh 5/21/2004 15:48'!primBasicNew	"Primitive. Answer an instance of the receiver (which is a class) with no 	indexable variables. Fail if the class is indexable. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 70>	self isVariable ifTrue: [ ^ self basicNew: 0 ].	"space must be low"	self environment signalLowSpace.	^ self basicNew  "retry if user proceeds"! !!ClosureRuntimeStats class methodsFor: 'original methods' stamp: 'ajh 5/21/2004 15:49'!primBasicNew: sizeRequested 	"Primitive. Answer an instance of this class with the number	of indexable variables specified by the argument, sizeRequested.	Fail if this class is not indexable or if the argument is not a	positive Integer, or if there is not enough memory available. 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 71>	self isVariable ifFalse:		[self error: self printString, ' cannot have variable sized instances'].	(sizeRequested isInteger and: [sizeRequested >= 0]) ifTrue:		["arg okay; space must be low."		self environment signalLowSpace.		^ self basicNew: sizeRequested  "retry if user proceeds"].	self primitiveFailed! !!ClosureRuntimeStats class methodsFor: 'original methods' stamp: 'ajh 7/1/2004 17:19'!primValueWithArguments: anArray 	"Primitive. Evaluate the block represented by the receiver. The argument 	is an Array whose elements are the arguments for the block. Fail if the 	length of the Array is not the same as the the number of arguments that 	the block was expecting. Fail if the block is already being executed. 	Essential. See Object documentation whatIsAPrimitive."	"<primitive: 187>"	^ self env withArgs: anArray executeMethod: self method! !!ClosureRuntimeStats class methodsFor: 'tests' stamp: 'ajh 5/21/2004 13:57'!testResults	"Collection of previously run test results"	^ Tests! !!ClosureStaticStats methodsFor: 'as yet unclassified' stamp: 'ajh 5/20/2004 02:18'!allMethodsDo: methodBlock	| count |	count _ 0.	Smalltalk allClassesDo: [:class | count _ count +		({class. class class} collect: [:behavior |			behavior methodDictionary size]) sum].		'Checking ', count printString, ' methods'		displayProgressAt: Sensor cursorPoint from: 0 to: count		during: [:bar | | m | m _ 0.			Smalltalk allClassesDo: [:class |				{class. class class} do: [:behavior |					behavior methodDictionary do: [:meth |						methodBlock value: meth.						bar value: (m _ m + 1)]]]].! !!ClosureStaticStats methodsFor: 'as yet unclassified' stamp: 'ajh 7/1/2004 10:47'!initBags	methodsByEmbeddedBlocks _ Bag new.	blocksByFreeVars _ Bag new.	homeFunctionsByEscapingEnvs _ Bag new.	problemMethods _ OrderedCollection new.! !!ClosureStaticStats methodsFor: 'printing' stamp: 'ajh 7/1/2004 10:47'!longPrintOn: stream	| list |	list _ [:bag | (0 to: 9) collect: [:i | bag valuesAndCounts at: i ifAbsent: [0]]].	stream nextPutAll: 'Methods: '.	stream print: methodsByEmbeddedBlocks size; cr.	stream nextPutAll: 'by num closures: '.	stream print: (list value: methodsByEmbeddedBlocks); cr; cr.	stream nextPutAll: 'Home methods/blocks: '.	stream print: homeFunctionsByEscapingEnvs size; cr.	stream nextPutAll: 'by having own env: '.	stream print: (list value: homeFunctionsByEscapingEnvs); cr; cr.	stream nextPutAll: 'Closures: '.	stream print: blocksByFreeVars size; cr.	stream nextPutAll: 'by num free vars: '.	stream print: (list value: blocksByFreeVars); cr.! !!ClosureStaticStats methodsFor: 'running' stamp: 'ajh 7/8/2004 19:19'!run	"scan all methods collecting stats"	self initBags.	self allMethodsDo: [:meth |		| blockMeths |		blockMeths _ meth allEmbeddedBlockMethods.		methodsByEmbeddedBlocks add: blockMeths size.		blockMeths size > 0 ifTrue: [			homeFunctionsByEscapingEnvs add: meth ast scope hasEscapingEnv asBit].		[blockMeths do: [:bm | | ast |			ast _ bm ast.			bm containsBlockClosures ifTrue: [				homeFunctionsByEscapingEnvs add: ast scope hasEscapingEnv asBit].			blocksByFreeVars add: ast freeVars size.		]] on: Error do: [problemMethods add: meth].	].	LastStats _ self.! !!ClosureStaticStats commentStamp: 'ajh 5/21/2004 14:52' prior: 0!After recompiling the image under the new closure compiler (using Recompiler), use this to find distribution of:number of closures per method,number of free vars per closure.number of indirect free vars per closure.number of indirect temp vars per method with closure(s).number of indirect temp vars per method. ClosureStaticStats new run inspect. ClosureStaticStats lastStats.!!ClosureStaticStats class methodsFor: 'as yet unclassified' stamp: 'ajh 5/20/2004 02:20'!lastStats	^ LastStats! !!Collection methodsFor: '*newcompiler' stamp: 'ms 10/16/2006 23:33'!do: elementBlock separatedByNext: separatorBlock	"Evaluate the elementBlock for all elements in the receiver,	and evaluate the separatorBlock between with the next element."	| beforeFirst | 	beforeFirst := true.	self do:		[:each |		beforeFirst			ifTrue: [beforeFirst := false]			ifFalse: [separatorBlock value: each].		elementBlock value: each]! !!Collection methodsFor: '*newcompiler' stamp: 'ms 10/16/2006 23:33'!do: elementBlock separatedByPrevious: separatorBlock	"Evaluate the elementBlock for all elements in the receiver,	and evaluate the separatorBlock between with the previous element."	| beforeFirst prev | 	beforeFirst := true.	prev := nil.	self do:		[:each |		beforeFirst			ifTrue: [beforeFirst := false]			ifFalse: [separatorBlock value: prev].		elementBlock value: each.		prev := each]! !!Collection methodsFor: '*persephone' stamp: 'pmm 9/27/2006 14:45'!addToSequence: aSequenceNode	self do: [ :each |		each isSequence			ifTrue: [ aSequenceNode addNodes: each statements ]			ifFalse: [ aSequenceNode addNode: each ] ].! !!Collection methodsFor: '*persephone' stamp: 'pmm 7/23/2006 21:50'!asAstArrayNode	^RBArrayNode statements: (self collect: [ :each | each copy ])! !!Collection methodsFor: '*persephone' stamp: 'pmm 7/22/2006 13:39'!asAstSquenceNode	| sequence |	sequence := RBSequenceNode		statements: OrderedCollection new.	self addToSequence: sequence.	^sequence! !!CompiledMethod methodsFor: '*ast' stamp: 'dvf 11/8/2003 15:01'!parseTree	^ RBParser parseMethod: self getSource asString.! !!CompiledMethod methodsFor: '*newcompiler' stamp: 'ms 11/7/2007 15:48'!= method	"Answer whether the receiver implements the same code as the 	argument, method."	self == method ifTrue:[^true].	(method isKindOf: CompiledMethod) ifFalse: [^false].		"Dont bother checking FFI and named primitives"	(#(117 120) includes: self primitive) ifTrue: [^ true].	"Dont bother checking quick return"	(self isReturnSpecial and: [self primitive = method primitive])		ifTrue:[^true].	self primitive = method primitive		ifFalse: [^false].	"self header = method header ifFalse: [^false]."	^(InstructionCompaire compaire: self with: method)! !!CompiledMethod methodsFor: '*newcompiler' stamp: 'md 2/21/2006 13:57'!ast	"Return the node for self"	self isBlockMethod ifTrue: [^ self blockNode] ifFalse: [^ self methodNode].! !!CompiledMethod methodsFor: '*newcompiler' stamp: 'md 2/21/2006 13:52'!blockNode	"Return the block node for self"	| homeMethodNode |	homeMethodNode := self methodNode.	self isBlockMethod ifFalse: [^ homeMethodNode].	homeMethodNode ifNil: [^ self decompilerClass new decompileBlock: self].	homeMethodNode compiledMethod.  "generate method"	homeMethodNode nodesDo: [:node |		(node isBlock and:		 [node scope notNil "not-inlined" and:		  [node compiledMethod = self]])			ifTrue: [^ node]	].	"node not found, must have been compiled differently (compiler changed)"	^ self decompilerClass new decompileBlock: self! !!CompiledMethod methodsFor: '*newcompiler' stamp: 'ajh 3/2/2003 13:51'!ir	^ BytecodeDecompiler new decompile: self! !!CompiledMethod methodsFor: '*persephone' stamp: 'pmm 8/23/2006 14:22'!bytecodes	^ByteArray streamContents: [ :stream |		self initialPC to: self size - 4 do: [ :index |			stream nextPut: (self at: index) ] ]! !!CompiledMethod methodsFor: '*persephone' stamp: 'md 3/31/2007 19:45'!classBinding	^(self literalAt: self numLiterals) ! !!CompiledMethod methodsFor: '*persephone' stamp: 'pmm 7/29/2005 14:21'!compiledMethod	^self! !!CompiledMethod methodsFor: '*persephone' stamp: 'md 3/31/2007 19:12'!compilerClass	^(Preferences compileReflectiveMethods) ifTrue: [PECompiler] ifFalse: [Compiler]. ! !!CompiledMethod methodsFor: '*persephone' stamp: 'md 10/25/2007 15:34'!getSourceFor: selector in: class	"Retrieve or reconstruct the source code for this method."	| source flagByte sourceSelector |	flagByte _ self last.	(flagByte = 0		or: [flagByte = 251 "some source-less methods have flag = 251, rest = 0"			and: [((1 to: 3) collect: [:i | self at: self size - i]) = #(0 0 0)]])		ifTrue: ["No source pointer -- decompile without temp names"		^ self decompileString].	flagByte < 252 ifTrue:		["Magic sources -- decompile with temp names"		^ ((self decompilerClass new withTempNames: self tempNames)				decompile: selector in: class method: self)			decompileString].	"Situation normal;  read the sourceCode from the file"		[ source _ self getSourceFromFile ] on: Error do: [ :ex |		"An error can happen here if, for example, the changes file has been truncated by an aborted download.  The present solution is to ignore the error and fall back on the decompiler.  A more thorough solution should probably trigger a systematic invalidation of all source pointers past the end of the changes file.  Consider that, as time goes on, the changes file will eventually grow large enough to cover the lost code, and then instead of falling into this error case, random source code will get returned."		source _ nil ].		source ifNotNil: [		sourceSelector _ self methodClass parserClass new parseSelector: source.		(selector == #DoIt and: [sourceSelector isNil]) ifTrue: [^source asString]. "Doit".		^sourceSelector = selector			ifTrue: [source]			ifFalse: [				self replace: sourceSelector with: selector in: source]].	"Something really wrong -- decompile blind (no temps)"	^ self decompileString! !!CompiledMethod methodsFor: '*persephone' stamp: 'pmm 8/23/2006 09:09'!hasPragma: aSymbol	^self pragmas anySatisfy: [ :each |		each keyword = aSymbol ]! !!CompiledMethod methodsFor: '*persephone' stamp: 'md 4/13/2007 15:07'!hasReflectiveMethod	^self properties includesKey: #reflectiveMethod! !!CompiledMethod methodsFor: '*persephone' stamp: 'md 4/17/2007 16:48'!invalidate	self isInvalid ifTrue: [^self].	self reflectiveMethod invalidate.! !!CompiledMethod methodsFor: '*persephone' stamp: 'md 7/26/2007 10:35'!isCoreMethod	^self reflectiveMethod isCoreMethod.! !!CompiledMethod methodsFor: '*persephone' stamp: 'md 3/1/2007 21:57'!isInvalid	"the cache is invalidated by installing the RM in the MethodDictionary.	 State of the compiledMethod is *not* the trigger!!"		^(self methodClass methodDict at: self selector) ~~ self.! !!CompiledMethod methodsFor: '*persephone' stamp: 'md 3/1/2007 20:25'!isReflectiveMethod	^false! !!CompiledMethod methodsFor: '*persephone' stamp: 'md 8/20/2007 16:10'!methodNode	"Return the parse tree that represents self"	| source |		self hasReflectiveMethod ifTrue: [^self reflectiveMethod methodNode].	^ (source := self getSourceFromFile)		ifNil: [self decompile]		ifNotNil: [			self selector isDoIt ifTrue: [self parserClass new parseDoit: source]					   ifFalse: [self parserClass new 										parse: source 										class: (self methodClass ifNil: [self sourceClass])]]! !!CompiledMethod methodsFor: '*persephone' stamp: 'md 9/28/2007 15:53'!methodNodeFromSource	"Return the parse tree that represents self"	| source |		^ (source := self getSourceFromFile)		ifNil: [self decompile]		ifNotNil: [			self selector isDoIt ifTrue: [self parserClass new parseDoit: source]					   ifFalse: [self parserClass new 										parse: source 										class: (self methodClass ifNil: [self sourceClass])]]! !!CompiledMethod methodsFor: '*persephone' stamp: 'md 4/13/2007 15:07'!reflectiveMethod	^self properties at: #reflectiveMethod ifAbsent: [		Preferences compileReflectiveMethods ifFalse: [self error: 'no reflective Method'].		self methodClass recompile: self selector.		^(self methodClass>>self selector) reflectiveMethod.	]! !!CompiledMethod methodsFor: '*persephone' stamp: 'md 4/13/2007 15:07'!reflectiveMethod: aJMethod	self properties at: #reflectiveMethod put: aJMethod! !!CompiledMethod methodsFor: '*persephone' stamp: 'md 4/13/2007 15:07'!reflectiveMethodOrNil	^self properties at: #reflectiveMethod ifAbsent: [ nil ]! !!CompiledMethod methodsFor: '*persephone' stamp: 'pmm 7/31/2006 15:33'!replace: oldSelector with: newSelector in: aText	| oldKeywords newKeywords args newSelectorWithArgs startOfSource lastSelectorToken |	oldKeywords _ oldSelector keywords.	newKeywords _ (newSelector ifNil: [self defaultSelector]) keywords.	self assert: oldKeywords size = newKeywords size.	args _ (self methodClass parserClass new		parseArgsAndTemps: aText string notifying: nil) copyFrom: 1 to: self numArgs.	newSelectorWithArgs _ String streamContents: [:stream |		newKeywords withIndexDo: [:keyword :index |			stream nextPutAll: keyword.			stream space.			args size >= index ifTrue: [				stream nextPutAll: (args at: index); space]]].	lastSelectorToken _ args isEmpty		ifFalse: [args last]		ifTrue: [oldKeywords last].	startOfSource _ (aText string		indexOfSubCollection: lastSelectorToken startingAt: 1) + lastSelectorToken size.	^newSelectorWithArgs withBlanksTrimmed asText , (aText copyFrom: startOfSource to: aText size)! !!CompiledMethod methodsFor: '*persephone' stamp: 'pmm 7/31/2006 15:32'!sourceSelector	"Answer my selector extracted from my source.  If no source answer nil"	| sourceString |	sourceString _ self getSourceFromFile ifNil: [^ nil].	^ self methodClass parserClass new parseSelector: sourceString! !!CompiledMethod methodsFor: '*persephone-override' stamp: 'md 4/15/2007 15:13' prior: 19073002!hasLiteralSuchThat: aBlock	"Answer true if aBlock returns true for any literal in this method, even if imbedded in array structure or within its pragmas."		| literal |		self hasReflectiveMethod ifTrue: [^self reflectiveMethod hasLiteralSuchThat: aBlock].		self pragmas do: [ :pragma |		(pragma hasLiteralSuchThat: aBlock)			ifTrue: [ ^ true ] ].	2 to: self numLiterals + 1 do: [ :index | 		literal := self objectAt: index.		(aBlock value: literal)			ifTrue: [ ^ true ].		(literal hasLiteralSuchThat: aBlock)			ifTrue: [ ^ true ] ].	^ false.! !!CompiledMethod methodsFor: '*persephone-override' stamp: 'md 4/15/2007 15:13' prior: 19073539!hasLiteralThorough: aLiteral	"Answer true if any literal in this method is literal, even if embedded in array structure or within its pragmas."	| literal |		self hasReflectiveMethod ifTrue: [^self reflectiveMethod hasLiteralThorough: aLiteral].		self pragmas do: [ :pragma |		(pragma hasLiteral: aLiteral) ifTrue: [ ^ true ] ].	2 to: self numLiterals + 1 do: [ :index | 		literal := self objectAt: index.		literal == aLiteral  ifTrue: [ ^ true ].		(literal hasLiteralThorough: aLiteral) ifTrue: [ ^ true ] ].	^ false.! !!CompiledMethod methodsFor: '*geppetto2' stamp: 'md 3/20/2007 17:25'!assignments	^self reflectiveMethod assignments.! !!CompiledMethod methodsFor: '*geppetto2' stamp: 'md 3/20/2007 17:25'!blocks	^self reflectiveMethod blocks.! !!CompiledMethod methodsFor: '*geppetto2' stamp: 'md 8/24/2007 00:05'!globalAssignments	^self reflectiveMethod globalAssignments.! !!CompiledMethod methodsFor: '*geppetto2' stamp: 'md 8/24/2007 00:05'!instanceAssignments	^self reflectiveMethod instanceAssignments.! !!CompiledMethod methodsFor: '*geppetto2' stamp: 'md 8/22/2007 07:44'!instanceVariableReads	^self reflectiveMethod instanceVariableReads.! !!CompiledMethod methodsFor: '*geppetto2' stamp: 'md 3/20/2007 17:25'!nodes	^self reflectiveMethod nodes.! !!CompiledMethod methodsFor: '*geppetto2' stamp: 'md 3/20/2007 17:25'!sends	^self reflectiveMethod sends.! !!CompiledMethod methodsFor: '*geppetto2' stamp: 'md 3/20/2007 17:25'!statements	^self reflectiveMethod statements.! !!CompiledMethod methodsFor: '*geppetto2' stamp: 'md 8/24/2007 00:05'!tempAssignments	^self reflectiveMethod tempAssignments.! !!CompiledMethod methodsFor: '*geppetto2' stamp: 'md 8/22/2007 07:52'!tempVariableReads	^self reflectiveMethod tempVariableReads.! !!CompiledMethod methodsFor: '*geppetto2' stamp: 'md 8/22/2007 07:52'!variableReads	^self reflectiveMethod variableReads.! !!CompiledMethod methodsFor: '*geppetto2' stamp: 'md 10/25/2007 17:06'!variableWrites	^self reflectiveMethod variableWrites.! !!CompiledMethod methodsFor: '*geppetto2' stamp: 'md 3/21/2007 15:10'!variables	^self reflectiveMethod variables.! !!CompiledMethod methodsFor: '*colorer' stamp: 'md 8/10/2007 15:56'!prettyPrintExecution	^self reflectiveMethod prettyPrintExecution.! !!Compiler methodsFor: '*newcompiler-override' stamp: 'md 2/28/2006 15:42' prior: 19125349!compile: textOrStream in: aClass classified: aCategory notifying: aRequestor ifFail: failBlock 	"Answer a MethodNode for the argument, textOrStream. If the 	MethodNode can not be created, notify the argument, aRequestor; if 	aRequestor is nil, evaluate failBlock instead. The MethodNode is the root 	of a parse tree. It can be told to generate a CompiledMethod to be 	installed in the method dictionary of the argument, aClass."		| methodNode |	self from: textOrStream		class: aClass		classified: aCategory 		context: nil		notifying: aRequestor.	methodNode := self translate: sourceStream noPattern: false ifFail: failBlock.	Preferences compileUseNewCompiler ifFalse: [		methodNode encoder requestor: requestor.	].	^methodNode.! !!Compiler methodsFor: '*newcompiler-override' stamp: 'md 10/16/2006 09:53' prior: 19127422!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	| methodNode method value toLog itsSelectionString itsSelection |	class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	method selector ifNil: [method selector: #DoIt].	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ])		executeMethod: method.	logFlag ifTrue:		[toLog := ((requestor respondsTo: #selection)  and:			[(itsSelection := requestor selection) notNil] and:			[(itsSelectionString := itsSelection asString) isEmptyOrNil not] )			ifTrue: 				[itsSelectionString]			ifFalse:				[sourceStream contents].		SystemChangeNotifier uniqueInstance evaluated: toLog context: aContext ].	^ value.! !!Compiler methodsFor: '*newcompiler-override' stamp: 'ms 1/7/2007 01:56' prior: 33919205!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	| methodNode method value |	  	(Preferences compileUseNewCompiler or: 			[aContext ifNotNil: [aContext method isClosureCompiled] ifNil: [false]]) ifTrue: 				[^ self evaluate2: textOrStream 					    in: aContext 					    to: receiver 					    notifying: aRequestor 					    ifFail: failBlock 					    logged: logFlag].		class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ])		executeMethod: method.	logFlag 		ifTrue: [ SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext ].	^ value.! !!Compiler methodsFor: '*newcompiler' stamp: 'md 7/24/2007 14:49'!compileDoIt: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock log: log	"Compiles the sourceStream into a parse tree, then generates code into a method.  This method is then wrapped in a block with the receiver or context as the sole free variable which the method refers to.  If requestor is not nil, then it will receive a notify:at: message if there is a compile error, followed by the failBlock being executed."	| scope parser blockNode method source |	source _ textOrStream readStream.	scope _ aContext		ifNotNil: [aContext doItScope]		ifNil: [receiver class parseScope instanceScope].	parser _ Parser2 new.	blockNode _ parser			parse: source			class: scope			noPattern: true			notifying: aRequestor			ifFail: [^ failBlock value].	method _ blockNode generate.	method selector: #DoIt.			log ifTrue: [		method putSource: source contents			fromParseNode: blockNode			inFile: 2 			withPreamble: [:file | file cr]].	^ BlockClosure new		env: (aContext ifNil: [receiver]);		method: method;		yourself! !!Compiler methodsFor: '*newcompiler' stamp: 'ms 1/7/2007 01:58'!evaluate2: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	^ (self compileDoIt: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: [^ failBlock value] log: logFlag) value! !!Compiler class methodsFor: '*newcompiler-override' stamp: 'md 11/11/2007 15:09' prior: 19133171!closureDecompilerClass	^Decompiler2! !!Compiler class methodsFor: '*newcompiler-override' stamp: 'md 3/5/2006 17:03' prior: 19133297!closureParserClass	^Parser2! !!Compiler class methodsFor: '*newcompiler-override' stamp: 'md 11/11/2007 15:09' prior: 19133660!decompilerClass	"Answer a decompiler class appropriate for this Compiler."	^ Preferences compileUseNewCompiler		ifTrue: [Decompiler2]		ifFalse: [Decompiler]! !!Compiler class methodsFor: '*newcompiler-override' stamp: 'ajh 1/20/2002 18:57' prior: 19133856!parserClass	"Return a parser class to use for parsing method headers."	^ Preferences compileUseNewCompiler		ifTrue: [Parser2]		ifFalse: [Parser]! !!Compiler class methodsFor: '*newcompiler' stamp: 'md 2/27/2006 16:32'!initialize	Preferences		addPreference: #compileUseNewCompiler		category: #compiler		default: false		balloonHelp: 'If true, the new compiler is used for compiling methods. Only newly compiled methods will be affected by this preference.'! !!CompilerRegressionTest methodsFor: 'testing' stamp: 'md 3/22/2005 15:56'!testBytecodeDecompileToIR	"decompile all the byteocde of all methods of all classes to IR"	self shouldnt: [		Smalltalk allClasses do: [:class |				class methodDict values do: [:m |							m ir.				] displayingProgress: 'decompiling'		]	] raise: Error.! !!CompilerRegressionTest methodsFor: 'testing' stamp: 'md 3/22/2005 15:56'!testBytecodeDecompileToIRAndRegenerate	"decompile all the byteocde of all methods of all classes to IR. Then it      gnerates a new method using IRBuilder"	self shouldnt: [			Smalltalk allClasses do: [:class|					class methodDict values do: [:m |						(m ir) compiledMethodWith: #().					] displayingProgress: 'recompiling'			]	] raise: Error.! !!CompilerRegressionTest methodsFor: 'testing' stamp: 'md 3/22/2005 16:26'!testBytecodeRecompile	"recompile the image BC->IR->BC and install"	| new |	self shouldnt: [			Smalltalk allClasses do: [:class|					class methodDict keysAndValuesDo: [:s :m |							new := (m ir) compiledMethodWith: m trailer.							class methodDict at: s put: new.					]			]	] raise: Error.! !!CompilerRegressionTest commentStamp: 'md 3/22/2005 14:51' prior: 0!These are tests that recompile the whole image. This takes a long time. Butif such a test runs to completion, we are sure that there are no errors.These tests are disabled by default. To enable:       CompilerRegressionTest runLongTestCases.Disable:       CompilerRegressionTest doNotRunLongTestCases.!!CompiletimeEvaluator methodsFor: 'transforming' stamp: 'md 3/31/2007 19:18'!evaluateNow: aNode	| body doit value literalNode |	body := RBSequenceNode statement: aNode copy.	doit := RBDoItNode body: body.	value := doit compiledMethod valueWithReceiver: nil arguments: #().	literalNode := PEObjectLiteralNode value: value.	aNode parent replaceNodeAndSetParent: aNode withNode: literalNode.	^self visitNode: literalNode! !!CompiletimeEvaluator methodsFor: 'accessing' stamp: 'pmm 1/14/2006 14:49'!evaluteAtCompiletimeAnnotaionKey	^EvaluateAtCompiletimeAnnotation evaluteAtCompiletimeAnnotaionKey! !!CompiletimeEvaluator methodsFor: 'visiting' stamp: 'pmm 1/14/2006 14:50'!visitNode: aNode	^(aNode hasAnnotation: self evaluteAtCompiletimeAnnotaionKey)		ifTrue: [ self evaluateNow: aNode ]		ifFalse: [ super visitNode: aNode ]! !!CompiletimeEvaluator class methodsFor: 'class initialization' stamp: 'md 12/16/2007 21:41'!initialize	"self initialize"	Preferences		addBooleanPreference: #compileTimeEval		category: #reflectivitydemo		default: false		balloonHelp: 'enable compileTimeEval.'! !!CompiletimeEvaluator class methodsFor: 'plugin interface' stamp: 'md 12/16/2007 21:42'!isActive	^Preferences compileTimeEval! !!Complex methodsFor: 'comparing' stamp: 'hmm 11/1/2006 23:29'!= anObject	anObject isNumber ifFalse: [^false].	anObject isComplex		ifTrue: [^ (real = anObject real) & (imaginary = anObject imaginary)]		ifFalse: [^ anObject adaptToComplex: self andSend: #=]! !!Complex methodsFor: 'testing' stamp: 'hmm 11/1/2006 23:34'!isNumber	^ true! !!CompositeLintRule methodsFor: 'accessing' stamp: 'nk 3/5/2005 15:16'!changes	^rules gather: [ :r  | r changes ]! !!CompositeLintRule methodsFor: 'accessing'!checkClass: aSmalllintContext 	rules do: 			[:each | 			each checkClass: aSmalllintContext.			Processor yield]! !!CompositeLintRule methodsFor: 'accessing'!checkMethod: aSmalllintContext 	rules do: 			[:each | 			each checkMethod: aSmalllintContext.			Processor yield]! !!CompositeLintRule methodsFor: 'accessing'!failedRules	^rules inject: OrderedCollection new into: [:oc :each | oc addAll: each failedRules; yourself]! !!CompositeLintRule methodsFor: 'accessing'!problemCount	^rules inject: 0 into: [:count :each | count + each problemCount]! !!CompositeLintRule methodsFor: 'accessing'!rules	^rules! !!CompositeLintRule methodsFor: 'testing'!hasConflicts	^(rules detect: [:each | each hasConflicts] ifNone: [nil]) notNil! !!CompositeLintRule methodsFor: 'testing'!isComposite	^true! !!CompositeLintRule methodsFor: 'testing'!isEmpty	^(rules detect: [:each | each isEmpty not] ifNone: [nil]) isNil! !!CompositeLintRule methodsFor: 'initialize-release'!resetResult	rules do: [:each | each resetResult]! !!CompositeLintRule methodsFor: 'initialize-release'!rules: aCollection	rules := aCollection! !!CompositeLintRule methodsFor: 'private' stamp: 'bh 5/9/2000 00:17'!viewResults	rules do: [:each | each viewResults]! !!CompositeLintRule class methodsFor: 'instance creation'!allRules	^self ruleFor: self protocol: 'all checks'! !!CompositeLintRule class methodsFor: 'instance creation'!ruleFor: aClass protocol: aProtocol 	| allRules |	allRules := aClass withAllSubclasses inject: OrderedCollection new				into: 					[:sum :each | 					sum						addAll: ((BrowserEnvironment new selectorsFor: aProtocol asSymbol									in: each class) collect: [:selector | each perform: selector]);						yourself].	^self rules: (allRules asSortedCollection: [:a :b | a name < b name])		name: ((aProtocol asString copy)				at: 1 put: aProtocol first asUppercase;				yourself)! !!CompositeLintRule class methodsFor: 'instance creation'!rules: aCollection 	^self new rules: aCollection! !!CompositeLintRule class methodsFor: 'instance creation'!rules: aCollection name: aString 	^(self new) rules: aCollection;		name: aString;		yourself! !!CompositeLintRule class methodsFor: 'all checks'!lintChecks	^self rules: (BasicLintRule protocols				collect: [:each | self ruleFor: BasicLintRule protocol: each])		name: 'Lint checks'! !!CompositeLintRule class methodsFor: 'all checks' stamp: 'nk 3/5/2005 15:54'!performAllTransformationsOn: anEnvironment	| transformations rc |	transformations := SmalllintChecker runRule: self transformations onEnvironment: anEnvironment.	transformations problemCount isZero ifTrue: [ ^self inform: 'none found!!' ].	rc := RefactoryChangeManager instance.	RefactoryChangeManager undoSize: (RefactoryChangeManager undoSize max: transformations changes size).	transformations changes do: [ :c | rc performChange: c ].	^self inform: ('{1} transformations performed' format: transformations problemCount)! !!CompositeLintRule class methodsFor: 'all checks' stamp: 'nk 3/5/2005 15:52'!previewAllTransformationsOn: anEnvironment	"	CompositeLintRule previewAllTransformationsOn: (BrowserEnvironment new forClasses: {RefactoryTestDataApp})	"	| transformations changes |	transformations := SmalllintChecker runRule: self transformations onEnvironment: anEnvironment.	transformations problemCount isZero ifTrue: [ ^self inform: 'none found!!' ].self halt.	changes := String streamContents: 					[:stream | 					stream						header;						timeStamp;						nextPutAll: '"Result of running all transformations"!!'.					transformations changes do: [ :ch | stream cr; print: ch  ]].	FileContentsBrowser browseStream: changes readStream		named: 'Prospective replacements'! !!CompositeLintRule class methodsFor: 'all checks'!transformations	^self ruleFor: TransformationRule protocol: 'transformations'! !!CompositeLintRuleTest methodsFor: 'accessing'!checkClass: aSmalllintContext 	rules do: 			[:each | 			each checkClass: aSmalllintContext.			Processor yield]! !!CompositeLintRuleTest methodsFor: 'accessing'!checkMethod: aSmalllintContext 	rules do: 			[:each | 			each checkMethod: aSmalllintContext.			Processor yield]! !!CompositeLintRuleTest methodsFor: 'accessing'!failedRules	^rules inject: OrderedCollection new into: [:oc :each | oc addAll: each failedRules; yourself]! !!CompositeLintRuleTest methodsFor: 'accessing'!problemCount	^rules inject: 0 into: [:count :each | count + each problemCount]! !!CompositeLintRuleTest methodsFor: 'accessing'!rules	^rules! !!CompositeLintRuleTest methodsFor: 'testing'!hasConflicts	^(rules detect: [:each | each hasConflicts] ifNone: [nil]) notNil! !!CompositeLintRuleTest methodsFor: 'testing'!isComposite	^true! !!CompositeLintRuleTest methodsFor: 'testing'!isEmpty	^(rules detect: [:each | each isEmpty not] ifNone: [nil]) isNil! !!CompositeLintRuleTest methodsFor: 'initialize-release'!resetResult	rules do: [:each | each resetResult]! !!CompositeLintRuleTest methodsFor: 'initialize-release'!rules: aCollection	rules := aCollection! !!CompositeLintRuleTest methodsFor: 'private'!viewResults	rules do: [:each | each viewResults]! !!CompositeLintRuleTest class methodsFor: 'instance creation'!allRules	^self ruleFor: self protocol: 'all checks'! !!CompositeLintRuleTest class methodsFor: 'instance creation'!ruleFor: aClass protocol: aProtocol 	^self		rules: (((BrowserEnvironment new selectorsFor: aProtocol asSymbol in: aClass class)				collect: [:selector | aClass perform: selector])					asSortedCollection: [:a :b | a name < b name])		name: ((aProtocol asString copy) at: 1 put: aProtocol first asUppercase;				yourself)! !!CompositeLintRuleTest class methodsFor: 'instance creation'!rules: aCollection 	^self new rules: aCollection! !!CompositeLintRuleTest class methodsFor: 'instance creation'!rules: aCollection name: aString 	^(self new) rules: aCollection;		name: aString;		yourself! !!CompositeLintRuleTest class methodsFor: 'all checks'!lintChecks	^self rules: (BasicLintRuleTest protocols				collect: [:each | self ruleFor: BasicLintRuleTest protocol: each])		name: 'Lint checks'! !!CompositeLintRuleTest class methodsFor: 'all checks'!transformations	^self ruleFor: TransformationRuleTest protocol: 'transformations'! !!CompositeLoggingPolicy methodsFor: 'adding'!addPattern: aPattern	self patterns add: aPattern			! !!CompositeLoggingPolicy methodsFor: '*Toothpick-Configuration'!configureFromDictionary: aDictionary	| filters |	filters := Set new.	aDictionary keysAndValuesDo: [ :key :val |		(key findString: 'filter' startingAt: 1) = 1 ifTrue: [			filters add: val]]. 	patterns:= filters collect: [ :filter | LoggingEventPattern fromString: filter].	^self			! !!CompositeLoggingPolicy methodsFor: 'initialize/release'!initialize	patterns := Set new			! !!CompositeLoggingPolicy methodsFor: 'querying'!isInterestingBlock	^[ :event | (self patterns detect: [ :pattern | pattern isInteresting: event] ifNone: [nil]) notNil ]			! !!CompositeLoggingPolicy methodsFor: 'accessing'!patterns	^patterns			! !!CompositeLoggingPolicy class methodsFor: '*Toothpick-Configuration'!mappingKey	^'composite'			! !!CompositeLoggingPolicy class methodsFor: 'instance creation'!new	^super new initialize			! !!CompositeLoggingPolicyTestCase methodsFor: 'accessing'!event	^event			! !!CompositeLoggingPolicyTestCase methodsFor: 'accessing'!event: anObject	event := anObject			! !!CompositeLoggingPolicyTestCase methodsFor: 'accessing'!policy	^policy			! !!CompositeLoggingPolicyTestCase methodsFor: 'accessing'!policy: anObject	policy := anObject			! !!CompositeLoggingPolicyTestCase methodsFor: 'setup'!setUp	LoggingMultiplexer reset			! !!CompositeLoggingPolicyTestCase methodsFor: 'testing' stamp: 'jp 10/12/2006 18:00'!testLoggingEventPatterns	| pattern |	pattern := LoggingEventPattern fromString: 'ui.!!error'.		self assert:( pattern categories includes: #ui);		assert: ( pattern level = 6);		assert: ( pattern comparator = #!!);		deny:( pattern isInteresting: LoggingEvent debugDebug);		assert:( pattern isInteresting: LoggingEvent uiWarning);		deny: ( pattern isInteresting: LoggingEvent uiFatal);		yourself.			pattern := LoggingEventPattern fromString: 'ui.!!=error'.		self assert:( pattern categories includes: #ui);		assert: ( pattern level = 6);		assert: ( pattern comparator = #!!=);		deny:( pattern isInteresting: LoggingEvent debugDebug);		assert:( pattern isInteresting: LoggingEvent uiWarning);		assert:( pattern isInteresting: LoggingEvent uiFatal);		yourself.! !!CompositeLoggingPolicyTestCase methodsFor: 'testing' stamp: 'jp 10/12/2006 18:00'!testMultiLoggingPolicy	| dict |	dict := Dictionary new		at: 'policy' put: 'composite';		at: 'filter1' put: 'perf.=debug';		at: 'filter2' put: 'debug.info';		at: 'filter3' put: 'ui.!!error';		yourself. 	policy := LoggingPolicy configureFromDictionary: dict.	self assert:( policy isInteresting: LoggingEvent uiWarning);		deny: ( policy isInteresting: LoggingEvent uiFatal);		deny:( policy isInteresting: LoggingEvent debugDebug);		assert:( policy isInteresting: LoggingEvent debugInfo);		deny:( policy isInteresting: LoggingEvent performanceWarning);		yourself! !!CompositeRefactoryChange methodsFor: 'comparing'!= aRefactoryBuilder 	self class = aRefactoryBuilder class ifFalse: [^false].	changes size = aRefactoryBuilder changes size ifFalse: [^false].	changes with: aRefactoryBuilder changes		do: [:each :change | each = change ifFalse: [^false]].	^true! !!CompositeRefactoryChange methodsFor: 'comparing'!hash	^changes size! !!CompositeRefactoryChange methodsFor: 'accessing'!addChange: aRefactoryChange 	changes add: aRefactoryChange.	^aRefactoryChange! !!CompositeRefactoryChange methodsFor: 'accessing'!addChangeFirst: aRefactoryChange 	changes addFirst: aRefactoryChange.	^aRefactoryChange! !!CompositeRefactoryChange methodsFor: 'accessing'!changeForClass: aRBClass selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForClass: aRBClass selector: aSelector.			change notNil ifTrue: [^change]].	^nil! !!CompositeRefactoryChange methodsFor: 'accessing'!changeForMetaclass: aSymbol selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForMetaclass: aSymbol selector: aSelector.			change notNil ifTrue: [^change]].	^nil! !!CompositeRefactoryChange methodsFor: 'accessing'!changesSize	^changes inject: 0 into: [:sum :each | sum + each changesSize]! !!CompositeRefactoryChange methodsFor: 'accessing'!problemCount	^self changesSize! !!CompositeRefactoryChange methodsFor: 'accessing'!renameChangesForClass: aClassName to: newClassName 	^(self copy)		changes: (self changes 					collect: [:each | each renameChangesForClass: aClassName to: newClassName]);		yourself! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!addClassVariable: variableName to: aClass 	^self addChange: (AddClassVariableChange add: variableName to: aClass)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!addInstanceVariable: variableName to: aClass 	^self addChange: (AddInstanceVariableChange add: variableName to: aClass)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!addPool: aPoolVariable to: aClass 	^self addChange: (AddPoolVariableChange add: aPoolVariable to: aClass)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!compile: source in: class 	^self addChange: (AddMethodChange compile: source in: class)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!compile: source in: class classified: aProtocol 	^self addChange: (AddMethodChange 				compile: source				in: class				classified: aProtocol)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!defineClass: aString 	^self addChange: (AddClassChange definition: aString)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!removeClass: aClass 	^self addChange: (RemoveClassChange removeClassName: aClass name)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!removeClassNamed: aSymbol 	self addChange: (RemoveClassChange removeClassName: aSymbol)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!removeClassVariable: variableName from: aClass 	^self 		addChange: (RemoveClassVariableChange remove: variableName from: aClass)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!removeInstanceVariable: variableName from: aClass 	^self 		addChange: (RemoveInstanceVariableChange remove: variableName from: aClass)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!removeMethod: aSelector from: aClass 	^self addChange: (RemoveMethodChange remove: aSelector from: aClass)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!renameClass: class to: newName 	^self addChange: (RenameClassChange rename: class name to: newName)! !!CompositeRefactoryChange methodsFor: 'private-inspector accessing'!changes	^changes! !!CompositeRefactoryChange methodsFor: 'private-inspector accessing'!changes: aCollection 	changes := aCollection! !!CompositeRefactoryChange methodsFor: 'private-inspector accessing'!removeChange: aChange 	changes remove: aChange ifAbsent: []! !!CompositeRefactoryChange methodsFor: 'printing'!displayString	^super displayString asText allBold! !!CompositeRefactoryChange methodsFor: 'printing' stamp: 'dvf 9/16/2001 00:56'!printOn: aStream 	name ifNotNil: [aStream nextPutAll: name] ifNil: [aStream nextPutAll: 'a CompositeRefactoringChange']! !!CompositeRefactoryChange methodsFor: 'private'!executeNotifying: aBlock 	| undos undo |	undos := changes collect: [:each | each executeNotifying: aBlock].	undo := self copy.	undo changes: undos reverse.	^undo! !!CompositeRefactoryChange methodsFor: 'private'!flattenOnto: aCollection 	changes do: [:each | each flattenOnto: aCollection]! !!CompositeRefactoryChange methodsFor: 'initialize-release'!initialize	super initialize.	changes := OrderedCollection new! !!CompositeRefactoryChange methodsFor: 'user interface' stamp: 'bh 11/8/2000 13:45'!inspect	"CompositeRefactoryChangeInspector openOn: self"	self needsWork.	^super inspect.! !!CompositeRefactoryChange methodsFor: 'copying'!postCopy	super postCopy.	changes := changes collect: [:each | each copy]! !!CompositeRefactoryChange class methodsFor: 'instance creation'!named: aString 	^(self new)		name: aString;		yourself! !!Context methodsFor: 'testing' stamp: 'ms 10/4/2007 14:28'!activate	active := true! !!Context methodsFor: 'testing' stamp: 'ms 10/4/2007 14:27'!deactivate	active := false! !!Context methodsFor: 'testing' stamp: 'ms 10/4/2007 14:28'!initialize	active := false! !!Context methodsFor: 'testing' stamp: 'ms 10/4/2007 14:26'!isActive	^active! !!Context methodsFor: 'testing' stamp: 'ms 11/8/2007 13:28'!notActive	^self isActive not! !!Context methodsFor: 'testing' stamp: 'ms 10/4/2007 14:55'!setActive: aBool	active := aBool! !!Context methodsFor: 'testing' stamp: 'md 7/26/2007 12:31'!value	^self isActive! !!Context class methodsFor: 'as yet unclassified' stamp: 'ms 10/31/2007 15:59'!current	^Processor activeProcess ctxtEnvironmentAt: self ifAbsentPut:[self new]! !!ContextDoItScope methodsFor: 'lookup' stamp: 'ajh 7/8/2004 17:06'!captureVar: name	"Don't convert temps to captured"	^ self lookupVar: name! !!ContextDoItScope methodsFor: 'parent env' stamp: 'ajh 7/8/2004 17:56'!closestEnvScope	"my temps are like inst vars, hence my own environment"	^ self! !!ContextDoItScope methodsFor: 'emitting' stamp: 'md 6/13/2005 13:58'!emitEnvParentEnv: methodBuilder	methodBuilder pushInstVar: (MethodContext allInstVarNames indexOf: #receiver).	"return which scope my receiver points to"	^ self outerEnvScope! !!ContextDoItScope methodsFor: 'emitting' stamp: 'md 3/10/2006 15:55'!emitLocalParentEnv: methodBuilder	"local parent is held in receiver"	"return which scope my receiver points to"	^ self outerEnvScope! !!ContextDoItScope methodsFor: 'emitting' stamp: 'md 6/13/2005 13:58'!emitMyEnv: methodBuilder	self flag: #myEnv.	methodBuilder pushInstVar: MethodContext myEnvFieldIndex.! !!ContextDoItScope methodsFor: 'initializing' stamp: 'ajh 7/8/2004 19:53'!hideOuterTemps	"Hide outer temps so they don't get captured (becuase they weren't captured and their values are not in the do-it env chain)"	self outerScope tempsAreNoLongerAvailable! !!ContextDoItScope methodsFor: 'scope' stamp: 'ajh 7/8/2004 17:15'!isDoItScope	^ true! !!ContextPart methodsFor: 'accessing' stamp: 'md 2/9/2007 17:34'!tempNamed: aName	"Answer the value of the temporary variable whose name is the 	argument, aName."	self subclassResponsibility! !!ContextPart methodsFor: 'accessing' stamp: 'md 2/9/2007 17:34'!tempNamed: aName put: value 	"Store the argument, value, as the temporary variable whose name is the 	argument, aName."	self subclassResponsibility! !!ContextPart methodsFor: '*persephone' stamp: 'md 9/28/2007 15:55'!methodNodeFromSource	self method isBlockMethod ifTrue: [^ self method blockNode].	^ self method methodNodeFromSource.! !!ContextPart methodsFor: '*geppetto2' stamp: 'md 12/13/2007 09:59'!gpsender	^(sender receiver isKindOf: ReflectiveMethod) 		ifTrue: [sender sender]		ifFalse: [sender].! !!ContextTODO methodsFor: 'as yet unclassified' stamp: 'md 12/13/2007 09:24'!brainstorming	'		self inContext: MyContext do: [	--> MyContext is *on* here	]	'! !!ContextTODO methodsFor: 'as yet unclassified' stamp: 'md 12/13/2007 14:23'!todo'	- GeppettoTest shows that #sender and #senderselector are broken with context	- When enabeling #linksAreContextual, there is a problem running GeppettoTest	'! !!ContextTest methodsFor: 'tests' stamp: 'md 7/26/2007 14:40'!testDeploymentContext		Preferences enable: #deploymentContext.		self assert: Preferences deploymentContext.	self assert: DeploymentContext current isActive.	Preferences disable: #deploymentContext.			self deny: Preferences deploymentContext.	self deny: DeploymentContext current isActive.	! !!ContextTest methodsFor: 'setup' stamp: 'ms 11/13/2007 16:35'!setup	gplink := nil.	MetaContext allInstancesDo: [:each | each deactivate]! !!ContextTest methodsFor: 'setup' stamp: 'ms 10/3/2007 15:50'!tearDown	gplink ifNotNil: [gplink uninstall].		GPExamples methodDict values do: [:method |		self removeLinks: method.		self assertNoLinks: method. 	].! !!ContextTest methodsFor: 'tools' stamp: 'ms 10/3/2007 15:50'!assertNoLinks: aMethod	aMethod  nodes do: [:node | self assert: node hasAnyLink not].! !!ContextTest methodsFor: 'tools' stamp: 'ms 10/3/2007 15:50'!removeLinks: aMethod	aMethod reflectiveMethod methodNode nodesDo: [:node |		node hasAnyLink ifTrue: [node removeAllLinks]].! !!CreateAccessorsForVariableRefactoring methodsFor: 'initialize-release'!classVariable: aBoolean 	classVariable := aBoolean! !!CreateAccessorsForVariableRefactoring methodsFor: 'transforming'!createGetterAccessor	getterMethod := self findGetterMethod.	getterMethod isNil ifTrue: [getterMethod := self defineGetterMethod]! !!CreateAccessorsForVariableRefactoring methodsFor: 'transforming'!createSetterAccessor	setterMethod := self findSetterMethod.	setterMethod isNil ifTrue: [setterMethod := self defineSetterMethod]! !!CreateAccessorsForVariableRefactoring methodsFor: 'transforming' stamp: 'dc 4/4/2007 16:41'!defineGetterMethod	| selector definingClass |	definingClass := self definingClass.	selector := self safeMethodNameFor: definingClass				basedOn: variableName asString.	definingClass 		compile: ('<1s><n><t>^ <2s>' expandMacrosWith: selector with: variableName)		classified: #(#accessing).	^selector! !!CreateAccessorsForVariableRefactoring methodsFor: 'transforming' stamp: 'dc 4/4/2007 16:41'!defineSetterMethod	| selector definingClass string |	definingClass := self definingClass.	string := self needsReturnForSetter 				ifTrue: ['<1s> anObject<n><t>^ <2s> := anObject']				ifFalse: ['<1s> anObject<n><t><2s> := anObject'].	selector := self safeMethodNameFor: definingClass				basedOn: variableName asString , ':'.	definingClass 		compile: (string expandMacrosWith: selector with: variableName)		classified: #accessing.	^selector! !!CreateAccessorsForVariableRefactoring methodsFor: 'transforming'!transform	self		createGetterAccessor;		createSetterAccessor! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!definingClass	^classVariable ifTrue: [class metaclass] ifFalse: [class]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!findGetterMethod	| definingClass matcher |	definingClass := self definingClass.	matcher := ParseTreeSearcher getterMethod: variableName.	^self possibleGetterSelectors detect: 			[:each | 			(self 				checkClass: definingClass				selector: each				using: matcher) notNil 				and: [(definingClass subclassRedefines: each) not]]		ifNone: [nil]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!findSetterMethod	| definingClass matcher |	definingClass := self definingClass.	matcher := self needsReturnForSetter 				ifTrue: [ParseTreeSearcher returnSetterMethod: variableName]				ifFalse: [ParseTreeSearcher setterMethod: variableName].	^self possibleSetterSelectors detect: 			[:each | 			(self 				checkClass: definingClass				selector: each				using: matcher) notNil 				and: [(definingClass subclassRedefines: each) not]]		ifNone: [nil]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!getterMethod	^getterMethod! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!methodsReferencingVariable	^classVariable 		ifTrue: [self definingClass whichSelectorsReferToClassVariable: variableName]		ifFalse: 			[self definingClass whichSelectorsReferToInstanceVariable: variableName]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!possibleGetterSelectors	^self methodsReferencingVariable select: [:each | each numArgs == 0]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!possibleSetterSelectors	^self methodsReferencingVariable select: [:each | each numArgs == 1]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!setterMethod	^setterMethod! !!CreateAccessorsForVariableRefactoring methodsFor: 'testing'!needsReturnForSetter	needsReturn isNil 		ifTrue: 			[needsReturn := self 						usesAssignmentOf: variableName						in: class						classVariable: classVariable].	^needsReturn! !!CreateAccessorsForVariableRefactoring methodsFor: 'testing'!usesAssignmentOf: aString in: aClass classVariable: isClassVar 	| matcher definingClass |	matcher := ParseTreeSearcher new.	matcher		answer: false;		matches: aString , ' := ``@object'			do: [:aNode :answer | answer or: [aNode isUsed]].	definingClass := isClassVar ifTrue: [aClass nonMetaclass] ifFalse: [aClass].	^(definingClass withAllSubclasses , (isClassVar 				ifTrue: [definingClass metaclass withAllSubclasses]				ifFalse: [#()]) 		detect: 			[:each | 			((isClassVar 				ifTrue: [each whichSelectorsReferToClassVariable: aString]				ifFalse: [each whichSelectorsReferToInstanceVariable: aString]) detect: 						[:sel | 						self 							checkClass: each							selector: sel							using: matcher]					ifNone: [nil]) notNil]		ifNone: [nil]) notNil! !!CreateAccessorsForVariableRefactoring methodsFor: 'preconditions'!preconditions	^classVariable 		ifTrue: [RBCondition definesClassVariable: variableName asSymbol in: class]		ifFalse: [RBCondition definesInstanceVariable: variableName in: class]! !!CreateAccessorsForVariableRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' variable: '.	variableName storeOn: aStream.	aStream nextPutAll: ' class: '.	class storeOn: aStream.	aStream nextPutAll: ' classVariable: '.	classVariable storeOn: aStream.	aStream nextPut: $)! !!CreateAccessorsForVariableRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk variable: aVarName class: aClass classVariable: aBoolean 	^(self 		model: aRBSmalltalk		variable: aVarName		class: aClass)		classVariable: aBoolean;		yourself! !!CreateAccessorsForVariableRefactoring class methodsFor: 'instance creation'!variable: aVarName class: aClass classVariable: aBoolean 	^(self variable: aVarName class: aClass)		classVariable: aBoolean; yourself! !!CreateAccessorsForVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!CreateAccessorsForVariableTest methodsFor: 'tests'!testExistingInstanceVariableAccessors	| ref |	ref := CreateAccessorsForVariableRefactoring 				variable: 'name'				class: LintRuleTest				classVariable: false.	self executeRefactoring: ref.	self assert: ref changes changes isEmpty.	self assert: ref setterMethod == #name:.	self assert: ref getterMethod == #name! !!CreateAccessorsForVariableTest methodsFor: 'tests'!testNewClassVariableAccessors	| ref class |	ref := CreateAccessorsForVariableRefactoring 				variable: 'Foo1'				class: LintRuleTest				classVariable: true.	self executeRefactoring: ref.	class := ref model metaclassNamed: #LintRuleTest.	self deny: ref changes changes isEmpty.	self assert: ref setterMethod == #foo1:.	self assert: ref getterMethod == #foo1.	self 		assert: (class parseTreeFor: #foo1) = (RBParser parseMethod: 'foo1 ^Foo1').	self assert: (class parseTreeFor: #foo1:) 				= (RBParser parseMethod: 'foo1: anObject Foo1 := anObject')! !!CreateAccessorsForVariableTest methodsFor: 'tests'!testNewInstanceVariableAccessors	| ref class |	ref := CreateAccessorsForVariableRefactoring 				variable: 'foo1'				class: LintRuleTest				classVariable: false.	self executeRefactoring: ref.	class := ref model classNamed: #LintRuleTest.	self deny: ref changes changes isEmpty.	self assert: ref setterMethod == #foo1:.	self assert: ref getterMethod == #foo1.	self 		assert: (class parseTreeFor: #foo1) = (RBParser parseMethod: 'foo1 ^foo1').	self assert: (class parseTreeFor: #foo1:) 				= (RBParser parseMethod: 'foo1: anObject foo1 := anObject')! !!CreateAccessorsForVariableTest methodsFor: 'failure tests'!testNonExistantName	self		shouldFail: (CreateAccessorsForVariableRefactoring 					variable: #Foo					class: BasicLintRuleTest					classVariable: true);		shouldFail: (CreateAccessorsForVariableRefactoring 					variable: 'foo'					class: BasicLintRuleTest					classVariable: true)! !!D commentStamp: 'Y.-G.G. 4/14/2014 16:06' prior: 0!Class use as example for the Reflection Scenario 3.!!D class methodsFor: 'as yet unclassified' stamp: 'Y.-G.G. 4/14/2014 16:20'!individualClassNumberOfInstances    ^ IndividualClassNumberOfInstances.! !!D class methodsFor: 'as yet unclassified' stamp: 'Y.-G.G. 4/14/2014 16:22'!initialize    IndividualClassNumberOfInstances := 0.! !!D class methodsFor: 'as yet unclassified' stamp: 'Y.-G.G. 4/14/2014 16:22'!new    NumberOfInstances := NumberOfInstances + 1.    IndividualClassNumberOfInstances := IndividualClassNumberOfInstances + 1.    ^ self basicNew initialize.! !!D class methodsFor: 'as yet unclassified' stamp: 'Y.-G.G. 4/14/2014 16:13'!numberOfInstances    ^ NumberOfInstances.! !!DateAndTime methodsFor: '*Toothpick-Core' stamp: 'jp 10/13/2006 12:57'!millisecond	^ nanos // (10 raisedToInteger: 6)! !!DateAndTime methodsFor: '*Toothpick-Core' stamp: 'jp 10/13/2006 12:21'!toothpickPrintString	| stream |	stream := WriteStream on: (String new: 32).	ISO8601TimestampFormatter new formatTimestamp: self on: stream.	^stream contents			! !!DateTimeTimestampFormatter methodsFor: 'converting'!formatTimestamp: aTimestamp on: stream	self		print: aTimestamp day			on: stream			followedBy: Character space			width: 2.	stream nextPutAll: (self monthNames at: aTimestamp month); space.	self		print: aTimestamp year			on: stream			followedBy: Character space			width: 4.	self		print: aTimestamp hour			on: stream			followedBy: $:			width: 2;		print: aTimestamp minute			on: stream			followedBy: $:			width: 2;		print: aTimestamp second			on: stream			followedBy: $,			width: 2;		print: aTimestamp millisecond			on: stream			followedBy: nil			width: 3.	^stream contents			! !!DateTimeTimestampFormatter methodsFor: 'converting'!monthNames	^#('Jan' 'Feb' 'Mar' 'Apr' 'May' 'Jun' 'Jul' 'Aug' 'Sep' 'Oct' 'Nov' 'Dec')			! !!DateTimeTimestampFormatter class methodsFor: '*Toothpick-Configuration'!mappingKey	^'dateTime'			! !!Debugger methodsFor: '*persephone-override' stamp: 'md 9/28/2007 15:56' prior: 19614268!contents: aText notifying: aController 	"The retrieved information has changed and its source must now be  	updated. In this case, the retrieved information is the method of the  	selected context."	| selector classOfMethod category h ctxt originalClassOfMethod |	contextStackIndex = 0		ifTrue: [^ false].	self selectedContext isExecutingBlock		ifTrue: [h := self selectedContext finalBlockHome.			h				ifNil: [self inform: 'Method not found for block, can''t edit'.					^ false].			(self confirm: 'I will have to revert to the method fromwhich this block originated.  Is that OK?')				ifTrue: [self resetContext: h]				ifFalse: [^ false]].	classOfMethod := self selectedClass.	category := self selectedMessageCategoryName.	selector := self selectedClass parserClass new parseSelector: aText.	selector == self selectedMessageName		ifFalse: [self inform: 'can''t change selector'.			^ false].	originalClassOfMethod := classOfMethod traitOrClassOfSelector: selector.	selector := originalClassOfMethod				compile: aText				classified: category				notifying: aController.	selector		ifNil: [^ false].	"compile cancelled"	contents := aText.	ctxt := interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext ifFalse: [		self inform: 'Method saved, but current context unchangedbecause of unwind error. Click OK to see error'.	] ifTrue: [		interruptedProcess			restartTopWith: (classOfMethod compiledMethodAt: selector);		 	stepToSendOrReturn.		contextVariablesInspector object: nil.		theMethodNode := Preferences browseWithPrettyPrint			ifTrue: [ctxt methodNodeFormattedAndDecorated: Preferences colorWhenPrettyPrinting]			ifFalse: [ctxt methodNodeFromSource].		sourceMap := theMethodNode sourceMap.		tempNames := theMethodNode tempNames.	].	self resetContext: ctxt.	^ true! !!Debugger methodsFor: '*persephone-override' stamp: 'md 9/28/2007 15:54' prior: 19617631!contextStackIndex: anInteger oldContextWas: oldContext 	"Change the context stack index to anInteger, perhaps in response to user selection."	| newMethod c |	contextStackIndex := anInteger.	anInteger = 0		ifTrue: [currentCompiledMethod := theMethodNode := tempNames := sourceMap := contents := nil.			self changed: #contextStackIndex.			self decorateButtons.			self contentsChanged.			contextVariablesInspector object: nil.			self receiverInspectorObject: self receiver context: nil.			^ self].	(newMethod := oldContext == nil					or: [oldContext method ~~ (currentCompiledMethod := self selectedContext method)])		ifTrue: [tempNames := sourceMap := nil.			theMethodNode := Preferences browseWithPrettyPrint				ifTrue: [ 	self selectedContext methodNodeFormattedAndDecorated: Preferences colorWhenPrettyPrinting ]				ifFalse: [	self selectedContext methodNodeFromSource ].			contents := self selectedMessage.			self contentsChanged.			self pcRange			"will compute tempNamesunless noFrills"].	self changed: #contextStackIndex.	self decorateButtons.	tempNames == nil		ifTrue: [tempNames := self selectedClassOrMetaClass parserClass new parseArgsAndTemps: contents notifying: nil].	contextVariablesInspector object: (c _ self selectedContext).	self receiverInspectorObject: self receiver context: c.	newMethod		ifFalse: [self changed: #contentsSelection]! !!Decompiler2 methodsFor: 'compiling' stamp: 'ajh 3/13/2003 21:09'!decompile: aMethod	"Answer a MethodNode that is the root of the parse tree for the argument, aMethod.  Selector will be 'unknown' and inst vars will be 'instVarN'.  selector and class can be placed in resulting MethodNode later"	^self		decompile: nil		in: nil		method: aMethod! !!Decompiler2 methodsFor: 'public access' stamp: 'ajh 3/13/2003 21:09'!decompile: aSelector in: aClass 	"See Decompiler|decompile:in:method:. The method is found by looking up 	the message, aSelector, in the method dictionary of the class, aClass."	^self		decompile: aSelector		in: aClass		method: (aClass compiledMethodAt: aSelector)! !!Decompiler2 methodsFor: 'public access' stamp: 'ms 6/15/2007 14:08'!decompile: selector in: aClass method: aMethod	"Answer a MethodNode that is the root of the parse tree for the 	argument, aMethod, which is the CompiledMethod associated with the 	message, aSelector. Variables are determined with respect to the 	argument, aClass."	| ird methodNode |	ird := IRDecompiler new.	ird scope: aClass parseScope newMethodScope.	(ird scope addTemp: 'self') markArg.	methodNode := ird decompileIR: aMethod ir.	selector ifNotNil: [[methodNode selector: selector] on: Error do: []].	^ methodNode! !!Decompiler2 methodsFor: 'public access' stamp: 'md 2/27/2006 12:33'!decompileBlock: aBlock	"Answer a BlockNode, not done yet... return nil."	^nil.			"ird _ IRDecompiler new.	ird scope: nil parseScope newBlockScope.	^ (ird decompileIR: aBlock ir) asBlock"! !!Decompiler2 methodsFor: 'initialize-release' stamp: 'ajh 3/15/2003 15:57'!withTempNames: tempNameArray! !!Decompiler2 commentStamp: 'ajh 3/25/2003 00:28' prior: 0!This mirrors the old Decompiler interface delegating the real work to BytecodeDecompiler then IRDecompiler.!!DeploymentContext methodsFor: 'as yet unclassified' stamp: 'ms 10/4/2007 14:30'!isActive	^Preferences deploymentContext! !!DeploymentContext class methodsFor: 'as yet unclassified' stamp: 'md 7/26/2007 11:55'!initialize	Preferences		addPreference: #deploymentContext		category: #contexts		default: false		balloonHelp: 'If true, DeploymentContext is active.'! !!Dictionary methodsFor: '*context' stamp: 'ms 10/31/2007 15:56'!ctxtAt: key ifAbsentPut: aBlock 	"	Only for context awar link of geppetto.		Return the value at the given key. 	If key is not included in the receiver store the result 	of evaluating aBlock as new value."	^ self at: key ifAbsent: [self ctxtAt: key put: aBlock value]! !!Dictionary methodsFor: '*context' stamp: 'ms 10/31/2007 16:01'!ctxtAt: key put: anObject 	"	Only for context awar link of geppetto.	Set the value at key to be anObject.  If key is not found, create a	new entry for key and set is value to anObject. Answer anObject."	| index assoc |	index := self findElementOrNil: key.	assoc := array at: index.	assoc		ifNil: [self ctxtAtNewIndex: index put: (Association key: key value: anObject)]		ifNotNil: [assoc value: anObject].	^ anObject! !!Dictionary methodsFor: '*context' stamp: 'ms 11/1/2007 13:02'!ctxtNoCheckAdd: anObject	"Only for context awar link of geppetto.	Must be defined separately for Dictionary because (self findElementOrNil:) expects a key, not an association.  9/7/96 tk"	array ctxtAt: (self findElementOrNil: anObject key) put: anObject.	tally := tally + 1! !!DynamicVariable commentStamp: 'mvl 3/13/2007 13:55' prior: 0!My subclasses are dynamic variables: each subclass represents a variablewhose value persists inside the block passed to #value:during:. There isno way to change the value inside such a block, but it is possible totemporarirly rebind it in a nested manner.!!DynamicVariable class methodsFor: 'accessing' stamp: 'mvl 3/13/2007 14:26'!value: anObject during: aBlock	| p oldValue |		p := Processor activeProcess.	oldValue := p environmentAt: self ifAbsent: [self default].	[		p environmentAt: self put: anObject.		aBlock value.	] ensure: [ 		p environmentAt: self put: oldValue 	].! !!ElapsedTimestampFormatter methodsFor: 'converting' stamp: 'jp 10/13/2006 12:53'!formatTimestamp: aTimestamp on: stream	stream print: (aTimestamp - ts) asMilliSeconds.	^stream contents			! !!ElapsedTimestampFormatter methodsFor: 'initialize'!initialize	ts := LoggingEvent timestampClass now			! !!ElapsedTimestampFormatter methodsFor: 'accessing'!ts	^ts			! !!ElapsedTimestampFormatter methodsFor: 'accessing'!ts: anObject	ts := anObject			! !!ElapsedTimestampFormatter class methodsFor: '*Toothpick-Configuration'!mappingKey	^'elapsed'			! !!ElapsedTimestampFormatter class methodsFor: 'instance creation'!new	^super new initialize			! !!EmitIfNilTest methodsFor: 'tests' stamp: 'ms 4/23/2007 15:33'!testIfNilIfNotNil0Arg		| notNilNode nilNode |	self shouldnt: [ notNilNode := ClosureCompiler new parseClosure: 'test ^5 ifNil: [#foo] ifNotNil: [#bar]' in: self class notifying: nil] raise: Error.	self shouldnt: [ nilNode := ClosureCompiler new parseClosure: 'test ^nil ifNil: [#foo] ifNotNil: [#bar]' in: self class notifying: nil] raise: Error.	self assert: (notNilNode generate valueWithReceiver: self arguments:#()) == #bar.	self assert: (nilNode generate valueWithReceiver: self arguments:#()) == #foo! !!EmitIfNilTest methodsFor: 'tests' stamp: 'ms 4/23/2007 15:39'!testIfNilIfNotNil0ArgAsVar	| notNilNode nilNode |	self shouldnt: [ notNilNode := ClosureCompiler new parseClosure: 'test | block1 block2 | block1 := [#foo]. block2 := [#bar]. ^5 ifNil: block1 ifNotNil: block2' in: self class notifying: nil] raise: Error.	self shouldnt: [ nilNode := ClosureCompiler new parseClosure: 'test | block1 block2 | block1 := [#foo]. block2 := [#bar]. ^nil ifNil: block1 ifNotNil: block2' in: self class notifying: nil] raise: Error.	self assert: (notNilNode generate valueWithReceiver: self arguments:#()) == #bar.	self assert: (nilNode generate valueWithReceiver: self arguments:#()) == #foo! !!EmitIfNilTest methodsFor: 'tests' stamp: 'ms 4/23/2007 15:41'!testIfNilIfNotNil1Arg	| notNilNode nilNode |	self shouldnt: [ notNilNode := ClosureCompiler new parseClosure: 'test ^5 ifNil: [#foo] ifNotNil: [:a | a printString]' in: self class notifying: nil] raise: Error.	self shouldnt: [ nilNode := ClosureCompiler new parseClosure: 'test ^nil ifNil: [#foo] ifNotNil: [:a | a printString]' in: self class notifying: nil] raise: Error.	self assert: (notNilNode generate valueWithReceiver: self arguments:#()) = '5'.	self assert: (nilNode generate valueWithReceiver: self arguments:#()) == #foo! !!EmitIfNilTest methodsFor: 'tests' stamp: 'ms 4/23/2007 15:42'!testIfNilIfNotNil1ArgAsVar	| notNilNode nilNode |	self shouldnt: [ notNilNode := ClosureCompiler new 									parseClosure: 'test | block1 block2 | block1 := [#foo]. block2 := [:a | a printString]. ^5 ifNil: block1 ifNotNil: block2' 									in: self class notifying: nil] raise: Error.	self shouldnt: [ nilNode := ClosureCompiler new 									parseClosure: 'test | block1 block2 | block1 := [#foo]. block2 := [:a | a printString]. ^nil ifNil: block1 ifNotNil: block2' 									in: self class notifying: nil] raise: Error.	self assert: (notNilNode generate valueWithReceiver: self arguments:#()) = '5'.	self assert: (nilNode generate valueWithReceiver: self arguments:#()) == #foo! !!EmitIfNilTest methodsFor: 'tests' stamp: 'ms 4/23/2007 15:46'!testIfNotNil0Arg	| notNilNode nilNode |	self shouldnt: [ notNilNode := ClosureCompiler new 									parseClosure: 'test ^5 ifNotNil: [#foo]' 									in: self class notifying: nil] raise: Error.	self shouldnt: [ nilNode := ClosureCompiler new 									parseClosure: 'test ^nil ifNotNil: [#foo]' 									in: self class notifying: nil] raise: Error.	self assert: (notNilNode generate valueWithReceiver: self arguments:#()) == #foo.	self assert: (nilNode generate valueWithReceiver: self arguments:#()) == nil! !!EmitIfNilTest methodsFor: 'tests' stamp: 'ms 4/23/2007 15:47'!testIfNotNil0ArgAsVar	| notNilNode nilNode |	self shouldnt: [ notNilNode := ClosureCompiler new 									parseClosure: 'test | block | block := [#foo]. ^5 ifNotNil: block' 									in: self class notifying: nil] raise: Error.	self shouldnt: [ nilNode := ClosureCompiler new 									parseClosure: 'test | block | block := [#foo]. ^nil ifNotNil: block' 									in: self class notifying: nil] raise: Error.	self assert: (notNilNode generate valueWithReceiver: self arguments:#()) == #foo.	self assert: (nilNode generate valueWithReceiver: self arguments:#()) == nil! !!EmitIfNilTest methodsFor: 'tests' stamp: 'ms 4/23/2007 17:36'!testIfNotNil1Arg	| notNilNode nilNode |	self shouldnt: [ notNilNode := ClosureCompiler new 									parseClosure: 'test | block | block := [:a | a printString]. ^5 ifNotNil: block' 									in: self class notifying: nil] raise: Error.	self shouldnt: [ nilNode := ClosureCompiler new 									parseClosure: 'test | block | block := [:a | a printString]. ^nil ifNotNil: block' 									in: self class notifying: nil] raise: Error.	self assert: (notNilNode generate valueWithReceiver: self arguments:#()) = '5'.	self assert: (nilNode generate valueWithReceiver: self arguments:#()) == nil! !!EmitIfNilTest methodsFor: 'tests' stamp: 'ms 4/23/2007 15:51'!testIfNotNilIfNil0Arg		| notNilNode nilNode |	self shouldnt: [ notNilNode := ClosureCompiler new parseClosure: 'test ^5 ifNotNil: [#bar] ifNil: [#foo]' in: self class notifying: nil] raise: Error.	self shouldnt: [ nilNode := ClosureCompiler new parseClosure: 'test ^nil ifNotNil: [#bar] ifNil: [#foo]' in: self class notifying: nil] raise: Error.	self assert: (notNilNode generate valueWithReceiver: self arguments:#()) == #bar.	self assert: (nilNode generate valueWithReceiver: self arguments:#()) == #foo! !!EmitIfNilTest methodsFor: 'tests' stamp: 'ms 4/23/2007 15:52'!testIfNotNilIfNil0ArgAsVar	| notNilNode nilNode |	self shouldnt: [ notNilNode := ClosureCompiler new parseClosure: 'test | block1 block2 | block1 := [#foo]. block2 := [#bar]. ^5 ifNotNil: block2 ifNil: block1' in: self class notifying: nil] raise: Error.	self shouldnt: [ nilNode := ClosureCompiler new parseClosure: 'test | block1 block2 | block1 := [#foo]. block2 := [#bar]. ^nil ifNotNil: block2 ifNil: block1' in: self class notifying: nil] raise: Error.	self assert: (notNilNode generate valueWithReceiver: self arguments:#()) == #bar.	self assert: (nilNode generate valueWithReceiver: self arguments:#()) == #foo! !!EmitIfNilTest methodsFor: 'tests' stamp: 'ms 4/23/2007 15:52'!testIfNotNilIfNil1Arg	| notNilNode nilNode |	self shouldnt: [ notNilNode := ClosureCompiler new parseClosure: 'test ^5 ifNotNil: [:a | a printString] ifNil: [#foo]' in: self class notifying: nil] raise: Error.	self shouldnt: [ nilNode := ClosureCompiler new parseClosure: 'test ^nil ifNotNil: [:a | a printString] ifNil: [#foo]' in: self class notifying: nil] raise: Error.	self assert: (notNilNode generate valueWithReceiver: self arguments:#()) = '5'.	self assert: (nilNode generate valueWithReceiver: self arguments:#()) == #foo! !!EmitIfNilTest methodsFor: 'tests' stamp: 'ms 4/23/2007 15:53'!testIfNotNilIfNil1ArgAsVar	| notNilNode nilNode |	self shouldnt: [ notNilNode := ClosureCompiler new 									parseClosure: 'test | block1 block2 | block1 := [#foo]. block2 := [:a | a printString]. ^5 ifNotNil: block2 ifNil: block1' 									in: self class notifying: nil] raise: Error.	self shouldnt: [ nilNode := ClosureCompiler new 									parseClosure: 'test | block1 block2 | block1 := [#foo]. block2 := [:a | a printString]. ^nil ifNotNil: block2 ifNil: block1' 									in: self class notifying: nil] raise: Error.	self assert: (notNilNode generate valueWithReceiver: self arguments:#()) = '5'.	self assert: (nilNode generate valueWithReceiver: self arguments:#()) == #foo! !!EvaluateAtCompiletimeAnnotation methodsFor: 'testing' stamp: 'pmm 1/14/2006 14:37'!isSourceVisible	^true! !!EvaluateAtCompiletimeAnnotation class methodsFor: 'accessing' stamp: 'pmm 1/14/2006 14:37'!evaluteAtCompiletimeAnnotaionKey	^#evaluteAtCompiletime! !!EvaluateAtCompiletimeAnnotation class methodsFor: 'accessing' stamp: 'pmm 1/14/2006 14:38'!keys	^Array with: self evaluteAtCompiletimeAnnotaionKey! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!computePoolsToMove	| poolVariables searcher |	poolVariables := self poolVariableNamesFor: fromClass.	pools := Set new.	searcher := ParseTreeSearcher new.	searcher matches: '`var'		do: 			[:aNode :answer | 			| varName pool |			varName := aNode name.			(aNode whoDefines: varName) isNil 				ifTrue: 					[(poolVariables includes: varName) 						ifTrue: 							[pool := self whichPoolDefines: varName.							pool notNil ifTrue: [pools add: pool]]]].	searcher executeTree: parseTree! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!movePool: aSymbol toClass: aClass 	| nonMetaClass |	nonMetaClass := aClass nonMetaclass.	(nonMetaClass definesPoolDictionary: aSymbol) 		ifFalse: [nonMetaClass addPoolDictionary: aSymbol]! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!movePoolVariables	pools 		do: [:poolDict | toClasses do: [:each | self movePool: poolDict toClass: each]]! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!poolVariableNamesIn: poolName 	^(Smalltalk at: poolName ifAbsent: [Dictionary new]) keys 		collect: [:name | name asString]! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!transform	self computePoolsToMove.	self hasPoolsToMove 		ifTrue: 			[self 				refactoringWarning: 'This method contains references to pools<n>which may need to be moved.' 						expandMacros].	self movePoolVariables! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!whichPoolDefines: varName 	| currentClass |	currentClass := fromClass.	[currentClass isNil] whileFalse: 			[currentClass allPoolDictionaryNames 				do: [:each | ((self poolVariableNamesIn: each) includes: varName) ifTrue: [^each]].			currentClass := currentClass superclass].	^nil! !!ExpandReferencedPoolsRefactoring methodsFor: 'initialize-release'!forMethod: aParseTree fromClass: aClass toClasses: classCollection 	fromClass := self model classFor: aClass.	parseTree := aParseTree.	toClasses := classCollection collect: [:each | self model classFor: each]! !!ExpandReferencedPoolsRefactoring methodsFor: 'testing'!hasPoolsToMove	^pools isEmpty not! !!ExpandReferencedPoolsRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition empty! !!ExpandReferencedPoolsRefactoring class methodsFor: 'instance creation'!forMethod: aParseTree fromClass: aClass toClasses: classCollection 	^(self new)		forMethod: aParseTree			fromClass: aClass			toClasses: classCollection;		yourself! !!ExpandReferencedPoolsRefactoring class methodsFor: 'instance creation'!model: aRBNamespace forMethod: aParseTree fromClass: aClass toClasses: classCollection 	^(self new)		model: aRBNamespace;		forMethod: aParseTree			fromClass: aClass			toClasses: classCollection;		yourself! !!ExternalIRCFiles methodsFor: 'see class side' stamp: 'sbw 5/23/2004 22:11'!nothingHappensOnInstanceSide! !!ExternalIRCFiles commentStamp: '<historical>' prior: 0!Handles the management and definition of all external files for IRC client.  This includes logs and channel lists.  Profiles will be handled in the future.Directory structure will be as follows off of the main Squeak root directory:irc  profiles (future)    profile files for each profile (future)  servers    server-name-1      channels        channel list for server-1      logs        channel traffic log files for each channel logged    server-name-2      channels        channel list for server-2      logs        channel traffic log files for each channel logged!!ExternalIRCFiles class methodsFor: 'channels list' stamp: 'sbw 5/23/2004 22:16'!channelsFolderName	^'channels'! !!ExternalIRCFiles class methodsFor: 'channels list' stamp: 'sbw 5/24/2004 18:09'!folderForChannelsListOnServerAddress: aString 	| dir subFolderName |	dir := self folderForServerAddress: aString.	subFolderName := self channelsFolderName.	(dir directoryExists: subFolderName)		ifFalse: [dir createDirectory: subFolderName].	^ dir directoryNamed: subFolderName! !!ExternalIRCFiles class methodsFor: 'errors' stamp: 'sbw 5/30/2004 09:15'!ensureErrorsFolder	self rootFolder assureExistenceOfPath: self errorsFolderName! !!ExternalIRCFiles class methodsFor: 'errors' stamp: 'sbw 5/30/2004 09:14'!errorsFolder	^ self rootFolder directoryNamed: self errorsFolderName! !!ExternalIRCFiles class methodsFor: 'errors' stamp: 'sbw 5/30/2004 09:13'!errorsFolderName	^ 'errors'! !!ExternalIRCFiles class methodsFor: 'private' stamp: 'sbw 5/23/2004 22:21'!ensureRootFolder	FileDirectory default assureExistenceOfPath: self rootFolderName! !!ExternalIRCFiles class methodsFor: 'private' stamp: 'sbw 5/23/2004 22:22'!rootFolder	^FileDirectory default directoryNamed: self rootFolderName! !!ExternalIRCFiles class methodsFor: 'private' stamp: 'sbw 5/23/2004 22:11'!rootFolderName	^'irc'! !!ExternalIRCFiles class methodsFor: 'servers' stamp: 'sbw 5/23/2004 22:26'!ensureServersFolder	self rootFolder assureExistenceOfPath: self serversFolderName! !!ExternalIRCFiles class methodsFor: 'servers' stamp: 'sbw 5/24/2004 17:49'!folderForServerAddress: aString 	| dir |	dir := self serversFolder.	(dir directoryExists: aString)		ifFalse: [dir createDirectory: aString].	^ dir directoryNamed: aString! !!ExternalIRCFiles class methodsFor: 'servers' stamp: 'sbw 5/23/2004 22:30'!serversFolder	^self rootFolder directoryNamed: self serversFolderName! !!ExternalIRCFiles class methodsFor: 'servers' stamp: 'sbw 5/23/2004 22:16'!serversFolderName	^'servers'! !!ExternalIRCFiles class methodsFor: 'channel logs' stamp: 'sbw 5/24/2004 18:08'!ensuredLogFilePathForServerAddress: serverAddressString channelName: channelNameString 	"We do not open a stream on the path, we just answer the path and  	made sure it is valid."	| dir fName path |	dir := self folderForChannelLogsOnServerAddress: serverAddressString.	fName := dir checkName: channelNameString , '.txt' fixErrors: true.	path := dir fullPathFor: fName.	^path! !!ExternalIRCFiles class methodsFor: 'channel logs' stamp: 'sbw 5/24/2004 18:08'!folderForChannelLogsOnServerAddress: aString 	| dir subFolderName |	dir := self folderForServerAddress: aString.	subFolderName := self logsFolderName.	(dir directoryExists: subFolderName) 		ifFalse: [dir createDirectory: subFolderName].	^dir directoryNamed: subFolderName! !!ExternalIRCFiles class methodsFor: 'channel logs' stamp: 'sbw 5/23/2004 22:17'!logsFolderName	^'logs'! !!ExternalIRCFiles class methodsFor: 'class initialization' stamp: 'sbw 5/30/2004 09:16'!initialize	"ExternalIRCFiles initialize"	self ensureErrorsFolder.	self ensureRootFolder.	self ensureServersFolder! !!ExternalIRCFiles class methodsFor: 'profiles' stamp: 'sbw 5/23/2004 22:16'!profilesFolderName	^'profiles'! !!ExtraParsingAndFormattingTests methodsFor: 'testing' stamp: 'bh 4/29/2000 17:34'!methodsNotToTest	^ self class methodsNotToTest.! !!ExtraParsingAndFormattingTests methodsFor: 'testing' stamp: 'bh 9/16/2001 22:21'!testParsingAndFormattingEverything	self needsWork. "commented to speed regression testing.  be sure to uncomment."	"Smalltalk allBehaviorsDo: 		[:class | Transcript cr; show:class name.		class selectors do: 			[:sel | (self methodsNotToTest includes: class >> sel) ifFalse: 				[| source tree1 tree2| 				tree2 := RBParser parseMethod: (tree1 := RBParser parseMethod: (class sourceCodeAt: sel)) formattedCode.				self assert:tree1 = tree2]]]"! !!ExtraParsingAndFormattingTests class methodsFor: 'testing' stamp: 'nk 2/23/2005 15:56'!methodsNotToTest	^ {"WonderlandCamera >> #destroy:. 	Parser >> #externalFunctionDeclaration. 	BalloonEngineSimulation >> #circleSinTable. 	BalloonEngineSimulation >> #circleCosTable.	PlayWithMe1 >> #listPane2NewSelection:. 	PlayWithMe1 >> #listPane1NewSelection:." 	Interval >> #valuesInclude:. 	Float class >> #initialize }! !!ExtractMethodRefactoring methodsFor: 'transforming'!checkAssignments: variableNames 	| node outsideVars removeAssigned |	removeAssigned := variableNames copy.	node := self placeholderNode.	outsideVars := variableNames 				select: [:each | (node whoDefines: each) references: each].	outsideVars size == 1 		ifTrue: [self checkSingleAssignment: outsideVars asArray first].	outsideVars size > 1 		ifTrue: 			[self refactoringError: 'Cannot extract assignment without all references.'].	removeAssigned removeAll: outsideVars.	(RBReadBeforeWrittenTester readBeforeWritten: removeAssigned		in: extractedParseTree) isEmpty 		ifFalse: 			[self refactoringError: 'Cannot extract assignment if read before written.'].	removeAssigned 		do: [:each | (node whoDefines: each) removeTemporaryNamed: each].	self createTemporariesInExtractedMethodFor: variableNames! !!ExtractMethodRefactoring methodsFor: 'transforming'!checkReturn	needsReturn := self placeholderNode isUsed.	extractedParseTree containsReturn ifFalse: [^self].	extractedParseTree lastIsReturn ifTrue: [^self].	(modifiedParseTree isLast: self placeholderNode) 		ifFalse: 			[self refactoringError: 'Couldn''t extract code since it contains a return.'].	self checkSelfReturns! !!ExtractMethodRefactoring methodsFor: 'transforming'!checkSelfReturns	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: '^self' do: [:aNode :answer | answer];		matches: '^`@anything' do: [:aNode :answer | true].	(searcher executeTree: extractedParseTree initialAnswer: false) 		ifTrue: [self placeholderNode asReturn]! !!ExtractMethodRefactoring methodsFor: 'transforming'!checkSingleAssignment: varName 	((RBReadBeforeWrittenTester isVariable: varName		readBeforeWrittenIn: extractedParseTree) 			or: [extractedParseTree containsReturn]) 			ifTrue: 				[self 					refactoringError: 'Cannot extract assignments to temporaries without all references'].	extractedParseTree 		addNode: (RBReturnNode value: (RBVariableNode named: varName)).	modifiedParseTree := ParseTreeRewriter 				replace: self methodDelimiter				with: varName , ' := ' , self methodDelimiter				in: modifiedParseTree! !!ExtractMethodRefactoring methodsFor: 'transforming'!checkSpecialExtractions	| node |	node := self placeholderNode parent.	node isNil ifTrue: [^self].	(node isAssignment and: [node variable = self placeholderNode]) ifTrue: 			[self refactoringError: 'Cannot extract left hand side of an assignment'].	node isCascade ifTrue: 			[self refactoringError: 'Cannot extract first message of a cascaded message']! !!ExtractMethodRefactoring methodsFor: 'transforming'!checkTemporaries	| temps accesses assigned |	temps := self remainingTemporaries.	accesses := temps select: [:each | extractedParseTree references: each].	assigned := accesses select: [:each | extractedParseTree assigns: each].	assigned isEmpty ifFalse: [self checkAssignments: assigned].	^parameters := (accesses asOrderedCollection)				removeAll: assigned;				yourself! !!ExtractMethodRefactoring methodsFor: 'transforming'!createTemporariesInExtractedMethodFor: assigned 	assigned do: [:each | extractedParseTree body addTemporaryNamed: each]! !!ExtractMethodRefactoring methodsFor: 'transforming' stamp: 'bh 5/10/2000 21:58'!existingSelector	"Try to find an existing method instead of creating a new one"	^class allSelectors detect: [:each | self isMethodEquivalentTo: each]		ifNone: [nil]! !!ExtractMethodRefactoring methodsFor: 'transforming' stamp: 'dvf 9/29/2001 17:58'!extractMethod	| parseTree isSequence extractCode subtree newCode |	extractCode := self getExtractedSource.	extractedParseTree := RBParser parseExpression: extractCode				onError: [:string :pos | self refactoringError: 'Invalid source to extract - ', string].	extractedParseTree isNil 		ifTrue: [self refactoringError: 'Invalid source to extract'].	(extractedParseTree isSequence 		and: [extractedParseTree statements isEmpty]) 			ifTrue: [self refactoringError: 'Select some code to extract'].	isSequence := extractedParseTree isSequence 				or: [extractedParseTree isReturn].	extractedParseTree := RBMethodNode 				selector: #value				arguments: #()				body: (extractedParseTree isSequence 						ifTrue: [extractedParseTree]						ifFalse: 							[RBSequenceNode temporaries: #()								statements: (OrderedCollection with: extractedParseTree)]).	extractedParseTree body temporaries isEmpty not 		ifTrue: [extractedParseTree body temporaries: #()].	extractedParseTree source: extractCode.	parseTree := class parseTreeFor: selector.	parseTree isNil 		ifTrue: [self refactoringError: 'Could not parse ' , selector printString].	subtree := isSequence 				ifTrue: 					[ParseTreeSearcher 						treeMatchingStatements: extractedParseTree body formattedCode						in: parseTree]				ifFalse: [ParseTreeSearcher treeMatching: extractCode in: parseTree].	subtree isNil 		ifTrue: [self refactoringError: 'Could not extract code from method'].	newCode := self methodDelimiter.	isSequence 		ifTrue: 			[| stmts |			stmts := extractedParseTree body statements.			stmts isEmpty 				ifFalse: 					[stmts last isAssignment 						ifTrue: 							[| name |							name := stmts last variable name.							(self shouldExtractAssignmentTo: name) 								ifFalse: 									[newCode := '<1s> := <2s>' expandMacrosWith: name with: newCode.									stmts at: stmts size put: stmts last value]]]].	modifiedParseTree := isSequence 				ifTrue: 					[ParseTreeRewriter 						replaceStatements: subtree formattedCode						with: newCode						in: parseTree						onInterval: extractionInterval]				ifFalse: 					[ParseTreeRewriter 						replace: subtree formattedCode						with: newCode						in: parseTree						onInterval: extractionInterval]! !!ExtractMethodRefactoring methodsFor: 'transforming'!getExtractedSource	| source |	source := class sourceCodeFor: selector.	((extractionInterval first between: 1 and: source size) 		and: [extractionInterval last between: 1 and: source size]) 			ifFalse: [self refactoringError: 'Invalid interval'].	^source copyFrom: extractionInterval first to: extractionInterval last! !!ExtractMethodRefactoring methodsFor: 'transforming'!getNewMethodName	| newSelector methodName newMethodName |	methodName := RBMethodName new.	methodName arguments: parameters.		[newMethodName := self requestMethodNameFor: methodName.	newMethodName isNil 		ifTrue: [self refactoringError: 'Did not extract code'].	newSelector := newMethodName selector.	(self checkMethodName: newSelector in: class) 		ifFalse: 			[self refactoringWarning: newSelector , ' is not a valid selector name.'.			newSelector := nil].	(class hierarchyDefinesMethod: newSelector asSymbol) 		ifTrue: 			[(self shouldOverride: newSelector in: class) ifFalse: [newSelector := nil]].	newSelector isNil] 			whileTrue: [].	parameters := newMethodName arguments asOrderedCollection.	^newSelector asSymbol! !!ExtractMethodRefactoring methodsFor: 'transforming'!isMethodEquivalentTo: aSelector 	selector == aSelector ifTrue: [^false].	aSelector numArgs ~~ parameters size ifTrue: [^false].	(self isParseTreeEquivalentTo: aSelector) ifFalse: [^false].	self reorderParametersToMatch: aSelector.	^true! !!ExtractMethodRefactoring methodsFor: 'transforming'!isParseTreeEquivalentTo: aSelector 	| tree definingClass |	definingClass := class whoDefinesMethod: aSelector.	tree := definingClass parseTreeFor: aSelector.	tree isNil ifTrue: [^false].	tree isPrimitive ifTrue: [^false].	(tree body equalTo: extractedParseTree body		exceptForVariables: (tree arguments collect: [:each | each name])) 			ifFalse: [^false].	(definingClass = class or: 			[(tree superMessages detect: 					[:each | 					(class superclass whichClassIncludesSelector: aSelector) 						~= (definingClass superclass whichClassIncludesSelector: each)]				ifNone: [nil]) isNil]) 		ifFalse: [^false].	^self shouldUseExistingMethod: aSelector! !!ExtractMethodRefactoring methodsFor: 'transforming'!methodDelimiter	^'#''place.holder.for.method'''! !!ExtractMethodRefactoring methodsFor: 'transforming'!nameNewMethod: aSymbol 	| args newSend |	args := parameters collect: [:parm | RBVariableNode named: parm].	extractedParseTree arguments: args asArray.	extractedParseTree selector: aSymbol.	aSymbol numArgs = 0 		ifTrue: 			[modifiedParseTree := ParseTreeRewriter 						replace: self methodDelimiter						with: 'self ' , aSymbol asString						in: modifiedParseTree.			^self].	newSend := WriteStream on: ''.	aSymbol keywords with: parameters		do: 			[:key :arg | 			newSend				nextPutAll: key asString;				nextPut: $ ;				nextPutAll: arg asString;				nextPut: $ ].	modifiedParseTree := ParseTreeRewriter 				replace: self methodDelimiter				with: 'self ' , newSend contents				in: modifiedParseTree! !!ExtractMethodRefactoring methodsFor: 'transforming'!placeholderNode	| node |	node := ParseTreeSearcher treeMatching: self methodDelimiter				in: modifiedParseTree.	node isNil ifTrue: [self refactoringError: 'Cannot extract code'].	^node! !!ExtractMethodRefactoring methodsFor: 'transforming'!remainingTemporaries	| temps |	temps := modifiedParseTree allDefinedVariables asSet.	extractedParseTree allDefinedVariables 		do: [:each | temps remove: each ifAbsent: []].	^temps! !!ExtractMethodRefactoring methodsFor: 'transforming'!reorderParametersToMatch: aSelector 	| tree dictionary |	tree := class parseTreeFor: aSelector.	dictionary := Dictionary new.	tree body equalTo: extractedParseTree body withMapping: dictionary.	parameters := tree arguments collect: 					[:each | 					dictionary at: each name						ifAbsent: 							[self 								refactoringError: 'An internal error occured, please report this error.']]! !!ExtractMethodRefactoring methodsFor: 'transforming' stamp: 'bh 5/10/2000 21:56'!transform	| existingSelector |	existingSelector := self existingSelector.	self nameNewMethod: (existingSelector isNil 				ifTrue: [self getNewMethodName]				ifFalse: [existingSelector]).	existingSelector isNil 		ifTrue: 			[class compileTree: extractedParseTree				classified: (class protocolsFor: selector)].	class compileTree: modifiedParseTree! !!ExtractMethodRefactoring methodsFor: 'initialize-release'!extract: anInterval from: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	extractionInterval := anInterval! !!ExtractMethodRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition withBlock: 					[self extractMethod.					self checkSpecialExtractions.					self checkReturn.					needsReturn ifTrue: [extractedParseTree addReturn].					self checkTemporaries.					true])! !!ExtractMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' extract: '.	extractionInterval storeOn: aStream.	aStream		nextPutAll: ' from: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!ExtractMethodRefactoring class methodsFor: 'instance creation'!extract: anInterval from: aSelector in: aClass 	^self new		extract: anInterval		from: aSelector		in: aClass! !!ExtractMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk extract: anInterval from: aSelector in: aClass 	^(self new)		model: aRBSmalltalk;		extract: anInterval			from: aSelector			in: aClass;		yourself! !!ExtractMethodTest methodsFor: 'failure tests'!testBadInterval	self		shouldFail: (ExtractMethodRefactoring 					extract: (self convertInterval: (24 to: 30)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					from: #testMethod					in: RefactoryTestDataApp);		shouldFail: (ExtractMethodRefactoring 					extract: (self convertInterval: (80 to: 147)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class)! !!ExtractMethodTest methodsFor: 'failure tests'!testExtractFailure	self		shouldFail: (ExtractMethodRefactoring 					extract: (self convertInterval: (80 to: 269)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class);		shouldFail: (ExtractMethodRefactoring 					extract: (self convertInterval: (53 to: 56)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class);		shouldFail: (ExtractMethodRefactoring 					extract: (self convertInterval: (77 to: 222)							for: (BasicLintRuleTest class 									sourceCodeAt: #subclassResponsibilityNotDefined))					from: #subclassResponsibilityNotDefined					in: BasicLintRuleTest class)! !!ExtractMethodTest methodsFor: 'failure tests'!testNonExistantSelector	self shouldFail: (ExtractMethodRefactoring 				extract: (10 to: 20)				from: #checkClass1:				in: BasicLintRuleTest)! !!ExtractMethodTest methodsFor: 'tests' stamp: 'bh 3/16/2000 12:13'!testExtractMethodAtEndOfMethodThatNeedsReturn	| refactoring class |	refactoring := ExtractMethodRefactoring 				extract: (self convertInterval: (52 to: 182)						for: (LintRuleTest sourceCodeAt: #openEditor))				from: #openEditor				in: LintRuleTest.	self setupMethodNameFor: refactoring toReturn: #foo:.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #LintRuleTest.	self 		assert: (class parseTreeFor: #openEditor) = (RBParser 						parseMethod: 'openEditor	| rules |	rules := self failedRules.	^self foo: rules').	self 		assert: (class parseTreeFor: #foo:) = (RBParser 						parseMethod: 'foo: rules	rules isEmpty ifTrue: [^self].	rules size == 1 ifTrue: [^rules first viewResults].	SmalllintResultEditor openOn: self label: name')! !!ExtractMethodTest methodsFor: 'tests'!testExtractMethodThatMovesTemporaryVariable	| refactoring class |	refactoring := ExtractMethodRefactoring 				extract: (self convertInterval: (22 to: 280)						for: (TransformationRuleTest sourceCodeAt: #superSends))				from: #superSends				in: TransformationRuleTest.	self setupMethodNameFor: refactoring toReturn: #foo.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #TransformationRuleTest.	self 		assert: (class parseTreeFor: #superSends) = (RBParser 						parseMethod: 'superSends	| rule |	rule := self foo.	self rewriteUsing: rule').	self 		assert: (class parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo | rule | 	rule := ParseTreeRewriter new.	rule addSearch: ''super `@message: ``@args''				-> (					[:aNode | 					(class withAllSubclasses						detect: [:each | each includesSelector: aNode selector]						ifNone: [nil]) isNil]							-> ''self `@message: ``@args'').		^rule')! !!ExtractMethodTest methodsFor: 'tests'!testExtractMethodThatNeedsArgument	| refactoring class |	refactoring := ExtractMethodRefactoring 				extract: (self convertInterval: (145 to: 343)						for: (TransformationRuleTest sourceCodeAt: #checkMethod:))				from: #checkMethod:				in: TransformationRuleTest.	self setupMethodNameFor: refactoring toReturn: #foo:.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #TransformationRuleTest.	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext 	class := aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[self foo: aSmalllintContext]').	self 		assert: (class parseTreeFor: #foo:) = (RBParser 						parseMethod: 'foo: aSmalllintContext (RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)				ifFalse: 					[builder compile: rewriteRule tree printString						in: class						classified: aSmalllintContext protocols]')! !!ExtractMethodTest methodsFor: 'tests'!testExtractMethodThatNeedsTemporaryVariable	| refactoring class |	refactoring := ExtractMethodRefactoring 				extract: (self convertInterval: (78 to: 197)						for: (LintRuleTest sourceCodeAt: #displayName))				from: #displayName				in: LintRuleTest.	self setupMethodNameFor: refactoring toReturn: #foo:.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #LintRuleTest.	self 		assert: (class parseTreeFor: #displayName) = (RBParser 						parseMethod: 'displayName	| nameStream |	nameStream := WriteStream on: (String new: 64).	self foo: nameStream.	^nameStream contents').	self 		assert: (class parseTreeFor: #foo:) = (RBParser 						parseMethod: 'foo: nameStream 	nameStream nextPutAll: self name;		nextPutAll: '' (''.	self problemCount printOn: nameStream.	nameStream nextPut: $).')! !!ExtractMethodTest methodsFor: 'tests'!testModelExtractMethodWithTemporariesSelected	| class refactoring |	model := RBNamespace new.	class := model classNamed: self class name.	class compile: 'foo [| temp | temp := 5. temp * temp] value'		classified: #(#accessing).	refactoring := ExtractMethodRefactoring 				model: model				extract: (6 to: 36)				from: #foo				in: class.	self setupMethodNameFor: refactoring toReturn: #foobar.	self executeRefactoring: refactoring.	self assert: (class parseTreeFor: #foo) 				= (RBParser parseMethod: 'foo [self foobar] value').	self assert: (class parseTreeFor: #foobar) 				= (RBParser parseMethod: 'foobar |temp | temp := 5. ^temp * temp')! !!ExtractMethodTest methodsFor: 'tests' stamp: 'bh 9/16/2001 21:06'!testModelExtractMethodWithTemporaryAssigned	| class refactoring |	model := RBNamespace new.	class := model classNamed: self class name.	class 		compile: 'foo 				| temp bar | 				bar := 5. 				temp := bar * bar. 				Transcript show: temp printString; cr. 				^temp * temp'		classified: #(#accessing).	refactoring := ExtractMethodRefactoring 				model: model				extract: (26 to: 102)				from: #foo				in: class.	self setupMethodNameFor: refactoring toReturn: #foobar.	self executeRefactoring: refactoring.	self assert: (class parseTreeFor: #foo) 				= (RBParser parseMethod: 'foo | temp | temp := self foobar. ^temp * temp').	self 		assert: ((class parseTreeFor: #foobar) = (RBParser 						parseMethod: 'foobar | bar temp | bar := 5. temp := bar * bar. Transcript show: temp printString; cr. ^temp.')) |				((class parseTreeFor: #foobar) = (RBParser 						parseMethod: 'foobar | temp bar | bar := 5. temp := bar * bar. Transcript show: temp printString; cr. ^temp.'))! !!ExtractMethodToComponentRefactoring methodsFor: 'initialize-release'!extract: anInterval from: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	extractionInterval := anInterval! !!ExtractMethodToComponentRefactoring methodsFor: 'transforming'!extractMethod	| refactoring |	refactoring := ExtractMethodRefactoring 				model: self model				extract: extractionInterval				from: selector				in: class.	refactoring setOption: #methodName		toUse: 			[:ref :methodName | 			extractedMethodSelector := ref 						uniqueMethodNameFor: methodName arguments size.			methodName				selector: extractedMethodSelector;				yourself].	self performComponentRefactoring: refactoring! !!ExtractMethodToComponentRefactoring methodsFor: 'transforming'!inlineForwarder	| refactoring |	refactoring := InlineAllSendersRefactoring 				model: self model				sendersOf: extractedMethodSelector				in: class.	refactoring setOption: #inlineExpression toUse: [:ref :string | true].	self performComponentRefactoring: refactoring! !!ExtractMethodToComponentRefactoring methodsFor: 'transforming'!moveMethod	| variable refactoring |	variable := self selectVariableToMoveMethodTo: extractedMethodSelector				class: class.	variable isNil ifTrue: [self refactoringError: 'Did not extract method'].	refactoring := MoveMethodRefactoring 				model: self model				selector: extractedMethodSelector				class: class				variable: variable.	self performComponentRefactoring: refactoring! !!ExtractMethodToComponentRefactoring methodsFor: 'transforming'!transform	self		extractMethod;		moveMethod;		inlineForwarder! !!ExtractMethodToComponentRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition empty! !!ExtractMethodToComponentRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' extract: '.	extractionInterval storeOn: aStream.	aStream		nextPutAll: ' from: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!ExtractMethodToComponentRefactoring class methodsFor: 'instance creation'!extract: anInterval from: aSelector in: aClass 	^self new		extract: anInterval		from: aSelector		in: aClass! !!ExtractMethodToComponentRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk extract: anInterval from: aSelector in: aClass 	^(self new)		model: aRBSmalltalk;		extract: anInterval			from: aSelector			in: aClass;		yourself! !!ExtractMethodToComponentTest methodsFor: 'failure tests'!testBadInterval	self		shouldFail: (ExtractMethodToComponentRefactoring 					extract: (self convertInterval: (24 to: 30)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					from: #testMethod					in: RefactoryTestDataApp);		shouldFail: (ExtractMethodToComponentRefactoring 					extract: (self convertInterval: (80 to: 147)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class)! !!ExtractMethodToComponentTest methodsFor: 'failure tests'!testExtractFailure	self		shouldFail: (ExtractMethodToComponentRefactoring 					extract: (self convertInterval: (80 to: 269)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class);		shouldFail: (ExtractMethodToComponentRefactoring 					extract: (self convertInterval: (53 to: 56)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class);		shouldFail: (ExtractMethodToComponentRefactoring 					extract: (self convertInterval: (77 to: 222)							for: (BasicLintRuleTest class 									sourceCodeAt: #subclassResponsibilityNotDefined))					from: #subclassResponsibilityNotDefined					in: BasicLintRuleTest class)! !!ExtractMethodToComponentTest methodsFor: 'failure tests'!testNonExistantSelector	self shouldFail: (ExtractMethodToComponentRefactoring 				extract: (10 to: 20)				from: #checkClass1:				in: BasicLintRuleTest)! !!ExtractMethodToComponentTest methodsFor: 'tests' stamp: 'bh 3/16/2000 12:14'!testExtractMethodAtEndOfMethodThatNeedsReturn	| refactoring class selectorsSize |	refactoring := ExtractMethodToComponentRefactoring 				extract: (self convertInterval: (52 to: 182)						for: (LintRuleTest sourceCodeAt: #openEditor))				from: #openEditor				in: LintRuleTest.	self setupMethodNameFor: refactoring toReturn: #foo:.	self setupSelfArgumentNameFor: refactoring toReturn: 'asdf'.	self setupVariableToMoveToFor: refactoring toReturn: 'rules'.	self setupVariableTypesFor: refactoring		toReturn: (Array with: (refactoring model classNamed: #Collection)).	class := refactoring model classNamed: #LintRuleTest.	selectorsSize := class selectors size.	self proceedThroughWarning: [self executeRefactoring: refactoring].	self 		assert: (class parseTreeFor: #openEditor) = (RBParser 						parseMethod: 'openEditor								| rules |								rules := self failedRules.								^rules foo: self').	self 		assert: ((refactoring model classNamed: #Collection) parseTreeFor: #foo:) 				= (RBParser 						parseMethod: 'foo: asdf								self isEmpty ifTrue: [^asdf].								self size == 1 ifTrue: [^self first viewResults].								SmalllintResultEditor openOn: asdf label: asdf name.								^asdf').	self assert: class selectors size = selectorsSize! !!ExtractMethodToComponentTest methodsFor: 'tests'!testMoveWithoutSelfReference	| refactoring class selectorsSize |	refactoring := ExtractMethodToComponentRefactoring 				extract: (self convertInterval: (118 to: 285)						for: (RBReadBeforeWrittenTester sourceCodeAt: #copyDictionary:))				from: #copyDictionary:				in: RBReadBeforeWrittenTester.	self setupMethodNameFor: refactoring toReturn: #copyWithAssociations.	self setupVariableToMoveToFor: refactoring toReturn: 'aDictionary'.	self setupVariableTypesFor: refactoring		toReturn: (Array with: (refactoring model classNamed: #Dictionary)).	class := refactoring model classNamed: #RBReadBeforeWrittenTester.	selectorsSize := class selectors size.	self executeRefactoring: refactoring.	self 		assert: (class parseTreeFor: #copyDictionary:) = (RBParser 						parseMethod: 'copyDictionary: aDictionary ^aDictionary copyWithAssociations').	self 		assert: ((refactoring model classNamed: #Dictionary) 				parseTreeFor: #copyWithAssociations) = (RBParser 							parseMethod: 'copyWithAssociations 							| newDictionary |							newDictionary := Dictionary new: self size.							self								keysAndValuesDo: [:key :value | newDictionary at: key put: value].							^newDictionary').	self assert: class selectors size = selectorsSize! !!ExtractToTemporaryRefactoring methodsFor: 'preconditions'!checkVariableName	(class whoDefinesInstanceVariable: newVariableName) notNil 		ifTrue: 			[self refactoringError: ('<1p> defines an instance variable named <2s>' 						expandMacrosWith: class						with: newVariableName)].	(class whoDefinesClassVariable: newVariableName) notNil 		ifTrue: 			[self refactoringError: ('<1p> defines a class variabled named <2s>' 						expandMacrosWith: class						with: newVariableName)].	(self parseTree allDefinedVariables includes: newVariableName) 		ifTrue: 			[self refactoringError: ('<1s> is already a temporary variable name' 						expandMacrosWith: newVariableName)]! !!ExtractToTemporaryRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition isValidInstanceVariableName: newVariableName for: class) 			& (RBCondition withBlock: 						[self verifySelectedInterval.						self checkVariableName.						true])! !!ExtractToTemporaryRefactoring methodsFor: 'preconditions'!verifySelectedInterval	| selectedParseTree selectedSources |	selectedSources := self selectedSource.	selectedParseTree := RBParser parseExpression: selectedSources				onError: [:message :position | self refactoringError: 'Invalid selection'].	selectedParseTree isSequence 		ifTrue: [self refactoringError: 'Cannot assign temp to multiple statements']! !!ExtractToTemporaryRefactoring methodsFor: 'transforming'!compileNewMethod	class compileTree: self parseTree! !!ExtractToTemporaryRefactoring methodsFor: 'transforming'!constructAssignmentFrom: aNode 	| valueNode |	valueNode := RBVariableNode named: newVariableName.	^RBAssignmentNode variable: valueNode value: aNode! !!ExtractToTemporaryRefactoring methodsFor: 'transforming'!insertTemporary	| node statementNode |	node := self parseTree whichNodeIsContainedBy: sourceInterval.	(node notNil and: [node isValue]) 		ifFalse: [self refactoringError: 'Cannot assign to non-value nodes'].	statementNode := node statementNode.	node replaceWith: (RBVariableNode named: newVariableName).	(statementNode parent)		addNode: (self constructAssignmentFrom: node)			before: (node == statementNode 					ifTrue: [RBVariableNode named: newVariableName]					ifFalse: [statementNode]);		addTemporaryNamed: newVariableName! !!ExtractToTemporaryRefactoring methodsFor: 'transforming'!transform	self		insertTemporary;		compileNewMethod! !!ExtractToTemporaryRefactoring methodsFor: 'initialize-release'!extract: anInterval to: aString from: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	sourceInterval := anInterval.	newVariableName := aString! !!ExtractToTemporaryRefactoring methodsFor: 'private-accessing'!parseTree	parseTree isNil 		ifTrue: 			[parseTree := class parseTreeFor: selector.			parseTree isNil ifTrue: [self refactoringError: 'Could not parse method']].	^parseTree! !!ExtractToTemporaryRefactoring methodsFor: 'private-accessing'!selectedSource	| source |	source := class sourceCodeFor: selector.	source isNil ifTrue: [self refactoringError: 'Couldn''t find sources'].	((sourceInterval first between: 1 and: source size) 		and: [sourceInterval last between: 1 and: source size]) 			ifFalse: [self refactoringError: 'Invalid interval'].	^source copyFrom: sourceInterval first to: sourceInterval last! !!ExtractToTemporaryRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' extract: '.	sourceInterval storeOn: aStream.	aStream		nextPutAll: ' to: ''';		nextPutAll: newVariableName;		nextPutAll: ''' from: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!ExtractToTemporaryRefactoring class methodsFor: 'instance creation'!extract: anInterval to: aString from: aSelector in: aClass 	^self new 		extract: anInterval		to: aString		from: aSelector		in: aClass! !!ExtractToTemporaryRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk extract: anInterval to: aString from: aSelector in: aClass 	^(self new)		model: aRBSmalltalk;		extract: anInterval			to: aString			from: aSelector			in: aClass;		yourself! !!ExtractToTemporaryTest methodsFor: 'failure tests'!testBadInterval	self		shouldFail: (ExtractToTemporaryRefactoring 					extract: (self convertInterval: (24 to: 30)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					to: 'asdf'					from: #testMethod					in: RefactoryTestDataApp);		shouldFail: (ExtractToTemporaryRefactoring 					extract: (self convertInterval: (14 to: 105)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod1))					to: 'asdf'					from: #testMethod1					in: RefactoryTestDataApp);		shouldFail: (ExtractToTemporaryRefactoring 					extract: (self convertInterval: (61 to: 101)							for: (RefactoryTestDataApp sourceCodeAt: #noMoveDefinition))					to: 'asdf'					from: #noMoveDefinition					in: RefactoryTestDataApp)! !!ExtractToTemporaryTest methodsFor: 'failure tests'!testBadName	self shouldFail: (ExtractToTemporaryRefactoring 				extract: (self convertInterval: (14 to: 23)						for: (RefactoryTestDataApp sourceCodeAt: #testMethod))				to: 'a sdf'				from: #testMethod				in: RefactoryTestDataApp)! !!ExtractToTemporaryTest methodsFor: 'failure tests'!testNonExistantSelector	self shouldFail: (ExtractToTemporaryRefactoring 				extract: (14 to: 23)				to: 'asdf'				from: #checkClass1:				in: RefactoryTestDataApp)! !!ExtractToTemporaryTest methodsFor: 'tests'!testExtractToTemporaryForLastStatementInBlock	| refactoring |	refactoring := ExtractToTemporaryRefactoring 				extract: (self convertInterval: (52 to: 73)						for: (RefactoryTestDataApp sourceCodeAt: #caller2))				to: 'temp'				from: #caller2				in: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #caller2) = (RBParser 							parseMethod: 'caller2	^(1 to: 10) inject: 1 into: [:sum :each | | temp | temp := sum * (self foo: each). temp]')! !!ExtractToTemporaryTest methodsFor: 'tests'!testExtractToTemporaryInsideBlock	| refactoring |	refactoring := ExtractToTemporaryRefactoring 				extract: (self convertInterval: (133 to: 141)						for: (RefactoryTestDataApp sourceCodeAt: #noMoveDefinition))				to: 'asdf'				from: #noMoveDefinition				in: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #noMoveDefinition) = (RBParser 							parseMethod: 'noMoveDefinition	| temp |	^(self collect: 			[:each | 			temp := each printString.			temp , temp]) 		select: [:each | | asdf | asdf := each size. temp := asdf + temp]')! !!Feature commentStamp: 'md 12/9/2007 15:14' prior: 0!Not yet used.!!FeatureAnnotation methodsFor: 'testing' stamp: 'md 8/20/2007 11:16'!isSourceVisible	^false! !!FeatureAnnotation class methodsFor: 'accessing' stamp: 'md 8/20/2007 11:23'!keys	^#(features)! !!FeatureTagger methodsFor: 'accessing' stamp: 'md 8/20/2007 11:25'!feature	^feature	! !!FeatureTagger methodsFor: 'accessing' stamp: 'md 8/21/2007 17:23'!feature: aFeature	feature := aFeature	! !!FeatureTagger methodsFor: 'mop' stamp: 'md 8/20/2007 11:35'!tagNode: aNode	aNode addFeatureAnnotation: feature! !!FeatureTagger commentStamp: 'md 8/20/2007 11:24' prior: 0!A FeatureTagger is a meta-object that taggs nodes on the AST to be part of a feature. Features are Symbols for now. This might change later.!!FeatureTagger class methodsFor: 'link creation' stamp: 'md 8/21/2007 18:19'!linkFor: aFeature	^GPLink new			metaObject: (self newFor: aFeature);			selector: #tagNode:;			arguments: #(node).! !!FeatureTagger class methodsFor: 'instance creation' stamp: 'md 8/20/2007 11:29'!newFor: aFeature	^self new feature: aFeature! !!FeatureTest methodsFor: 'tools' stamp: 'md 8/21/2007 18:45'!assertNoFeatureAnnotation: aMethod	aMethod  nodes do: [:node | self assert: (node hasAnnotation: #features) not].! !!FeatureTest methodsFor: 'tools' stamp: 'md 8/21/2007 18:41'!assertNoLinks: aMethod	aMethod  nodes do: [:node | self assert: node hasAnyLink not].! !!FeatureTest methodsFor: 'tools' stamp: 'md 8/21/2007 18:44'!removeFeatureAnnotation: aMethod	aMethod reflectiveMethod methodNode nodesDo: [:node |		(node hasAnnotation: #features) ifTrue: [node  removeAnnotation: #features]].! !!FeatureTest methodsFor: 'tools' stamp: 'md 8/21/2007 18:40'!removeLinks: aMethod	aMethod reflectiveMethod methodNode nodesDo: [:node |		node hasAnyLink ifTrue: [node removeAllLinks]].! !!FeatureTest methodsFor: 'setup' stamp: 'md 8/21/2007 18:41'!setup	gplink := nil.! !!FeatureTest methodsFor: 'setup' stamp: 'md 8/21/2007 18:45'!tearDown	gplink ifNotNil: [gplink uninstall].		GPExamples methodDict values do: [:method |		self removeLinks: method.		self assertNoLinks: method. 		self removeFeatureAnnotation: method.		self assertNoFeatureAnnotation: method.	].! !!FeatureTest methodsFor: 'ui' stamp: 'md 8/22/2007 14:27'!testEnable	| ui |	ui := FeatureUI new.	self deny: ui active.		ui featureStart.	self assert: ui active.		ui featureStop.	self deny: ui active.! !!FeatureTest methodsFor: 'ui' stamp: 'md 8/22/2007 20:43'!testSetPackage	| ui |	ui := FeatureUI new.	ui feature: #Test.		ui package: 'Network-IRC'.	self assert: (ui selectedClasses anyOne isKindOf: Class).! !!FeatureTest methodsFor: 'ui' stamp: 'md 8/22/2007 19:53'!testTaggerLink	| ui |	ui := FeatureUI new.	ui feature: #Test.	gplink := ui taggerLink.	self deny: gplink isActive.		ui featureStart.	self assert: gplink isActive.	ui featureStop.	self deny: gplink isActive.	! !!FeatureTest methodsFor: 'ui' stamp: 'md 8/22/2007 20:24'!testUILinkInstall	| ui |	ui := FeatureUI new.	ui feature: #Test.		ui package: 'Network-IRC'.		gplink := ui installLinks.! !!FeatureTest methodsFor: 'tagger' stamp: 'md 8/21/2007 17:23'!testTaggerInstanciation	| tagger |	tagger := FeatureTagger newFor: #Logging.		self assert: tagger feature = #Logging. ! !!FeatureTest methodsFor: 'tagger' stamp: 'md 8/21/2007 18:42'!testTaggerLinkInstall	gplink := FeatureTagger linkFor: #Logging.	(GPExamples>>#exampleIf) nodes do: [:node | node link: gplink].! !!FeatureTest methodsFor: 'tagger' stamp: 'md 12/9/2007 15:09'!testTaggerSmallExample	| block |	gplink := FeatureTagger linkFor: #Logging.		(GPExamples>>#exampleIf) nodes do: [:node | node link: gplink].		self assertNoFeatureAnnotation: (GPExamples>>#exampleIf).	self assert: (GPExamples new exampleIf = 3).		block := ((GPExamples>>#exampleIf) nodes select: #isBlock) asArray at: 1.	self assert: ((block annotationAt: #features) values includes: #Logging).		block := ((GPExamples>>#exampleIf) nodes select: #isBlock) asArray at: 2.	self deny: ((block annotationAt: #features) values includes: #Logging).! !!FeatureUI methodsFor: 'accessing' stamp: 'md 8/22/2007 14:08'!active	^active! !!FeatureUI methodsFor: 'accessing' stamp: 'md 8/22/2007 14:10'!active: aBoolean	active := aBoolean! !!FeatureUI methodsFor: 'accessing' stamp: 'md 8/22/2007 14:10'!feature	^feature! !!FeatureUI methodsFor: 'accessing' stamp: 'md 8/22/2007 14:10'!feature: aFeature	feature := aFeature! !!FeatureUI methodsFor: 'accessing' stamp: 'md 8/22/2007 20:19'!link	^link! !!FeatureUI methodsFor: 'accessing' stamp: 'md 8/22/2007 20:00'!package	^package! !!FeatureUI methodsFor: 'accessing' stamp: 'md 8/22/2007 20:02'!package: aString	package := aString! !!FeatureUI methodsFor: 'ui' stamp: 'md 8/21/2007 09:33'!buttonNamed: aString action: aSymbol color: aColor help: helpString	| f col |	f _ SimpleButtonMorph new		target: self;		label: aString font: Preferences standardEToysFont;		color: aColor;		borderColor: aColor muchDarker;		actionSelector: aSymbol;		setBalloonText: helpString.	col _ (self inAColumn: {f}) hResizing: #spaceFill.	^col! !!FeatureUI methodsFor: 'ui' stamp: 'md 8/21/2007 09:33'!cancelButton	^ self		buttonNamed: 'Cancel'		action: #doCancel		color: ColorTheme current cancelColor		help: 'Cancel this login operation.'! !!FeatureUI methodsFor: 'ui' stamp: 'md 8/21/2007 09:32'!okButton	^ self		buttonNamed: 'OK'		action: #doOK		color:ColorTheme current okColor		help: 'Login into Squeak'! !!FeatureUI methodsFor: 'ui' stamp: 'md 8/21/2007 12:35'!openAsMorph	| window allignment theNameMorph |	window := (SystemWindow new) model: self.	allignment := AlignmentMorph new							 hResizing: #shrinkWrap; vResizing: #shrinkWrap.							allignment addMorph: (AlignmentMorph inARow: {(StringMorph contents: 'Feature name:' font: Preferences standardEToysFont) lock.	(theNameMorph _ TextMorph new			beAllFont: Preferences standardEToysFont;			crAction: (MessageSend receiver: self selector: #doOK);			extent: 300@20;			contentsWrapped: 'name';			setBalloonText: 'Enter a name'			)}).		window addMorph: allignment frame: (0@0 extent: 1@1).	window extent:  allignment fullBounds extent.	window openInHand. ! !!FeatureUI methodsFor: 'ui' stamp: 'md 8/21/2007 09:31'!rebuild	| theNameMorph |	self removeAllMorphs.	self addARow: { (StringMorph contents:'') lock }.	self addARow: {		(StringMorph contents: 'Feature name:' font: Preferences standardEToysFont) lock.	}.	(self addARow: {		(theNameMorph _ TextMorph new			beAllFont: Preferences standardEToysFont;			crAction: (MessageSend receiver: self selector: #doOK);			extent: 300@20;			contentsWrapped: 'name';			setBalloonText: 'Enter a name'			).	}) color: Color white; borderColor: Color black; borderWidth: 1.	self addARow: {		self okButton.		self cancelButton.	}.	self addARow: { (StringMorph contents:'') lock }.! !!FeatureUI methodsFor: 'featureTracing' stamp: 'md 8/22/2007 14:25'!featureStart	active := true.! !!FeatureUI methodsFor: 'featureTracing' stamp: 'md 8/22/2007 14:25'!featureStop	active := false.! !!FeatureUI methodsFor: 'featureTracing' stamp: 'md 8/22/2007 20:43'!installLinks	self selectedClasses do: [:class |		class methods do: [:method |			method nodes do: [:node | node link: self taggerLink]]].	^link! !!FeatureUI methodsFor: 'featureTracing' stamp: 'md 8/22/2007 20:20'!taggerLink	link ifNil: [		link := FeatureTagger linkFor: feature.		link condition: [active].	].	^link.! !!FeatureUI methodsFor: 'initialize-release' stamp: 'md 8/22/2007 14:28'!initialize	active := false.! !!FeatureUI methodsFor: 'package' stamp: 'md 8/22/2007 20:02'!selectedClasses	^(PackageInfo named: package) classes	! !!FeatureUI commentStamp: 'md 12/9/2007 15:15' prior: 0!This will be replaced by the Seaside gui!!FeatureUI class methodsFor: 'instance creation' stamp: 'md 8/21/2007 12:00'!open	^self new openAsMorph.! !!FileLogger methodsFor: 'adding' stamp: 'jp 10/19/2006 13:04'!addEvent: anEvent 	self isLogging ifFalse: [^self].	(self policy isInteresting: anEvent) ifFalse: [^self].	self format addEvent: anEvent on: buffer from: self.	self flush! !!FileLogger methodsFor: 'adding' stamp: 'jp 10/19/2006 13:05'!flush	"Flush the buffered output to the display."	buffer position == 0 ifFalse: [		mutex critical: [			self stream 				nextPutAll: buffer contents; 				flush; 				close.			buffer reset]]! !!FileLogger methodsFor: 'accessing'!fileName	fileName isNil ifTrue: [fileName := self class defaultLogFileName].	^fileName			! !!FileLogger methodsFor: 'accessing'!fileName: anObject	fileName := anObject			! !!FileLogger methodsFor: 'accessing' stamp: 'jp 10/19/2006 13:02'!stream	"dialect-specific"	^FileStream oldFileNamed: self fileName			! !!FileLogger methodsFor: 'initialize-release' stamp: 'jp 10/19/2006 13:03'!initialize	buffer := String new writeStream.	mutex := self newMutex! !!FileLogger methodsFor: 'initialize-release' stamp: 'jp 10/19/2006 13:03'!newMutex	^Semaphore forMutualExclusion! !!FileLogger methodsFor: 'printing' stamp: 'jp 10/19/2006 13:05'!outputFooter	self format outputFooterOn: buffer.	self flush! !!FileLogger methodsFor: 'printing' stamp: 'jp 10/19/2006 13:05'!outputHeader	self format outputHeaderOn: buffer.	self flush! !!FileLogger class methodsFor: '*Toothpick-Configuration'!configureFromDictionary: aDictionary 	" OrderedCollection ('format' 'name' 'stream' 'isLogging' 'fileName')"	^ ( super configureFromDictionary: aDictionary  )		fileName: ( aDictionary at: 'filename' ifAbsent: [ self defaultLogFileName ]);		yourself			! !!FileLogger class methodsFor: '*Toothpick-Configuration'!iniFileFields"The following fields may be defined in a toothpick.ini chunk. Check my subclasses for additional fields which they support		fileName - a String giving the filename the logger writes to"	^super iniFileFields add: 'fileName'; yourself			! !!FileLogger class methodsFor: '*Toothpick-Configuration'!mappingKey	^'file'			! !!FileLogger class methodsFor: 'configuring'!defaultLogFileName	^'debug.log'			! !!FileLogger class methodsFor: 'configuring'!defaultLogName	^ 'an unnamed file logger'			! !!FileLogger class methodsFor: 'instance creation'!defaultLogger	^(self new)		name: self defaultLogName;		format: SimpleLoggingFormatter new;		policy: LoggingPolicy defaultPolicy;		yourself			! !!FileLogger class methodsFor: 'instance creation' stamp: 'jp 10/19/2006 13:16'!new	^super new initialize! !!FileLogger class methodsFor: 'instance creation'!xmlLogger	^ ( self new )		name: 'XML Log';		fileName: 'debugLog.xml';		format: XMLLoggingFormatter new;		policy: LoggingPolicy defaultPolicy;		yourself			! !!FileLogger class methodsFor: 'examples'!exampleFileLogger	| logger event |	event := LoggingEvent newDebugEventLevel: #info message: 'Test Message'.	logger := (FileLogger new)				name: 'my file logger';				fileName: 'mylog.txt';				format: SimpleLoggingFormatter new;				policy: LoggingPolicy debugPolicy;				yourself.	logger		startLogging;		addEvent: event;		stopLogging			! !!FinderTool methodsFor: 'user interface' stamp: 'nk 2/25/2005 10:26'!addModelItemsToWindowMenu: aMenu	super addModelItemsToWindowMenu: aMenu.	^aMenu		addLine;		add: 'select classes to operate on' target: self action: #chooseClasses;		yourself.! !!FinderTool methodsFor: 'user interface' stamp: 'nk 2/27/2005 15:42'!canSearch	^searchEnvironment isEmpty not ! !!FinderTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:00'!commentPaneFrame	^0 @ 0.4 corner: 1 @ 0.9! !!FinderTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:00'!conditionsPaneFrame	^0 @ 0.2 corner: 1.0 @ 0.4! !!FinderTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:28'!createMorphicWindow	| conditionsPane searchStringPane window |	window := (SystemWindow labelled: self labelString) model: self.	searchStringPane := PluggableTextMorph 				on: self				text: #searchPatternString				accept: #searchString:				readSelection: nil				menu: #codePaneMenu:shifted:.	window addMorph: searchStringPane frame: self searchStringPaneFrame.	conditionsPane := PluggableTextMorph 				on: self				text: #conditionString				accept: #conditionString:				readSelection: nil				menu: #codePaneMenu:shifted:.	window addMorph: conditionsPane frame: self conditionsPaneFrame.	window addMorph: (PluggableTextMorph 				on: self class				text: #jokerHelp				accept: nil				readSelection: nil				menu: nil)		frame: self commentPaneFrame.	window addMorph: ((PluggableButtonMorph 				on: self				getState: #canSearch				action: #searchAndOpenEditor)				label: 'Search';				onColor: self defaultBackgroundColor lighter					offColor: self defaultBackgroundColor darker)		frame: self searchButtonFrame.	window addMorph: self methodCheckBoxPane frame: self methodCheckBoxFrame.	^window! !!FinderTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:29'!methodCheckBoxFrame	^0.5 @ 0.9 corner: 1 @ 1! !!FinderTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:53'!methodCheckBoxPane	^(AlignmentMorph newRow)		cellInset: 4;		listCentering: #center;		wrapCentering: #center;		addMorph: ((UpdatingThreePhaseButtonMorph checkBox)					target: self;					getSelector: #searchMethods;					actionSelector: #toggleSearchMethods);		addMorph: (TextMorph new contentsAsIs: 'Search Entire Methods' translated);		yourself! !!FinderTool methodsFor: 'user interface' stamp: 'nk 2/27/2005 15:43'!openAsMorph	"self new openAsMorph"	| window |	window := self createMorphicWindow.	self changed: #canSearch.	window		center: Display center;		extent: 100 @ 100.	window openInWorld.	^window! !!FinderTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:16'!searchButtonFrame	^0 @ 0.9 corner: 0.5 @ 1! !!FinderTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 12:59'!searchStringPaneFrame	^0 @ 0 corner: 1.0 @ 0.2! !!FinderTool methodsFor: 'class membership' stamp: 'nk 2/27/2005 13:48'!chooseClasses	| newEnvironment |	newEnvironment := CategoryAndClassSelector new getClassEnvironmentFromUser.	newEnvironment isEmpty ifFalse: [self searchEnvironment: newEnvironment]! !!FinderTool methodsFor: 'menus' stamp: 'nk 3/1/2005 07:35'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items in a text pane"	| donorMenu |	donorMenu := shifted		ifTrue:			[ParagraphEditor shiftedYellowButtonMenu]		ifFalse:			[ParagraphEditor yellowButtonMenu].	^ aMenu labels: donorMenu labelString lines: donorMenu lineArray selections: donorMenu selections! !!FinderTool methodsFor: 'accessing' stamp: 'dvf 9/22/2001 15:42'!conditionString	^conditionString! !!FinderTool methodsFor: 'accessing' stamp: 'nk 2/24/2005 14:39'!conditionString: anObject	conditionString := anObject.	foundEnvironment := nil.	self changed: #conditionString.	^true! !!FinderTool methodsFor: 'accessing' stamp: 'nk 1/6/2004 12:56'!foundEnvironment	^foundEnvironment! !!FinderTool methodsFor: 'accessing' stamp: 'nk 1/6/2004 12:56'!foundEnvironment: anObject	foundEnvironment := anObject! !!FinderTool methodsFor: 'accessing' stamp: 'nk 2/25/2005 10:36'!labelString	^self class name, ' on ', self searchEnvironment printString! !!FinderTool methodsFor: 'accessing' stamp: 'dvf 9/27/2001 18:40'!searchEnvironment	^searchEnvironment! !!FinderTool methodsFor: 'accessing' stamp: 'nk 2/25/2005 10:35'!searchEnvironment: anObject	searchEnvironment := anObject.	foundEnvironment := nil.	self changed: #relabel.! !!FinderTool methodsFor: 'accessing' stamp: 'nk 3/5/2005 16:19'!searchMethods	^searchMethods! !!FinderTool methodsFor: 'accessing' stamp: 'nk 3/5/2005 16:19'!searchMethods: anObject	searchMethods := anObject! !!FinderTool methodsFor: 'accessing' stamp: 'nk 3/1/2005 07:32'!searchPatternString	^searchString! !!FinderTool methodsFor: 'accessing' stamp: 'dvf 9/22/2001 15:42'!searchString	^searchString! !!FinderTool methodsFor: 'accessing' stamp: 'nk 3/1/2005 07:33'!searchString: aString	searchString := aString.	foundEnvironment := nil.	self changed: #searchPatternString.	^true! !!FinderTool methodsFor: 'accessing' stamp: 'nk 3/5/2005 16:56'!toggleSearchMethods	| wasDefault |	wasDefault := self searchString = self defaultSearchString.	searchMethods := searchMethods not.	wasDefault ifTrue: [self searchString: self defaultSearchString]! !!FinderTool methodsFor: 'initialization' stamp: 'nk 8/13/2003 16:39'!createConditionBlock	^self conditionString isEmpty 		ifFalse: [Compiler evaluate: '[ :aNode | ' , conditionString , ' ]' for: self logged: false ]		ifTrue: [[:aNode | true]]! !!FinderTool methodsFor: 'initialization' stamp: 'nk 3/5/2005 16:54'!defaultExpressionSearchString	^'`@Expression halt'! !!FinderTool methodsFor: 'initialization' stamp: 'nk 3/5/2005 16:58'!defaultMethodSearchString	^'`methodName: `@args	| `@temps |	^`@Expression'! !!FinderTool methodsFor: 'initialization' stamp: 'nk 3/5/2005 16:58'!defaultSearchString	^self searchMethods ifTrue: [ self defaultMethodSearchString ] ifFalse: [ self defaultExpressionSearchString ].! !!FinderTool methodsFor: 'initialization' stamp: 'nk 3/5/2005 16:55'!initialize	conditionString := 'true'.	self searchEnvironment: BrowserEnvironment new.	searchMethods := false.	searchString := self defaultSearchString.! !!FinderTool methodsFor: 'actions' stamp: 'nk 2/24/2005 14:42'!search	| env |	self dependents 		do: [:dep | (dep respondsTo: #accept) ifTrue: [dep hasUnacceptedEdits ifTrue: [ dep accept]]].	([ self searchEnabled ] on: Error do: [ :ex | ex return: false ])		ifFalse: [ ^self inform: 'bad search string' ].	Cursor wait showWhile: 			[ env := (self searchFor: searchString asString				when: (self createConditionBlock ifNil: [^self flash])).				self foundEnvironment: env ]! !!FinderTool methodsFor: 'actions' stamp: 'nk 2/24/2005 14:41'!searchAndOpenEditor	self search.	self foundEnvironment ifNotNilDo: [ :env | env openEditor ]! !!FinderTool methodsFor: 'actions' stamp: 'nk 3/5/2005 16:41'!searchFor: pattern when: conditionalBlock 	| newEnv searches selector |	newEnv := SelectorEnvironment onEnvironment: BrowserEnvironment new.	searches := Set new.	selector := self searchMethods				ifTrue: [#replaceMethod:withValueFrom:when:]				ifFalse: [#replace:withValueFrom:when:].	searchEnvironment classesAndSelectorsDo: 			[:currentClass :currentSelector | 			| methodTree |			searchClass := currentClass.			methodTree := currentClass parseTreeFor: currentSelector.			methodTree ifNotNil: 					[(ParseTreeRewriter new 						perform: selector						with: pattern						with: 							[:tree | 							searches 								add: ((currentClass sourceCodeAt: currentSelector) copyFrom: tree start										to: tree stop).							newEnv addClass: currentClass selector: currentSelector.							tree]						with: conditionalBlock) executeTree: methodTree]].	searchClass := nil.	newEnv searchStrings: searches.	^newEnv! !!FinderTool methodsFor: 'testing' stamp: 'nk 3/5/2005 16:43'!searchEnabled	^self searchMethods 		ifTrue: [(RBParser parseRewriteMethod: searchString) notNil]		ifFalse: [(RBParser parseRewriteExpression: searchString) notNil]! !!FinderTool commentStamp: 'nk 2/25/2005 10:53' prior: 0!To match unknown code, use "Jokers" (explained below) that start with a ` , like the `@Expression in the example.That Joker will match any expression: 3 halt and (3 + 4) halt both match.The condition (second) paneBeyond the pattern match in the top pane, the expression found is also checked against a test condition in the second pane. Within that condition, aNode is set to each node that matches the pattern. If that pane is empty, the default pattern is true which is equivalent to this test block:[:aNode | true]Edit the second pane to make the test block more selective.See below for a quick reference to the node accessors and some tests.Browse RBProgramNode and subclasses to see what other tests they support.Joker referenceAll of the wild-card patterns used in the FinderTool start with a ` character. They include:`#literal		matches any literal (#(), #foo, 1, etc.)`@	(list of...) When applied to a variable node, this will match a literal, variable, or a sequence of messages sent to a literal or variable.When applied to a keyword in a message, it will match a list of keyword messages (i.e., any message send).When applied with a statement character, it will match a list of statements.	| `@Temps |				matches list of temps	`@.Statements			matches list of statements	`@object					matches any message node, literal node or block node	foo `@message: `@args	matches any message sent to foo`.Statement				matches a single statement in a sequence node`@.Statements			matches list of statements in a sequence node`		(recurse into)Whenever a match is found, look inside this matched node for more matches.	``@object foo				matches foo sent to any object, plus for each match found look for more matches in the ``@object part`{ :node :context | code }		Abitrary code; matches if code returns true. Block is passed the node being examined, and a Dictionary that can be used to hold context. The context is reset every method.For more information on Joker, aka meta-variables, see this page on the rewrite rule editor, with whom this tool shares much logic. http://st-www.cs.uiuc.edu/users/brant/Refactory/Rewrite.htmlTest condition quick referenceBrowse RBProgramNode and subclasses to see what other tests the nodes support.accessors:allArgumentVariables allDefinedVariables allTemporaryVariables asReturn blockVariables children comments comments: formattedCode formatterClass parent parent: precedence sentMessages source sourceInterval start stop temporaryVariablestests:isList isPatternNode assigns: containedBy: containsReturn defines: directlyUses: evaluatedFirst: intersectsInterval: isAssignment isBlock isCascade isDirectlyUsed isEvaluatedFirst isImmediate isLast: isLiteral isMessage isMethod isReturn isSequence isUsed isValue isVariable lastIsReturn references: uses:!!FinderTool class methodsFor: 'class initialization' stamp: 'nk 2/25/2005 10:16'!initialize	"self initialize"	TheWorldMenu unregisterOpenCommandWithReceiver: self.	TheWorldMenu registerOpenCommand: {'Code Finder'. {self. #open}}.	self registerInFlapsRegistry.! !!FinderTool class methodsFor: 'class initialization' stamp: 'nk 2/25/2005 10:17'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(#FinderTool #prototypicalToolWindow 'Finder Tool' 'For finding advanced patterns in code' ) 						forFlapNamed: 'Tools']! !!FinderTool class methodsFor: 'instance creation' stamp: 'nk 2/25/2005 10:54'!jokerHelp	^'This tool searches for code matching the pattern in the top pane.', self comment! !!FinderTool class methodsFor: 'instance creation' stamp: 'nk 2/25/2005 09:32'!onBrowserEnvironment: anEvironment	^self new searchEnvironment: anEvironment! !!FinderTool class methodsFor: 'instance creation' stamp: 'dvf 9/28/2001 23:31'!onClass: aClass	^self new searchEnvironment: (BrowserEnvironment new forClasses: {aClass}).! !!FinderTool class methodsFor: 'instance creation' stamp: 'dvf 9/29/2001 00:03'!onClassCategory: aClassCategory	^self new searchEnvironment: (BrowserEnvironment new forCategories: {aClassCategory}).! !!FinderTool class methodsFor: 'instance creation' stamp: 'nk 2/25/2005 07:43'!onClassHierarchyIncluding: aClass	| classes |	classes := Set new.	aClass withAllSubAndSuperclassesDo: [ :cls | classes add: cls ].	^self new searchEnvironment: (BrowserEnvironment new forClasses: classes).! !!FinderTool class methodsFor: 'instance creation' stamp: 'nk 3/4/2005 13:36'!onPackageWithClassCategory: aClassCategory	^self new searchEnvironment: ((BrowserEnvironment new forPackageContainingClassCategory: aClassCategory) ifNil: [ ^nil ])! !!FinderTool class methodsFor: 'instance creation' stamp: 'dvf 8/27/2003 14:50'!open	self new openAsMorph! !!FinderTool class methodsFor: 'instance creation' stamp: 'nk 2/25/2005 10:14'!prototypicalToolWindow	^(self new createMorphicWindow) extent: 400@400; yourself.! !!FinderTool class methodsFor: 'initialize-release' stamp: 'nk 2/25/2005 10:19'!unload	TheWorldMenu unregisterOpenCommandWithReceiver: self.	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!FinderTool class methodsFor: 'as yet unclassified' stamp: 'nk 2/27/2005 14:56'!windowColorSpecification	^RefactoringBrowser windowColorSpecification! !!FunctionScope methodsFor: 'captured vars' stamp: 'ms 7/3/2007 15:45'!addCaptured: name index: index	self forceThisEnv.	^ capturedVars add: (CapturedVar new			name: name;			index: index;			scope: self)! !!FunctionScope methodsFor: 'captured vars' stamp: 'ms 7/29/2007 22:48'!captureSelf: index	| captVar var |	var := self tempVarAt: 0.	captVar := self addCaptured: var name index: index.	captVar markArg.	captVar sourceTemp: var.	 ^captVar! !!FunctionScope methodsFor: 'captured vars' stamp: 'ajh 6/25/2004 22:24'!capturedVars	^ capturedVars asSortedCollection: [:x :y | x index <= y index]! !!FunctionScope methodsFor: 'captured vars' stamp: 'ajh 10/28/2004 23:41'!moveToCaptured: tempVar	"tempVar has been captured by an inner scope, move it from temps to captured. If tempVar is an arg, keep a temp version of it and link them via sourceTemp. tempVar 'becomes' a captured var so parse tree var nodes will keep pointer to its var."	| newTempVar |	self forceThisEnv.	tempVar isArg ifTrue: [		newTempVar _ tempVar copy.		tempVars remove: tempVar.		tempVars add: newTempVar.		tempVar becomeCaptured.		capturedVars add: tempVar.		tempVar index: capturedVars size.		tempVar sourceTemp: newTempVar.	] ifFalse: [		self removeTemp: tempVar.		tempVar becomeCaptured.		capturedVars add: tempVar.		tempVar index: capturedVars size.	].	^ tempVar! !!FunctionScope methodsFor: 'temp vars' stamp: 'ms 6/14/2007 22:36'!addObjectTemp: aTempVar	^ tempVars add: aTempVar! !!FunctionScope methodsFor: 'temp vars' stamp: 'ajh 6/26/2004 17:46'!addTemp: name	^ tempVars add: (TempVar new			name: name;			index: tempVars size; "zero-based; receiver is at 0"			scope: self)! !!FunctionScope methodsFor: 'temp vars' stamp: 'ajh 7/8/2004 19:50'!hideTemps	"If true do not allow inner scopes to capture my temps. Used by do-it scopes, which are fetching from an existing context env which no longer has its temps"	^ hideTemps = true! !!FunctionScope methodsFor: 'temp vars' stamp: 'ajh 6/25/2004 17:12'!receiverVar	^ self tempVars first! !!FunctionScope methodsFor: 'temp vars' stamp: 'ajh 6/25/2004 22:05'!removeTemp: tempVar	tempVars remove: tempVar.	tempVars do: [:var |		var index > tempVar index ifTrue: [			var index: var index - 1]].! !!FunctionScope methodsFor: 'temp vars' stamp: 'ms 7/13/2007 15:30'!removeTemp: tempVar ifAbsent: aBlock	tempVars remove: tempVar ifAbsent: aBlock.	tempVars do: [:var |		var index > tempVar index ifTrue: [			var index: var index - 1]].! !!FunctionScope methodsFor: 'temp vars' stamp: 'ms 7/10/2007 14:25'!removeTempFromOldBlock: tempVar	tempVars remove: tempVar ifAbsent: [self outerScope removeTempFromOldBlock: tempVar]! !!FunctionScope methodsFor: 'temp vars' stamp: 'ajh 6/25/2004 22:23'!tempVars	^ tempVars asSortedCollection: [:x :y | x index <= y index]! !!FunctionScope methodsFor: 'temp vars' stamp: 'ajh 7/8/2004 19:52'!tempsAreNoLongerAvailable	"Hide my temps and outer temps so they don't get captured (becuase they weren't captured and their values are not in the do-it env chain)"	hideTemps _ true.	self outerScope tempsAreNoLongerAvailable.! !!FunctionScope methodsFor: 'parent env' stamp: 'ms 8/7/2007 11:36'!addSlotForCapturedParentEnv	| receiver |	self hasInnerFreeVars ifFalse: [^ false].	receiver := self receiverVar.	capturedVars do: [:var | var sourceTemp = receiver ifTrue: [^ false]].	^ true! !!FunctionScope methodsFor: 'parent env' stamp: 'ms 8/20/2007 13:47'!capturedParentEnv	| receiver |	self hasInnerFreeVars ifFalse: [^ nil].	receiver := self receiverVar.	self remapCaptureVarForParentEnv.	capturedVars do: [:var | var sourceTemp = receiver ifTrue: [^ var]].	"not added to captured list, but slot is created for it in emitCreateEnv.	 It's not added since it was not captured directly by a variable reference in the code (only indirectly)"	^ CapturedVar new		name: 'env parent';		index: 1;		scope: self! !!FunctionScope methodsFor: 'parent env' stamp: 'ajh 7/8/2004 14:26'!closestEnvScope	"If self has its own env return self, otherwise return first outer scope with its own env"	self hasEscapingEnv ifTrue: [^ self].	^ self outerScope closestEnvScope! !!FunctionScope methodsFor: 'parent env' stamp: 'ajh 7/8/2004 15:38'!hasInnerFreeVars	"True if has inner scope that references to outer scope (non-global) variables. Indicates whether or not to add parent ref to local env"	^ hasInnerFreeVars = true! !!FunctionScope methodsFor: 'parent env' stamp: 'ajh 7/8/2004 15:37'!hasInnerFreeVars: bool	"True if has inner scope that references to outer scope (non-global) variables. Indicates whether or not to add parent ref to local env"	hasInnerFreeVars _ bool! !!FunctionScope methodsFor: 'parent env' stamp: 'ajh 7/8/2004 14:26'!outerEnvScope	^ outerScope closestEnvScope! !!FunctionScope methodsFor: 'parent env' stamp: 'ms 8/20/2007 10:16'!remapCaptureVarForParentEnv	| receiver receiverCaptured |	isCapturedVarsRemap ifTrue: [^self].	isCapturedVarsRemap := true.	receiver := self receiverVar.	(capturedVars anySatisfy: [:var | var sourceTemp = receiver and:[var index = 1]])		ifFalse:[			(capturedVars anySatisfy: [:var | var sourceTemp = receiver])				ifTrue: [					receiverCaptured := capturedVars detect: [:var | var sourceTemp = receiver].					(capturedVars detect:[:var | var index = 1]) index: receiverCaptured index.					receiverCaptured index: 1]				ifFalse: [					capturedVars  do: [:each | each index: each index + 1]]].! !!FunctionScope methodsFor: 'initializing' stamp: 'ajh 7/8/2004 20:23'!asDoItScope	^ (self primitiveChangeClassTo: ContextDoItScope basicNew) hideOuterTemps! !!FunctionScope methodsFor: 'initializing' stamp: 'ms 8/20/2007 01:36'!initialize	tempVars := KeyedSet keyBlock: [:var | var name].	capturedVars := KeyedSet keyBlock: [:var | var name].	isCapturedVarsRemap := false.	thisContextVar := ThisContextVar new		name: 'thisContext';		index: -2;		scope: self.! !!FunctionScope methodsFor: 'decompiling' stamp: 'ms 7/29/2007 01:24'!basicTempVarAt: tempIndex	^self basicTempVarAt: tempIndex ifNone:[self createTemp: tempIndex]! !!FunctionScope methodsFor: 'decompiling' stamp: 'ms 7/29/2007 01:23'!basicTempVarAt: tempIndex ifNone: aBlock	tempIndex = -2 ifTrue: [^ self thisContextVar].	tempIndex = -1 ifTrue: [^ self thisEnvVar].		^ tempVars detect: [:var | var index = tempIndex] ifNone: [		Preferences compileBlocksAsClosures ifFalse:[			self outerScope 				ifNotNil:[self outerScope isFunctionScope 					ifTrue:[^self outerScope tempVarAt: tempIndex ifNone: aBlock]]].		aBlock valueWithPossibleArgument: self	]! !!FunctionScope methodsFor: 'decompiling' stamp: 'ms 9/6/2007 05:01'!compactIndexTemps	| lastIndex |	lastIndex := self tempVars first index - 1.	self tempVars do: [:each | each index: (lastIndex := lastIndex + 1)].	^ self tempVars! !!FunctionScope methodsFor: 'decompiling' stamp: 'ms 6/26/2007 02:54'!createTemp: tempIndex	| name |	name := String streamContents: [:str |				self scopeLevel timesRepeat: [str nextPut: $t].		tempIndex printOn: str].	^tempVars add: 		(TempVar new			name: name;			index: tempIndex;			scope: self)! !!FunctionScope methodsFor: 'decompiling' stamp: 'ms 8/7/2007 11:42'!receiverVarAt: instVarIndex	^self outerScope hasEscapingEnv 		ifTrue: [self outerScope instVar: instVarIndex]		ifFalse: [self outerScope receiverVarAt: instVarIndex]! !!FunctionScope methodsFor: 'decompiling' stamp: 'ms 8/8/2007 13:06'!receiverVarForAssignmentAt: instVarIndex 	^ self outerScope hasEscapingEnv 		ifTrue: [self outerScope instVarForAssignment: instVarIndex]		ifFalse: [self outerScope receiverVarForAssignmentAt: instVarIndex]! !!FunctionScope methodsFor: 'decompiling' stamp: 'ms 7/3/2007 15:18'!tempVarAt: tempIndex	^self tempVarAt: tempIndex ifNone:[self createTemp: tempIndex]! !!FunctionScope methodsFor: 'decompiling' stamp: 'ms 7/28/2007 13:58'!tempVarAt: tempIndex ifNone: aBlock	tempIndex = -2 ifTrue: [^ self thisContextVar].	tempIndex = -1 ifTrue: [^ self thisEnvVar].	Preferences compileBlocksAsClosures ifTrue:[		capturedVars do:[:each | each index == tempIndex ifTrue: [^each]].		].	^ tempVars detect: [:var | var index = tempIndex] ifNone: [		Preferences compileBlocksAsClosures ifFalse:[			self outerScope 				ifNotNil:[self outerScope isFunctionScope 					ifTrue:[^self outerScope tempVarAt: tempIndex ifNone: aBlock]]].		aBlock valueWithPossibleArgument: self	]! !!FunctionScope methodsFor: 'lookup' stamp: 'md 10/16/2004 20:56'!captureVar: name	"Return the ScopeVar with this name. If a temp move to captured."	| var |	capturedVars at: name ifPresent: [:v | ^ v].	self hideTemps ifFalse: [		tempVars at: name ifPresent: [:v | ^ self moveToCaptured: v]].	(name = 'top env' and: [self isHome]) ifTrue: [^ self forceThisEnv].	var _ self outerScope captureVar: name.	(var notNil and: [var isGlobal not]) ifTrue: [self hasInnerFreeVars: true].	^ var! !!FunctionScope methodsFor: 'lookup' stamp: 'ms 8/8/2007 00:44'!captureVarAt: index 	| var name |	name := self captureVarName: index.	var := self tempVarAt: index						ifNone: [(TempVar new)								name: name;								index: index;								scope: self;								cantBeCapture].	^self captureVarAt: index sourceTemp: var! !!FunctionScope methodsFor: 'lookup' stamp: 'ms 8/8/2007 13:07'!captureVarAt: index sourceTemp: aTempVar	| captVar use name |		^ capturedVars detect: [:each | each index = index]		ifNone: 			[			name := self captureVarName: index.			aTempVar name = 'self' ifTrue:[name := 'self'].			use := aTempVar privUsage.			aTempVar itCanBeCapture				ifTrue: 					[aTempVar isArg 						ifTrue: 							[captVar := self addCaptured: aTempVar name index: index.							captVar sourceTemp: aTempVar]						ifFalse: 							[tempVars remove: aTempVar.							aTempVar name: name.							aTempVar becomeCaptured.							capturedVars add: aTempVar.							aTempVar index: index.							captVar := aTempVar]]				ifFalse:[					aTempVar isArg 						ifTrue: 							[(capturedVars at: aTempVar  name ifAbsent:[								captVar := self addCaptured: aTempVar name index: index.								captVar sourceTemp: aTempVar.								nil])									ifNotNil:[captVar := self addCaptured: (self captureVarName: index) index: index].]						ifFalse:[captVar := self addCaptured: name index: index]].			captVar privUsage: use.			captVar]! !!FunctionScope methodsFor: 'lookup' stamp: 'ms 8/8/2007 13:10'!captureVarForAssignmentAt: index 	| var name |	name := self captureVarName: index.	var := self tempVarAt: index				ifNone: 					[(TempVar new)						name: name;						index: index;						scope: self;						cantBeCapture].	(var isTemp and: [var isArg] )		ifTrue: 			[var := (TempVar new)						name: name;						index: index;						scope: self;						cantBeCapture].	^ self captureVarAt: index sourceTemp: var! !!FunctionScope methodsFor: 'lookup' stamp: 'ms 7/29/2007 01:19'!captureVarName: index 	^ String streamContents: 			[:str | 			self scopeLevel timesRepeat: [str nextPut: $c].			index printOn: str]! !!FunctionScope methodsFor: 'lookup' stamp: 'ms 7/3/2007 23:44'!instVar: index	^self captureVarAt: index! !!FunctionScope methodsFor: 'lookup' stamp: 'ms 8/8/2007 13:06'!instVarForAssignment: index 	^ self captureVarForAssignmentAt: index! !!FunctionScope methodsFor: 'lookup' stamp: 'md 3/10/2006 15:53'!lookupVar: name	"Return the ScopeVar with this name. If found in outer scope then move it to captured."	capturedVars at: name ifPresent: [:v | ^ v].	tempVars at: name ifPresent: [:v | ^ v].	name = 'thisEnv' ifTrue: [^ self forceThisEnv].	name = 'thisContext' ifTrue: [^ thisContextVar].	(name = 'top env' and: [self isHome]) ifTrue: [^ nil]. "'top env' used by return node"		Preferences compileBlocksAsClosures ifFalse: [				^ self outerScope rawVar: name.	].		^ self outerScope captureVar: name! !!FunctionScope methodsFor: 'lookup' stamp: 'ajh 7/8/2004 16:10'!possibleVarsFor: name continued: listOrNil	"Return my var names that are close in spelling to name"	| list |	list _ listOrNil.	name first isLowercase ifTrue: [		{tempVars. capturedVars} do: [:vars |			list _ name correctAgainstDictionary: vars continuedFrom: list]	].	^ self outerScope possibleVarsFor: name continued: list! !!FunctionScope methodsFor: 'lookup' stamp: 'ajh 10/28/2004 23:26'!rawVar: name	"Return the var with this name without capturing temps"	capturedVars at: name ifPresent: [:v | ^ v].	tempVars at: name ifPresent: [:v | ^ v].	name = 'thisEnv' ifTrue: [^ self forceThisEnv].	name = 'thisContext' ifTrue: [^ thisContextVar].	^ self outerScope rawVar: name! !!FunctionScope methodsFor: 'lookup' stamp: 'ms 7/5/2007 20:35'!rawVarAt: index ifNone: aBlock	"Return the var with the specific index"	^tempVars detect: [:each | each index = index] ifNone: aBlock.! !!FunctionScope methodsFor: 'emitting' stamp: 'ajh 7/8/2004 16:02'!emitCreateEnv: methodBuilder	"Create a heap environment for my captured vars"	methodBuilder		pushLiteral: ClosureEnvironment;		pushLiteral: capturedVars size + self addSlotForCapturedParentEnv asBit;		send: #new:.	self thisEnvVar emitLocalStore: methodBuilder.	methodBuilder popTop.! !!FunctionScope methodsFor: 'emitting' stamp: 'md 3/9/2006 12:04'!emitEnvParentEnv: methodBuilder	Preferences compileBlocksAsClosures ifTrue:  [		methodBuilder pushInstVar: self capturedParentEnv index.	].	"return which scope my parent env points to"	^ self outerEnvScope! !!FunctionScope methodsFor: 'emitting' stamp: 'md 3/9/2006 12:03'!emitLocalParentEnv: methodBuilder	"local parent is held in receiver"	Preferences compileBlocksAsClosures ifTrue:  [		self receiverVar emitLocalValue: methodBuilder.	].	"return which scope my receiver points to"	^ self outerEnvScope! !!FunctionScope methodsFor: 'emitting' stamp: 'ms 8/20/2007 10:16'!emitMoveCapturedRargs: methodBuilder	self isParentEnvCaptured ifTrue: [		self remapCaptureVarForParentEnv].	self capturedVars do: [:var |		| sourceTemp |		sourceTemp := var sourceTemp.		sourceTemp ifNotNil: [			sourceTemp emitLocalValue: methodBuilder.			self thisEnvVar emitLocalValue: methodBuilder.			methodBuilder storeInstVar: var index; popTop]].	self addSlotForCapturedParentEnv ifTrue: [		self receiverVar emitLocalValue: methodBuilder.		self thisEnvVar emitLocalValue: methodBuilder.		methodBuilder storeInstVar: 1; popTop].! !!FunctionScope methodsFor: 'emitting' stamp: 'ajh 7/8/2004 17:12'!emitMyEnv: methodBuilder	thisEnvVar emitLocalValue: methodBuilder! !!FunctionScope methodsFor: 'emitting' stamp: 'md 10/17/2004 14:14'!emitPrologue: methodBuilder	Preferences compileBlocksAsClosures ifTrue: [			self hasEscapingEnv ifFalse: [^ self].		self emitCreateEnv: methodBuilder.		self emitMoveCapturedRargs: methodBuilder.	]! !!FunctionScope methodsFor: 'env' stamp: 'ms 6/17/2007 16:24'!forceThisEnv	"create local env (if not already)"	thisEnvVar ifNotNil: [^ thisEnvVar].	^ thisEnvVar := ThisEnvVar new			name: 'thisEnv';			index: -1;			scope: self! !!FunctionScope methodsFor: 'env' stamp: 'ajh 7/8/2004 14:30'!hasEscapingEnv	"has own env?"	^ thisEnvVar notNil! !!FunctionScope methodsFor: 'env' stamp: 'ajh 6/25/2004 17:11'!thisContextVar	^ thisContextVar! !!FunctionScope methodsFor: 'env' stamp: 'ms 6/17/2007 16:29'!thisEnvVar	^ thisEnvVar ifNil:[self forceThisEnv ]! !!FunctionScope methodsFor: 'scope' stamp: 'ajh 6/26/2004 13:57'!isBlockScope	^ self isMethodScope not! !!FunctionScope methodsFor: 'scope' stamp: 'ajh 6/25/2004 15:18'!isFunctionScope	^ true! !!FunctionScope methodsFor: 'scope' stamp: 'ajh 6/29/2004 16:38'!isHome	"the home scope is the one that returns (^) return from"	^ isHome = true! !!FunctionScope methodsFor: 'scope' stamp: 'ajh 6/29/2004 16:38'!isHome: bool	"the home scope is the one that returns (^) return from"	isHome _ bool! !!FunctionScope methodsFor: 'scope' stamp: 'ajh 6/29/2004 16:38'!isMethodScope	^ self isHome! !!FunctionScope methodsFor: 'scope' stamp: 'ms 8/20/2007 01:55'!isParentEnvCaptured	self hasInnerFreeVars ifFalse: [^false].	^true! !!FunctionScope methodsFor: 'scope' stamp: 'ajh 7/8/2004 14:19'!popScope	"Propogate free var usages to their outer vars, then return outer scope"	^ self outerScope! !!FunctionScope methodsFor: 'printing' stamp: 'ajh 3/20/2003 11:29'!printOn: stream	super printOn: stream.	stream space.	self scopeLevel printOn: stream.! !!FunctionScope commentStamp: 'ajh 7/8/2004 18:33' prior: 0!I am the symbol table (for declared temp vars) for methods and blocks (non-inlined closures). Scopes nest mirroring the block nesting (skipping inlined blocks like ifTrue: blocks). Variable references are looked up in the closest scope first then if not found searches the outer scope and so on. Temp variables found in an outer scope become captured in that outer scope. The emitPrologue: checks if any temp were captured and if so generates code that creates a ClosureEnvironment for those captured vars and copies any captured rargs (receiver and arguments) into it. This way MethodContexts are LIFO. Even a non-local (remote) return does not hold onto its home context, but rather holds onto its home context's environment. Upon return the caller stack is searched for the context that points to that home environment and returns to it. This allows stacks to be copied and blocks to still return to the correct context within the current thread.!!GPArg1Parameter methodsFor: 'code generation' stamp: 'md 2/15/2007 10:10'!genForRBProgramNode	^node arguments first! !!GPArg1Parameter class methodsFor: 'plugin interface' stamp: 'md 2/11/2007 10:57'!key	^#arg1! !!GPArg1Parameter class methodsFor: 'plugin interface' stamp: 'md 2/27/2007 21:16'!nodes	^{RBMessageNode. RBMethodNode. RBBlockNode}! !!GPArg2Parameter methodsFor: 'code generation' stamp: 'md 2/15/2007 10:11'!genForRBProgramNode	^node arguments second! !!GPArg2Parameter class methodsFor: 'plugin interface' stamp: 'md 2/11/2007 10:58'!key	^#arg2! !!GPArg2Parameter class methodsFor: 'plugin interface' stamp: 'md 2/15/2007 12:35'!nodes	^{RBMessageNode. RBMethodNode}! !!GPArg3Parameter methodsFor: 'code generation' stamp: 'md 2/15/2007 10:11'!genForRBProgramNode	^node arguments third! !!GPArg3Parameter class methodsFor: 'plugin interface' stamp: 'md 2/11/2007 10:58'!key	^#arg3! !!GPArg3Parameter class methodsFor: 'plugin interface' stamp: 'md 2/15/2007 12:35'!nodes	^{RBMessageNode. RBMethodNode}! !!GPArg4Parameter methodsFor: 'code generation' stamp: 'md 2/15/2007 10:11'!genForRBProgramNode	^node arguments fourth! !!GPArg4Parameter class methodsFor: 'plugin interface' stamp: 'md 2/11/2007 10:58'!key	^#arg4! !!GPArg4Parameter class methodsFor: 'plugin interface' stamp: 'md 2/15/2007 12:35'!nodes	^{RBMessageNode. RBMethodNode}! !!GPArgumentsParameter methodsFor: 'code generation' stamp: 'md 4/14/2007 01:59'!genForRBProgramNode	node numArgs = 0 ifTrue: [^#() asLiteralNode].	node numArgs <= 4 ifTrue: [			^RBMessageNode 						receiver: Array asLiteralNode			 			selector: (#braceWith numArgs: node numArgs) 						arguments: 	node arguments				].			node numArgs > 4 ifTrue: [ | stream messages |			stream := RBMessageNode 				receiver: Array asLiteralNode	 			selector:  #braceStream:				argument: 	node arguments size asLiteralNode.			messages := (node arguments collect: [:each | 														RBMessageNode																receiver: stream 																selector: #nextPut:																argument: each]) asOrderedCollection.			messages add: (RBMessageNode receiver: stream selector: #braceArray).			^RBCascadeNode messages: messages.		].! !!GPArgumentsParameter methodsFor: 'code generation' stamp: 'md 2/27/2007 21:18'!optimize	^node isBlock not and: [node selector numArgs >0].! !!GPArgumentsParameter class methodsFor: 'plugin interface' stamp: 'md 2/10/2007 23:19'!key	^#arguments! !!GPArgumentsParameter class methodsFor: 'plugin interface' stamp: 'md 2/27/2007 21:17'!nodes	^{RBMessageNode. RBMethodNode. RBBlockNode}! !!GPAssignment methodsFor: 'accessing' stamp: 'md 2/9/2007 14:32'!newValue	^newValue! !!GPAssignment methodsFor: 'accessing' stamp: 'md 2/9/2007 14:31'!newValue: anObject	newValue := anObject! !!GPBindingParameter methodsFor: 'code generation' stamp: 'md 2/24/2007 10:00'!genForRBAssignmentNode	^node variable binding assoc asLiteralNode	! !!GPBindingParameter methodsFor: 'code generation' stamp: 'md 2/24/2007 10:01'!genForRBVariableNode	^node binding assoc asLiteralNode! !!GPBindingParameter class methodsFor: 'plugin interface' stamp: 'md 2/24/2007 09:56'!key	^#binding! !!GPBindingParameter class methodsFor: 'plugin interface' stamp: 'md 2/24/2007 09:47'!nodes	^{RBAssignmentNode. RBVariableNode}! !!GPBlock methodsFor: 'accessing' stamp: 'md 2/23/2007 18:07'!arguments	^arguments! !!GPBlock methodsFor: 'accessing' stamp: 'md 2/23/2007 18:07'!arguments: anArray	arguments := anArray! !!GPBlock methodsFor: 'accessing' stamp: 'md 2/23/2007 18:07'!block	^block! !!GPBlock methodsFor: 'accessing' stamp: 'md 2/23/2007 18:06'!block: aBlock	block := aBlock! !!GPBlock methodsFor: 'evaluating' stamp: 'md 5/11/2007 15:19'!value	context ifNotNil: [thisContext privSender: context].		^arguments		ifNil: [block value] 		ifNotNil: [block valueWithArguments: arguments].! !!GPBlockContextTest methodsFor: 'testing' stamp: 'md 2/18/2007 00:18'!testBlockNames	| block names |		block := [:hey :du | ^hey + du].	 	names := block blockArgNames.		self assert: names first = 'hey'.	self assert: names second = 'du'.! !!GPBlockContextTest methodsFor: 'testing' stamp: 'md 2/18/2007 00:25'!testValueSelector	self assert: ([1] valueSelector = #value).	self assert: ([:each | 1] valueSelector = #value:).	self assert: ([:each :each2 | 1] valueSelector = #value:value:).	self assert: ([:each :each2 :each3  | 1] valueSelector = #value:value:value:).! !!GPBlockTempDecompiler methodsFor: 'initialize-release' stamp: 'md 2/13/2007 16:05'!initialize	offsets := OrderedCollection new.	^super initialize! !!GPBlockTempDecompiler methodsFor: 'accessing' stamp: 'md 2/13/2007 16:07'!offsets	^offsets! !!GPBlockTempDecompiler methodsFor: 'instruction decoding' stamp: 'md 2/13/2007 16:21'!popIntoTemporaryVariable: offset 	"Remove Top Of Stack And Store Into Temporary Variable bytecode."	offsets add: offset.! !!GPBlockTempDecompiler methodsFor: 'instruction decoding' stamp: 'md 2/13/2007 16:27'!storeIntoTemporaryVariable: offset 	"Store Top Of Stack Into Temporary Variable Of Method bytecode."	offsets add: offset.! !!GPClassParameter methodsFor: 'code generation' stamp: 'md 2/23/2007 12:36'!genForRBProgramNode	^RBMessageNode 			receiver: (RBVariableNode named: 'self')			selector: #class! !!GPClassParameter methodsFor: 'code generation' stamp: 'md 2/23/2007 12:36'!optimize	^true! !!GPClassParameter class methodsFor: 'plugin interface' stamp: 'md 2/23/2007 12:35'!key	^#class! !!GPClassParameter class methodsFor: 'plugin interface' stamp: 'md 2/23/2007 12:35'!nodes	^{RBProgramNode}! !!GPCondition methodsFor: 'as yet unclassified' stamp: 'md 10/18/2007 11:20'!arguments: args	arguments := args.! !!GPCondition methodsFor: 'as yet unclassified' stamp: 'md 10/18/2007 11:04'!condition	^condition! !!GPCondition methodsFor: 'as yet unclassified' stamp: 'md 10/18/2007 11:04'!condition: aBooleanOrBlock	condition := aBooleanOrBlock! !!GPCondition methodsFor: 'as yet unclassified' stamp: 'md 10/18/2007 11:06'!numArgs	^condition numArgs! !!GPCondition methodsFor: 'as yet unclassified' stamp: 'md 10/18/2007 11:01'!reifications	condition isBoolean ifTrue: [^#()].	arguments ifNotNil: [^arguments].  		"arguments of the block are the reifications"		^condition blockArgNames collect: #asSymbol.! !!GPCondition methodsFor: 'as yet unclassified' stamp: 'md 10/18/2007 11:09'!value	^condition value.! !!GPCondition methodsFor: 'as yet unclassified' stamp: 'md 10/18/2007 11:09'!value: anObject	^condition  value: anObject.! !!GPCondition methodsFor: 'as yet unclassified' stamp: 'md 10/18/2007 11:08'!value: anObjectA value: anObjectB	^condition value: anObjectA value: anObjectB! !!GPCondition methodsFor: 'as yet unclassified' stamp: 'md 10/18/2007 11:09'!value: anObjectA value: anObjectB value: anObjectC	^condition value: anObjectA value: anObjectB value: anObjectC! !!GPCondition methodsFor: 'as yet unclassified' stamp: 'md 10/18/2007 11:09'!value: anObjectA value: anObjectB value: anObjectC value: anObjectD	^condition value: anObjectA value: anObjectB value: anObjectC value: anObjectD! !!GPCondition methodsFor: 'as yet unclassified' stamp: 'md 10/18/2007 11:10'!valueSelector	^condition valueSelector! !!GPCondition class methodsFor: 'as yet unclassified' stamp: 'md 10/18/2007 11:04'!with: aBooleanOrBlock	^self new condition: aBooleanOrBlock! !!GPContinuation methodsFor: 'private' stamp: 'md 3/9/2007 16:40'!initializeFromContext: aContext	| valueStream context |	valueStream := WriteStream on: (Array new: 20).	context := aContext.	[context notNil] whileTrue:		[valueStream nextPut: context.		1 to: context class instSize do: [:i | valueStream nextPut: (context instVarAt: i)].		1 to: context size do: [:i | valueStream nextPut: (context at: i)].		context := context sender].	values := valueStream contents! !!GPContinuation methodsFor: 'private' stamp: 'md 3/9/2007 16:40'!restoreValues	| valueStream context |	valueStream := values readStream.	[valueStream atEnd] whileFalse:		[context := valueStream next.		1 to: context class instSize do: [:i | context instVarAt: i put: valueStream next].		1 to: context size do: [:i | context at: i put: valueStream next]]! !!GPContinuation methodsFor: 'private' stamp: 'ab 6/15/2003 19:13'!terminate: aContext	| context |	context := aContext.	[context notNil] whileTrue: [context := context swapSender: nil]! !!GPContinuation methodsFor: 'evaluating' stamp: 'lr 2/6/2007 17:19'!invoke: aBlock	"Invoke the continuation and evaluates aBlock within the captured execution context."		| activation | 	aBlock fixTemps.	self terminate: thisContext.	self restoreValues.	activation := aBlock asContext.	activation swapSender: values first.	thisContext swapSender: activation! !!GPContinuation methodsFor: 'evaluating' stamp: 'ab 6/15/2003 19:13'!value	self value: nil! !!GPContinuation methodsFor: 'evaluating' stamp: 'lr 1/5/2007 18:35'!value: anObject	"Invoke the continuation and answer anObject as return value."		self terminate: thisContext.	self restoreValues.	thisContext swapSender: values first.	^ anObject! !!GPContinuation methodsFor: 'evaluating' stamp: 'lr 1/5/2007 16:02'!valueWithArguments: anArray	anArray size = 1 		ifFalse: [ ^ self error: 'continuations can only be resumed with one argument' ].	self value: anArray first! !!GPContinuation methodsFor: 'accessing' stamp: 'ab 6/15/2003 19:18'!numArgs	^ 1! !!GPContinuation class methodsFor: 'instance creation' stamp: 'ab 6/15/2003 19:13'!current	^ self fromContext: thisContext sender! !!GPContinuation class methodsFor: 'instance creation' stamp: 'ab 6/15/2003 19:13'!currentDo: aBlock	^ aBlock value: (self fromContext: thisContext sender)! !!GPContinuation class methodsFor: 'instance creation' stamp: 'ab 6/15/2003 19:13'!fromContext: aStack	^self new initializeFromContext: aStack! !!GPContinuation class methodsFor: 'instance creation' stamp: 'md 3/9/2007 16:05'!gpCurrentDo: aBlock	^ aBlock value: (self fromContext: thisContext gpsender)! !!GPContinuationParameter methodsFor: 'code generation' stamp: 'md 3/9/2007 15:59'!genForRBProgramNode	^RBVariableNode named: 'continuation'.! !!GPContinuationParameter class methodsFor: 'as yet unclassified' stamp: 'md 3/9/2007 11:47'!key	^#continuation! !!GPContinuationParameter class methodsFor: 'as yet unclassified' stamp: 'md 3/9/2007 11:47'!nodes	^{RBProgramNode}.! !!GPContinuationTest methodsFor: 'utilities' stamp: 'md 3/9/2007 16:40'!callcc: aBlock	^ GPContinuation currentDo: aBlock! !!GPContinuationTest methodsFor: 'tests' stamp: 'lr 1/5/2007 17:26'!testBlockEscape	| x |	tmp := 0.	x := [ tmp := tmp + 1. tmp2 value ].	self callcc: [ :cc | tmp2 := cc. x value ].	tmp2 := [ ].	x value.	self assert: tmp = 2! !!GPContinuationTest methodsFor: 'tests' stamp: 'lr 1/5/2007 17:27'!testBlockTemps	| y |	#(1 2 3) do: [ :i |		| x |		x := i.		tmp ifNil: [ tmp2 := (self callcc: [ :cc | tmp := cc. [ :q ] ]) ].		tmp2 value: x.		x := 17 ].	y := (self callcc: [ :cc | tmp value: cc. 42 ]).	self assert: y = 1! !!GPContinuationTest methodsFor: 'tests' stamp: 'lr 1/5/2007 17:27'!testBlockVars	| continuation |	tmp := 0.	tmp := (self callcc: [ :cc | continuation := cc. 0 ]) + tmp.	tmp2 		ifNotNil: [ tmp2 value ]		ifNil: [			#(1 2 3) do: [ :i |				self callcc: [ :cc | tmp2 := cc. continuation value: i ] ] ].	self assert: tmp = 6! !!GPContinuationTest methodsFor: 'tests' stamp: 'lr 1/5/2007 17:28'!testComprehension	"What should this print out?		| yin yang |	yin := [ :x | Transcript cr. x ] value: Continuation current.	yang := [ :x | Transcript nextPut: $*. x ] value: Continuation current.	yin value: yang"! !!GPContinuationTest methodsFor: 'tests' stamp: 'lr 1/5/2007 18:24'!testInvokeMultiple	| assoc |	assoc := self callcc: [ :cc | cc -> 0 ].	assoc value: assoc value + 1.	self assert: assoc value ~= 5.	assoc value = 4		ifFalse: [ assoc key invoke: [ assoc ] ]! !!GPContinuationTest methodsFor: 'tests' stamp: 'mb 2/6/2007 18:20'!testInvokeSimple	| x continuation |	x := self callcc: [ :cc | continuation := cc. false ].	x ifFalse: [ continuation invoke: [ true & true ] ]. "Must have a least one message send in this block for VW"	self assert: x! !!GPContinuationTest methodsFor: 'tests' stamp: 'lr 1/5/2007 17:27'!testMethodTemps	| i continuation |	i := 0.	i := i + (self callcc: [:cc | continuation := cc. 1]).	self assert: i ~= 3.	i = 2 ifFalse: [ continuation value: 2 ]! !!GPContinuationTest methodsFor: 'tests' stamp: 'lr 1/5/2007 18:22'!testReentrant	| assoc |	assoc := self callcc: [ :cc | cc -> 0 ].	assoc value: assoc value + 1.	self assert: assoc value ~= 5.	assoc value = 4		ifFalse: [ assoc key value: assoc ]! !!GPContinuationTest methodsFor: 'tests' stamp: 'lr 1/5/2007 17:28'!testSimpleCallCC	| x continuation |	x := self callcc: [ :cc | continuation := cc. false ].	x ifFalse: [ continuation value: true ].	self assert: x! !!GPContinuationTest methodsFor: 'tests' stamp: 'lr 1/5/2007 17:28'!testSimplestCallCC	| x |	x := self callcc: [ :cc | cc value: true ].	self assert: x! !!GPControlParameter methodsFor: 'code generation' stamp: 'md 2/12/2007 20:44'!genForRBProgramNode	^link control asLiteralNode! !!GPControlParameter class methodsFor: 'plugin interface' stamp: 'md 2/11/2007 10:52'!key	^#control! !!GPControlParameter class methodsFor: 'plugin interface' stamp: 'md 2/15/2007 12:36'!nodes	^{RBProgramNode}! !!GPCopyingTransformer methodsFor: 'visiting' stamp: 'md 11/4/2007 20:19'!acceptSequenceNode: aSequenceNode 	aSequenceNode temporaries: (self visitTemporaryVariables: aSequenceNode temporaries).	"need special code here: check if before, do right thing"	aSequenceNode statements: (aSequenceNode statements collect: [:each | self visitNode: each]).	^aSequenceNode! !!GPCopyingTransformer methodsFor: 'visiting' stamp: 'md 11/4/2007 20:15'!visitNode: aNode	^aNode copy acceptVisitor: self.		"	node := aNode copy.	node hasAnyLink ifTrue: [		node links do: [:each |			link := each.			self initForNode: node.			self transform.		].	]."	! !!GPCopyingTransformer methodsFor: 'transformation' stamp: 'md 11/4/2007 18:23'!addPreamble: aNode	ptable do: [:each | aNode gpAddBefore: each].! !!GPCopyingTransformer methodsFor: 'transformation' stamp: 'md 11/4/2007 18:23'!genInitialHook	| metaObject  |		metaObject := (link metaObject isSymbol and: [self reifications includes: link metaObject])   "Allow reifications as MetaObject"				ifTrue: [table at: link metaObject]				ifFalse: [link isInlineMeta 							ifTrue: [link metaObject asLiteralNode]							ifFalse: [RBMessageNode 											receiver: link asLiteralNode											selector: #metaObject]].										link hasMoScope ifTrue: [metaObject := RBMessageNode 											receiver: link asLiteralNode											selector: #metaObjectFor:											arguments: {table at: link moScope}].																hook := RBMessageNode 						receiver: metaObject  						selector: link selector						arguments: (link arguments collect: #asLiteralNode).	! !!GPCopyingTransformer methodsFor: 'transformation' stamp: 'md 11/4/2007 18:23'!genSelectorFor: aCondition	^link isInlineCondition 		ifTrue: [link condition valueSelector]	     ifFalse: [#isActive numArgs: aCondition numArgs].! !!GPCopyingTransformer methodsFor: 'transformation' stamp: 'md 11/4/2007 18:23'!insertCode	link isBefore ifTrue: [^node gpAddBefore: hook].	link isAfter ifTrue: [^node gpAddAfter: hook].	link isBeforeAfter ifTrue: [^(node gpAddAfter: hook) gpAddBefore: hook].	link isInstead ifTrue: [^node gpreplaceWith: hook].! !!GPCopyingTransformer methodsFor: 'transformation' stamp: 'md 11/4/2007 18:23'!patchArguments	hook arguments: (link arguments collect: [:each | table at: each])! !!GPCopyingTransformer methodsFor: 'transformation' stamp: 'md 11/4/2007 18:23'!reifications	"all reifications the plugins installed can do. Installed are only the plugins compatible with the node" 	^plugins values collect: [:each | each class key].! !!GPCopyingTransformer methodsFor: 'transformation' stamp: 'md 11/4/2007 18:23'!selectorForNode	"The selector to be called on the Reification plugin"	^('genFor' , node class name) asSymbol.! !!GPCopyingTransformer methodsFor: 'transformation' stamp: 'md 11/4/2007 18:23'!setupTable	"Here we set up two tables: for every reification requested, we put the Reifier Plugin into 'table'. If a second	 reification is requested that requires complex code, we move the reification code into the preamble's 'ptable'	 and put an tempVarRead into the main table instead	 Later we just access 'table at: symbol' to get code for a requested reification and generate a preamble that fills	 those variable at the beginning of the link's code"	| reification |	reification := OrderedCollection new.	reification addAll: link arguments. 	link metaObject isSymbol ifTrue: [reification add: link metaObject].	link condition ifNotNil: [reification addAll: link condition reifications].	link hasMoScope ifTrue: [reification add: link moScope].		reification do: [:symbol |		(plugins at: symbol) optimize ifTrue: [ "don't bother to optimize one-bytecode reifications" 			((table includesKey: symbol) and: [(ptable includesKey: symbol) not]) ifTrue: [ | var |  "we already saw this one, use temp instead"				var := RBVariableNode named: ('gphhhddd', symbol).				ptable at: symbol put: (RBAssignmentNode variable: var				  										 value: (table at: symbol)).				node methodNode body addTemporaryNamed: 'gphhhddd', symbol.				table at: symbol put: var.			].		].		table at: symbol ifAbsentPut: [(plugins at: symbol) perform: self selectorForNode].	]! !!GPCopyingTransformer methodsFor: 'transformation' stamp: 'md 11/4/2007 18:23'!transform	"Main transformation method"	| newNode |	(link isInlineCondition and: [link condition condition = false]) ifTrue: [^self]. "nothing to do..."	self setupTable.	link hasCondition ifFalse: [self addPreamble: node].	self genInitialHook.	self patchArguments.	self wrapCondition.	self wrapContext.	link requestsContinuation ifTrue: [self wrapContinuation].	link requestsResult ifTrue: [self wrapResult].	newNode := self insertCode.	newNode ifNotNil: [node := newNode].		! !!GPCopyingTransformer methodsFor: 'transformation' stamp: 'md 11/4/2007 18:23'!wrapCondition		|  ifSelector ifArguments condReceiver condSelector condArguments blockBody blockBody2 |		link hasCondition ifFalse: [^self]. "no condition"	(link isInlineCondition and: [link condition condition = true]) ifTrue: [^self].  "no condition needed"		condReceiver := (link isInlineCondition ifTrue: [link condition condition] ifFalse: [link]) asLiteralNode.	condSelector := self genSelectorFor: link condition condition.		(condSelector numArgs = 0) ifTrue: [condArguments  := #()].	(condSelector numArgs > 0) ifTrue: [			condArguments := OrderedCollection new.			1 to: condSelector numArgs do: [:i |				condArguments add: (table at: (link condition reifications at: i))]	].														ifSelector :=  link isInstead ifTrue: [#ifTrue:ifFalse:] ifFalse:[#ifTrue:].		blockBody := hook asSequenceNode.	self addPreamble: hook.		blockBody2 := (node isKindOf: RBMethodNode) ifTrue: [node body] ifFalse: [node copy asSequenceNode].		ifArguments := link isInstead				ifTrue: [{RBBlockNode body: blockBody. RBBlockNode body: blockBody2 }]				ifFalse: [{RBBlockNode body: blockBody}].				hook := RBMessageNode			receiver: (RBMessageNode 							receiver: condReceiver							selector: condSelector							arguments: condArguments)			selector: ifSelector			arguments: ifArguments.	! !!GPCopyingTransformer methodsFor: 'transformation' stamp: 'md 11/4/2007 18:23'!wrapContext		|  ifSelector ifArguments condReceiver condSelector condArguments blockBody blockBody2 |		link context ifNil: [^self].	condReceiver := RBMessageNode			receiver:  (RBVariableNode new				identifierToken: (SqueakToken value: link context name start: 0))			selector: #current			arguments: #().	condSelector := #isActive.	condArguments  := #().														ifSelector :=  link isInstead ifTrue: [#ifTrue:ifFalse:] ifFalse:[#ifTrue:].		blockBody := hook asSequenceNode.	"self addPreamble: hook."		blockBody2 := (node isKindOf: RBMethodNode) ifTrue: [node body] ifFalse: [node copy asSequenceNode].		ifArguments := link isInstead				ifTrue: [{RBBlockNode body: blockBody. RBBlockNode body: blockBody2 }]				ifFalse: [{RBBlockNode body: blockBody}].				hook := RBMessageNode			receiver: (RBMessageNode 							receiver: condReceiver							selector: condSelector							arguments: condArguments)			selector: ifSelector			arguments: ifArguments.	! !!GPCopyingTransformer methodsFor: 'transformation' stamp: 'md 11/4/2007 18:23'!wrapContinuation		| continuationBlock |		continuationBlock := RBBlockNode 							arguments: {RBVariableNode named: 'continuation'}							body: hook asSequenceNode.			hook := RBMessageNode			receiver: GPContinuation asLiteralNode			selector: #gpCurrentDo:			argument: continuationBlock.	! !!GPCopyingTransformer methodsFor: 'transformation' stamp: 'md 11/4/2007 18:23'!wrapResult	| parent newNode |	parent := node parent.	node methodNode body addTemporaryNamed: 'gpResultkkdkdkkd'. 		node isMethod 		ifFalse: [    newNode := (RBAssignmentNode						variable: (RBVariableNode named: 'gpResultkkdkdkkd')						value: node copy) parent: parent.					"node replaceWith: newNode."					"node := newNode"]		ifTrue: [ | toReplace |			toReplace := node body statements first.			 toReplace replaceWith:  (RBAssignmentNode						variable: (RBVariableNode named: 'gpResultkkdkdkkd')						value: toReplace copy).			toReplace methodNode   body addTemporaryNamed: 'gpResultkkdkdkkd'. 						 ]							! !!GPCopyingTransformer methodsFor: 'accessing' stamp: 'md 11/4/2007 18:23'!hook: aHook	hook := aHook! !!GPCopyingTransformer methodsFor: 'accessing' stamp: 'md 11/4/2007 18:23'!link: aLink	link := aLink! !!GPCopyingTransformer methodsFor: 'initializing' stamp: 'md 11/4/2007 18:23'!initForNode: aNode	table := Dictionary new.	ptable := Dictionary new.	plugins := Dictionary new.		"register all the plugins that can reify information for this node"	GPParameter subclasses do: [:plugin |		(plugin nodes anySatisfy: [:class | node isKindOf: class])	 ifTrue: [			plugins at: plugin key put: (plugin node: node link: link)]		]! !!GPCopyingTransformerTest methodsFor: 'as yet unclassified' stamp: 'md 11/4/2007 19:44'!testCopyHalt	| tree copy |	tree := PEParser new parse: (Object>>#halt) getSource class: Object.			copy := GPCopyingTransformer new visitNode: tree.		self assert: copy = tree.	self deny: copy == tree.		self deny: copy body statements first == tree body statements first.! !!GPCountMethodWrapper methodsFor: 'before after' stamp: 'md 2/24/2007 14:48'!beforeMethod	self count: self count + 1.! !!GPCountMethodWrapper methodsFor: 'initializing' stamp: 'md 2/24/2007 14:49'!class: aClass selector: aSymbol	self count: 0.	^ super class: aClass selector: aSymbol! !!GPCountMethodWrapper methodsFor: 'accessing' stamp: 'md 2/24/2007 14:49'!count 	^count! !!GPCountMethodWrapper methodsFor: 'accessing' stamp: 'md 2/24/2007 14:49'!count: aNumber	count := aNumber! !!GPCountMethodWrapper methodsFor: 'accessing' stamp: 'md 2/24/2007 14:52'!reset	count := 0.! !!GPCountMethodWrapper commentStamp: 'md 2/24/2007 15:23' prior: 0!A count method wrapper counts the number of times the method is called.Instance Variables	count:	 	invocation counter!!GPCountMethodWrapperTest methodsFor: 'testing' stamp: 'md 5/18/2007 15:57'!testCounts	| wrapper instance |	wrapper := self wrapperClass on: #methodOne inClass: GPMwClassA.	wrapper install.	instance := GPMwClassA new.	self assert: wrapper count = 0.	instance methodOne.	self assert: wrapper count = 1. 	instance methodOne.	self assert: wrapper count = 2.	wrapper uninstall.		GPMwClassA methodDict values do: [:method | 		method reflectiveMethod methodNode removeProperty: #before ifAbsent: [].		method  reflectiveMethod methodNode  removeProperty: #after  ifAbsent: [].	].! !!GPCountMethodWrapperTest methodsFor: 'private' stamp: 'md 2/24/2007 15:49'!wrapperClass	^ GPCountMethodWrapper! !!GPCounter methodsFor: 'counter' stamp: 'md 2/7/2007 08:55'!count 	^count! !!GPCounter methodsFor: 'counter' stamp: 'md 2/7/2007 08:55'!inc	count := count + 1.! !!GPCounter methodsFor: 'initialize-release' stamp: 'md 2/14/2007 20:42'!initialize	count := 0! !!GPCounter class methodsFor: 'counter' stamp: 'md 2/7/2007 17:17'!counter 	^counter! !!GPCounter class methodsFor: 'counter' stamp: 'md 2/7/2007 17:17'!inc	counter := counter + 1.! !!GPCounter class methodsFor: 'counter' stamp: 'md 2/7/2007 17:17'!reset 	counter := 0.! !!GPCounter class methodsFor: 'protocol' stamp: 'md 2/8/2007 20:51'!link	^ GPLink new			metaObject: self new;				selector: #inc.	   ! !!GPExamples methodsFor: 'testcode' stamp: 'md 8/20/2007 16:49'!a	i := 5.	^i! !!GPExamples methodsFor: 'testcode' stamp: 'md 8/20/2007 11:48'!a: anInteger	i := anInteger.	^i! !!GPExamples methodsFor: 'testcode' stamp: 'md 7/25/2007 15:25'!exampleIf	^false ifFalse: [1+2] ifTrue: [7].! !!GPExamples methodsFor: 'testcode' stamp: 'ms 10/3/2007 15:40'!log: aString		GPCounter inc.	Transcript show: aString! !!GPExamples methodsFor: 'examples' stamp: 'md 4/13/2007 22:53'!example	| a b |	 	a := 5. 	b := 6.    	^ a + b.    ! !!GPExamples methodsFor: 'examples' stamp: 'dr 10/4/2007 13:48'!exampleBlock	|  c |	c := [:a | a + 6]. 	c value: 2.	^c value: 2.! !!GPExamples methodsFor: 'examples' stamp: 'md 10/5/2007 14:39'!exampleBlock2	^b ifNotNilDo: [:ea | self a: ea].! !!GPExamples methodsFor: 'examples' stamp: 'md 8/23/2007 16:46'!exampleCascade	^2 class;class;class! !!GPExamples methodsFor: 'examples' stamp: 'dr 9/24/2007 16:43'!exampleCascade2	^self class new a: self; a: self; a: self! !!GPExamples methodsFor: 'examples' stamp: 'md 2/22/2007 17:59'!exampleClassWrite	Test := 5. 	^Test.! !!GPExamples methodsFor: 'examples' stamp: 'md 2/22/2007 17:59'!exampleGlobalRead	| t |	t := Smalltalk.	^t. ! !!GPExamples methodsFor: 'examples' stamp: 'md 2/22/2007 17:59'!exampleIvar	 	i := 6. 	^ i + 5.   ! !!GPExamples methodsFor: 'examples' stamp: 'ms 10/3/2007 15:00'!exampleLog		| a |	a := 4 + 3.	^a! !!GPExamples methodsFor: 'examples' stamp: 'md 2/22/2007 17:59'!exampleSend	| a b |		a := 5.	b := 7. 	^ 6 between: 5 and: 7.    ! !!GPExamples methodsFor: 'examples' stamp: 'md 8/25/2007 15:18'!exampleSend2	| a b r |	 	a := 5.	b := 7. 	r :=  6 between: 5 and: 7.  	^r.  ! !!GPExamples methodsFor: 'examples' stamp: 'md 2/22/2007 17:59'!exampleSendZeroArg	^ 5 factorial ! !!GPExamples methodsFor: 'examples' stamp: 'md 2/22/2007 17:59'!exampleSendmanyArgs	^ self send: #+ with: 1 with: 2 with: 3 with: 4 with: 5.  ! !!GPExamples methodsFor: 'examples' stamp: 'dr 10/9/2007 15:43'!exampleSingleVariableInBlock	^[b] value! !!GPExamples methodsFor: 'examples' stamp: 'md 3/16/2007 15:28'!exampleWriteTransform	| a |		a := 5 + 9.		^a.! !!GPExamples methodsFor: 'examples' stamp: 'md 3/28/2007 11:49'!examplea: a b: b	^ a + b.   ! !!GPExamples methodsFor: 'examples' stamp: 'md 2/22/2007 17:59'!examplea: a b: b c: c d: d e: e	^ a + b  + c + d + e. ! !!GPExamples methodsFor: 'examples' stamp: 'md 3/5/2007 16:06'!send: sel with: a with: b with: c with: d with: e   	GPCounter inc.	^{a. b. c. d. e.} inject: 0 into: [:result :each | result perform: sel with: each]! !!GPExamples methodsFor: 'examples'!testReifyMo	GPCounter inc! !!GPExamples methodsFor: 'initializing' stamp: 'dr 10/4/2007 13:40'!initialize    b := 5! !!GPExamples class methodsFor: 'accessing' stamp: 'md 3/31/2007 19:13'!compilerClass	^ PECompiler! !!GPExamples class methodsFor: 'accessing' stamp: 'md 3/20/2007 17:24'!parseTreeFor: aSymbol	^(self compiledMethodAt: aSymbol) reflectiveMethod methodNode! !!GPExamples class methodsFor: 'compiling' stamp: 'md 3/20/2007 17:28'!recompile: selector from: oldClass	| jMethod |	jMethod := (oldClass >> selector) reflectiveMethodOrNil.	(jMethod notNil and: [ jMethod hasMethodClass not ]) ifTrue: [ jMethod methodClass: oldClass ].	super recompile: selector from: oldClass.	! !!GPGlobalAssignment methodsFor: 'accessing' stamp: 'md 2/24/2007 10:02'!binding	^binding! !!GPGlobalAssignment methodsFor: 'accessing' stamp: 'md 2/24/2007 10:02'!binding: anAssoc	binding := anAssoc! !!GPGlobalAssignment methodsFor: 'evaluating' stamp: 'md 2/24/2007 10:02'!oldValue	 ^binding value! !!GPGlobalAssignment methodsFor: 'evaluating' stamp: 'md 5/11/2007 15:18'!value	context ifNotNil: [thisContext privSender: context].	 ^binding value: newValue. ! !!GPGlobalAssignment class methodsFor: 'instance creation' stamp: 'md 2/24/2007 10:18'!binding: aBinding newValue: val	^self new		binding: aBinding;		newValue: val.! !!GPGlobalAssignment class methodsFor: 'instance creation' stamp: 'md 2/24/2007 10:18'!binding: aBinding newValue: val context: aContext	^self new		binding: aBinding;		newValue: val;		context: aContext.! !!GPGlobalVariable methodsFor: 'accessing' stamp: 'md 2/24/2007 10:05'!binding	^binding! !!GPGlobalVariable methodsFor: 'accessing' stamp: 'md 2/24/2007 10:05'!binding: aBinding	binding := aBinding! !!GPGlobalVariable methodsFor: 'evaluating' stamp: 'md 5/11/2007 15:19'!value	context ifNotNil: [thisContext privSender: context].	 ^binding value! !!GPGlobalVariable class methodsFor: 'instance creation' stamp: 'md 2/24/2007 10:06'!binding: aBinding	^self new		binding: aBinding! !!GPGlobalVariable class methodsFor: 'instance creation' stamp: 'md 2/24/2007 10:06'!binding: aBinding context: aContext	^self new		binding: aBinding;		context: aContext! !!GPInstanceAssignment methodsFor: 'accessing' stamp: 'md 2/23/2007 17:24'!object	^object! !!GPInstanceAssignment methodsFor: 'accessing' stamp: 'md 2/23/2007 17:25'!object: anObject	object := anObject! !!GPInstanceAssignment methodsFor: 'accessing' stamp: 'md 2/23/2007 17:24'!offset	^offset! !!GPInstanceAssignment methodsFor: 'accessing' stamp: 'md 2/23/2007 17:24'!offset: anOffset	offset := anOffset! !!GPInstanceAssignment methodsFor: 'evaluating' stamp: 'md 2/22/2007 17:25'!oldValue	 ^object instVarAt: offset.! !!GPInstanceAssignment methodsFor: 'evaluating' stamp: 'md 5/11/2007 15:18'!value	context ifNotNil: [thisContext privSender: context].	 ^object instVarAt: offset put: newValue. ! !!GPInstanceAssignment class methodsFor: 'instance creation' stamp: 'md 2/23/2007 17:29'!offset: offset in: object put: newValue	^self new 		offset: offset;		object: object;		newValue: newValue.! !!GPInstanceAssignment class methodsFor: 'instance creation' stamp: 'md 2/23/2007 17:29'!offset: offset in: object put: newValue context: aContext	^self new 		offset: offset;		object: object;		newValue: newValue;		context: aContext! !!GPInstanceVariable methodsFor: 'accessing' stamp: 'md 2/23/2007 17:37'!object	^object! !!GPInstanceVariable methodsFor: 'accessing' stamp: 'md 2/23/2007 17:37'!object: anObject	object := anObject! !!GPInstanceVariable methodsFor: 'accessing' stamp: 'md 3/22/2007 14:33'!offset	^offset! !!GPInstanceVariable methodsFor: 'accessing' stamp: 'md 3/22/2007 14:33'!offset: aNumber	offset := aNumber! !!GPInstanceVariable methodsFor: 'evaluation' stamp: 'md 5/11/2007 15:19'!value	context ifNotNil: [thisContext privSender: context].	^object instVarAt: offset ! !!GPInstanceVariable class methodsFor: 'instance creation' stamp: 'md 2/23/2007 17:39'!offset: offset in: object	^self new 		offset: offset;		object: object.! !!GPInstanceVariable class methodsFor: 'instance creation' stamp: 'md 2/23/2007 17:40'!offset: offset in: object context: aContext	^self new 		offset: offset;		object: object;		context: aContext! !!GPLink methodsFor: 'accessing' stamp: 'ms 11/8/2007 13:11'!addOnActiveContext: anObject	self onActiveContexts add: anObject! !!GPLink methodsFor: 'accessing' stamp: 'ms 11/8/2007 12:58'!addOnInactiveContext: anObject	self onInactiveContexts add: anObject! !!GPLink methodsFor: 'accessing' stamp: 'md 2/7/2007 13:01'!arguments	^arguments! !!GPLink methodsFor: 'accessing' stamp: 'md 2/9/2007 15:43'!condition	^condition! !!GPLink methodsFor: 'accessing' stamp: 'md 2/3/2007 16:39'!control	^control.! !!GPLink methodsFor: 'accessing' stamp: 'md 10/18/2007 14:05'!metaObject	^mo! !!GPLink methodsFor: 'accessing' stamp: 'md 3/8/2007 21:11'!moScope	^self properties at: #moScope ifAbsent: [#link].! !!GPLink methodsFor: 'accessing' stamp: 'md 3/1/2007 18:01'!nodes	^nodes ifNil: [nodes := Set new].! !!GPLink methodsFor: 'accessing' stamp: 'ms 11/8/2007 12:56'!onActiveContexts	^ onActiveContexts  ifNil:[onActiveContexts := Set new].! !!GPLink methodsFor: 'accessing' stamp: 'ms 11/8/2007 12:56'!onInactiveContexts	^ onInactiveContexts  ifNil:[onInactiveContexts := Set new].! !!GPLink methodsFor: 'accessing' stamp: 'md 3/8/2007 20:37'!properties	^properties ifNil: [properties := Dictionary new].! !!GPLink methodsFor: 'accessing' stamp: 'md 2/3/2007 16:39'!selector 	^selector.! !!GPLink methodsFor: 'link api' stamp: 'md 2/13/2007 17:37'!after	self control: #after! !!GPLink methodsFor: 'link api' stamp: 'md 2/23/2007 12:20'!arguments: anArray	self checkReification: anArray.	arguments := anArray.	self update.! !!GPLink methodsFor: 'link api' stamp: 'md 2/13/2007 17:36'!before	self control: #before! !!GPLink methodsFor: 'link api' stamp: 'md 10/18/2007 11:04'!condition: aCondition	(aCondition isBlock or: [aCondition isBoolean]) ifFalse: [		self error: 'condition needs to be a block or boolean'].	aCondition isBlock ifTrue: [self checkReification: aCondition blockArgNames].		condition := GPCondition with: aCondition.	self isInlineCondition ifTrue: [self update].! !!GPLink methodsFor: 'link api' stamp: 'md 10/18/2007 11:19'!condition: aCondition arguments: args	aCondition isBlock ifFalse: [self error: 'condition needs to be a block'].		self checkReification: args.		condition := GPCondition with: aCondition.	condition arguments: args.	self isInlineCondition ifTrue: [self update].! !!GPLink methodsFor: 'link api' stamp: 'md 3/9/2007 10:05'!control: aSymbol	(#(before after beforeafter instead) includes: aSymbol) ifFalse: [			self error: 'Control', aSymbol printString,  ' not supported!!'].	control := aSymbol.	self update.! !!GPLink methodsFor: 'link api' stamp: 'md 2/13/2007 17:37'!instead	self control: #instead! !!GPLink methodsFor: 'link api' stamp: 'md 2/23/2007 12:24'!metaObject: anObject	mo := anObject.	mo isBlock ifTrue: [		self checkReification: mo blockArgNames.				"Block meta Object. We need to set the link's arguments to the args of the Block"				arguments ifEmpty: [self arguments: (mo blockArgNames collect: #asSymbol)].		selector == #value ifTrue:[self selector: mo valueSelector].				].	self update.! !!GPLink methodsFor: 'link api' stamp: 'md 3/8/2007 20:56'!metaObjectCreator	^self properties at: #metaObjectCreator.! !!GPLink methodsFor: 'link api' stamp: 'md 3/15/2007 16:16'!metaObjectCreator: aBlock	self properties at: #metaObjectCreator put: aBlock.	"this needs to be a weakkeydictionary..."	mo := Dictionary new.! !!GPLink methodsFor: 'link api' stamp: 'md 3/8/2007 20:24'!metaObjectFor: anObject	^mo at: anObject ifAbsentPut: [self metaObjectCreator value]! !!GPLink methodsFor: 'link api' stamp: 'md 3/8/2007 20:57'!moScope: aSymbol	self properties at: #moScope put: aSymbol.! !!GPLink methodsFor: 'link api' stamp: 'md 3/8/2007 22:01'!noInlineCondition	self properties at: #noInlineCondtition put: true.! !!GPLink methodsFor: 'link api' stamp: 'md 3/8/2007 22:01'!noInlineMeta	self properties at: #noInlineMeta put: true.! !!GPLink methodsFor: 'link api' stamp: 'md 2/23/2007 11:46'!selector: aSymbol	selector := aSymbol.	self update.! !!GPLink methodsFor: 'link installation' stamp: 'md 3/1/2007 17:44'!checkCompatibilityWith: aNode	| supported |	supported := aNode supportedReifications.	self arguments do: [:arg | 		(supported includes: arg) ifFalse: [self error: 'reification not possible on this node']].		! !!GPLink methodsFor: 'link installation' stamp: 'md 3/9/2007 10:08'!checkForMultipleInstead: aNode	self isInstead ifFalse: [^self].		"check all installed links, error message when instead"		aNode links do: [:each | 		each isInstead ifTrue: [self error: 'Multiple instead not yet supported']].! !!GPLink methodsFor: 'link installation' stamp: 'md 3/9/2007 10:05'!hookOn: aNode	self checkCompatibilityWith: aNode.	self checkForMultipleInstead: aNode. "for now, only one".		aNode addLinkAnnotation: self.	self nodes add: aNode.! !!GPLink methodsFor: 'link installation' stamp: 'md 3/1/2007 18:26'!uninstall	nodes ifNotNil: [nodes do: [:node | node removeLink: self]].! !!GPLink methodsFor: 'link installation' stamp: 'md 3/1/2007 18:25'!update	nodes ifNotNil: [nodes do: [:node | node resetCache]].! !!GPLink methodsFor: 'testing' stamp: 'md 2/26/2007 17:32'!checkReification: anArray	anArray do: [:each | (GPParameter allKeys includes: each) 			ifFalse: [self error: 'wrong reification']].! !!GPLink methodsFor: 'testing' stamp: 'md 2/12/2007 10:02'!hasCondition	^condition notNil.! !!GPLink methodsFor: 'testing' stamp: 'md 3/8/2007 21:28'!hasMoScope	properties ifNil: [^false].	^self properties includesKey: #moScope! !!GPLink methodsFor: 'testing' stamp: 'md 2/14/2007 19:58'!isActive	^condition value! !!GPLink methodsFor: 'testing' stamp: 'md 2/14/2007 19:58'!isActive: anObject	^condition value: anObject! !!GPLink methodsFor: 'testing' stamp: 'md 2/14/2007 19:58'!isActive: anObjectA with: anObjectB	^condition value: anObjectA value: anObjectB! !!GPLink methodsFor: 'testing' stamp: 'md 2/14/2007 19:59'!isActive: anObjectA with: anObjectB with: anObjectC	^condition value: anObjectA value: anObjectB value: anObjectC! !!GPLink methodsFor: 'testing' stamp: 'md 2/14/2007 19:59'!isActive: anObjectA with: anObjectB with: anObjectC with: anObjectD	^condition value: anObjectA value: anObjectB value: anObjectC value: anObjectD! !!GPLink methodsFor: 'testing' stamp: 'md 3/9/2007 10:07'!isAfter	^control == #after! !!GPLink methodsFor: 'testing' stamp: 'md 3/9/2007 10:06'!isBefore	^control == #before! !!GPLink methodsFor: 'testing' stamp: 'md 3/9/2007 10:07'!isBeforeAfter	^control == #beforeafter! !!GPLink methodsFor: 'testing' stamp: 'md 10/18/2007 11:15'!isInlineCondition	self hasCondition ifFalse: [^false].	properties ifNil: [^true].	^self properties at: #noInlineCondition ifAbsent: [true].! !!GPLink methodsFor: 'testing' stamp: 'md 3/8/2007 22:01'!isInlineMeta	properties ifNil: [^true].	^self properties at: #noInlineMeta ifAbsent: [true].! !!GPLink methodsFor: 'testing' stamp: 'md 3/9/2007 10:06'!isInstead	^control == #instead! !!GPLink methodsFor: 'testing' stamp: 'md 3/9/2007 15:48'!requestsContinuation	"mo = #continuation ifTrue: [^true]."	^arguments includes: #continuation! !!GPLink methodsFor: 'testing' stamp: 'md 3/9/2007 17:51'!requestsResult	^arguments includes: #result! !!GPLink methodsFor: 'initializing' stamp: 'md 12/13/2007 14:20'!initialize	control := #before.	selector := #value.	arguments := #().	Preferences linksAreContextual ifTrue: [		self addOnInactiveContext: MetaContext.	]! !!GPLink class methodsFor: 'as yet unclassified' stamp: 'ms 11/1/2007 17:25'!metaObject: aMeta	^self new metaObject: aMeta"; addContext: MetaContext."! !!GPLinkAnnotation methodsFor: 'testing' stamp: 'md 8/20/2007 10:59'!isSourceVisible	^false! !!GPLinkAnnotation class methodsFor: 'accessing' stamp: 'md 2/7/2007 09:41'!keys	^#(link)! !!GPLinkParameter methodsFor: 'code generation' stamp: 'md 2/12/2007 20:46'!genForRBProgramNode	^link asLiteralNode! !!GPLinkParameter class methodsFor: 'plugin interface' stamp: 'md 2/11/2007 10:54'!key	^#link! !!GPLinkParameter class methodsFor: 'plugin interface' stamp: 'md 2/15/2007 12:36'!nodes	^{RBProgramNode}! !!GPMessageSend methodsFor: 'accessing' stamp: 'md 2/22/2007 17:07'!arguments	^arguments! !!GPMessageSend methodsFor: 'accessing' stamp: 'md 2/22/2007 17:07'!arguments: anArray	arguments := anArray! !!GPMessageSend methodsFor: 'accessing' stamp: 'md 2/22/2007 17:08'!receiver	^receiver! !!GPMessageSend methodsFor: 'accessing' stamp: 'md 2/22/2007 17:07'!receiver: anObject	receiver := anObject! !!GPMessageSend methodsFor: 'accessing' stamp: 'md 2/22/2007 17:08'!selector	^selector! !!GPMessageSend methodsFor: 'accessing' stamp: 'md 2/22/2007 17:07'!selector: aSymbol	selector := aSymbol! !!GPMessageSend methodsFor: 'private' stamp: 'md 2/22/2007 17:10'!collectArguments: anArgArray	"Private"    | staticArgs |    staticArgs := self arguments.    ^(anArgArray size = staticArgs size)        ifTrue: [anArgArray]        ifFalse:            [(staticArgs isEmpty                ifTrue: [ staticArgs := Array new: selector numArgs]                ifFalse: [staticArgs copy] )                    replaceFrom: 1                    to: (anArgArray size min: staticArgs size)                    with: anArgArray                    startingAt: 1]! !!GPMessageSend methodsFor: 'testing' stamp: 'md 2/22/2007 17:09'!isMessageSend	^true! !!GPMessageSend methodsFor: 'evaluating' stamp: 'md 5/11/2007 15:19'!value	"Send the message and answer the return value"	context ifNotNil: [thisContext privSender: context].	arguments ifNil: [^ receiver perform: selector].	^ receiver 		perform: selector 		withArguments: (self collectArguments: arguments)! !!GPMessageSend methodsFor: 'evaluating' stamp: 'md 5/11/2007 15:19'!valueWithArguments: anArray	context ifNotNil: [thisContext privSender: context].	^ receiver 		perform: selector 		withArguments: (self collectArguments: anArray)! !!GPMessageSend class methodsFor: 'instance creation' stamp: 'md 2/22/2007 17:12'!receiver: anObject selector: aSymbol	^ self receiver: anObject selector: aSymbol arguments: #()! !!GPMessageSend class methodsFor: 'instance creation' stamp: 'md 2/22/2007 17:12'!receiver: anObject selector: aSymbol argument: aParameter	^ self receiver: anObject selector: aSymbol arguments: (Array with: aParameter)! !!GPMessageSend class methodsFor: 'instance creation' stamp: 'md 2/22/2007 17:12'!receiver: anObject selector: aSymbol arguments: anArray	^ self new		receiver: anObject;		selector: aSymbol;		arguments: anArray! !!GPMessageSend class methodsFor: 'instance creation' stamp: 'md 2/22/2007 17:35'!receiver: anObject selector: aSymbol arguments: anArray context: aContext	^ self new		receiver: anObject;		selector: aSymbol;		arguments: anArray;		context: aContext.! !!GPMethod methodsFor: 'accessing' stamp: 'md 2/13/2007 10:11'!arguments	^arguments! !!GPMethod methodsFor: 'accessing' stamp: 'md 2/13/2007 10:11'!arguments: anArray	arguments := anArray! !!GPMethod methodsFor: 'accessing' stamp: 'md 2/13/2007 10:10'!method	^method! !!GPMethod methodsFor: 'accessing' stamp: 'md 2/13/2007 10:10'!method: aMethod	method := aMethod! !!GPMethod methodsFor: 'accessing' stamp: 'md 2/13/2007 10:11'!receiver	^receiver! !!GPMethod methodsFor: 'accessing' stamp: 'md 2/13/2007 10:11'!receiver: anObject	receiver := anObject! !!GPMethod methodsFor: 'evaluating' stamp: 'md 5/11/2007 15:19'!value	context ifNotNil: [thisContext privSender: context].	arguments ifNil: [^ receiver executeMethod: method].	^receiver withArgs: arguments executeMethod: method.! !!GPMethod methodsFor: 'evaluating' stamp: 'md 5/11/2007 15:19'!valueWithReceiver: anObject arguments: anArray	context ifNotNil: [thisContext privSender: context].	^receiver withArgs: arguments executeMethod: method.! !!GPMethod class methodsFor: 'instance creation' stamp: 'md 2/13/2007 10:14'!method: aMethod receiver: anObject arguments: args	^self new		method: aMethod;		receiver: anObject;		arguments: args! !!GPMethod class methodsFor: 'instance creation' stamp: 'md 2/22/2007 17:35'!method: aMethod receiver: anObject arguments: args context: aContext	^self new		method: aMethod;		receiver: anObject;		arguments: args;		context: aContext		! !!GPMethodWrapper methodsFor: 'before after' stamp: 'md 2/19/2007 12:12'!afterMethod! !!GPMethodWrapper methodsFor: 'before after' stamp: 'md 2/19/2007 12:13'!beforeMethod! !!GPMethodWrapper methodsFor: 'before after' stamp: 'md 2/25/2007 18:21'!valueWithReceiver: receiver arguments: args operation: method	self clientMethod: method.	^self valueWithReceiver: receiver arguments: args.	! !!GPMethodWrapper methodsFor: 'initialization' stamp: 'md 2/24/2007 19:07'!class: aClass selector: aSelector	self wrappedClass: aClass.	self clientSelector: aSelector.! !!GPMethodWrapper methodsFor: 'accessing' stamp: 'md 2/24/2007 19:10'!clientMethod	^clientMethod! !!GPMethodWrapper methodsFor: 'accessing' stamp: 'md 2/25/2007 18:14'!clientMethod: aMethod	clientMethod := aMethod! !!GPMethodWrapper methodsFor: 'accessing' stamp: 'md 2/24/2007 19:04'!clientSelector	^clientSelector! !!GPMethodWrapper methodsFor: 'accessing' stamp: 'md 2/24/2007 19:04'!clientSelector: aSel	clientSelector := aSel! !!GPMethodWrapper methodsFor: 'accessing' stamp: 'md 2/25/2007 19:08'!method	^wrappedClass>>clientSelector! !!GPMethodWrapper methodsFor: 'accessing' stamp: 'md 3/20/2007 17:25'!methodNode	^self method reflectiveMethod methodNode! !!GPMethodWrapper methodsFor: 'accessing' stamp: 'md 2/24/2007 19:08'!wrappedClass	^wrappedClass! !!GPMethodWrapper methodsFor: 'accessing' stamp: 'md 2/24/2007 19:08'!wrappedClass: aClass	wrappedClass := aClass! !!GPMethodWrapper methodsFor: 'installing' stamp: 'md 2/25/2007 18:13'!install	"find out what exactly is overritten in our subclass... and do a link *just* for that"	(self class methodDict keys includes: #valueWithReceiver:arguments:) ifTrue: [		insteadLink := GPLink new 					metaObject: self;					selector: #valueWithReceiver:arguments:operation:;					control: #instead;					arguments: #(object arguments operation).		self methodNode link: insteadLink.		^self.	].	(self class methodDict keys includes: #beforeMethod) ifTrue: [		beforeLink := GPLink new metaObject: self; selector: #beforeMethod; control: #before.		self methodNode link: beforeLink.	].	(self class methodDict keys includes: #afterMethod) ifTrue: [		afterLink := GPLink new metaObject: self; selector: #afterMethod; control: #after.		self methodNode link: afterLink.	].								! !!GPMethodWrapper methodsFor: 'installing' stamp: 'md 2/25/2007 19:40'!uninstall	self methodNode 			removeLink: beforeLink;			removeLink: afterLink;			removeLink: insteadLink.! !!GPMethodWrapper class methodsFor: 'instance creation' stamp: 'md 2/24/2007 19:05'!on: aSelector inClass: aClass	^self new class: aClass selector: aSelector.	! !!GPMethodWrapperTest methodsFor: 'testing' stamp: 'md 3/20/2007 17:12'!testInstallInstantiateUninstall	| wrapper instance |	wrapper := self wrapperClass on: #methodOne inClass: GPMwClassA.	wrapper install.	instance := GPMwClassA new.	instance methodOne.	wrapper uninstall.	instance methodOne.! !!GPMethodWrapperTest methodsFor: 'testing' stamp: 'md 3/20/2007 17:12'!testInstantiateInstallUninstall	| wrapper instance |	wrapper := self wrapperClass on: #methodOne inClass: GPMwClassA.	instance := GPMwClassA new.	instance methodOne.	wrapper install.	instance methodOne.	wrapper uninstall.	instance methodOne.! !!GPMethodWrapperTest methodsFor: 'testing' stamp: 'md 5/18/2007 15:58'!testMethodWrapper	|w|	GPCounter reset. 	w := GPSimpleMethodWrapper on: #example inClass: GPExamples.	w install.	self assert: (GPCounter counter = 0).	3 timesRepeat: [self assert: (GPExamples new example = 11)].	self assert: (GPCounter counter = 6). 	GPCounter reset. w uninstall.	3 timesRepeat: [self assert: (GPExamples new example = 11)].	self assert: (GPCounter counter = 0).! !!GPMethodWrapperTest methodsFor: 'testing' stamp: 'md 5/18/2007 15:58'!testMethodWrapperWithState		|w|	w := GPCountMethodWrapper on: #example inClass: GPExamples.	w install.	self assert: (w count = 0).	3 timesRepeat: [self assert: (GPExamples new example = 11)].	self assert: (w count = 3).	w uninstall. w reset.	3 timesRepeat: [self assert: (GPExamples new example = 11)].	self assert: (w count = 0).! !!GPMethodWrapperTest methodsFor: 'testing' stamp: 'md 3/20/2007 17:12'!testOnInClass	| wrapper clientSelector wrappedClass |	clientSelector := #methodOne.	wrappedClass := GPMwClassA.	wrapper := self wrapperClass on: clientSelector inClass: wrappedClass.	self assert: wrapper clientSelector == clientSelector.	self assert: wrapper clientMethod == nil.	"self assert: wrapper definingClass == nil."	self assert: wrapper wrappedClass == wrappedClass.	"self assert: (wrapper realObjectAt: wrapper methodPosition) == wrapper."	"self assert: (wrapper realObjectAt: wrapper arrayPosition) == Array."	wrapper uninstall.! !!GPMethodWrapperTest methodsFor: 'private' stamp: 'md 2/24/2007 18:48'!wrapperClass	^ GPMethodWrapper! !!GPMwClassA methodsFor: 'debugging' stamp: 'md 3/19/2007 00:04'!methodDelay	(Delay forMilliseconds: 1) wait.! !!GPMwClassA methodsFor: 'debugging' stamp: 'md 5/18/2007 15:08'!methodOne	Transcript cr; show: 'MwClassA>>methodOne'.! !!GPMwClassA methodsFor: 'debugging' stamp: 'md 2/24/2007 18:45'!methodTwo	"Transcript cr; show: 'MwClassA>>methodTwo'."! !!GPMwClassA methodsFor: 'debugging' stamp: 'md 2/24/2007 18:45'!methodWithArgument: anInteger	self x: self x + anInteger.	^ self x! !!GPMwClassA methodsFor: 'debugging' stamp: 'md 2/24/2007 18:45'!methodWithException	Warning new  signal: 'Ouch'.! !!GPMwClassA methodsFor: 'debugging' stamp: 'md 2/25/2007 18:34'!methodWithoutException	^ 69  ! !!GPMwClassA methodsFor: 'accessing' stamp: 'md 3/19/2007 00:04'!x	"^ <Integer>"	^ x! !!GPMwClassA methodsFor: 'accessing' stamp: 'md 3/19/2007 00:04'!x: anInteger	x := anInteger. ! !!GPMwClassA commentStamp: '<historical>' prior: 0!Instance Variables:	x	<Integer>!!GPMwClassA class methodsFor: 'accessing' stamp: 'md 3/31/2007 19:13'!compilerClass	^PECompiler! !!GPMwClassA class methodsFor: 'accessing' stamp: 'md 3/20/2007 17:24'!parseTreeFor: aSymbol	^(self compiledMethodAt: aSymbol) reflectiveMethod methodNode! !!GPMwClassA class methodsFor: 'compiling' stamp: 'md 3/20/2007 17:28'!recompile: selector from: oldClass	| jMethod |	jMethod := (oldClass >> selector) reflectiveMethodOrNil.	(jMethod notNil and: [ jMethod hasMethodClass not ]) ifTrue: [ jMethod methodClass: oldClass ].	super recompile: selector from: oldClass.	! !!GPMwClassB methodsFor: 'debugging' stamp: 'md 3/19/2007 00:04'!methodThree 	"Transcript cr; show: 'MwClassB>>methodThree'." ! !!GPMwClassB methodsFor: 'debugging' stamp: 'md 3/19/2007 00:04'!methodTwo	"Transcript cr; show: 'MwClassB>>methodTwo'." ! !!GPMwClassB class methodsFor: 'accessing' stamp: 'md 3/31/2007 19:13'!compilerClass	^PECompiler! !!GPMwClassB class methodsFor: 'accessing' stamp: 'md 3/20/2007 17:24'!parseTreeFor: aSymbol	^(self compiledMethodAt: aSymbol) reflectiveMethod methodNode! !!GPMwClassB class methodsFor: 'compiling' stamp: 'md 3/20/2007 17:28'!recompile: selector from: oldClass	| jMethod |	jMethod := (oldClass >> selector) reflectiveMethodOrNil.	(jMethod notNil and: [ jMethod hasMethodClass not ]) ifTrue: [ jMethod methodClass: oldClass ].	super recompile: selector from: oldClass.	! !!GPNewValueParameter methodsFor: 'code generation' stamp: 'md 2/11/2007 11:49'!genForRBAssignmentNode	^node value! !!GPNewValueParameter class methodsFor: 'plugin interface' stamp: 'md 2/11/2007 10:48'!key	^#newValue! !!GPNewValueParameter class methodsFor: 'plugin interface' stamp: 'md 10/22/2007 22:17'!nodes	^{RBAssignmentNode}! !!GPNodeParameter methodsFor: 'code generation' stamp: 'md 2/11/2007 11:39'!genForRBProgramNode	^node asLiteralNode! !!GPNodeParameter class methodsFor: 'plugin interface' stamp: 'md 2/10/2007 22:07'!key	^#node! !!GPNodeParameter class methodsFor: 'plugin interface' stamp: 'md 2/15/2007 12:29'!nodes	^{RBProgramNode}.! !!GPObjectParameter methodsFor: 'code generation' stamp: 'md 2/17/2007 12:10'!genForRBProgramNode	^RBVariableNode named: 'self'! !!GPObjectParameter class methodsFor: 'plugin interface' stamp: 'md 2/20/2007 09:11'!key	^#object! !!GPObjectParameter class methodsFor: 'plugin interface' stamp: 'md 2/15/2007 12:37'!nodes	^{RBProgramNode}! !!GPOffsetParameter methodsFor: 'code generation' stamp: 'md 2/11/2007 11:48'!genForRBAssignmentNode	^  node variable binding index asLiteralNode! !!GPOffsetParameter methodsFor: 'code generation' stamp: 'md 2/11/2007 11:44'!genForRBVariableNode	^ node  binding index asLiteralNode! !!GPOffsetParameter class methodsFor: 'plugin interface' stamp: 'md 2/11/2007 10:30'!key	^#offset! !!GPOffsetParameter class methodsFor: 'plugin interface' stamp: 'md 2/11/2007 10:30'!nodes	^{RBVariableNode. RBAssignmentNode}! !!GPOperation methodsFor: 'accessing' stamp: 'md 2/22/2007 17:29'!context	^context! !!GPOperation methodsFor: 'accessing' stamp: 'md 2/22/2007 17:29'!context: aContext	context := aContext! !!GPOperation methodsFor: 'evaluating' stamp: 'md 2/15/2007 10:49'!value	self subclassResponsibility.! !!GPOperationParameter methodsFor: 'code generation' stamp: 'md 2/26/2007 17:59'!genForRBAssignmentNode	node variable isTemp ifTrue: [ 				^RBMessageNode						receiver: GPTempAssignment asLiteralNode						selector: #offset:in:put:						arguments: {node variable binding index asLiteralNode .  									RBVariableNode named: 'thisContext' . 									node value}].									node variable isInstance ifTrue: [ 				^RBMessageNode						receiver: GPInstanceAssignment asLiteralNode						selector: #offset:in:put:						arguments: {node variable binding index asLiteralNode .  									RBVariableNode named: 'self' . 									node value}].		node variable isGlobal ifTrue: [ 				^RBMessageNode						receiver: GPGlobalAssignment asLiteralNode						selector: #binding:newValue:						arguments: {(GPBindingParameter node: node link: link) genForRBAssignmentNode.									(GPNewValueParameter node: node link: link) genForRBAssignmentNode}.						].! !!GPOperationParameter methodsFor: 'code generation' stamp: 'md 2/26/2007 17:55'!genForRBMessageNode	^ RBMessageNode 			receiver: GPMessageSend asLiteralNode			selector: #receiver:selector:arguments:			arguments: {node receiver.						node selector asLiteralNode.						(GPArgumentsParameter node: node link: link) genForRBMessageNode}! !!GPOperationParameter methodsFor: 'code generation' stamp: 'md 2/26/2007 17:55'!genForRBMethodNode	"The method wrapped needs to be the method with just not our link"		| methodNode |	methodNode := node copy.	methodNode annotations: methodNode annotations copy.	methodNode removeLink: link.		^ RBMessageNode 			receiver: GPMethod asLiteralNode			selector: #method:receiver:arguments:			arguments:  {   methodNode generate compiledMethod asLiteralNode. 							RBMessageNode 								receiver: (RBVariableNode named: 'thisContext')								selector: #receiver.							(GPArgumentsParameter node: node link: link) genForRBMethodNode}! !!GPOperationParameter methodsFor: 'code generation' stamp: 'md 2/26/2007 17:57'!genForRBVariableNode	node isTemp ifTrue: [				^RBMessageNode						receiver: GPTempVariable asLiteralNode						selector: #offset:in:						arguments: {node binding index asLiteralNode. 									RBVariableNode named: 'thisContext'}].									node isInstance	ifTrue: [				^RBMessageNode						receiver: GPInstanceVariable asLiteralNode						selector: #offset:in:						arguments: {node binding index asLiteralNode. 									RBVariableNode named: 'self'}].									node isGlobal ifTrue: [				^RBMessageNode						receiver: GPGlobalVariable asLiteralNode						selector: #binding:						arguments: {(GPBindingParameter node: node link: link) genForRBVariableNode}		].		! !!GPOperationParameter methodsFor: 'code generation' stamp: 'md 2/15/2007 10:18'!optimize	^true! !!GPOperationParameter class methodsFor: 'plugin interface' stamp: 'md 2/10/2007 17:18'!key	^#operation! !!GPOperationParameter class methodsFor: 'plugin interface' stamp: 'md 2/15/2007 12:36'!nodes	^{RBMessageNode . RBAssignmentNode. RBVariableNode. RBMethodNode}! !!GPParameter methodsFor: 'code generation' stamp: 'md 8/25/2007 15:40'!genForPEInstrumentedAssignmentNode	^self genForRBAssignmentNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 8/25/2007 15:40'!genForPEInstrumentedLiteralNode	^self genForRBLiteralNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 8/25/2007 15:40'!genForPEInstrumentedMessageNode	^self genForRBMessageNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 8/25/2007 15:40'!genForPEInstrumentedObjectLiteralNode	^self genForRBProgramNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 8/25/2007 15:40'!genForPEInstrumentedReturnNode	^self genForRBReturnNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 8/25/2007 15:40'!genForPEInstrumentedSequenceNode	^self genForRBSequenceNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 9/25/2007 14:45'!genForPEInstrumentedTempVariableNode	^self genForRBTempVariableNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 8/25/2007 15:40'!genForPEInstrumentedVariableNode	^self genForRBVariableNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 3/31/2007 18:59'!genForPEReflectiveMethodNode	^self genForRBMethodNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 2/11/2007 11:47'!genForRBAssignmentNode	^self genForRBProgramNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 2/27/2007 21:17'!genForRBBlockNode	^self genForRBProgramNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 8/23/2007 15:17'!genForRBCascadeNode	^self genForRBProgramNode ! !!GPParameter methodsFor: 'code generation' stamp: 'md 3/30/2007 10:06'!genForRBGlobalVariableNode	^self genForRBVariableNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 3/30/2007 10:06'!genForRBInstanceVariableNode	^self genForRBVariableNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 7/25/2007 15:03'!genForRBLiteralNode	^self genForRBProgramNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 2/11/2007 11:39'!genForRBMessageNode	^self genForRBProgramNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 2/12/2007 23:22'!genForRBMethodNode	^self genForRBProgramNode ! !!GPParameter methodsFor: 'code generation' stamp: 'md 2/11/2007 11:39'!genForRBProgramNode	self subclassResponsibility! !!GPParameter methodsFor: 'code generation' stamp: 'md 8/25/2007 16:32'!genForRBReturnNode	^self genForRBProgramNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 7/25/2007 14:59'!genForRBSequenceNode	^self genForRBProgramNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 9/25/2007 14:45'!genForRBTempVariableNode	^self genForRBVariableNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 2/11/2007 11:39'!genForRBVariableNode	^self genForRBProgramNode! !!GPParameter methodsFor: 'code generation' stamp: 'md 2/15/2007 10:17'!optimize	"do we optimize this reification if there are multiple ones?"	^false! !!GPParameter methodsFor: 'accessing' stamp: 'md 2/12/2007 20:43'!link: aLink	link := aLink.! !!GPParameter methodsFor: 'accessing' stamp: 'md 2/10/2007 17:35'!node	^node! !!GPParameter methodsFor: 'accessing' stamp: 'md 2/10/2007 17:35'!node: aNode	node := aNode! !!GPParameter class methodsFor: 'querying' stamp: 'md 2/13/2007 09:14'!allKeys	^self subclasses collect: [:plugin | plugin key]! !!GPParameter class methodsFor: 'plugin interface' stamp: 'md 2/10/2007 22:12'!key	^self subclassResponsibility! !!GPParameter class methodsFor: 'plugin interface' stamp: 'md 2/10/2007 22:11'!nodes	^self subclassResponsibility! !!GPParameter class methodsFor: 'instance creation' stamp: 'md 2/12/2007 20:42'!node: aNode link: aLink	^self new node: aNode; link: aLink.! !!GPProceedParameter methodsFor: 'code generation' stamp: 'md 2/26/2007 17:59'!genForRBAssignmentNode	node variable isTemp ifTrue: [ 			^RBMessageNode						receiver: GPTempAssignment asLiteralNode						selector: #offset:in:put:context:						arguments: {node variable binding index asLiteralNode .  									RBVariableNode named: 'thisContext' . 									node value.									RBVariableNode named: 'thisContext'}].	node variable isInstance ifTrue: [			^RBMessageNode						receiver: GPInstanceAssignment asLiteralNode						selector: #offset:in:put:context:						arguments: {node variable binding index asLiteralNode .  									RBVariableNode named: 'self' . 									node value.									RBVariableNode named: 'thisContext'}].	node variable isGlobal ifTrue: [				^RBMessageNode						receiver: GPGlobalAssignment asLiteralNode						selector: #binding:newValue:context:						arguments: {(GPBindingParameter node: node link: link) genForRBAssignmentNode.									(GPNewValueParameter node: node link: link) genForRBAssignmentNode.									RBVariableNode named: 'thisContext'}.				].! !!GPProceedParameter methodsFor: 'code generation' stamp: 'md 2/26/2007 17:56'!genForRBMessageNode	^ RBMessageNode 			receiver: GPMessageSend asLiteralNode			selector: #receiver:selector:arguments:context:			arguments: {node receiver.						node selector asLiteralNode.						(GPArgumentsParameter node: node link: link) genForRBMessageNode.						RBVariableNode named: 'thisContext'}! !!GPProceedParameter methodsFor: 'code generation' stamp: 'md 2/26/2007 17:55'!genForRBMethodNode	^ RBMessageNode 			receiver: GPMethod asLiteralNode			selector: #method:receiver:arguments:context:			arguments:  {    RBMessageNode 								receiver: (RBVariableNode named: 'thisContext')								selector: #method.  							RBMessageNode 								receiver: (RBVariableNode named: 'thisContext')								selector: #receiver.							(GPArgumentsParameter node: node link: link) genForRBMethodNode.							RBVariableNode named: 'thisContext'}! !!GPProceedParameter methodsFor: 'code generation' stamp: 'md 2/26/2007 17:57'!genForRBVariableNode	node isTemp ifTrue: [				^RBMessageNode					receiver: GPTempVariable asLiteralNode						selector: #offset:in:context:						arguments: {node binding index asLiteralNode. 									RBVariableNode named: 'thisContext'.									RBVariableNode named: 'thisContext'}].									node isInstance	ifTrue: [				^	RBMessageNode					receiver: GPInstanceVariable asLiteralNode						selector: #offset:in:context:						arguments: {node binding index asLiteralNode. 									RBVariableNode named: 'self'.									RBVariableNode named: 'thisContext'}].									node isGlobal ifTrue: [				^RBMessageNode						receiver: GPGlobalVariable asLiteralNode						selector: #binding:context:						arguments: {(GPBindingParameter node: node link: link) genForRBVariableNode.						RBVariableNode named: 'thisContext'}		].		! !!GPProceedParameter methodsFor: 'code generation' stamp: 'md 2/22/2007 17:32'!optimize	^true! !!GPProceedParameter class methodsFor: 'plugin interface' stamp: 'md 2/22/2007 17:32'!key	^#proceed! !!GPProceedParameter class methodsFor: 'plugin interface' stamp: 'md 2/22/2007 17:32'!nodes	^{RBMessageNode . RBAssignmentNode. RBVariableNode. RBMethodNode}! !!GPReceiverParameter methodsFor: 'code generation' stamp: 'md 2/11/2007 11:17'!genForRBMessageNode	^node receiver! !!GPReceiverParameter methodsFor: 'code generation' stamp: 'md 2/13/2007 10:25'!genForRBMethodNode	^RBMessageNode 		receiver: (RBVariableNode named: 'thisContext')		selector: #receiver! !!GPReceiverParameter methodsFor: 'code generation' stamp: 'md 2/15/2007 10:19'!optimize	^node isKindOf: RBMethodNode! !!GPReceiverParameter class methodsFor: 'plugin interface' stamp: 'md 2/11/2007 10:56'!key	^#receiver! !!GPReceiverParameter class methodsFor: 'plugin interface' stamp: 'md 2/15/2007 12:36'!nodes	^{RBMessageNode. RBMethodNode}! !!GPResultParameter methodsFor: 'code generation' stamp: 'md 3/9/2007 18:10'!genForRBProgramNode	^RBVariableNode named: 'gpResultkkdkdkkd'.! !!GPResultParameter class methodsFor: 'plugin interface' stamp: 'md 3/9/2007 17:28'!key	^#result! !!GPResultParameter class methodsFor: 'plugin interface' stamp: 'md 3/9/2007 17:28'!nodes	^{RBMessageNode. RBMethodNode}! !!GPSelectorParameter methodsFor: 'code generation' stamp: 'md 2/11/2007 11:17'!genForRBMessageNode	^node selector asLiteralNode! !!GPSelectorParameter methodsFor: 'code generation' stamp: 'md 2/13/2007 10:30'!genForRBMethodNode	^node selector asLiteralNode! !!GPSelectorParameter class methodsFor: 'plugin interface' stamp: 'md 2/11/2007 10:55'!key	^#selector! !!GPSelectorParameter class methodsFor: 'plugin interface' stamp: 'md 2/15/2007 12:37'!nodes	^{RBMessageNode. RBMethodNode}! !!GPSenderParameter methodsFor: 'code generation' stamp: 'md 2/10/2007 22:19'!genForRBMessageNode	^RBVariableNode named: 'self'! !!GPSenderParameter methodsFor: 'code generation' stamp: 'md 2/13/2007 11:30'!genForRBMethodNode	^RBMessageNode 		receiver: (RBMessageNode 			receiver: (RBVariableNode named: 'thisContext')			selector: #gpsender)		selector: #receiver.		! !!GPSenderParameter methodsFor: 'code generation' stamp: 'md 2/15/2007 10:20'!optimize	^node isKindOf: RBMethodNode! !!GPSenderParameter class methodsFor: 'plugin interface' stamp: 'md 2/10/2007 18:03'!key	^#sender! !!GPSenderParameter class methodsFor: 'plugin interface' stamp: 'md 3/31/2007 18:58'!nodes	^{RBMessageNode .PEReflectiveMethodNode}! !!GPSenderSelectorParameter methodsFor: 'code generation' stamp: 'md 4/1/2007 13:13'!genForRBMessageNode	^ RBMessageNode 		receiver: (RBMessageNode 			receiver: (RBVariableNode named: 'thisContext')			selector: #sender)		selector: #selector.! !!GPSenderSelectorParameter methodsFor: 'code generation' stamp: 'md 4/1/2007 13:12'!genForRBMethodNode	^ RBMessageNode 		receiver: (RBMessageNode 			receiver: (RBVariableNode named: 'thisContext')			selector: #gpsender)		selector: #selector.! !!GPSenderSelectorParameter methodsFor: 'code generation' stamp: 'md 2/15/2007 10:20'!optimize	^true! !!GPSenderSelectorParameter class methodsFor: 'plugin interface' stamp: 'md 2/11/2007 10:55'!key	^#senderselector! !!GPSenderSelectorParameter class methodsFor: 'plugin interface' stamp: 'md 3/31/2007 18:58'!nodes	^{RBMessageNode .PEReflectiveMethodNode}! !!GPSimpleMethodWrapper methodsFor: 'before after' stamp: 'md 2/19/2007 12:12'!afterMethod	GPCounter inc! !!GPSimpleMethodWrapper methodsFor: 'before after' stamp: 'md 2/19/2007 12:12'!beforeMethod	GPCounter inc! !!GPSimpleMethodWrapper commentStamp: 'md 2/24/2007 15:24' prior: 0!A very simple MethodWrapper for testing. It increments GPCounter before and after, but has no state of it's own!!GPStatementCollector methodsFor: 'visitor-double dispatching' stamp: 'md 7/26/2007 09:45'!acceptSequenceNode: aSequenceNode 	statements addAll: aSequenceNode statements.	super acceptSequenceNode: aSequenceNode.! !!GPStatementCollector methodsFor: 'initialize-release' stamp: 'md 2/10/2007 16:33'!initialize	statements := OrderedCollection new.! !!GPStatementCollector methodsFor: 'accessing' stamp: 'md 2/10/2007 16:36'!statements	^statements! !!GPTODO methodsFor: 'Metrics' stamp: 'md 3/1/2007 21:58'!bench	"just run the Tests"		"self new bench"	^[GeppettoTest buildSuite run] timeToRun! !!GPTODO methodsFor: 'TODO' stamp: 'md 12/13/2007 14:28'!todo	'	- #sender and #senderSelector wrong with context enabled. (see GeppettoTest)	- GeppettoTest shows that #sender and #senderselector are broken with context		-> Test: #result for after end of method					-> Port Benchmarks and Examples of Geppetto 1==============================================================================	-> think about multiple replace...			-> complex link composition of Reflex.	-> Support for Hookset like declarative pattern based definition of nodes	-> Detect excessive recompiles of update, turn off inlining mo/condition'! !!GPTODO methodsFor: 'TODO' stamp: 'md 12/13/2007 14:28'!todoLater	'	-> Optimize multiple links	 	- preamble comes allways *after* condition check. 	 	- preamble sets all reifications of *this* link, conditionally: 				(temp ifNil: [temp := doReify])	 	- inside the hook, use just temp access.	 	- check: condition is before preamble --> always generate reifications'! !!GPTempAssignment methodsFor: 'accessing' stamp: 'md 2/23/2007 17:25'!frame	^frame! !!GPTempAssignment methodsFor: 'accessing' stamp: 'md 2/23/2007 17:25'!frame: aContext	frame := aContext! !!GPTempAssignment methodsFor: 'accessing' stamp: 'md 2/23/2007 17:25'!offset	^offset! !!GPTempAssignment methodsFor: 'accessing' stamp: 'md 2/23/2007 17:26'!offset: anOffset	offset := anOffset! !!GPTempAssignment methodsFor: 'evaluating' stamp: 'md 2/23/2007 17:27'!oldValue	^frame tempAt: offset! !!GPTempAssignment methodsFor: 'evaluating' stamp: 'md 5/11/2007 15:18'!value	context ifNotNil: [thisContext privSender: context].	^frame tempAt: offset put: newValue! !!GPTempAssignment class methodsFor: 'instance creation' stamp: 'md 2/23/2007 17:28'!offset: offset in: object put: newValue	^self new 		offset: offset;		frame: object;		newValue: newValue.! !!GPTempAssignment class methodsFor: 'instance creation' stamp: 'md 2/23/2007 17:28'!offset: offset in: object put: newValue context: aContext	^self new 		offset: offset;		frame: object;		newValue: newValue;		context: aContext! !!GPTempVariable methodsFor: 'accessing' stamp: 'md 2/23/2007 17:39'!frame	^frame! !!GPTempVariable methodsFor: 'accessing' stamp: 'md 2/23/2007 17:39'!frame: aContext	frame := aContext! !!GPTempVariable methodsFor: 'accessing' stamp: 'md 2/23/2007 17:38'!offset	^offset! !!GPTempVariable methodsFor: 'accessing' stamp: 'md 2/23/2007 17:38'!offset: aNumber	offset := aNumber! !!GPTempVariable methodsFor: 'evaluation' stamp: 'md 5/11/2007 15:19'!value	context ifNotNil: [thisContext privSender: context].	^frame tempAt: offset	 ! !!GPTempVariable class methodsFor: 'instance creation' stamp: 'md 2/23/2007 17:40'!offset: offset in: object	^self new 		offset: offset;		frame: object.! !!GPTempVariable class methodsFor: 'instance creation' stamp: 'md 2/23/2007 17:40'!offset: offset in: object context: aContext	^self new 		offset: offset;		frame: object;		context: aContext! !!GPThisContextParameter methodsFor: 'code generation' stamp: 'md 2/11/2007 11:36'!genForRBProgramNode	^RBVariableNode named: 'thisContext'! !!GPThisContextParameter class methodsFor: 'plugin interface' stamp: 'md 2/10/2007 22:08'!key	^#context! !!GPThisContextParameter class methodsFor: 'plugin interface' stamp: 'md 2/15/2007 13:47'!nodes	^{RBProgramNode}.! !!GPTimeMethodWrapper methodsFor: 'accessing' stamp: 'md 2/24/2007 15:29'!averageTime	^ self count == 0		ifTrue: [0]		ifFalse: [self totalTime / self count asFloat]! !!GPTimeMethodWrapper methodsFor: 'accessing' stamp: 'md 2/24/2007 15:30'!class: aClass selector: aSymbol	self time: 0.	^ super class: aClass selector: aSymbol! !!GPTimeMethodWrapper methodsFor: 'accessing' stamp: 'md 2/24/2007 15:29'!time	^time! !!GPTimeMethodWrapper methodsFor: 'accessing' stamp: 'md 2/24/2007 15:29'!time: anObject	time := anObject! !!GPTimeMethodWrapper methodsFor: 'accessing' stamp: 'md 2/24/2007 15:30'!totalTime	^ self time! !!GPTimeMethodWrapper methodsFor: 'evaluating' stamp: 'md 2/24/2007 15:28'!valueWithReceiver: anObject arguments: argumentsArray	"This method was overriden so that recursive calls will have a different beginTime."	| beginTime |	beginTime := Time millisecondClockValue.	self count: self count + 1.	^ [		self clientMethod valueWithReceiver: anObject arguments: argumentsArray	] ensure: [self time: self time + (Time millisecondClockValue - beginTime max: 0)]! !!GPTimeMethodWrapperTest methodsFor: 'testing' stamp: 'md 3/20/2007 17:11'!testAverageTime	| wrapper instance count |	count := 10.	wrapper := self wrapperClass on: #methodDelay inClass: GPMwClassA.	wrapper install.	instance := GPMwClassA new.	count timesRepeat: [instance methodDelay].	self assert: wrapper count = count.	self assert: (wrapper time / count asFloat) = wrapper averageTime.	wrapper uninstall.! !!GPTimeMethodWrapperTest methodsFor: 'testing' stamp: 'md 3/20/2007 17:12'!testCounts	| wrapper instance |	wrapper := self wrapperClass on: #methodDelay inClass: GPMwClassA.	wrapper install.	instance := GPMwClassA new.	self assert: wrapper count = 0.	instance methodDelay.	self assert: wrapper count = 1.	instance methodDelay.	self assert: wrapper count = 2. 	wrapper uninstall.! !!GPTimeMethodWrapperTest methodsFor: 'testing' stamp: 'md 3/20/2007 17:11'!testCountsAndTimes	| wrapper instance |	wrapper := self wrapperClass on: #methodDelay inClass: GPMwClassA.	wrapper install.	instance := GPMwClassA new.	self assert: wrapper count = 0.	self assert: wrapper time = 0.	instance methodDelay.	self assert: wrapper count = 1.	self assert: wrapper time > 0.	instance methodDelay.	self assert: wrapper count = 2.	self assert: wrapper time > 0.	wrapper uninstall.! !!GPTimeMethodWrapperTest methodsFor: 'testing' stamp: 'md 3/20/2007 17:11'!testTimes	| wrapper instance previousTime |	wrapper := self wrapperClass on: #methodDelay inClass: GPMwClassA.	wrapper install.	instance := GPMwClassA new.	self assert: wrapper time = 0.	previousTime := wrapper time.	instance methodDelay.	self assert: wrapper time > previousTime.	previousTime := wrapper time.	instance methodDelay.	self assert: wrapper time > previousTime.	wrapper uninstall.! !!GPTimeMethodWrapperTest methodsFor: 'private' stamp: 'md 2/24/2007 19:17'!wrapperClass	^ GPTimeMethodWrapper! !!GPTransformer methodsFor: 'visiting' stamp: 'md 9/1/2007 11:23'!acceptInstrumentedAssignmentNode: anAssignmentNode	^self acceptAssignmentNode: anAssignmentNode.		! !!GPTransformer methodsFor: 'visiting' stamp: 'md 9/1/2007 11:15'!acceptInstrumentedVariableNode: aVariableNode	^self acceptVariableNode: aVariableNode! !!GPTransformer methodsFor: 'visiting' stamp: 'md 9/1/2007 11:42'!acceptSequenceNode: aSequenceNode 	self visitTemporaryVariables: aSequenceNode temporaries.	aSequenceNode statements copy do: [:each | self visitNode: each]! !!GPTransformer methodsFor: 'visiting' stamp: 'md 8/25/2007 15:49'!visitNode: aNode	node := aNode.	node hasAnyLink ifTrue: [		node links do: [:each |			link := each.			self initForNode: node.			self transform.		].	].	super visitNode: node.	! !!GPTransformer methodsFor: 'transformation' stamp: 'md 3/8/2007 22:16'!addPreamble: aNode	ptable do: [:each | aNode gpAddBefore: each].! !!GPTransformer methodsFor: 'transformation' stamp: 'md 3/8/2007 22:00'!genInitialHook	| metaObject  |		metaObject := (link metaObject isSymbol and: [self reifications includes: link metaObject])   "Allow reifications as MetaObject"				ifTrue: [table at: link metaObject]				ifFalse: [link isInlineMeta 							ifTrue: [link metaObject asLiteralNode]							ifFalse: [RBMessageNode 											receiver: link asLiteralNode											selector: #metaObject]].										link hasMoScope ifTrue: [metaObject := RBMessageNode 											receiver: link asLiteralNode											selector: #metaObjectFor:											arguments: {table at: link moScope}].																hook := RBMessageNode 						receiver: metaObject  						selector: link selector						arguments: (link arguments collect: #asLiteralNode).	! !!GPTransformer methodsFor: 'transformation' stamp: 'md 2/23/2007 00:09'!genSelectorFor: aCondition	^link isInlineCondition 		ifTrue: [link condition valueSelector]	     ifFalse: [#isActive numArgs: aCondition numArgs].! !!GPTransformer methodsFor: 'transformation' stamp: 'md 8/25/2007 15:03'!insertCode	link isBefore ifTrue: [^node gpAddBefore: hook].	link isAfter ifTrue: [^node gpAddAfter: hook].	link isBeforeAfter ifTrue: [^(node gpAddAfter: hook) gpAddBefore: hook].	link isInstead ifTrue: [^node gpreplaceWith: hook].! !!GPTransformer methodsFor: 'transformation' stamp: 'md 2/14/2007 21:29'!patchArguments	hook arguments: (link arguments collect: [:each | table at: each])! !!GPTransformer methodsFor: 'transformation' stamp: 'md 2/15/2007 10:35'!reifications	"all reifications the plugins installed can do. Installed are only the plugins compatible with the node" 	^plugins values collect: [:each | each class key].! !!GPTransformer methodsFor: 'transformation' stamp: 'md 2/15/2007 10:34'!selectorForNode	"The selector to be called on the Reification plugin"	^('genFor' , node class name) asSymbol.! !!GPTransformer methodsFor: 'transformation' stamp: 'md 10/18/2007 11:02'!setupTable	"Here we set up two tables: for every reification requested, we put the Reifier Plugin into 'table'. If a second	 reification is requested that requires complex code, we move the reification code into the preamble's 'ptable'	 and put an tempVarRead into the main table instead	 Later we just access 'table at: symbol' to get code for a requested reification and generate a preamble that fills	 those variable at the beginning of the link's code"	| reification |	reification := OrderedCollection new.	reification addAll: link arguments. 	link metaObject isSymbol ifTrue: [reification add: link metaObject].	link condition ifNotNil: [reification addAll: link condition reifications].	link hasMoScope ifTrue: [reification add: link moScope].		reification do: [:symbol |		(plugins at: symbol) optimize ifTrue: [ "don't bother to optimize one-bytecode reifications" 			((table includesKey: symbol) and: [(ptable includesKey: symbol) not]) ifTrue: [ | var |  "we already saw this one, use temp instead"				var := RBVariableNode named: ('gphhhddd', symbol).				ptable at: symbol put: (RBAssignmentNode variable: var				  										 value: (table at: symbol)).				node methodNode body addTemporaryNamed: 'gphhhddd', symbol.				table at: symbol put: var.			].		].		table at: symbol ifAbsentPut: [(plugins at: symbol) perform: self selectorForNode].	]! !!GPTransformer methodsFor: 'transformation' stamp: 'md 12/13/2007 09:55'!transform	"Main transformation method"	| newNode |	(link isInlineCondition and: [link condition condition = false]) ifTrue: [^self]. "nothing to do..."	self setupTable.	link hasCondition ifFalse: [self addPreamble: node].	self genInitialHook.	self patchArguments.	self wrapCondition.	Preferences linksEnableMetaContext ifTrue: [		self wrapMetaContext.		self wrapContext].	link requestsContinuation ifTrue: [self wrapContinuation].	link requestsResult ifTrue: [self wrapResult].	newNode := self insertCode.	newNode ifNotNil: [node := newNode].		! !!GPTransformer methodsFor: 'transformation' stamp: 'md 10/18/2007 11:13'!wrapCondition		|  ifSelector ifArguments condReceiver condSelector condArguments blockBody blockBody2 |		link hasCondition ifFalse: [^self]. "no condition"	(link isInlineCondition and: [link condition condition = true]) ifTrue: [^self].  "no condition needed"		condReceiver := (link isInlineCondition ifTrue: [link condition condition] ifFalse: [link]) asLiteralNode.	condSelector := self genSelectorFor: link condition condition.		(condSelector numArgs = 0) ifTrue: [condArguments  := #()].	(condSelector numArgs > 0) ifTrue: [			condArguments := OrderedCollection new.			1 to: condSelector numArgs do: [:i |				condArguments add: (table at: (link condition reifications at: i))]	].														ifSelector :=  link isInstead ifTrue: [#ifTrue:ifFalse:] ifFalse:[#ifTrue:].		blockBody := hook asSequenceNode.	self addPreamble: hook.		blockBody2 := (node isKindOf: RBMethodNode) ifTrue: [node body] ifFalse: [node copy asSequenceNode].		ifArguments := link isInstead				ifTrue: [{RBBlockNode body: blockBody. RBBlockNode body: blockBody2 }]				ifFalse: [{RBBlockNode body: blockBody}].				hook := RBMessageNode			receiver: (RBMessageNode 							receiver: condReceiver							selector: condSelector							arguments: condArguments)			selector: ifSelector			arguments: ifArguments.	! !!GPTransformer methodsFor: 'transformation' stamp: 'ms 11/8/2007 13:06'!wrapContext	link onActiveContexts do: 			[:eachContext | 			self wrapContext: eachContext onActive: true].	link onInactiveContexts do: 			[:eachContext | 			self wrapContext: eachContext onActive: false]! !!GPTransformer methodsFor: 'transformation' stamp: 'md 12/12/2007 20:56'!wrapContext: eachContext onActive: bool	| ifArguments blockBody condArguments condReceiver ifSelector condSelector blockBody2 |	condReceiver := RBMessageNode 				receiver: (RBVariableNode named: eachContext name)				selector: #current				arguments: #().	condSelector := bool ifTrue:[#isActive]ifFalse:[#notActive].		condArguments := #().	ifSelector := link isInstead ifTrue: [#ifTrue:ifFalse:] ifFalse: [#ifTrue:].	blockBody := hook asSequenceNode.	blockBody2 := (node isKindOf: RBMethodNode) 				ifTrue: [node body]				ifFalse: [node copy asSequenceNode].	ifArguments := link isInstead 				ifTrue: 					[{ 						(RBBlockNode body: blockBody).						(RBBlockNode body: blockBody2)}]				ifFalse: 					[{  (RBBlockNode body: blockBody)}].	^ hook := RBMessageNode 				receiver: (RBMessageNode 						receiver: condReceiver						selector: condSelector						arguments: condArguments)				selector: ifSelector				arguments: ifArguments! !!GPTransformer methodsFor: 'transformation' stamp: 'md 3/30/2007 17:18'!wrapContinuation		| continuationBlock |		continuationBlock := RBBlockNode 							arguments: {RBVariableNode named: 'continuation'}							body: hook asSequenceNode.			hook := RBMessageNode			receiver: GPContinuation asLiteralNode			selector: #gpCurrentDo:			argument: continuationBlock.	! !!GPTransformer methodsFor: 'transformation' stamp: 'md 12/12/2007 20:55'!wrapMetaContext	"this wraps the hook code into [hook] valueWithContext: MetaContext	 this means, the turns on the Meta Context for the execution of the meta code"	| linkContext argument blockLink |	argument := RBVariableNode named: 'MetaContext'.	argument binding: (GlobalVar new assoc: MetaContext binding).	linkContext := hook asSequenceNode.	blockLink := RBBlockNode body: linkContext.	hook := RBMessageNode			receiver: blockLink			selector: #valueWithContext:			arguments: {argument}! !!GPTransformer methodsFor: 'transformation' stamp: 'md 9/1/2007 12:46'!wrapResult	| parent newNode |	parent := node parent.	node methodNode body addTemporaryNamed: 'gpResultkkdkdkkd'. 		node isMethod 		ifFalse: [    newNode := (RBAssignmentNode						variable: (RBVariableNode named: 'gpResultkkdkdkkd')						value: node copy) parent: parent.					"node replaceWith: newNode."					"node := newNode"]		ifTrue: [ | toReplace |			toReplace := node body statements first.			 toReplace replaceWith:  (RBAssignmentNode						variable: (RBVariableNode named: 'gpResultkkdkdkkd')						value: toReplace copy).			toReplace methodNode   body addTemporaryNamed: 'gpResultkkdkdkkd'. 						 ]							! !!GPTransformer methodsFor: 'accessing' stamp: 'md 2/7/2007 14:43'!hook: aHook	hook := aHook! !!GPTransformer methodsFor: 'accessing' stamp: 'md 2/7/2007 14:43'!link: aLink	link := aLink! !!GPTransformer methodsFor: 'initializing' stamp: 'md 8/25/2007 15:27'!initForNode: aNode	table := Dictionary new.	ptable := Dictionary new.	plugins := Dictionary new.		"register all the plugins that can reify information for this node"	GPParameter subclasses do: [:plugin |		(plugin nodes anySatisfy: [:class | node isKindOf: class])	 ifTrue: [			plugins at: plugin key put: (plugin node: node link: link)]		]! !!GPTransformer class methodsFor: 'as yet unclassified' stamp: 'md 12/13/2007 14:22'!initialize	Preferences		addPreference: #linksEnableMetaContext		category: #reflectivityexp		default: false		balloonHelp: 'If true, links, the meta context is activated whenever a link is activated'.	Preferences		addPreference: #linksAreContextual		category: #reflectivityexp		default: false		balloonHelp: 'If true, links are only active outside the meta'.! !!GPValueParameter methodsFor: 'code generation' stamp: 'md 8/20/2007 16:26'!genForRBAssignmentNode	^node variable! !!GPValueParameter methodsFor: 'code generation' stamp: 'md 9/25/2007 14:45'!genForRBTempVariableNode	^node copy.! !!GPValueParameter methodsFor: 'code generation' stamp: 'md 8/20/2007 21:59'!genForRBVariableNode	node isGlobal ifTrue: [^node binding value asLiteralNode]. 	^node copy.! !!GPValueParameter class methodsFor: 'plugin interface' stamp: 'md 2/11/2007 10:49'!key	^#value! !!GPValueParameter class methodsFor: 'plugin interface' stamp: 'md 2/11/2007 10:49'!nodes	^{RBVariableNode. RBAssignmentNode}! !!GPVarNameParameter methodsFor: 'code generation' stamp: 'md 2/11/2007 11:49'!genForRBAssignmentNode	^ node variable binding name asLiteralNode! !!GPVarNameParameter methodsFor: 'code generation' stamp: 'md 2/11/2007 11:45'!genForRBVariableNode	^ node  binding name asLiteralNode! !!GPVarNameParameter class methodsFor: 'plugin interface' stamp: 'md 2/11/2007 10:31'!key	^#varname! !!GPVarNameParameter class methodsFor: 'plugin interface' stamp: 'md 2/11/2007 10:31'!nodes	^{RBVariableNode. RBAssignmentNode}! !!GenericMultiValuedAnnotation methodsFor: 'testing' stamp: 'pmm 9/24/2006 13:37'!isSourceVisible	^self sourceVisible! !!GenericMultiValuedAnnotation methodsFor: 'testing' stamp: 'pmm 9/24/2006 13:37'!sourceVisible	^sourceVisible! !!GenericMultiValuedAnnotation methodsFor: 'testing' stamp: 'pmm 9/24/2006 13:37'!sourceVisible: aBoolean	sourceVisible := aBoolean! !!GenericNoValueAnnotation methodsFor: 'testing' stamp: 'pmm 9/24/2006 13:38'!isSourceVisible	^self sourceVisible! !!GenericNoValueAnnotation methodsFor: 'testing' stamp: 'pmm 9/24/2006 13:38'!sourceVisible	^sourceVisible! !!GenericNoValueAnnotation methodsFor: 'testing' stamp: 'pmm 9/24/2006 13:38'!sourceVisible: aBoolean	sourceVisible := aBoolean! !!GenericNoValueAnnotation class methodsFor: 'accessing' stamp: 'pmm 7/23/2006 15:59'!keys	^#()! !!GenericSingleValuedAnnotation methodsFor: 'testing' stamp: 'pmm 9/24/2006 13:38'!isSourceVisible	^self sourceVisible! !!GenericSingleValuedAnnotation methodsFor: 'testing' stamp: 'pmm 9/24/2006 13:38'!sourceVisible	^sourceVisible! !!GenericSingleValuedAnnotation methodsFor: 'testing' stamp: 'pmm 9/24/2006 13:38'!sourceVisible: aBoolean	sourceVisible := aBoolean! !!GeppettoDemoTest methodsFor: 'as yet unclassified' stamp: 'md 12/13/2007 09:57'!testOrderedCollectionBeep	"this nicely demos the problem of infinite meta calls."	| link |			Preferences linksEnableMetaContext ifFalse: [^self].	link := GPLink new metaObject: Beeper;			selector: #beep;			addOnInactiveContext: MetaContext.				(OrderedCollection>>#add:) reflectiveMethod methodNode link: link.	self assert: (OrderedCollection new add: 5) = 5.	link uninstall.! !!GeppettoSystemTest methodsFor: 'tools' stamp: 'md 10/18/2007 16:22'!assertNoLinks: aMethod	aMethod  nodes do: [:node | self assert: node hasAnyLink not].! !!GeppettoSystemTest methodsFor: 'tools' stamp: 'md 10/18/2007 16:22'!removeLinks: aMethod	aMethod reflectiveMethod methodNode nodesDo: [:node |		node hasAnyLink ifTrue: [node removeAllLinks]].! !!GeppettoSystemTest methodsFor: 'tools' stamp: 'md 10/18/2007 16:22'!setup	gplink := nil.! !!GeppettoSystemTest methodsFor: 'tools' stamp: 'md 10/18/2007 16:22'!tearDown	gplink ifNotNil: [gplink uninstall].		GPExamples methodDict values do: [:method |		self removeLinks: method.		self assertNoLinks: method. 	].! !!GeppettoSystemTest methodsFor: 'as yet unclassified' stamp: 'md 10/21/2007 20:47'!testObjectAtPut	"make sure that at:put: is persephonized"	PERecompiler new recompileClass: Object.		gplink := GPLink new	metaObject: [:arg1 :arg2 :context |					context receiver					basicAt: arg1 put: arg2.					GPCounter inc];				selector: #value:value:value:;				control: #instead;				arguments: #(arg1 arg2 context).	GPCounter reset.	(Object>>#at:put:) methodNode link: gplink.	self assert: (Object>>#at:put:) methodNode links size = 1.	(Object>>#at:put:)  invalidate.	#(1 2) at: 2 put: 3.	self assert: GPCounter counter > 0.			! !!GeppettoSystemTest methodsFor: 'as yet unclassified' stamp: 'md 10/25/2007 14:46'!testOrderedCollectionAdd	"make sure that OrderedCollection>#add: is persephonized"	PERecompiler new recompileClass: OrderedCollection.		gplink := GPLink new metaObject: GPCounter.	gplink selector: #inc.							GPCounter reset.	(OrderedCollection>>#add:) methodNode link: gplink.	#(1 3) asOrderedCollection add: 4.	self assert: GPCounter counter > 0.			! !!GeppettoTest methodsFor: 'tools' stamp: 'md 2/19/2007 17:59'!assertNoLinks: aMethod	aMethod  nodes do: [:node | self assert: node hasAnyLink not].! !!GeppettoTest methodsFor: 'tools' stamp: 'md 3/20/2007 17:25'!removeLinks: aMethod	aMethod reflectiveMethod methodNode nodesDo: [:node |		node hasAnyLink ifTrue: [node removeAllLinks]].! !!GeppettoTest methodsFor: 'setup' stamp: 'md 6/13/2007 13:56'!setup	gplink := nil.! !!GeppettoTest methodsFor: 'setup' stamp: 'md 12/12/2007 21:07'!tearDown	gplink ifNotNil: [gplink uninstall].		GPExamples methodDict values do: [:method |		self removeLinks: method.		self assertNoLinks: method. 	].! !!GeppettoTest methodsFor: 'testing - blocks' stamp: 'md 5/18/2007 15:20'!testBlockAfter		gplink := GPLink new metaObject: [GPCounter inc]; control: #after.	(GPExamples>>#exampleBlock) blocks do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleBlock = 8).	self assert: (GPCounter counter = 2).! !!GeppettoTest methodsFor: 'testing - blocks' stamp: 'md 5/18/2007 15:22'!testBlockArg1		gplink := GPLink metaObject: [:arg1 | self assert: arg1 = 2. GPCounter inc].					 	(GPExamples>>#exampleBlock) blocks do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleBlock = 8).	self assert: (GPCounter counter = 2).! !!GeppettoTest methodsFor: 'testing - blocks' stamp: 'md 2/27/2007 21:18'!testBlockArguments		gplink := GPLink metaObject: [:arguments | self assert: (arguments first = 2). GPCounter inc].						(GPExamples>>#exampleBlock) blocks do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleBlock = 8).	self assert: (GPCounter counter = 2).! !!GeppettoTest methodsFor: 'testing - blocks' stamp: 'md 4/14/2007 00:40'!testBlockBefore		gplink := GPLink metaObject: [GPCounter inc].	(GPExamples>>#exampleBlock) blocks do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleBlock = 8).	self assert: (GPCounter counter = 2).! !!GeppettoTest methodsFor: 'testing - blocks' stamp: 'md 3/9/2007 09:48'!testBlockReplace		gplink := GPLink new metaObject: [GPCounter inc. 5]; control: #instead.	(GPExamples>>#exampleBlock) blocks do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleBlock = 5).	self assert: (GPCounter counter = 2).! !!GeppettoTest methodsFor: 'testing - meta' stamp: 'md 2/22/2007 18:27'!testBlockAsLink		(GPExamples>>#example) sends do: [:node | 		node link: ([:control | GPCounter inc. self assert: (control = #before)] link)	].	 	GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).		self removeLinks: (GPExamples>>#example).! !!GeppettoTest methodsFor: 'testing - meta' stamp: 'md 2/23/2007 11:02'!testBlockAsMeta	gplink := GPLink new metaObject: [:control | GPCounter inc. self assert: (control = #before)];					selector: #value:;					arguments: #(control).   		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - meta' stamp: 'md 2/23/2007 11:04'!testBlockAsMetaNoArg	gplink := GPLink metaObject: [GPCounter inc].		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - meta' stamp: 'md 2/23/2007 11:22'!testBlockAsMetaNoSel	gplink := GPLink new metaObject: [:control | GPCounter inc. self assert: (control = #before)];						arguments: #(control).		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - meta' stamp: 'md 2/23/2007 12:08'!testBlockAsMetaNoSelNoArg	gplink := GPLink metaObject: [:control | GPCounter inc. self assert: (control = #before)].		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - meta' stamp: 'md 2/21/2007 09:37'!testExecuteBlockBefore		(GPExamples>>#example) sends do: [:node |  		node executeBlockBefore: [:control | GPCounter inc].	].	GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).		self removeLinks: (GPExamples>>#example).! !!GeppettoTest methodsFor: 'testing - meta' stamp: 'md 3/9/2007 09:48'!testObjectAsMeta		gplink := GPLink new metaObject: #object;						selector: #instVarAt:put:;					control: #instead;					arguments: #(offset newValue).   		(GPExamples>>#exampleIvar) assignments do: [:node | node link: gplink].		self assert: (GPExamples new exampleIvar = 11).! !!GeppettoTest methodsFor: 'testing - bugs' stamp: 'md 10/22/2007 15:40'!testBlockVariables	| link |	link := GPLink new metaObject: self class;						selector: #assertVariable:;						arguments: #(node).							GPCounter reset.						PERecompiler new recompile: #exampleBlock in: GPExamples.	(GPExamples>>#exampleBlock) variableReads do: [:node | node link: link].	self assert: (GPExamples new exampleBlock) = 8.	self assert: GPCounter counter = 4.! !!GeppettoTest methodsFor: 'testing - bugs' stamp: 'md 10/5/2007 14:39'!testBlockVariables2	| link examples vars |	link := GPLink new metaObject: self class;						selector: #assertVariable:value:context:;						arguments: #(node value context).							GPCounter reset.						PERecompiler new recompile: #exampleBlock2 in: GPExamples.	vars := (GPExamples>>#exampleBlock2) variables select: [:each | each name ~= 'self'].	vars do: [:node | node link: link].	examples := GPExamples new.	self assert: examples exampleBlock2 = 5.	self assert: examples a = 5.	self assert: GPCounter counter = 2.! !!GeppettoTest methodsFor: 'testing - bugs' stamp: 'md 9/25/2007 15:01'!testCascadeVariables	| link |	link := GPLink new metaObject: self class;						selector: #assertReceiverForMethod:;						arguments: #(value).							GPCounter reset.						PERecompiler new recompile: #exampleCascade2 in: GPExamples.	(GPExamples>>#exampleCascade2) variables do: [:node | node link: link].	self assert: (GPExamples new exampleCascade2 isKindOf: GPExamples).	self assert: GPCounter counter = 4.! !!GeppettoTest methodsFor: 'testing - bugs' stamp: 'md 8/20/2007 16:30'!testFredAssignment	| link checkValue checkNewValue |			link := GPLink new metaObject: [:value :newValue | Transcript show: 'value : ', (checkValue := value asString), ' and newValue: ', (checkNewValue := newValue asString)]; 				selector: #'value:value:';				arguments: #(value newValue).	self assert: checkValue = nil.	self assert: checkNewValue = nil.	self assert: (GPExamples new a: 5) = 5.	PERecompiler new recompile: #a: in: GPExamples.	(GPExamples>>#a:) assignments do: [:node | node link: link]. 			self assert: (GPExamples new a: 5) = 5.	self assert: checkValue = 'nil'.	self assert: checkNewValue = '5'.	! !!GeppettoTest methodsFor: 'testing - bugs' stamp: 'md 8/20/2007 21:59'!testFredRead	| link checkValue |	link := GPLink new metaObject: [:value | Transcript show: 'value : ', (checkValue := value asString)];						selector: #value:;						arguments: #(value).							PERecompiler new recompile: #a in: GPExamples.	(GPExamples>>#a) variables do: [:node | node link: link].	self assert: (GPExamples new a) = 5.	self assert: checkValue = '5'.! !!GeppettoTest methodsFor: 'testing - bugs' stamp: 'md 10/21/2007 21:28'!testSingleVariableStatementInBlock	| link |	link := GPLink new metaObject: self class;						selector: #assertVariable:;						arguments: #(node).							GPCounter reset.						PERecompiler new recompile: #exampleSingleVariableInBlock in: GPExamples.	self assert: (GPExamples>>#exampleSingleVariableInBlock) variableReads size = 1.	self assert: (GPExamples>>#exampleSingleVariableInBlock) variableReads asArray first name = 'b'.	(GPExamples>>#exampleSingleVariableInBlock) variableReads do: [:node | node link: link].	self assert: (GPExamples new exampleSingleVariableInBlock) = 5.	self assert: GPCounter counter = 1.! !!GeppettoTest methodsFor: 'testing - condition' stamp: 'md 2/19/2007 18:51'!testConditionArgument		gplink := GPLink new metaObject: self class;						selector: #assertControl:;					arguments: #(control);					condition: [:context | context receiver class = GPExamples].   						(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).	! !!GeppettoTest methodsFor: 'testing - condition' stamp: 'md 2/19/2007 23:08'!testConditionArgumentLink		gplink := GPLink new metaObject: self class;						selector: #assertControl:;					arguments: #(control);					condition: [:link |  link = gplink].   		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).	! !!GeppettoTest methodsFor: 'testing - condition' stamp: 'md 2/21/2007 09:26'!testConditionArgumentMultiple		gplink := GPLink new metaObject: self class;						selector: #assertControl:;					arguments: #(control);					condition: [:link :context | 						self assert: (context isKindOf: ContextPart). link = gplink].   						(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).	! !!GeppettoTest methodsFor: 'testing - condition' stamp: 'md 3/8/2007 22:07'!testConditionArgumentNoInline		gplink := GPLink new metaObject: self class;						selector: #assertControl:;					arguments: #(control);					noInlineCondition;					condition: [:context | context receiver class = GPExamples].   		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).	! !!GeppettoTest methodsFor: 'testing - condition' stamp: 'md 2/19/2007 22:40'!testConditionBoolean		gplink := GPLink new metaObject: self class;						selector: #assertControl:;					arguments: #(control);					condition: false.   	(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 0).		gplink condition: true.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).	! !!GeppettoTest methodsFor: 'testing - condition' stamp: 'md 2/19/2007 22:41'!testConditionSimple		gplink := GPLink new metaObject: self class;						selector: #assertControl:;					arguments: #(control);					condition: [false].   						(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 0).		gplink condition: [true].	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).	! !!GeppettoTest methodsFor: 'testing - condition' stamp: 'md 10/18/2007 11:19'!testConditionWithArgument		gplink := GPLink new metaObject: self class;						selector: #assertControl:;					arguments: #(control);					condition: [:rr | rr receiver class = GPExamples] arguments: #(context).						(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).	! !!GeppettoTest methodsFor: 'testing - link API' stamp: 'md 2/19/2007 22:43'!testLinkAPI		gplink := GPLink new					metaObject: Object new;						selector: #tagNode:.	   	self assert: gplink notNil.	self assert: (gplink metaObject isKindOf: Object).	self assert: (gplink selector = #tagNode:).		self assert: (gplink control = #before).! !!GeppettoTest methodsFor: 'testing - link API' stamp: 'md 2/19/2007 22:43'!testLinkAPIArgs	gplink := GPLink new					metaObject: self class;						selector: #tagNode:;   					arguments: #(node).		self assert: (gplink arguments = #(node)).! !!GeppettoTest methodsFor: 'testing - link API' stamp: 'md 3/9/2007 09:48'!testLinkCompatibilityCheck		gplink := (GPLink metaObject: self class)						selector: #operation:;					control: #instead;					arguments: #(arg1).   		self		should: [(GPExamples>>#example) variables do: [:send | send link: gplink]]		raise: Error		whoseDescriptionIncludes: 'not possible on this node'		description: 'Wrong reification arguments for this node '.! !!GeppettoTest methodsFor: 'testing - link update' stamp: 'md 8/19/2007 18:34'!testLinkDeactivate		gplink := GPLink new metaObject: self class;						selector: #deactivate:;					control: #before;					arguments: #(link);   					condition: true.		(GPExamples>>#example) nodes do: [:node | 		node isMessage ifTrue: [node link: gplink]].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 0).! !!GeppettoTest methodsFor: 'testing - link update' stamp: 'md 3/9/2007 09:48'!testLinkReplaceInactive		gplink := GPLink new metaObject: self class;						selector: #send:to:withArguments:;					control: #instead;					arguments: #(selector receiver arguments); 					condition: [false].	((GPExamples>>#example) nodes select: #isMessage) do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 0).		gplink condition: [true].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).		! !!GeppettoTest methodsFor: 'testing - link update' stamp: 'md 3/9/2007 09:48'!testLinkReplaceInactiveNotInlined	gplink := GPLink new metaObject: self class;						selector: #send:to:withArguments:;					control: #instead;					arguments: #(selector receiver arguments); 					noInlineCondition;					condition: [false].	((GPExamples>>#example) nodes select: #isMessage) do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 0).		gplink condition: [true].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).		! !!GeppettoTest methodsFor: 'testing - link update' stamp: 'md 8/19/2007 18:37'!testLinkUninstall		gplink := GPLink new metaObject: self class;						selector: #uninstall:;					control: #before;					arguments: #(link);   					condition: true.		(GPExamples>>#example) nodes do: [:node | node isMessage ifTrue: [node link: gplink]].	GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 0).! !!GeppettoTest methodsFor: 'testing - link update' stamp: 'md 2/21/2007 09:40'!testLinkUpdating			gplink := GPLink new metaObject: self class;						selector: #assertControl:;					arguments: #(control).		(GPExamples>>#example)  sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).		gplink selector: #assertNode:; arguments: #(node).	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 2).! !!GeppettoTest methodsFor: 'testing - moScope' stamp: 'md 3/8/2007 20:27'!testMoScope	gplink := GPLink new metaObjectCreator: [self class];						selector: #assertControl:;					moScope: #class;					arguments: #(control).   		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - moScope' stamp: 'md 10/18/2007 14:10'!testMoScopeNode	gplink := GPLink new metaObjectCreator: [self class];						selector: #assertControl:;					moScope: #node;					arguments: #(control).   		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).		self assert: gplink metaObject size = 1.! !!GeppettoTest methodsFor: 'testing - moScope' stamp: 'md 10/18/2007 14:06'!testMoScopeObject	gplink := GPLink new metaObjectCreator: [self class];						selector: #assertControl:;					moScope: #object;					arguments: #(control).   		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).		self assert: (GPExamples new example = 11).		self assert: gplink metaObject size = 2.! !!GeppettoTest methodsFor: 'testing - operation' stamp: 'md 8/24/2007 00:05'!testOperationAssignment		gplink := (GPLink metaObject: self class)						selector: #operation:;					control: #instead;					arguments: #(operation).   		(GPExamples>>#exampleIvar) instanceAssignments do: [:send | send link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleIvar = 11).	self assert: GPCounter counter = 1.! !!GeppettoTest methodsFor: 'testing - operation' stamp: 'md 3/9/2007 09:48'!testOperationAssignmentProceed		gplink := (GPLink metaObject: self class)						selector: #operationProceed:context:;					control: #instead;					arguments: #(operation context).   		(GPExamples>>#exampleIvar) assignments do: [:send | send link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleIvar = 11).	self assert: GPCounter counter = 1.! !!GeppettoTest methodsFor: 'testing - operation' stamp: 'md 8/24/2007 00:06'!testOperationAssignmentTemp	gplink := (GPLink metaObject: self class)						selector: #operation:;					control: #instead;					arguments: #(operation).   		(GPExamples>>#example) tempAssignments do: [:send | send link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: GPCounter counter = 2.! !!GeppettoTest methodsFor: 'testing - operation' stamp: 'md 3/9/2007 09:48'!testOperationSend	gplink := GPLink new 					metaObject: self class;						selector: #operation:;					control: #instead;					arguments: #(operation).   		(GPExamples>>#example) sends do: [:send | send link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: GPCounter counter = 1.! !!GeppettoTest methodsFor: 'testing - operation' stamp: 'md 3/9/2007 09:49'!testOperationSendManyArgs		gplink := GPLink new 					metaObject: self class;						selector: #operation:;					control: #instead;					arguments: #(operation).   		(GPExamples>>#exampleSendmanyArgs) sends do: [:send | send link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleSendmanyArgs = 15).	self assert: GPCounter counter = 2.! !!GeppettoTest methodsFor: 'testing - operation' stamp: 'md 3/9/2007 09:49'!testOperationSendMetaBlock		gplink := GPLink new metaObject: self class;						selector: #operation:;					control: #instead;					arguments: #(operation).   		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: GPCounter counter = 1.! !!GeppettoTest methodsFor: 'testing - operation' stamp: 'md 3/9/2007 09:50'!testOperationSendObjectSpecific	| object  |		object := GPExamples new.		gplink := (GPLink metaObject: self class)						selector: #operation:;					control: #instead;					condition: [:context | context receiver = object];					arguments: #(operation).   		(GPExamples>>#example) sends do: [:send | send link: gplink].		GPCounter reset.	self assert: (object example = 11).	self assert: GPCounter counter = 1.	self assert: (GPExamples new example = 11).	self assert: GPCounter counter = 1.! !!GeppettoTest methodsFor: 'testing - operation' stamp: 'md 3/9/2007 09:50'!testOperationSendZeroArgs		gplink := GPLink new 					metaObject: self class;						selector: #operation:;					control: #instead;					arguments: #(operation).   		(GPExamples>>#exampleSendZeroArg) sends do: [:send | send link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleSendZeroArg = 5 factorial).	self assert: GPCounter counter = 1.! !!GeppettoTest methodsFor: 'testing - operation' stamp: 'md 10/22/2007 14:36'!testOperationVariable		gplink := (GPLink metaObject: self class)						selector: #operation:;					control: #instead;					arguments: #(operation).   		(GPExamples>>#exampleIvar) variableReads do: [:send | send link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleIvar = 11).	self assert: GPCounter counter = 1.! !!GeppettoTest methodsFor: 'testing - operation' stamp: 'md 10/22/2007 14:36'!testOperationVariableTemp		gplink := (GPLink metaObject: self class)						selector: #operation:;					control: #instead;					arguments: #(operation).   		(GPExamples>>#example) variableReads do: [:send | send link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: GPCounter counter = 2.! !!GeppettoTest methodsFor: 'testing - proceed' stamp: 'md 3/9/2007 09:49'!testOperationSendProceed		gplink := GPLink new metaObject: [:proceed | GPCounter inc. proceed value];					selector: #value:;					control: #instead;					arguments: #(proceed).   		(GPExamples>>#example) sends do: [:send | send link: gplink].		GPCounter reset.	self assert: (GPExamples new example  = 11).	self assert: GPCounter counter = 1.! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 2/21/2007 09:28'!testReificationAsMeta		gplink := GPLink new metaObject: #object;						selector: #testReifyMo.		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 3/9/2007 09:50'!testReificationAsMetaClass		gplink := GPLink new metaObject: #class;						control: #instead;					selector: #name.		(GPExamples>>#example) sends do: [:node | node link: gplink].	self assert: (GPExamples new example = 'GPExamples').! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 5/5/2007 18:04'!testReificationAsMetaReceiver		gplink := GPLink new metaObject: #receiver;					selector: #perform:withArguments:;					control: #instead;					arguments: #(selector arguments).	(GPExamples>>#example) statements do: [:node |		node isMessage ifTrue: [node link: gplink]].		self assert: (GPExamples new example = 11).! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 2/21/2007 09:28'!testReifyControl		gplink := GPLink new metaObject: self class;						selector: #assertControl:;					control: #before;					arguments: #(control).   		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 3/8/2007 22:07'!testReifyControlNoInlineMeta		gplink := GPLink new metaObject: self class;						selector: #assertControl:;					control: #before;					noInlineMeta;					arguments: #(control).   		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 3/9/2007 09:50'!testReifyIvarAssignment		gplink := GPLink new metaObject: self class;						selector: #iVarAt:in:to:;					control: #instead;					arguments: #(offset object newValue).   		(GPExamples>>#exampleIvar) assignments do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleIvar = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 3/9/2007 09:50'!testReifyIvarAssignmentName		gplink := GPLink new metaObject: self class;						selector: #iVarNamed:in:to:;					control: #instead;					arguments: #(varname object newValue).   		(GPExamples>>#exampleIvar) assignments do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleIvar = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 10/22/2007 14:40'!testReifyIvarRead		gplink := GPLink new metaObject: self class;						selector: #'iVarAt:in:';					control: #instead;					arguments: #(offset object).   		(GPExamples>>#exampleIvar) variableReads do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleIvar = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 8/19/2007 18:36'!testReifyIvarReifyName		gplink := GPLink new metaObject: self class;						selector: #'assertName:';					control: #before;					arguments: #(varname).   		(GPExamples>>#exampleIvar) nodes do: [:node |		(node isVariable and: [node isRead])  ifTrue: [node link: gplink]].		GPCounter reset.	self assert: (GPExamples new exampleIvar = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 8/19/2007 18:36'!testReifyLink		gplink := GPLink new metaObject: self class;						selector: #assertLink:;					control: #before;					arguments: #(link).   		(GPExamples>>#example) nodes do: [:node | node isMessage ifTrue: [node link: gplink]].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 2/21/2007 09:30'!testReifyNode	gplink := GPLink new metaObject: self class;						selector: #assertNode:;					control: #before;					arguments: #(node).   		(GPExamples>>#example) statements do: [:node |		node isMessage ifTrue: [node link: gplink]].		GPCounter reset.	self assert: (GPExamples new example = 11).	! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 2/21/2007 09:30'!testReifyNodeBeforeAfter		gplink := GPLink new metaObject: self class;						selector: #assertNode:;					control: #beforeafter;					arguments: #(node).   		 (GPExamples>>#example) statements do: [:node | 		node isAssignment ifTrue: [node link: gplink]].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 4)! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 3/9/2007 09:51'!testReifySend	gplink := GPLink new metaObject: self class;						selector: #send:to:with:;					control: #instead;					arguments: #(selector receiver arg1).   	(GPExamples>>#example) statements do: [:node |		node isMessage ifTrue: [node link: gplink]].		self assert: (GPExamples new example = 11).! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 3/9/2007 09:51'!testReifySendArguments2	gplink := GPLink new metaObject: self class;						selector: #send:to:withArguments:;					control: #instead;					arguments: #(selector receiver arguments).   		(GPExamples>>#exampleSend) sends do: [:node | node link: gplink].	self assert: (GPExamples new exampleSend).! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 2/21/2007 09:37'!testReifySendArgumentsDual	gplink := GPLink new metaObject: self class;						selector: #checkArg:arg:;					arguments: #(arguments arguments).   		(GPExamples>>#exampleSend) sends do: [:node | node link: gplink].		self assert: (GPExamples new exampleSend).! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 3/9/2007 09:51'!testReifySendArgumentsMany		gplink := GPLink new metaObject: self class;						selector: #send:to:withArguments:;					control: #instead;					arguments: #(selector receiver arguments).   		(GPExamples>>#exampleSendmanyArgs) sends do: [:node | node link: gplink].	GPCounter reset.	self assert: (GPExamples new exampleSendmanyArgs = 15).	self assert: (GPCounter counter = 2)! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 3/9/2007 09:51'!testReifySendArgumentsZero		gplink := GPLink new metaObject: self class;						selector: #send:to:withArguments:;					control: #instead;					arguments: #(selector receiver arguments).   		(GPExamples>>#exampleSendZeroArg) sends do: [:node | node link: gplink].	self assert: ((GPExamples new exampleSendZeroArg) = 5 factorial).! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 3/9/2007 09:51'!testReifyTempVarAssign		gplink := GPLink new metaObject: self class;						selector: #'tempVarAt:in:put:';					control: #instead;					arguments: #(offset context newValue).   		 (GPExamples>>#example) nodes do: [:node | (node isAssignment) ifTrue: [node link: gplink]].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 2).! !!GeppettoTest methodsFor: 'testing - reifications' stamp: 'md 3/9/2007 09:51'!testReifyTempVarRead	gplink := GPLink new metaObject: self class;						selector: #'tempVarAt:in:';					control: #instead;					arguments: #(offset context).   						(GPExamples>>#example)  variables do: [:node | node isRead ifTrue: [node link: gplink]].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 2).! !!GeppettoTest methodsFor: 'testing - globals' stamp: 'md 8/24/2007 00:06'!testReifyClassVarAssignment	gplink := GPLink metaObject: [:node | GPCounter inc. self assert: node isAssignment].						(GPExamples>>#exampleClassWrite) globalAssignments do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleClassWrite = 5).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - globals' stamp: 'md 2/24/2007 10:00'!testReifyClassVarAssignmentBinding	gplink := GPLink metaObject: [:binding | GPCounter inc. self assert: (binding key = #Test)].						(GPExamples>>#exampleClassWrite) assignments do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleClassWrite = 5).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - globals' stamp: 'md 2/24/2007 09:36'!testReifyClassVarAssignmentNewValue	gplink := GPLink metaObject: [:newValue | GPCounter inc. self assert: newValue = 5].						(GPExamples>>#exampleClassWrite) assignments do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleClassWrite = 5).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - globals' stamp: 'md 3/9/2007 09:50'!testReifyClassVarAssignmentOperation	gplink := GPLink new metaObject: self class;						selector: #operation:;					control: #instead;					arguments: #(operation).						(GPExamples>>#exampleClassWrite) assignments do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleClassWrite = 5).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - globals' stamp: 'md 3/9/2007 09:50'!testReifyClassVarAssignmentProceed	gplink := GPLink new metaObject: [:proceed | GPCounter inc. proceed value];						control: #instead.								(GPExamples>>#exampleClassWrite) assignments do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleClassWrite = 5).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - globals' stamp: 'md 8/19/2007 18:47'!testReifyGlobalRead		gplink := GPLink new metaObject: self class;						selector: #assertGlobal:;					arguments: #(node).						((GPExamples>>#exampleGlobalRead) variables select: [:node | node isRead]) do: [:node |			 node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleGlobalRead = Smalltalk).	self assert: (GPCounter counter = 2).! !!GeppettoTest methodsFor: 'testing - globals' stamp: 'md 2/24/2007 09:59'!testReifyGlobalReadBinding		gplink := GPLink metaObject: [:binding | GPCounter inc. self assert: (binding key = #Smalltalk)].						((GPExamples>>#exampleGlobalRead) variables select: [:node | node isGlobal]) do: [:node |			 node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleGlobalRead = Smalltalk).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - globals' stamp: 'md 3/9/2007 09:50'!testReifyGlobalReadOperation		gplink := GPLink new metaObject: self class;						selector: #operation:;					control: #instead;					arguments: #(operation).						((GPExamples>>#exampleGlobalRead) variables select: [:node | node isRead]) do: [:node |			 node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleGlobalRead = Smalltalk).	self assert: (GPCounter counter = 2).! !!GeppettoTest methodsFor: 'testing - globals' stamp: 'md 3/9/2007 09:50'!testReifyGlobalReadProceed		gplink := GPLink new metaObject: [:proceed | GPCounter inc. proceed value];						control: #instead.						((GPExamples>>#exampleGlobalRead) variables select: [:node | node isGlobal]) do: [:node |			 node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleGlobalRead = Smalltalk).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - globals' stamp: 'md 2/23/2007 16:54'!testReifyGlobalReadValue		gplink := GPLink metaObject: [:value | GPCounter inc. self assert: value = Smalltalk].						((GPExamples>>#exampleGlobalRead) variables select: [:node | node isGlobal]) do: [:node |			 node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleGlobalRead = Smalltalk).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - continuations' stamp: 'md 3/9/2007 16:40'!testReifyContinuation	gplink := GPLink new metaObject: [:continuation | GPCounter inc. self assert: (continuation isKindOf: GPContinuation)].		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - continuations' stamp: 'md 3/9/2007 16:41'!testReifyContinuationReplace	gplink := GPLink new 		metaObject: [:continuation | GPCounter inc. self assert: (continuation isKindOf: GPContinuation). 11];		control: #instead.		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - continuations' stamp: 'md 3/9/2007 15:57'!testReifyContinuationReplaceValue	gplink := GPLink new 		metaObject: self class;		selector: #continue:;		arguments: #(continuation);		control: #instead.		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - continuations' stamp: 'md 3/9/2007 15:58'!testReifyContinuationReplaceValue2	gplink := GPLink new 		metaObject: [:continuation | GPCounter inc. continuation value: 11];		control: #instead.		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - continuations' stamp: 'md 3/9/2007 15:58'!testReifyContinuationReplaceValueOperation	gplink := GPLink new 		metaObject: [:continuation :operation | GPCounter inc. continuation value: operation value];		control: #instead.		(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - continuations' stamp: 'md 3/9/2007 16:41'!testRequestsContiunation	gplink := GPLink new metaObject: [:continuation | GPCounter inc. self assert: (continuation isKindOf: GPContinuation)].		self assert: gplink requestsContinuation.! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 2/19/2007 22:45'!testReifyMethodAfter		gplink := GPLink new metaObject: self class;						selector: #assertMethod;					control: #after.						(GPExamples>>#example) methodNode link: gplink.		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: GPCounter counter = 1.! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 3/28/2007 11:43'!testReifyMethodArg1		gplink := GPLink new metaObject: self class;						selector: #assertMethodArg1:;					control: #before;					arguments: #(arg1).						(GPExamples>>#examplea:b:) methodNode link: gplink.		GPCounter reset.	self assert: ((GPExamples new examplea: 5 b: 6) = 11).	self assert: (GPCounter counter = 1).		gplink uninstall.! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 2/19/2007 22:46'!testReifyMethodArguments		gplink := GPLink new metaObject: self class;						selector: #assertMethodArgs:;					control: #before;					arguments: #(arguments).						(GPExamples>>#examplea:b:) methodNode link: gplink.		GPCounter reset.	self assert: ((GPExamples new examplea: 5 b: 6) = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 3/28/2007 11:20'!testReifyMethodBefore		gplink := GPLink new metaObject: self class;						selector: #assertMethod;					control: #before.						(GPExamples>>#example) methodNode link: gplink.		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: GPCounter counter = 1.! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 2/19/2007 22:46'!testReifyMethodContext		gplink := GPLink new metaObject: self class;						selector: #assertContext:;					control: #before;					arguments: #(context).						(GPExamples>>#example) methodNode link: gplink.		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 2/19/2007 22:46'!testReifyMethodControl		gplink := GPLink new metaObject: self class;						selector: #assertControl:;					control: #before;					arguments: #(control).						(GPExamples>>#example) methodNode link: gplink.		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 3/28/2007 14:34'!testReifyMethodLink		gplink := GPLink new metaObject: self class;						selector: #assertLink:;					control: #before;					arguments: #(link).						(GPExamples>>#example) methodNode link: gplink.		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 2/19/2007 22:47'!testReifyMethodNode		gplink := GPLink new metaObject: self class;						selector: #assertMethod:;					control: #after;					arguments: #(node).						(GPExamples>>#example) methodNode link: gplink.		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 2/19/2007 22:47'!testReifyMethodOperation		gplink := GPLink new metaObject: self class;						selector: #assertOperationMethod:;					control: #before;					arguments: #(operation).						(GPExamples>>#examplea:b:) methodNode link: gplink.		GPCounter reset.	self assert: ((GPExamples new examplea: 5 b: 6) = 11).	self assert: GPCounter counter = 1.! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 2/19/2007 22:47'!testReifyMethodOperationManyArguments		gplink := GPLink new metaObject: self class;						selector: #assertOperationMethod:;					control: #before;					arguments: #(operation).						(GPExamples>>#examplea:b:c:d:e:) methodNode link: gplink.		GPCounter reset.	self assert: ((GPExamples new examplea: 1 b: 1 c: 1 d: 1 e: 1) = 5).	self assert: GPCounter counter = 1.! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 3/9/2007 09:51'!testReifyMethodOperationReplace		gplink := GPLink new metaObject: self class;						selector: #assertOperationMethod:;					control: #instead;					arguments: #(operation).						(GPExamples>>#examplea:b:) methodNode link: gplink.		GPCounter reset.	GPExamples new examplea: 5 b: 6.	self assert: GPCounter counter = 1.! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 3/9/2007 09:51'!testReifyMethodOperationReplaceCondition		gplink := GPLink new metaObject: self class;						selector: #assertOperationMethod:;					control: #instead;					arguments: #(operation);					condition: [true].								(GPExamples>>#examplea:b:) methodNode link: gplink.		GPCounter reset.	GPExamples new examplea: 5 b: 6.	self assert: GPCounter counter = 1.! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 3/9/2007 09:51'!testReifyMethodOperationReplaceConditionFalse		gplink := GPLink new metaObject: self class;						selector: #assertOperationMethod:;					control: #instead;					arguments: #(operation);					condition: [false].								(GPExamples>>#examplea:b:) methodNode link: gplink.		GPCounter reset.	GPExamples new examplea: 5 b: 6.	self assert: GPCounter counter = 0.! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 2/19/2007 22:49'!testReifyMethodReceiver		gplink := GPLink new metaObject: self class;						selector: #assertReceiverForMethod:;					control: #before;					arguments: #(receiver).						(GPExamples>>#example) methodNode link: gplink.		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 2/19/2007 22:49'!testReifyMethodSelector		gplink := GPLink new metaObject: self class;						selector: #assertSelectorMethod:;					control: #before;					arguments: #(selector).						(GPExamples>>#example) methodNode link: gplink.		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 2/20/2007 09:13'!testReifyMethodSelf		gplink := GPLink new metaObject: self class;						selector: #assertSelf:;					control: #before;					arguments: #(object).						(GPExamples>>#example) methodNode link: gplink.		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 2/19/2007 22:50'!testReifyMethodSender		gplink := GPLink new metaObject: self class;						selector: #assertSenderForMethod:;					control: #before;					arguments: #(sender).						(GPExamples>>#example) methodNode link: gplink.		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - methods' stamp: 'md 2/19/2007 22:50'!testReifyMethodSenderSelector		gplink := GPLink new metaObject: self class;						selector: #assertSenderSelectorForMethod:;					control: #before;					arguments: #(senderselector).						(GPExamples>>#example) methodNode link: gplink.		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: (GPCounter counter = 1).! !!GeppettoTest methodsFor: 'testing - result' stamp: 'md 3/10/2007 14:05'!testReifyMethodResult	"gplink := GPLink new metaObject: [:result | GPCounter inc. self assert: result = true];					control: #after.		(GPExamples>>#example) methodNode link: gplink.		GPCounter reset.	self assert: (GPExamples new example = 11).	self assert: GPCounter counter = 1."! !!GeppettoTest methodsFor: 'testing - result' stamp: 'md 9/1/2007 11:16'!testReifySendResult	gplink := GPLink new metaObject: [:result | GPCounter inc. self assert: result = true];					control: #after.		(GPExamples>>#exampleSend2) sends do: [:node | node link: gplink].		GPCounter reset.	self assert: (GPExamples new exampleSend2).	self assert: GPCounter counter = 1. ! !!GeppettoTest methodsFor: 'testing - examples' stamp: 'md 2/21/2007 09:25'!testStatementCounter		| nodes |		nodes := OrderedCollection new.	gplink := GPCounter link.		(GPExamples>>#example)  statements do: [:node |		node isAssignment ifTrue: [			nodes add: node.			node link: gplink 		]	].		nodes do: [:node | 		self assert: (node hasLink: gplink).	].	self assert: (GPExamples new example = 11).	self assert: gplink metaObject count = 2.! !!GeppettoTest methodsFor: 'testing - examples' stamp: 'md 2/21/2007 09:16'!testStatementCounterAfter	gplink := GPCounter link control: #after.		(GPExamples>>#example) statements do: [:node |		node isAssignment ifTrue: [node link: gplink]].		self assert: (GPExamples new example = 11).	self assert: gplink metaObject count = 2.! !!GeppettoTest methodsFor: 'testing - examples' stamp: 'md 2/21/2007 09:23'!testStatementCounterBefore		gplink := GPCounter link.	(GPExamples>>#example) assignments do: [:node | node link: gplink].		self assert: (GPExamples new example = 11).	self assert: gplink metaObject count = 2.! !!GeppettoTest methodsFor: 'testing - examples' stamp: 'md 3/9/2007 09:51'!testStatementSimpleReplace		gplink := GPLink new metaObject: self class;						selector: #return77;					control: #instead.   		(GPExamples>>#example) sends do: [:node | node link: gplink].	self assert: (GPExamples new example = 77).! !!GeppettoTest methodsFor: 'testing - multiple' stamp: 'md 2/26/2007 16:54'!testTwoLinks	| link1 link2 |		link1 := GPLink new metaObject: self class;						selector: #csend:to:withArguments:;					control: #before;					arguments: #(selector receiver arguments).   						link2 := GPLink new metaObject: self class;						selector: #csend:to:withArguments:;					control: #before;					arguments: #(selector receiver arguments).   		(GPExamples>>#exampleSend) sends do: [:node | node link: link1; link: link2].	GPCounter reset.	self assert: (GPExamples new exampleSend).	self assert: (GPCounter counter = 2).		link1 uninstall. link2 uninstall. ! !!GeppettoTest methodsFor: 'testing - multiple' stamp: 'md 2/26/2007 16:54'!testTwoLinksAfter	| link1 link2 |		link1 := GPLink new metaObject: self class;						selector: #csend:to:withArguments:;					control: #after;					arguments: #(selector receiver arguments).   						link2 := GPLink new metaObject: self class;						selector: #csend:to:withArguments:;					control: #after;					arguments: #(selector receiver arguments).   	(GPExamples>>#exampleSend2) sends do: [:node | node link: link1; link: link2].	GPCounter reset.	self assert: (GPExamples new exampleSend2).	self assert: (GPCounter counter = 2).		link1 uninstall. link2 uninstall. ! !!GeppettoTest methodsFor: 'testing - multiple' stamp: 'md 2/26/2007 16:54'!testTwoLinksAfter2	| link1 link2 |		link1 := GPLink new metaObject: self class;						selector: #csend:to:withArguments:;					control: #after;					arguments: #(selector receiver arguments).   						link2 := GPLink new metaObject: self class;						selector: #csend:to:withArguments:;					control: #after;					arguments: #(selector receiver arguments).   	(GPExamples>>#exampleSend2) sends do: [:node | node link: link2; link: link1].	GPCounter reset.	self assert: (GPExamples new exampleSend2).	self assert: (GPCounter counter = 2).		link1 uninstall. link2 uninstall. ! !!GeppettoTest methodsFor: 'testing - multiple' stamp: 'md 3/9/2007 10:04'!testTwoLinksAfterReplace	| link1 link2 |		link1 := GPLink new metaObject: self class;						selector: #csend:to:withArguments:;					control: #after;					arguments: #(selector receiver arguments).   						link2 := GPLink new metaObject: self class;						selector: #send:to:withArguments:;					control: #instead;					arguments: #(selector receiver arguments).   	(GPExamples>>#exampleSend2) sends do: [:node | node link: link1; link: link2].	GPCounter reset.	self assert: (GPExamples new exampleSend2).	self assert: (GPCounter counter = 2).		link1 uninstall. link2 uninstall. ! !!GeppettoTest methodsFor: 'testing - multiple' stamp: 'md 3/9/2007 10:04'!testTwoLinksAfterReplace2	| link1 link2 |		link1 := GPLink new metaObject: self class;						selector: #csend:to:withArguments:;					control: #after;					arguments: #(selector receiver arguments).   						link2 := GPLink new metaObject: self class;						selector: #send:to:withArguments:;					control: #instead;					arguments: #(selector receiver arguments).   	(GPExamples>>#exampleSend2) sends do: [:node | node link: link2; link: link1].	GPCounter reset.	self assert: (GPExamples new exampleSend2).	self assert: (GPCounter counter = 2).			link1 uninstall. link2 uninstall. ! !!GeppettoTest methodsFor: 'testing - multiple' stamp: 'md 3/9/2007 10:04'!testTwoLinksBeforeReplace	| link1 link2 |		link1 := GPLink new metaObject: self class;						selector: #csend:to:withArguments:;					control: #before;					arguments: #(selector receiver arguments).   						link2 := GPLink new metaObject: self class;						selector: #send:to:withArguments:;					control: #instead;					arguments: #(selector receiver arguments).   	(GPExamples>>#exampleSend) sends do: [:node | node link: link1; link: link2].	GPCounter reset.	self assert: (GPExamples new exampleSend).	self assert: (GPCounter counter = 2).		link1 uninstall. link2 uninstall ! !!GeppettoTest methodsFor: 'testing - multiple' stamp: 'md 3/9/2007 10:04'!testTwoLinksReplace	| link1 link2 |		link1 := GPLink new metaObject: self class;						selector: #csend:to:withArguments:;					control: #instead;					arguments: #(selector receiver arguments).   						link2 := GPLink new metaObject: self class;						selector: #csend:to:withArguments:;					control: #instead;					arguments: #(selector receiver arguments).   	"for now"	self should: [(GPExamples>>#exampleSend2) sends do: [:node | node link: link1; link: link2]]		raise: Error		whoseDescriptionIncludes: 'not yet'		description: 'Multipe replace not supported '.			link1 uninstall. link2 uninstall ! !!GeppettoTest methodsFor: 'as yet unclassified' stamp: 'md 11/3/2007 19:44'!expectedFailures	^#(testReifySendResult testTwoLinksAfter testTwoLinksAfter2 testTwoLinksAfterReplace  testTwoLinksAfterReplace2 testTwoLinksBeforeReplace)! !!GeppettoTest class methodsFor: 'examples' stamp: 'test 10/31/2007 14:10'!assertContext: aContext	GPCounter inc.	self assert: (aContext isKindOf: ContextPart).! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/8/2007 21:15'!assertControl: aSymbol	GPCounter inc.	self assert: (aSymbol = #before).! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/23/2007 17:01'!assertGlobal: aNode	GPCounter inc.	self assert: (aNode isKindOf: RBVariableNode). ! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/8/2007 17:58'!assertLink: link	GPCounter inc.	self assert: (link isKindOf: GPLink).	self assert: (link arguments = #(link)).! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/12/2007 22:19'!assertMethod	GPCounter inc! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/12/2007 23:36'!assertMethod: aMethodNode	GPCounter inc.	self assert: (aMethodNode isKindOf: RBMethodNode)! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/13/2007 11:52'!assertMethodArg1: anObject	GPCounter inc.	self assert: (anObject = 5)! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/13/2007 12:05'!assertMethodArgs: anArray	GPCounter inc.	self assert: (anArray first = 5)! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/9/2007 11:01'!assertName: aName	GPCounter inc.	self assert: (aName = 'i').! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/9/2007 14:00'!assertNode: aNode	GPCounter inc.	self assert: (aNode isKindOf: RBProgramNode).! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/15/2007 10:06'!assertOperationMethod: anOperation	GPCounter inc.	self assert: (anOperation isKindOf: GPMethod).	self assert: (anOperation arguments class = Array).	self assert: (anOperation receiver isKindOf: GPExamples).! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/13/2007 10:26'!assertReceiverForMethod: anObject	GPCounter inc.	self assert: (anObject isKindOf: GPExamples) ! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/13/2007 10:30'!assertSelectorMethod: aSymbol	GPCounter inc.	self assert: (aSymbol = #example).! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/13/2007 10:07'!assertSelf: aContext	GPCounter inc.	self assert: (aContext isKindOf: GPExamples).! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/13/2007 10:57'!assertSenderForMethod: anObject	GPCounter inc.	self assert: (anObject isKindOf: GeppettoTest) ! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/8/2007 21:24'!assertSenderSelector: aSymbol	GPCounter inc.	self assert: (aSymbol isSymbol).! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/15/2007 10:45'!assertSenderSelectorForMethod: aSymbol	GPCounter inc.	self assert: (aSymbol = #testReifyMethodSenderSelector).! !!GeppettoTest class methodsFor: 'examples' stamp: 'dr 9/21/2007 11:42'!assertVariable: aNode	GPCounter inc.	self assert: (aNode isKindOf: RBVariableNode). ! !!GeppettoTest class methodsFor: 'examples' stamp: 'test 10/31/2007 14:10'!assertVariable: aNode value: anInteger context: aContext	GPCounter inc.	self assert: (aNode isKindOf: RBVariableNode). 	self assert: anInteger = 5.	self assert: (aContext isKindOf: ContextPart).! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 3/1/2007 13:41'!checkArg: array1 arg: array2	GPCounter inc.	self assert:  array1 == array2.! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 3/9/2007 15:57'!continue: aContinuation	GPCounter inc. 	aContinuation value: 11.! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/12/2007 20:50'!csend: selector to: receiver withArguments: argument	GPCounter inc.! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/12/2007 13:48'!deactivate: aLink	GPCounter inc.	aLink condition: false.	! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/7/2007 17:18'!iVarAt: offset in: object	GPCounter inc.	^object instVarAt: offset.! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/7/2007 17:21'!iVarAt: offset in: object to: newvalue	GPCounter inc.	^object instVarAt: offset put: newvalue! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/7/2007 17:18'!iVarNamed: varname in: object	GPCounter inc.	^object instVarNamed: varname.! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/7/2007 18:21'!iVarNamed: varname in: object to: newvalue	GPCounter inc.	^object instVarNamed: varname put: newvalue! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/8/2007 15:33'!operation: anOperation	GPCounter inc.	^anOperation value.! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/20/2007 16:05'!operationProceed: anOperation context: aContext	GPCounter inc.	anOperation value.	thisContext swapSender: aContext.	! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/7/2007 12:49'!return77	^77! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/7/2007 17:18'!send: selector to: receiver with: argument	GPCounter inc.	^receiver perform: selector with: argument! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/8/2007 11:34'!send: selector to: receiver withArguments: argument	GPCounter inc.	^receiver perform: selector withArguments: argument! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/8/2007 14:51'!tempVarAt: offtset in: aContext	GPCounter inc.	^aContext tempAt: offtset.! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/8/2007 14:51'!tempVarAt: offtset in: aContext put: newValue	GPCounter inc.	^aContext tempAt: offtset put: newValue.! !!GeppettoTest class methodsFor: 'examples' stamp: 'md 2/26/2007 16:53'!uninstall: aLink	GPCounter inc.	aLink uninstall.! !!GlobalScope methodsFor: 'lookup' stamp: 'ajh 2/26/2003 13:42'!classEncoding	"subclass responsibility, default is nil"	^ nil! !!GlobalScope methodsFor: 'lookup' stamp: 'md 2/21/2006 14:11'!lookupVar: name	"subclass responsibility, default is to look up global vars"	(ProtoObject bindingOf: name asSymbol) ifNotNilDo: [:assoc | 		^ GlobalVar new assoc: assoc; scope: self].	^ nil! !!GlobalScope methodsFor: 'lookup' stamp: 'ajh 3/12/2003 12:10'!possibleVarsFor: name continued: listOrNil	"subclass responsibility, default is to look up global vars"	name first isLowercase ifTrue: [^ listOrNil].	^ ProtoObject possibleVariablesFor: name continuedFrom: listOrNil! !!GlobalScope methodsFor: 'lookup' stamp: 'md 2/21/2006 14:11'!rawVar: name	"subclass responsibility, default is to look up global vars"	(ProtoObject bindingOf: name asSymbol) ifNotNilDo: [:assoc | 		^ GlobalVar new assoc: assoc; scope: self].	^ nil! !!GlobalScope commentStamp: 'ajh 3/24/2003 21:52' prior: 0!When the class is not known, use me to at least find global vars.!!GlobalVar methodsFor: 'initializing' stamp: 'ajh 2/26/2003 17:31'!assoc: anAssociation	assoc _ anAssociation! !!GlobalVar methodsFor: 'emitting' stamp: 'md 10/4/2005 17:23'!emitStore: methodBuilder from: refScope	self flag: #fixme.	methodBuilder storeIntoLiteralVariable: assoc.	"methodBuilder pushLiteral: assoc.	methodBuilder send: #privSetInHolder:."! !!GlobalVar methodsFor: 'emitting' stamp: 'md 7/9/2005 22:15'!emitValue: methodBuilder from: refScope	methodBuilder pushLiteralVariable: assoc.! !!GlobalVar methodsFor: 'accessing' stamp: 'ajh 7/8/2004 16:25'!isGlobal	^ true! !!GlobalVar methodsFor: 'accessing' stamp: 'ajh 7/2/2004 14:15'!name	^ assoc name! !!GlobalVar methodsFor: 'accessing' stamp: 'ms 8/5/2006 14:35'!value	^assoc value! !!GlobalVar methodsFor: '*geppetto2' stamp: 'md 2/24/2007 09:59'!assoc	^assoc! !!GlobalVar commentStamp: 'ajh 3/24/2003 21:53' prior: 0!I am a global, pool, or class variable.!!IRAccess methodsFor: 'testing' stamp: 'md 6/13/2005 12:01'!isRead	^self isStore not! !!IRAccess methodsFor: 'accessing' stamp: 'md 6/12/2005 17:56'!number	^ number! !!IRAccess methodsFor: 'accessing' stamp: 'md 6/12/2005 17:57'!number: num	number _ num! !!IRBlockReturnTop methodsFor: 'interpret' stamp: 'md 10/8/2004 16:04'!executeOn: interpreter	interpreter blockReturnTop.! !!IRBlockReturnTop methodsFor: 'testing' stamp: 'md 10/8/2004 16:04'!isBlockReturnTop	^true.! !!IRBlockReturnTop methodsFor: 'testing' stamp: 'md 10/21/2004 18:38'!isRemote	^false.! !!IRBlockReturnTop methodsFor: 'accessing' stamp: 'md 10/8/2004 16:04'!successor: anObject	successor := anObject. ! !!IRBlockReturnTop methodsFor: 'accessing' stamp: 'md 10/8/2004 16:04'!successorSequences	"sent to last instruction in sequence which is expected to be a jump and return instruction"	^  { successor }! !!IRBuilder methodsFor: 'private' stamp: 'ajh 3/13/2003 13:20'!add: instr	"Associate instr with current parse node or byte range"	instr sourceNode: self sourceNode.	instr bytecodeIndex: self sourceByteIndex.	^ currentSequence add: instr! !!IRBuilder methodsFor: 'private' stamp: 'md 7/11/2005 22:20'!addLiteral: aSymbol	ir addLiteral: aSymbol! !!IRBuilder methodsFor: 'private' stamp: 'md 7/12/2005 00:21'!addLiterals: aSymbol	ir addLiterals: aSymbol! !!IRBuilder methodsFor: 'private' stamp: 'ms 6/26/2007 02:48'!initialize	ir := IRMethod new.	tempMap := Dictionary new.	jumpAheadStacks := IdentityDictionary new.	jumpBackTargetStacks := IdentityDictionary new.	sourceMapNodes := OrderedCollection new.	"stack"	"Leave an empty sequence up front (guaranteed not to be in loop)"	ir  startSequence:((IRSequence new  orderNumber:0)  method:ir).	currentSequence := (IRSequence new  orderNumber:1)  method:ir.	ir startSequence  add:(IRJump new  destination: currentSequence)! !!IRBuilder methodsFor: 'private' stamp: 'md 9/26/2005 13:09'!startNewSequence	"End current instruction sequence and start a new sequence to add instructions to.  If ending block just falls through to new block then add an explicit jump to it so they stay linked"	| newSequence |	currentSequence isEmpty  ifTrue:[^ self].	"block is still empty, continue using it"	newSequence _ IRSequence new  orderNumber:currentSequence orderNumber  +1.	newSequence  method:ir.	currentSequence last isJumpOrReturn 		 ifFalse:[self  add:(IRJump new  destination:newSequence)].	currentSequence _ newSequence! !!IRBuilder methodsFor: 'decompiling' stamp: 'ajh 6/22/2003 14:44'!addJumpBackTarget: label to: sequence	(jumpBackTargetStacks at: label ifAbsentPut: [OrderedCollection new])		addLast: sequence! !!IRBuilder methodsFor: 'decompiling' stamp: 'ajh 3/21/2003 01:48'!testJumpAheadTarget: label	jumpAheadStacks at: label ifPresent: [:stack |		[stack isEmpty] whileFalse: [self jumpAheadTarget: label]	]! !!IRBuilder methodsFor: 'initialize' stamp: 'md 11/16/2004 15:18'!addTemp: tempKey	self addTemps: {tempKey}! !!IRBuilder methodsFor: 'initialize' stamp: 'md 7/11/2005 23:53'!addTemps: newKeys	| keys i new |	keys := ir tempKeys.	i := keys size - 1. "zero-based (index 0 equals receiver)"	new := OrderedCollection new.	newKeys do: [:key |		tempMap at: key ifAbsentPut: [			new add: key.			i := i + 1]	].	ir tempKeys: keys, new.! !!IRBuilder methodsFor: 'initialize' stamp: 'ajh 6/25/2004 11:24'!numRargs: n	ir numRargs: n.! !!IRBuilder methodsFor: 'initialize' stamp: 'ajh 3/10/2003 14:10'!primitiveNode: primNode	ir primitiveNode: primNode! !!IRBuilder methodsFor: 'instr - old blocks' stamp: 'md 9/26/2005 13:09'!blockReturnTop	| retInst newSequence |	retInst _ IRInstruction blockReturnTop.	self  add:retInst.	newSequence _ IRSequence new  orderNumber:currentSequence orderNumber  +1.	newSequence  method:ir.	currentSequence last isJumpOrReturn 		 ifFalse:[self  add:(IRJump new  destination:newSequence)].	currentSequence _ newSequence.	retInst  successor:currentSequence! !!IRBuilder methodsFor: 'instr - old blocks' stamp: 'md 10/8/2004 15:59'!jumpOverBlockTo: labelSymbol	"Conditional jump to the sequence that will be created when jumpAheadTarget: labelSymbol is sent to self.  This and its corresponding target is only good for one use.  Other jumpAheadTo:... with the same label will be put on a stack and superceed existing ones until its jumpAheadTarget: is called."	| instr |	"jumpAheadTarget: label will pop this and replace destination with its basic block"	(jumpAheadStacks at: labelSymbol ifAbsentPut: [OrderedCollection new])		addLast: (instr _ self add: (IRJumpOverBlock new)).	self startNewSequence.	instr blockSequence: currentSequence.! !!IRBuilder methodsFor: 'accessing' stamp: 'md 10/11/2004 15:19'!currentSequence	^currentSequence! !!IRBuilder methodsFor: 'accessing' stamp: 'md 7/10/2005 22:37'!properties: aDict	ir properties: aDict! !!IRBuilder methodsFor: 'results' stamp: 'ajh 3/10/2003 15:51'!ir	^ ir! !!IRBuilder methodsFor: 'instructions' stamp: 'md 2/27/2005 17:19'!jumpAheadTarget: labelSymbol	"Pop latest jumpAheadTo: with this labelSymbol and have it point to this new instruction sequence"	| jumpInstr |	self startNewSequence.	jumpInstr := (jumpAheadStacks at: labelSymbol ifAbsent: [			self error: 'Missing jumpAheadTo: ', labelSymbol printString]) removeLast.	jumpInstr destination: currentSequence.! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 6/22/2003 14:44'!jumpAheadTo: labelSymbol	"Jump to the sequence that will be created when jumpAheadTarget: labelSymbol is sent to self.  This is and its corresponding target is only good for one use.  Other jumpAheadTo: with the same label will be put on a stack and superceed existing ones until its jumpAheadTarget: is called."	"jumpAheadTarget: label will pop this and replace destination with its basic block"	(jumpAheadStacks at: labelSymbol ifAbsentPut: [OrderedCollection new])		addLast: (self add: IRJump new).	self startNewSequence.! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 6/22/2003 14:44'!jumpAheadTo: labelSymbol if: boolean	"Conditional jump to the sequence that will be created when jumpAheadTarget: labelSymbol is sent to self.  This and its corresponding target is only good for one use.  Other jumpAheadTo:... with the same label will be put on a stack and superceed existing ones until its jumpAheadTarget: is called."	| instr |	"jumpAheadTarget: label will pop this and replace destination with its basic block"	(jumpAheadStacks at: labelSymbol ifAbsentPut: [OrderedCollection new])		addLast: (instr _ self add: (IRJumpIf new boolean: boolean)).	self startNewSequence.	instr otherwise: currentSequence.! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 6/22/2003 14:44'!jumpBackTarget: labelSymbol	"Remember this basic block for a future jumpBackTo: labelSymbol.  Stack up remembered targets with same name and remove them from stack for each jumpBackTo: called with same name."	self startNewSequence.	(jumpBackTargetStacks at: labelSymbol ifAbsentPut: [OrderedCollection new])		addLast: currentSequence.! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 6/22/2003 14:25'!jumpBackTo: labelSymbol	"Pop last remembered position with this label and write an unconditional jump to it"	| sequence |	sequence _ (jumpBackTargetStacks at: labelSymbol ifAbsent: [self error: 'Missing jumpBackTarget: ', labelSymbol printString]) removeLast.	self add: (IRJump new destination: sequence).	self startNewSequence.! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 3/10/2003 01:09'!popTop	self add: IRInstruction popTop! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:38'!pushBlock: irMethod	self add: (IRInstruction pushBlock: irMethod)! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:38'!pushBlockMethod: irMethod	self add: (IRInstruction pushBlockMethod: irMethod)! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 3/10/2003 01:09'!pushDup	self add: IRInstruction pushDup! !!IRBuilder methodsFor: 'instructions' stamp: 'md 6/13/2005 13:59'!pushInstVar: instVarIndex	"Receiver must be on top"	self add: (IRInstruction pushInstVar: instVarIndex)."	self pushLiteral: instVarIndex.	self send: #privGetField:."! !!IRBuilder methodsFor: 'instructions' stamp: 'md 7/5/2005 15:52'!pushLiteral: object		self add: (IRInstruction pushLiteral: object)! !!IRBuilder methodsFor: 'instructions' stamp: 'md 7/5/2005 15:52'!pushLiteralVariable: object		self add: (IRInstruction pushLiteralVariable: object)! !!IRBuilder methodsFor: 'instructions' stamp: 'md 4/21/2005 11:38'!pushReceiver	self add: (IRInstruction pushReceiver)! !!IRBuilder methodsFor: 'instructions' stamp: 'ms 6/15/2007 11:30'!pushTemp: key	| index |	index := tempMap at: key.	self add: (IRInstruction pushTemp: index)! !!IRBuilder methodsFor: 'instructions' stamp: 'md 4/21/2005 12:06'!pushThisContext	self add: (IRInstruction pushThisContext)! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 6/26/2004 13:47'!pushThisEnv	self add: (IRInstruction pushTemp: -1)! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 3/15/2003 01:55'!remoteReturn	self add: IRInstruction remoteReturn.	self startNewSequence.! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 3/15/2003 01:55'!returnTop	self add: IRInstruction returnTop.	self startNewSequence.! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 3/10/2003 01:09'!send: selector	self add: (IRInstruction send: selector)! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 3/10/2003 01:09'!send: selector toSuperOf: behavior	self add: (IRInstruction send: selector toSuperOf: behavior)! !!IRBuilder methodsFor: 'instructions' stamp: 'md 6/13/2005 14:02'!storeInstVar: instVarIndex	"receiver must be on top with new field value underneath"	self add: (IRInstruction storeInstVar: instVarIndex).	"self pushLiteral: instVarIndex.	self send: #privStoreIn:field:."! !!IRBuilder methodsFor: 'instructions' stamp: 'md 7/5/2005 15:52'!storeIntoLiteralVariable: object		self add: (IRInstruction storeIntoLiteralVariable: object)! !!IRBuilder methodsFor: 'instructions' stamp: 'ms 6/16/2007 20:21'!storeTemp: key	| index |	index := tempMap at: key.	self add: (IRInstruction storeTemp: index)! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 6/26/2004 13:48'!storeThisEnv	self add: (IRInstruction storeTemp: -1)! !!IRBuilder methodsFor: 'mapping' stamp: 'ajh 3/13/2003 13:17'!mapToByteIndex: index	"decompiling"	sourceMapByteIndex _ index! !!IRBuilder methodsFor: 'mapping' stamp: 'ajh 6/22/2003 14:45'!mapToNode: object	"new instructions will be associated with object"	sourceMapNodes addLast: object! !!IRBuilder methodsFor: 'mapping' stamp: 'ajh 6/22/2003 14:25'!popMap	sourceMapNodes removeLast! !!IRBuilder methodsFor: 'mapping' stamp: 'ajh 3/13/2003 13:19'!sourceByteIndex	"decompiling"	^ sourceMapByteIndex! !!IRBuilder methodsFor: 'mapping' stamp: 'ajh 6/22/2003 21:03'!sourceNode	^ sourceMapNodes isEmpty		ifTrue: [nil]		ifFalse: [sourceMapNodes last]! !!IRBuilder commentStamp: 'kwl 5/12/2006 18:29' prior: 0!I provide a simple interface for constructing an IRMethod.  For example, to create an ir method that compares first instVar to first arg and returns 'yes' or 'no' (same example as in BytecodeGenerator), do:	IRBuilder new		numRargs: 2;		addTemps: #(self a z);		"rcvr, arg, & extra temp (not used here)"		pushTemp: #self;		pushInstVar: 1;		pushTemp: #a;		send: #>;		jumpAheadTo: #else if: false;		pushLiteral: 'yes';		returnTop;		jumpAheadTarget: #else;		pushLiteral: 'no';		returnTop;		irSending #compiledMethod to an ir method will generate its compiledMethod.  Sending #methodNode to it will decompile to its parse tree.!!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/15/2007 00:07'!expectedFailures	^ #()! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:50'!isThisEverCalled	"Redefinition for testing the #send:toSuperOf:"! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:37'!testDup	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: 3;		pushDup;				send: #=;				returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = true).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:46'!testInstVar	| irMethod aCompiledMethod irBuilder |	irBuilder := IRBuilder new		numRargs: 1;		addTemps: #(self).		"receiver and args declarations"	Preferences compileBlocksAsClosures ifTrue:[		irBuilder pushReceiver].	irBuilder		pushInstVar: 1.	Preferences compileBlocksAsClosures ifTrue:[		irBuilder pushReceiver].	irMethod := irBuilder		pushInstVar: 2;		send: #+;				returnTop;		ir.	aCompiledMethod := irMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: (3@4) arguments: #() ) = 7).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:51'!testJumpAheadTo	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushTemp: #self	;					jumpAheadTo: #end;		pushLiteral: 3;		jumpAheadTarget: #end;					returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = nil).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:35'!testJumpAheadToIf	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushTemp: #self	;		pushLiteral: true;				"jumpAhaedTo pop the first element of thz stack"		jumpAheadTo: #end if: true;		pushLiteral: 3;		jumpAheadTarget: #end;					returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = nil).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:51'!testJumpBackTo	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushTemp: #self	;		pushLiteral: false;		jumpBackTarget: #begin;				"jumpAhaedTo pop the first element of the stack"		jumpAheadTo: #end if: true;		pushLiteral: true;		jumpBackTo: #begin;		jumpAheadTarget: #end;					returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = nil).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:35'!testLiteralArray	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: #(test 4 you); 			returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = #(test 4 you)).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:36'!testLiteralBoolean	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: true; 			returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = true).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:36'!testLiteralCharacter	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: $e; 			returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = $e).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:37'!testLiteralFloat	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: 2.0; 			returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2.0).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:37'!testLiteralInteger	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: 2; 			returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:51'!testLiteralNil	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: nil; 			returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: 4 arguments: #() ) = nil).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:51'!testLiteralString	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: 'hello'; 			returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = 'hello').	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:52'!testLiteralSymbole	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: #you; 			returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = #you).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:52'!testLiteralVariableClass	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteralVariable: Object binding;			returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = Object).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:52'!testLiteralVariableClassVariable	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteralVariable: (DateAndTime bindingOf: #LocalTimeZone); 			returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = DateAndTime localTimeZone).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:52'!testLiteralVariableGlobale	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteralVariable: (Smalltalk associationAt: #Smalltalk);			returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = Smalltalk).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/14/2007 23:52'!testPopTop	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushTemp: #self	;					pushLiteral: false;		popTop;				returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = nil).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:33'!testPushReceiver	| iRMethod aCompiledMethod receiver |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushReceiver;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.		receiver :=  (5@8).	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: receiver arguments: #() ) == receiver).! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:33'!testPushTempArgument	| iRMethod aCompiledMethod  |	iRMethod := IRBuilder new		numRargs: 3;		addTemps: #(self a b);		"receiver and args declarations"		pushTemp: #a;		pushTemp: #b;		send: #+;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #(2 8) ) = 10).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:33'!testPushTempSelf	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushTemp: #self;		send: #class;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) == UndefinedObject).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:33'!testPushTempTemp	| iRMethod aCompiledMethod  |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self a);		"receiver and args declarations"			pushTemp: #a;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: 5 arguments: #() ) = nil).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:33'!testPushThisContext	| iRMethod aCompiledMethod  |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self a);		"receiver and args declarations"			pushThisContext;		send: #receiver;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: 5 arguments: #() ) = 5).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/15/2007 00:06'!testPushThisEnv	| iRMethod aCompiledMethod receiver |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushThisContext;		pushLiteral: 5;		pushLiteral: ClosureEnvironment;		pushLiteral: 1;		send: #new:;		send: #privSetInstVar:put:;		pushThisEnv;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	receiver := Object new.		self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: receiver arguments: #()) isKindOf: ClosureEnvironment)	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:41'!testSendSuper	| iRMethod aCompiledMethod  |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"			pushReceiver;		send: #isThisEverCalled toSuperOf: IRBuilderTest;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self should: [(aCompiledMethod valueWithReceiver: (IRBuilderTest new) arguments: #())] raise: Halt.	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:34'!testStorIntoVariable	| iRMethod aCompiledMethod  |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"			pushLiteral: 4;		storeIntoLiteralVariable: (IRBuilderTest bindingOf: #TestToPush);		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     aCompiledMethod valueWithReceiver: nil arguments: #().	self assert: (IRBuilderTest testToPush = 4).	IRBuilderTest testToPush: nil.	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:48'!testStoreTemp	| iRMethod aCompiledMethod  |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self a);		"receiver and args declarations"			pushLiteral: 34;		storeTemp: #a;		popTop;		pushTemp: #a;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = 34).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 5/15/2007 00:03'!testStoreThisEnv	| iRMethod aCompiledMethod  |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self a);		"receiver and args declarations"		pushLiteral: ClosureEnvironment;		pushLiteral: 1;		send: #new:;		storeThisEnv;		pushThisContext;		pushLiteral: 5;		send: #privGetInstVar:;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) isKindOf: ClosureEnvironment).	! !!IRBuilderTest class methodsFor: 'as yet unclassified' stamp: 'ms 7/12/2006 18:43'!testToPush	^TestToPush! !!IRBuilderTest class methodsFor: 'as yet unclassified' stamp: 'ms 7/12/2006 18:43'!testToPush: anObject	TestToPush := anObject! !!IRCChannelFilter methodsFor: 'private' stamp: 'sbw 3/11/2005 09:57'!adjustFilter: aString	| filter |	filter := aString.	(filter beginsWith: '*')		ifFalse: [filter := '*' , filter].	(filter endsWith: '*')		ifFalse: [filter := filter , '*'].^filter! !!IRCChannelFilter methodsFor: 'private' stamp: 'sbw 3/11/2005 09:58'!filterOnName: aCollection 	| filter |	filter := self adjustFilter: self nameFilter.	^ aCollection		select: [:each | filter match: each name]! !!IRCChannelFilter methodsFor: 'private' stamp: 'sbw 3/11/2005 09:58'!filterOnTopic: aCollection 	| filter |	filter := self adjustFilter: self topicFilter.	^ aCollection		select: [:each | filter match: each topic]! !!IRCChannelFilter methodsFor: 'accessing' stamp: 'sbw 3/11/2005 09:33'!doBoth	^ self doTopic		and: [self doName]! !!IRCChannelFilter methodsFor: 'accessing' stamp: 'sbw 3/11/2005 09:26'!doName	^ doName! !!IRCChannelFilter methodsFor: 'accessing' stamp: 'sbw 3/11/2005 09:24'!doName: aBoolean 	doName := aBoolean! !!IRCChannelFilter methodsFor: 'accessing' stamp: 'sbw 3/11/2005 09:33'!doNone	^(self doTopic or: [self doName]) not! !!IRCChannelFilter methodsFor: 'accessing' stamp: 'sbw 3/11/2005 09:26'!doTopic	^ doTopic! !!IRCChannelFilter methodsFor: 'accessing' stamp: 'sbw 3/11/2005 09:24'!doTopic: aBoolean 	doTopic := aBoolean! !!IRCChannelFilter methodsFor: 'accessing' stamp: 'sbw 3/11/2005 19:22'!initialize	self doName: false.	self nameFilter: ''.	self doTopic: false.	self topicFilter: ''! !!IRCChannelFilter methodsFor: 'accessing' stamp: 'sbw 3/11/2005 09:23'!nameFilter	^nameFilter! !!IRCChannelFilter methodsFor: 'accessing' stamp: 'sbw 3/11/2005 09:28'!nameFilter: aString 	nameFilter := aString.	aString isNil ifFalse: [self doName: true]! !!IRCChannelFilter methodsFor: 'accessing' stamp: 'sbw 3/11/2005 14:50'!toggleDoName	self doName: self doName not! !!IRCChannelFilter methodsFor: 'accessing' stamp: 'sbw 3/11/2005 14:50'!toggleDoTopic	self doTopic: self doTopic not! !!IRCChannelFilter methodsFor: 'accessing' stamp: 'sbw 3/11/2005 09:23'!topicFilter	^topicFilter! !!IRCChannelFilter methodsFor: 'accessing' stamp: 'sbw 3/11/2005 09:28'!topicFilter: aString 	topicFilter := aString.		aString isNil		ifFalse: [self doTopic: true]! !!IRCChannelFilter methodsFor: 'process' stamp: 'sbw 3/11/2005 09:42'!filter: aCollection 	| result |	self doNone		ifTrue: [^ aCollection].	self doBoth		ifTrue: [result := self filterOnName: aCollection.			result := self filterOnTopic: result.			^ result].	self doName ifTrue: [^self filterOnName: aCollection].	self doTopic ifTrue: [^self filterOnTopic: aCollection].	^aCollection! !!IRCChannelFilter methodsFor: 'printing' stamp: 'sbw 3/11/2005 19:12'!printOn: aStream 	super printOn: aStream.	aStream cr; nextPutAll: '  name: ' , self doName printString.	self doName		ifTrue: [aStream nextPutAll: '  "' , self nameFilter , '"'].	aStream cr; nextPutAll: '  topic: ' , self doTopic printString.	self doTopic		ifTrue: [aStream nextPutAll: '  "' , self topicFilter , '"']! !!IRCChannelFilter commentStamp: '<historical>' prior: 0!Defines channel list filtering for IRCConnection.  Filtering can be on name, topic or both.!!IRCChannelFilter class methodsFor: 'as yet unclassified' stamp: 'sbw 3/11/2005 09:27'!filterNames: aString 	| model |	model := self new.	model nameFilter: aString.	^ model! !!IRCChannelFilter class methodsFor: 'as yet unclassified' stamp: 'sbw 3/11/2005 09:30'!filterNames: nameString andTopics: topicsString 	| model |	model := self new.	model nameFilter: nameString.	model topicFilter: topicsString.	^ model! !!IRCChannelFilter class methodsFor: 'as yet unclassified' stamp: 'sbw 3/11/2005 09:29'!filterTopics: aString 	| model |	model := self new.	model topicFilter: aString.	^ model! !!IRCChannelFilter class methodsFor: 'as yet unclassified' stamp: 'sbw 3/11/2005 09:25'!noFilter	| model |	model := self new.	^model! !!IRCChannelInfo methodsFor: 'access' stamp: 'sbw 5/13/2004 07:25'!addMember: memberName 	"note that memberName is on the channel. memberName should be given 	in the user's preferred capitalization"	| newMember |	newMember := IRCChannelMember fromString: memberName.	newMember channel: self name.	(members includes: newMember)		ifFalse: [members add: newMember.			self changed: #memberNames]! !!IRCChannelInfo methodsFor: 'access' stamp: 'sbw 5/13/2004 07:25'!addMembers: listOfIRCChannelMembers 	listOfIRCChannelMembers		do: [:each | (members includes: each)				ifFalse: [members add: each]].	self changed: #memberNames.	connection channelMembersLoaded: self! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 10:07'!changeTopic: aText	"attempt to change the topic"	connection sendMessage: (IRCProtocolMessage		command: 'TOPIC'		arguments: (Array with: self name with: aText asString)).	^true! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 09:44'!connection	"return the IRC connection I am watching"	^connection! !!IRCChannelInfo methodsFor: 'access' stamp: 'sbw 5/13/2004 07:26'!memberNames	"names of the clients subscribing to this channel"	^ members collect: [:each | each nick]! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/3/1998 21:28'!name	"name of the channel, in its preferred capitalization"	^name! !!IRCChannelInfo methodsFor: 'access' stamp: 'sbw 5/13/2004 07:27'!removeMember: memberName 	"note that memberName has left (PART-ed or QUIT-ed) the channel"	| member |	member _ self findMember: memberName.	member isNil ifTrue: [^nil].	members		remove: member		ifAbsent: [^ self].	self changed: #memberNames! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/5/1998 00:41'!subscribe: anObject	"add anObject as a subscriber.  anObject must respond to ircMessageRecieved"	subscribers isEmpty ifTrue: [ connection join: name ].	subscribers add: anObject! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/3/1998 21:28'!subscribers	"collection of objects watching for messages on the channel"	^subscribers! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 08:52'!topic	^topic ifNil: ['']! !!IRCChannelInfo methodsFor: 'access' stamp: 'sbw 1/11/2003 08:41'!topic: aString 	topic _ aString.	self changed: #topic! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/5/1998 00:39'!unsubscribe: anObject	"unsubscribe anObject"	subscribers remove: anObject.	subscribers isEmpty ifTrue: [ connection leave: name ].! !!IRCChannelInfo methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:26'!findMember: memberName 	| index |	index _ members				findFirst: [:each | each nick = memberName].	index = 0		ifTrue: [^ nil].	^members at: index.! !!IRCChannelInfo methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:26'!hasMember: memberName 	^(self findMember: memberName) isNil not! !!IRCChannelInfo methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:26'!modeChanged: mode forMemberNamed: aString 	| member |	member _ self findMember: aString.	member isNil		ifTrue: [^ nil].	member modeChanged: mode.	members reSort! !!IRCChannelInfo methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:26'!nickFor: oldName changedTo: newName 	| member |	member _ self findMember: oldName.	member isNil		ifTrue: [^ nil].	member nick: newName! !!IRCChannelInfo methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:27'!operatorIndexes	"Answers an Interval of indexes for members that are operators."	| start stop member |	start _ 0.	stop _ 0.	1 to: members size do: [:index |		member _ members at: index.		member isOperator			ifTrue: [				start _ 1.				stop _ index]			ifFalse: [^Interval from: start to: stop]		].	^ Interval from: start to: stop! !!IRCChannelInfo methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:27'!voicedIndexes	"Answers an Interval of indexes for members that are voiced."	| start stop member |	start _ members				findFirst: [:x | x hasVoice].	stop _ 0.	start = 0		ifFalse: [start				to: members size				do: [:index | 					member _ members at: index.					(member hasVoice and: [member isOperator not])						ifTrue: [stop _ index]						ifFalse: [^ Interval from: start to: stop]]].	^ Interval from: start to: stop! !!IRCChannelInfo methodsFor: 'private-initialization' stamp: 'sbw 5/13/2004 07:26'!initializeName: aString connection: aConnection 	name _ aString.	members _ SortedCollection sortBlock: [:a :b | a < b].	subscribers _ IdentitySet new.	connection _ aConnection! !!IRCChannelInfo methodsFor: 'messages' stamp: 'ls 9/5/1998 00:40'!sendMessage: aString	"send a message on the channel"	connection privmsgFrom: nil  to: name  text: aString! !!IRCChannelInfo commentStamp: '<historical>' prior: 0!Describes the channel information itself.!!IRCChannelInfo class methodsFor: 'instance creation' stamp: 'ls 9/6/1998 20:22'!forChannelNamed: aString  onConnection: connection	"create an instance for the channel with the given name"	^super new initializeName: aString connection: connection! !!IRCChannelListBrowser methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:13'!aboutToBeClosed	connection channelsBrowser: nil.	^ true! !!IRCChannelListBrowser methodsFor: 'as yet unclassified' stamp: 'sbw 3/11/2005 14:24'!channelListDownloadAborted	refreshButton isNil		ifTrue: [^ nil].	refreshButton offColor: IRCClientColors channelListIdle;		 label: self channelListDownloadButtonTag.	self inform: 'Unable to download channels list.  See console.'! !!IRCChannelListBrowser methodsFor: 'as yet unclassified' stamp: 'sbw 3/14/2005 22:04'!channelListDownloadCompleted	refreshButton isNil		ifTrue: [^ nil].	refreshButton offColor: IRCClientColors channelListIdle;		 label: self channelListDownloadButtonTag.	self saveChannelList.	self changed.	self topView isNil		ifFalse: [self topView activate]! !!IRCChannelListBrowser methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:17'!channelListDownloading: count 	refreshButton isNil		ifTrue: [^ nil].	refreshButton label: self channelListDownloadingButtonTag , ' ' , count printString; update: nil! !!IRCChannelListBrowser methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 19:19'!forcePoundSignInChannelName	^ IRCOptionsManagement option: #forceChannelsToHaveLeadingPoundSign! !!IRCChannelListBrowser methodsFor: 'as yet unclassified' stamp: 'sbw 5/23/2004 12:50'!recentChannelUsedByConnection	| result |	result _ connection recentChannelName.	result isNil ifTrue: [result _ '#squeak'].	result isEmpty ifTrue: [result _ '#squeak'].	^result! !!IRCChannelListBrowser methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:15'!removeSelfFromConsole	connection channelsBrowser: nil! !!IRCChannelListBrowser methodsFor: 'as yet unclassified' stamp: 'sbw 3/11/2005 14:12'!requestChannelList	| btns coll |	btns := self myDependents				select: [:m | m isKindOf: self actionButtonClass].	coll := btns				select: [:btn | btn label asString = self channelListDownloadButtonTag].	coll isEmpty		ifFalse: [coll first offColor: IRCClientColors channelListBuilding;				 label: self channelListDownloadingButtonTag].	connection requestChannelList! !!IRCChannelListBrowser methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 19:19'!saveChannelList	| dir fStream fName |	(IRCOptionsManagement option: #saveChannelLists)		ifFalse: [^ self].	dir := ExternalIRCFiles folderForChannelsListOnServerAddress: connection server.	fName := 'channel.list.txt'.	[fStream := dir forceNewFileNamed: fName.	self saveChannelListOn: fStream named: fName]		ensure: [fStream close]! !!IRCChannelListBrowser methodsFor: 'as yet unclassified' stamp: 'sbw 5/24/2004 20:00'!saveChannelListOn: aStream named: aString 	channelList		do: [:channel | aStream nextPutAll: channel name;				 tab;				 nextPutAll: channel numUsers printString;				tab;				 nextPutAll: channel topic;				 cr]		displayingProgress: 'Saving channel information on ' , aString! !!IRCChannelListBrowser methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:15'!specialFunction	self inspect! !!IRCChannelListBrowser methodsFor: 'constants' stamp: 'sbw 3/11/2005 14:11'!actionButtonClass			"PluggableButtonIRCeMorph or PluggableButtonMorph"	^ PluggableButtonIRCeMorph! !!IRCChannelListBrowser methodsFor: 'constants' stamp: 'sbw 3/11/2005 13:33'!buttonSpecs	^ {		{#channelListJoinSelectedButtonTag. #openSelectedChannel. #none. 'Join the channel selected in the channel list.'}. 		{#channelListJoinMenuButtonTag. #openPromptedChannel. #none. 'Join or Create a channel specified in the menu'}. 		{#channelListDownloadButtonTag. #requestChannelList. #none. 'Refresh the channel list'}	}! !!IRCChannelListBrowser methodsFor: 'constants' stamp: 'sbw 3/11/2005 13:31'!channelListDownloadButtonTag	^ 'Refresh'! !!IRCChannelListBrowser methodsFor: 'constants' stamp: 'sbw 5/13/2004 07:17'!channelListDownloadingButtonTag	^'Fetching...'! !!IRCChannelListBrowser methodsFor: 'constants' stamp: 'sbw 3/11/2005 13:32'!channelListJoinMenuButtonTag	^ 'Join Menu'! !!IRCChannelListBrowser methodsFor: 'constants' stamp: 'sbw 3/11/2005 13:33'!channelListJoinSelectedButtonTag	^ 'Join Selected'! !!IRCChannelListBrowser methodsFor: 'constants' stamp: 'sbw 3/12/2005 13:59'!rowHighlightColor	^ IRCClientColors channelListRowHighlight! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'sbw 3/11/2005 17:05'!addActionButtonsToButtonRow: aRow 	| btn getState btnLabel |	self buttonSpecs		do: [:spec | 			btnLabel := self perform: spec first.			getState := spec third.			getState = #none				ifTrue: [getState := nil].			btn := self actionButtonClass						on: self						getState: getState						action: spec second.			Preferences alternativeWindowLook				ifTrue: [btn borderWidth: 2;						 borderColor: #raised].			btn color: Color transparent;				 label: btnLabel;				 useRoundedCorners;				 vResizing: #spaceFill;				 hResizing: #shrinkWrap;				 onColor: Color transparent offColor: IRCClientColors channelListIdle.			aRow addMorphBack: btn.			btn setBalloonText: spec fourth].	self setRefreshButton: aRow! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'sbw 3/11/2005 14:55'!addActionButtonsToWindow: win fractions: fractions offsets: offsets 	| btnRow |	btnRow := self buttonRow.	self addActionButtonsToButtonRow: btnRow.	self addNameFilterControlTo: btnRow.	self addTopicFilterControlTo: btnRow.	win		addMorph: btnRow		fullFrame: (LayoutFrame fractions: fractions offsets: offsets)! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'sbw 3/11/2005 13:41'!addChannelListTo: win fractions: fractions offsets: offsets 	multiColumnMorph := PluggableMultiColumnIRCListMorph				on: self				list: #channelDescriptions				selected: #channelIndex				changeSelected: #channelIndex:				headerStrings: #('Name' '#' 'Channel Topic' ).	multiColumnMorph color: Color white.	multiColumnMorph headerBackColor: Color paleTan muchLighter.	win		addMorph: multiColumnMorph		fullFrame: (LayoutFrame fractions: fractions offsets: offsets)! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'sbw 3/16/2005 20:41'!addNameFilterControlTo: aPane 	| morph |	morph := IRCGUIHelper				entryFieldRowFor: self				tag: 'name:'				backLabel: 'name filter'				textGetter: #nameFilter				textSetter: #nameFilter:				color: Color transparent				tagColumnWidth: 46				tagPad: 20				tagInset: 6.	aPane addMorphBack: morph! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'sbw 3/16/2005 20:41'!addTopicFilterControlTo: aPane 	| morph |	morph := IRCGUIHelper				entryFieldRowFor: self				tag: 'topic:'				backLabel: 'topic filter'				textGetter: #topicFilter				textSetter: #topicFilter:				color: Color transparent				tagColumnWidth: 46				tagPad: 20				tagInset: 6.	aPane addMorphBack: morph! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'fc 1/13/2005 20:34'!buildChannelMenu	| channelMenu |		channelMenuList _ channelMenuList asSet asSortedCollection.	channelMenu _ MenuMorph new defaultTarget: self.		channelMenu addTitle: connection server.	channelMenuList do: [:channel | 		channelMenu add: channel selector: #openChannelNamed: argument: channel].			channelMenu addLine.	channelMenu add: 'Create Channel...' action: #createChannel.	channelMenu balloonTextForLastItem: 'Enter Channel name. Join the channel and add it to the menu.'.	channelMenu addTitle: 'Channels'.	channelMenu  addStayUpItem.	channelMenu color: Color veryVeryLightGray.	^channelMenu	! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'sbw 3/11/2005 18:36'!buildMorphIn: parentMorph 	| buttonHeight horizMargin vertMargin |	buttonHeight := 28.	horizMargin := 12.	vertMargin := 5.	self		addActionButtonsToWindow: parentMorph		fractions: (0 @ 0 corner: 1 @ 0)		offsets: (horizMargin @ vertMargin corner: horizMargin negated @ (vertMargin + buttonHeight)).	self		addChannelListTo: parentMorph		fractions: (0 @ 0 corner: 1 @ 1)		offsets: (horizMargin @ (vertMargin + buttonHeight + vertMargin) corner: horizMargin negated @ vertMargin negated)! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'sbw 3/11/2005 13:59'!buttonRow	| aRow |	aRow := AlignmentMorph newRow beSticky.	aRow color: Color paleTan.	aRow clipSubmorphs: true.	aRow layoutInset: 5 @ 3;		 borderWidth: 0;		 cellInset: 6.	^ aRow! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'sbw 3/11/2005 19:31'!nameFilter	^self channelsFilter nameFilter! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'sbw 3/11/2005 19:42'!nameFilter: aText 	| str |	str := aText string.	self channelsFilter nameFilter = str		ifFalse: [self channelsFilter nameFilter: str.			 self refreshChannelList]! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'sbw 5/13/2004 07:16'!openCapturedView	"We do it inside the console window!!"	| paneName alignMorph |	paneName := self class tabbedPaneName.	alignMorph := AlignmentMorph newColumn beSticky; borderWidth: 0; layoutPolicy: ProportionalLayout new.	alignMorph color: Color paleTan.	self buildMorphIn: alignMorph.	connection gui		addSwapPane: alignMorph		named: paneName		hidden: false		closeable: true		swapModel: self! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'sbw 3/11/2005 14:40'!setRefreshButton: row 	| btns |	btns := row submorphs				select: [:m | m isKindOf: self actionButtonClass].	refreshButton := btns				detect: [:btn | btn actionSelector = #requestChannelList]				ifNone: []! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'sbw 3/11/2005 19:31'!topicFilter	^ self channelsFilter topicFilter! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'sbw 3/11/2005 19:42'!topicFilter: aText 	| str |	str := aText string.	self channelsFilter topicFilter = str		ifFalse: [self channelsFilter topicFilter: str.			 self refreshChannelList]		! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'sbw 5/13/2004 07:14'!windowIsClosing	self removeSelfFromConsole! !!IRCChannelListBrowser methodsFor: 'access' stamp: 'sbw 5/13/2004 07:16'!channelDescriptions	| list topicLimit topicString |	topicLimit := 100.	list := Array new: 3.	1		to: list size		do: [:index | list at: index put: OrderedCollection new].	channelList		do: [:channel | 			(list at: 1)				add: channel name.			(list at: 2)				add: channel numUsers printString.			topicString := channel topic.			topicString size > topicLimit				ifTrue: [topicString := topicString copyFrom: 1 to: topicLimit].			(list at: 3)				add: topicString].	^ list! !!IRCChannelListBrowser methodsFor: 'access' stamp: 'ls 9/4/1998 21:34'!channelIndex	^channelIndex! !!IRCChannelListBrowser methodsFor: 'access' stamp: 'ls 9/4/1998 21:53'!channelIndex: anInteger	channelIndex _ anInteger.	self changed: #channelIndex! !!IRCChannelListBrowser methodsFor: 'access' stamp: 'sbw 3/11/2005 14:07'!channelsFilter	channelsFilter == nil		ifTrue: [self initializeChannelsFilter].	^ channelsFilter! !!IRCChannelListBrowser methodsFor: 'access' stamp: 'sbw 3/11/2005 14:06'!channelsFilter: anIRCChannelFilter	channelsFilter _ anIRCChannelFilter! !!IRCChannelListBrowser methodsFor: 'access' stamp: 'sbw 3/11/2005 14:07'!initializeChannelsFilter	self channelsFilter: IRCChannelFilter noFilter! !!IRCChannelListBrowser methodsFor: 'open channel observer' stamp: 'fc 1/13/2005 20:32'!createChannel	| channelName |	channelName := FillInTheBlank request: 'channel name'.	channelName isEmpty ifTrue: [^self].	channelMenuList add: channelName.	self openChannelNamed: channelName! !!IRCChannelListBrowser methodsFor: 'open channel observer' stamp: 'fc 11/27/2004 19:18'!openChannelNamed: channelName	| observer |	connection connected ifFalse: [		self inform: 'Not connected to any server.'	]	ifTrue: [		observer _ (IRCOptionsManagement option: #tabbedChannelWindows)				ifTrue: [IRCChannelObserver openForChannelNamed: channelName onCaptiveConnection: connection]				ifFalse: [IRCChannelObserver openForChannelNamed: channelName onConnection: connection].		connection addChannelObserver: observer;			recentChannelName: channelName	]! !!IRCChannelListBrowser methodsFor: 'open channel observer' stamp: 'fc 8/16/2004 22:30'!openPromptedChannel	"ActiveWorld addMorph: self buildChannelMenu centeredNear: ActiveHand cursorPoint"		self buildChannelMenu invokeModal! !!IRCChannelListBrowser methodsFor: 'open channel observer' stamp: 'fc 1/13/2005 20:31'!openSelectedChannel	| channelInfo channelName |	channelInfo _ channelList				at: multiColumnMorph getCurrentSelectionIndex				ifAbsent: [^ self].	channelName _ channelInfo name.	channelMenuList add: channelName.	self openChannelNamed: channelName! !!IRCChannelListBrowser methodsFor: 'private-initialization' stamp: 'sbw 3/11/2005 14:07'!initialize: anIRCConnection 	connection := anIRCConnection.	channelList := #().	channelIndex := 0.	sortCriterion := #name.	self initializeChannelsFilter.	anIRCConnection addDependent: self.	self refreshChannelList.	channelMenuList := SortedCollection new: 1.	channelMenuList add: '#squeak'! !!IRCChannelListBrowser methodsFor: 'private' stamp: 'sbw 3/14/2005 21:58'!refreshChannelList	"update the list of channels"	| sortBlock |	channelList := connection filteredChannelList: self channelsFilter.	channelList		ifNil: [channelList := #()].	"sort the channels"	sortCriterion = #name		ifTrue: [sortBlock := [:a :b | a name asIRCLowercase < b name asIRCLowercase]]		ifFalse: [sortBlock := [:a :b | a numUsers = b numUsers						ifTrue: [a name asIRCLowercase < b name asIRCLowercase]						ifFalse: [a numUsers > b numUsers]]].	channelList := channelList asSortedCollection: sortBlock.	channelList := channelList asArray.	channelIndex := 0.	self changed: #channelDescriptions.	self changed: #channelIndex.	self topView isNil		ifFalse: [self topView activate]! !!IRCChannelListBrowser methodsFor: 'private' stamp: 'ls 9/17/1998 07:00'!update: aSymbol	aSymbol == #channelList ifTrue: [		self refreshChannelList ].! !!IRCChannelListBrowser commentStamp: '<historical>' prior: 0!a browser of the list of channels a given connection offers.  Allows users to easily join and create channels.!!IRCChannelListBrowser class methodsFor: 'instance creation' stamp: 'ls 9/4/1998 21:35'!forConnection: connection	^super new initialize: connection! !!IRCChannelListBrowser class methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:13'!openForCaptiveConnection: connection 	^(self forConnection: connection) openCapturedView! !!IRCChannelListBrowser class methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:13'!tabbedPaneName	^'channels list'! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 3/10/2002 22:15'!< anIRCChannelMember 	"Priority is related to operators first, then voiced, then by name."	self isOperator		ifTrue: [anIRCChannelMember isOperator				ifTrue: [^ self nick asIRCLowercase < anIRCChannelMember nick asIRCLowercase]				ifFalse: [^ true]].	anIRCChannelMember isOperator		ifTrue: [^ false].	self hasVoice		ifTrue: [anIRCChannelMember hasVoice				ifTrue: [^ self nick asIRCLowercase < anIRCChannelMember nick asIRCLowercase]				ifFalse: [^ true]].	anIRCChannelMember hasVoice		ifTrue: [^ false].	^ self nick asIRCLowercase < anIRCChannelMember nick asIRCLowercase! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 10:08'!= anIRCChannelMember	^self nick = anIRCChannelMember nick! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 1/11/2003 08:49'!canChangeTopic	^ self topic or: [self operator]! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 09:20'!channel	^channel! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 09:31'!channel: aString 	channel _ aString! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'fc 2/17/2005 20:01'!fromString: aString 	"Member cannot be both @ and + (operator and voiced) since operators  	already have voice." 	self initialize.	self flag: #noteToFrank. "Removed t from +@ string, need to come back here." 	('+@' includes: aString first)		ifTrue: [aString first = $@				ifTrue: [self operator: true].			aString first = $+				ifTrue: [self voice: true].			aString first = $t ifTrue: [self topic: true].			self				nick: (aString copyFrom: 2 to: aString size)]		ifFalse: [self nick: aString]! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 09:39'!hasVoice	^self voice! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 10:09'!hash	^self nick hash! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 1/10/2003 19:36'!initialize	self operator: false.	self voice: false.	self topic: false! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 09:38'!isOperator	^self operator! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 1/10/2003 19:45'!modeChanged: aString 	"+/- v/o"	| plus voiced opped topicControl |	aString size = 2		ifFalse: [^ nil].	plus _ (aString at: 1)				= $+.	voiced _ (aString at: 2)				= $v.	opped _ (aString at: 2)				= $o.	topicControl _ (aString at: 2) = $t.	voiced		ifTrue: [self voice: plus].	opped		ifTrue: [self operator: plus].	topicControl ifTrue: [self topic: plus]! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 09:20'!nick	^nick! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 09:21'!nick: aString	nick _ aString! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 09:21'!operator	^operator! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 09:21'!operator: aBoolean	operator _ aBoolean! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 1/10/2003 19:29'!printOn: aStream 	super printOn: aStream.	aStream nextPutAll: ' ("' , self nick , '")'! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 1/10/2003 19:37'!topic	"Better lazy initialize since we just added this var."	topic == nil ifTrue: [self topic: false].	^ topic! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 1/10/2003 19:35'!topic: aBoolean 	topic _ aBoolean! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 09:21'!voice	^voice! !!IRCChannelMember methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 09:21'!voice: aBoolean	voice _ aBoolean! !!IRCChannelMember commentStamp: '<historical>' prior: 0!We will use instances of IRCChannelMember to hold information about and organize our channel members.!!IRCChannelMember class methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 09:29'!fromString: aString 	^self new fromString: aString! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:32'!aboutToBeClosed	connection removeChannelObserver: self.	self release.	self closeLog.	^ true! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:33'!attemptedNicks	attemptedNicks isNil ifTrue: [self initAttemptedNicks].	^attemptedNicks! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:33'!calculateWidestNick	"Select an arbitrary minimum."	widestNick == nil ifTrue: [widestNick _ 7].	self channelUsers do: [:each |		widestNick _ widestNick max: each size].! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:33'!channelName	^channelName! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/25/2004 06:44'!channelNameWithoutSymbol	| string |	string _ self channelName.	string first = $# ifTrue: [string _ string copyFrom: 2 to: string size].	^string! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:34'!channelUser	self selectedUser = 0 ifTrue: [^nil].	^ self channelUsers at: self selectedUser! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:34'!channelUsers	^ channel memberNames ! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/23/2004 11:19'!channelUsersFormatted	"The list already comes back to us with proper ordering of operators,  	voiced and members. We need to indicate status for some of these  	members in the list."	| newList |	newList := self channelUsers				collect: [:each | StringMorph contents: each].	channel operatorIndexes		do: [:index | index > 0				ifTrue: [(newList at: index)						color: IRCClientColors nickIsOperator]].	channel voicedIndexes		do: [:index | index > 0				ifTrue: [(newList at: index)						color: IRCClientColors nickIsVoiced]].	^ newList! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'fc 6/5/2005 11:59'!checkForNickCompletionOn: morph 	"Use attemptedNicks to track the ones we have tried already."	| typed words word prefixSentence sentence limit match |	typed := morph text.	typed size < 1		ifTrue: ["leading tabs are not nick matches."			^ true].	words := typed asString substrings.	words isEmpty ifTrue: [^true].	word := words last.	nickMatchWord == nil		ifTrue: [nickMatchWord := word].	match := self firstUnattemptedNickThatMatches: word.	match isNil		ifFalse: [limit := typed size - word size.			prefixSentence := typed copyFrom: 1 to: limit.			sentence := prefixSentence , match.			words size == 1 ifTrue: [ sentence := sentence, ': '].			morph setText: sentence.			morph				setSelection: (sentence size + 1 to: sentence size + 1).			morph hasUnacceptedEdits: true.			^ false].	^ true! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:34'!checkForScrollPlaybackDownOn: morph 	| previous |	self messagePlayback rollIndexForward.	previous _ self messagePlayback getIndexedMessage.	previous isNil		ifFalse: [morph setText: previous.			morph				setSelection: (previous size + 1 to: previous size + 1).			morph hasUnacceptedEdits: true].	^ false! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:34'!checkForScrollPlaybackUpOn: morph 	| previous |	previous _ self messagePlayback getIndexedMessage.	self messagePlayback rollIndexBack.	previous isNil ifFalse: [		morph setText: previous.		morph setSelection: (previous size + 1 to: previous size + 1).		morph hasUnacceptedEdits: true.		].	^ false! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:34'!closeFrontMostWindow	connection gui closeTab! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 6/7/2004 22:59'!connection: anIRCConnection channelName: aString 	connection _ anIRCConnection.	channel _ connection channelInfo: aString.	channelName _ aString.	channel subscribe: self.	self initializeChatTextLines! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 6/10/2004 20:19'!docs	IRCConnection showDocs! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:35'!findMorphNamed: aString 	^ self findMorphNamed: aString in: self topView! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:35'!findMorphNamed: aString in: parentMorph 	parentMorph isNil		ifTrue: [^ nil].	^ parentMorph		submorphNamed: aString		ifNone: []! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 6/7/2004 21:38'!fingerSelectedUser	| who msg |	who _ self channelUser.	who isNil		ifTrue: [^ nil].	msg _ IRCProtocolMessage				command: 'FINGER'				arguments: (Array with: self channelName with: who asString).	connection sendMessage: msg! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:36'!firstUnattemptedNickThatMatches: word 	| test |	channel memberNames		do: [:each | (self attemptedNicks includes: each)				ifFalse: [self attemptedNicks add: each.					test _ (self attemptedNicks includes: word)								ifTrue: [each asIRCLowercase beginsWith: nickMatchWord asIRCLowercase]								ifFalse: [each asIRCLowercase beginsWith: word asIRCLowercase].					test						ifTrue: [^ each]]].	^ nil! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:36'!initAttemptedNicks	attemptedNicks _ Set new! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:36'!inputPaneHeight	^30! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:36'!inspectChannel	self inspect! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'fc 6/5/2005 12:21'!ircMessageRecieved: aMessage 	"Ugly message specifc code in here."	| sender newLine nickText messageText messageWords actionFlag |	sender := aMessage sender				ifNil: [self nick].	sender := IRCProtocolMessage cleanSenderString: sender.	nickText := self prepareNickAsRequired: sender.	messageText := aMessage text asText.	messageWords := messageText asString substrings.	actionFlag := false.	messageWords size > 1		ifTrue: [messageWords first asUppercase = (IRCProtocolMessage extendedDelimeterCharacter asString , 'ACTION')				ifTrue: [actionFlag := true.					messageText := messageText copyFrom: 9 to: messageText size - 1]].		"Colors..."	aMessage sender isNil		ifTrue: ["message is going out"			messageText addAttribute: IRCClientColors transmittedMessage]		ifFalse: ["message is coming in"			(messageText asString asIRCLowercase includesSubString: connection nick asIRCLowercase)				ifTrue: [IRCClientSounds channelNickMessageArrived.					messageText addAttribute: IRCClientColors messageContainsNick]].	actionFlag		ifTrue: [ newLine :=  nickText , ' ', (Text string: messageText asString   attributes: IRCClientColors messageContainsAction), String cr]		ifFalse: [ newLine := nickText , ' : ' , messageText , String cr. ].	newLine := connection markIfURL: newLine startingAt: nickText size + 3.	self addTextToChannelPane: newLine! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:36'!justOpened	"Placeholder"! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:36'!keyInterceptEndedFrom: morph 	morph clearInterceptActive.	nickMatchWord _ nil.	self initAttemptedNicks.	self messagePlayback resetIndex! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 6/9/2004 03:51'!keyInterceptedEvent: evt morph: morph 	"Answer true if we want the pane to have the event anyway.  	There are 3 classes involved here.  	TextMorphForInterceptingIRCEditView intercepts the keystrokes.  	PluggableInterceptingIRCTextMorph is the morph holding the text.  	IRCChannelObserver (this class) decides what to do with the  	intercepts.  	Once an intercept is tripped we will recieve ALL keystrokes until we  	tell the text morph #clearInterceptActive"	| char |	char _ evt keyCharacter.	char = Character tab		ifTrue: [^ self checkForNickCompletionOn: morph].	char = Character arrowUp		ifTrue: [^ self checkForScrollPlaybackUpOn: morph].	char = Character arrowDown		ifTrue: [^ self checkForScrollPlaybackDownOn: morph].	self keyInterceptEndedFrom: morph.	^ true! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:37'!messagePlayback	messagePlayback == nil ifTrue: [messagePlayback _ IRCMessagePlayback new].	^messagePlayback! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:37'!nick	^connection nick! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:37'!openCapturedView	"We do it inside the console window!!"	"open a view for interacting with this collector"	| alignMorph paneName |	paneName := channel name.	alignMorph := (AlignmentMorph newColumn)				hResizing: #spaceFill;				vResizing: #spaceFill;				layoutInset: 0;				borderWidth: 0;				layoutPolicy: ProportionalLayout new.	alignMorph color: Color white.	self buildMorphIn: alignMorph.	connection gui		addSwapPane: alignMorph		named: paneName		hidden: false		closeable: true		swapModel: self.	self justOpened! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 6/13/2004 21:59'!openMorphicView	"open a view for interacting with this collector"	| win |	win _ IRCSystemWindow new.	win setLabel: channel name.	win model: self.	self buildMorphIn: win.	win openInWorld.	self justOpened! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/3/1998 20:59'!openView	"open a view for interacting with this collector"	^self openMorphicView! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'fc 1/20/2005 22:15'!prepareNickAsRequired: aTextOrString 	"We answer a Text"	| nickText pad |	nickText _ aTextOrString asText.	nickText size < self widestNick		ifTrue: [pad _ String new: (widestNick - nickText size) withAll: Character space.			nickText _ (pad , nickText) asText].	nickText		addAttribute: (TextFontReference toFont: (TextStyle named: #DefaultFixedTextStyle) defaultFont).	^ nickText! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:38'!reconnect	self connection: connection channelName: channelName.	self changed: #chatText.	self justOpened! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 08:57'!release	super release.	channel unsubscribe: self! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:38'!removeSelfFromConnectionObserversList	connection removeChannelObserver: self! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:38'!selectedUser	selectedUser isNil		ifTrue: [self selectedUser: 0].	^ selectedUser! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:38'!selectedUser: obj 	selectedUser _ obj.	self changed: #channelUsersFormatted! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 08:57'!sendMessage: aText	channel sendMessage: aText asString.	^true! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'fc 6/16/2005 10:15'!spawn: aMessage	"Message sent by text morph when user clicks blue-mouse button"	connection spawn: aMessage! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 08:08'!talkToSelectedUser	self channelUser isNil		ifTrue: [^ nil].	self channelUser = connection nick		ifTrue: [^ nil].	IRCDirectMessagesObserver openForConnection: channel connection talkingTo: self channelUser! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:39'!topicStatus	| count string |	count _ self channelUsers size.	string _ self topicStatusPrefix , count printString.	status contents: string! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:39'!topicStatusPrefix	^ 'population: '! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 6/2/2004 09:59'!traceOff	IRCConnection tracing: false! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 6/2/2004 10:00'!traceOn	IRCConnection tracing: true! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:39'!updateUsers	self calculateWidestNick.	self changed: #channelUsersFormatted.	self topicStatus.	self updateTopicPaneState! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 6/7/2004 21:43'!versionSelectedUser	| who msg |	who _ self channelUser.	who isNil		ifTrue: [^ nil].	msg _ IRCProtocolMessage				command: 'VERSION'				arguments: (Array with: self channelName with: who asString).	connection sendMessage: msg! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:40'!whoisSelectedUser	| who msg |	who _ self channelUser.	who isNil		ifTrue: [^ nil].	msg _ IRCProtocolMessage				command: 'WHOIS'				arguments: (Array with: self channelName with: who asString).	connection sendMessage: msg! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:40'!widestNick	widestNick == nil		ifTrue: [widestNick _ 7].	^ widestNick! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:41'!windowIsClosing	self removeSelfFromConnectionObserversList! !!IRCChannelObserver methodsFor: 'sending' stamp: 'fc 1/18/2005 17:07'!acceptChannelString: aString 	"New message path logic."	^ connection				sendChannelString: aString				from: self				channelName: self channelName! !!IRCChannelObserver methodsFor: 'sending' stamp: 'sbw 5/13/2004 07:40'!perform: aSelector orSendTo: rcvr 	(self respondsTo: aSelector)		ifTrue: [^ self perform: aSelector].	^ rcvr perform: aSelector! !!IRCChannelObserver methodsFor: 'sending' stamp: 'sbw 5/13/2004 07:38'!textWasSent: aText 	"New message logic."	self messagePlayback addMessage: aText! !!IRCChannelObserver methodsFor: 'panel building' stamp: 'sbw 5/27/2004 07:17'!addChannelTextTo: win fractions: fractions offsets: offsets 	| textArea |	textArea := PluggableIRCTextMorph				on: self				text: #chatText				accept: nil				readSelection: #chatTextSelection				menu: #channelTextMenu:.	win		addMorph: textArea		fullFrame: (LayoutFrame fractions: fractions offsets: offsets).	^ textArea! !!IRCChannelObserver methodsFor: 'panel building' stamp: 'fc 12/4/2004 20:56'!addInputPaneTo: win fractions: fractions offsets: offsets 	| inputArea |	inputArea := PluggableInterceptingIRCTextMorph				on: self				text: nil				accept: #acceptChannelString:.	inputArea acceptOnCR: true.	inputArea addIntercept: Character tab;		 addIntercept: Character arrowUp;		 addIntercept: Character arrowDown;		 hideScrollBarsIndefinitely.	win		addMorph: inputArea		fullFrame: (LayoutFrame fractions: fractions offsets: offsets).	^ inputArea! !!IRCChannelObserver methodsFor: 'panel building' stamp: 'sbw 5/13/2004 07:33'!addTopicPaneTo: morph fractions: fractions offsets: offsets 	| topicMorph |	topicMorph _ PluggableTextMorph				on: self				text: #topic				accept: #changeTopic:.	channel addDependent: topicMorph.	topicMorph acceptOnCR: true;		 name: 'topicPane';		 color: IRCClientColors channelTopicPane.	morph		addMorph: topicMorph		fullFrame: (LayoutFrame fractions: fractions offsets: offsets)! !!IRCChannelObserver methodsFor: 'panel building' stamp: 'sbw 5/21/2004 20:10'!addUsersListTo: win fractions: fractions offsets: offsets 	| listView alignMorph statusHeight |	listView := PluggableIRCHighlightingListMorph				on: self				list: #channelUsersFormatted				selected: #selectedUser				changeSelected: #selectedUser:				menu: #userListMenu:.	listView color: IRCClientColors userListPane.	status := TextMorph new.	status contents: self topicStatusPrefix;		 lock.	alignMorph := AlignmentMorph newColumn hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 0;				 color: IRCClientColors usersPopulationPaneBackground;				 layoutPolicy: ProportionalLayout new.	statusHeight := 24.	alignMorph		addMorph: status		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (6 @ 2 corner: 0 @ statusHeight));				addMorph: listView		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ statusHeight corner: 0 @ 0)).	win		addMorph: alignMorph		fullFrame: (LayoutFrame fractions: fractions offsets: offsets).	alignMorph fillWithRamp: connection gui paneColorRamp oriented: 16 @ 32! !!IRCChannelObserver methodsFor: 'panel building' stamp: 'sbw 5/13/2004 07:33'!buildMorphIn: parentMorph 	| topicHeight nicksWidth inputHeight channelTextPane |	topicHeight _ 48.	nicksWidth _ 120.	inputHeight _ self inputPaneHeight.	self		addTopicPaneTo: parentMorph		fractions: (0 @ 0 corner: 1 @ 0)		offsets: (0 @ 0 corner: nicksWidth negated @ topicHeight).	channelTextPane _ self				addChannelTextTo: parentMorph				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ topicHeight corner: nicksWidth negated @ inputHeight negated).	self		addUsersListTo: parentMorph		fractions: (1 @ 0 corner: 1 @ 1)		offsets: (nicksWidth negated @ 0 corner: 0 @ inputHeight negated).	inPane _ self				addInputPaneTo: parentMorph				fractions: (0 @ 1 corner: 1 @ 1)				offsets: (0 @ inputHeight negated corner: 0 @ 0).	channelTextPane keysInputPane: inPane! !!IRCChannelObserver methodsFor: 'panel building' stamp: 'sbw 5/13/2004 07:34'!channelTextMenu: aMenu 	aMenu 		addList: #(#('find (f)' #find) #('find again (g)' #findAgain) #('set search string (h)' #setSearchString) #('copy (c)' #copySelection) #('inspect channel observer' #inspectChannel)).	connection gui frontMostPaneIsCloseable 		ifTrue: [aMenu addList: #(#('close' #closeFrontMostWindow))].	^aMenu! !!IRCChannelObserver methodsFor: 'panel building' stamp: 'sbw 5/13/2004 07:38'!statusMenu: aMenu 	"Treat the menu like a button."	self updateUsers.	^ aMenu! !!IRCChannelObserver methodsFor: 'panel building' stamp: 'sbw 6/10/2004 20:13'!userListMenu: aMenu 	"Build a context sensitive menu for the users list."	| selected |	selected _ self channelUser.	selected isNil		ifFalse: [selected = connection nick				ifFalse: [aMenu add: 'talk to selected user' action: #talkToSelectedUser;						 add: 'finger selected user' action: #fingerSelectedUser";						 add: 'version selected user' action: #versionSelectedUser"].			aMenu add: 'who is selected user?' action: #whoisSelectedUser].	^ aMenu! !!IRCChannelObserver methodsFor: 'channel pane text' stamp: 'fc 6/8/2005 20:08'!addTextToChannelPane: aString 	| stringToAppend |	stringToAppend := (IRCOptionsManagement option: #timeStampMessages)				ifTrue: [self prependTimeStampToChannelMessage: aString]				ifFalse: [aString].	(IRCOptionsManagement option: #logChannelTraffic)		ifTrue: [self logChannelTraffic: stringToAppend].	(IRCOptionsManagement option: #usemIRCColors)				ifTrue: [stringToAppend := self class convertTextUsingMIRCColors: stringToAppend].	chatTextLines add: stringToAppend.	self changed: #chatText.	connection gui possibleTabStateChange: self channelName! !!IRCChannelObserver methodsFor: 'channel pane text' stamp: 'sbw 5/13/2004 07:33'!addTextToChannelPane: aString usingUnpreparedNick: sender	| nickText |	nickText _ self prepareNickAsRequired: sender.	self addTextToChannelPane: nickText, ' : ', aString! !!IRCChannelObserver methodsFor: 'channel pane text' stamp: 'sbw 6/7/2004 23:02'!chatAreaSelection	"where to put the cursor in the chat area. We'll leave it at the very end 	so that the most recent mesages are always visible"	| theSize |	theSize _ chatTextLines text size.	^ theSize to: theSize - 1! !!IRCChannelObserver methodsFor: 'channel pane text' stamp: 'sbw 6/7/2004 23:02'!chatText	^ chatTextLines text! !!IRCChannelObserver methodsFor: 'channel pane text' stamp: 'sbw 6/7/2004 23:03'!chatTextSelection	"where to put the cursor in the chat area. We'll leave it at the very end 	so that the most recent mesages are always visible"	| theSize |	theSize _ chatTextLines text size.	^ theSize to: theSize - 1! !!IRCChannelObserver methodsFor: 'channel pane text' stamp: 'sbw 6/7/2004 23:03'!clearTextPane	chatTextLines clear.	self changed: #chatText! !!IRCChannelObserver methodsFor: 'channel pane text' stamp: 'fc 10/10/2005 16:00'!initializeChatTextLines	chatTextLines _ IRCTextLines new initialize! !!IRCChannelObserver methodsFor: 'channel pane text' stamp: 'fc 6/8/2005 20:15'!prependTimeStampToChannelMessage: aString 	| ts tm |	ts := TimeStamp current.	tm := ts time.	^ (tm print24 asText , ' ', aString)! !!IRCChannelObserver methodsFor: 'topic pane' stamp: 'sbw 5/13/2004 07:33'!canChangeTopic	| nick user |	nick := self nick.	user := channel findMember: nick.	user isNil ifTrue: [^false].	^ user canChangeTopic! !!IRCChannelObserver methodsFor: 'topic pane' stamp: 'sbw 5/13/2004 07:33'!changeTopic: aText 	self canChangeTopic		ifTrue: [channel changeTopic: aText]! !!IRCChannelObserver methodsFor: 'topic pane' stamp: 'sbw 5/13/2004 07:35'!disableTopicEdits	| pane color |	pane _ self findTopicMorph.	color _ IRCClientColors channelTopicPane.	pane color: color.	pane replaceSetTextSelector: nil! !!IRCChannelObserver methodsFor: 'topic pane' stamp: 'sbw 5/13/2004 07:35'!enableTopicEdits	| pane color |	pane _ self findTopicMorph.	color _ IRCClientColors channelTopicPaneEnabled.	pane color: color.	pane replaceSetTextSelector: #changeTopic:! !!IRCChannelObserver methodsFor: 'topic pane' stamp: 'sbw 5/13/2004 07:35'!findTopicMorph	| morphs |	morphs _ self myDependents				select: [:m | m isMorph].	^ morphs		detect: [:m | m knownName = 'topicPane']! !!IRCChannelObserver methodsFor: 'topic pane' stamp: 'sbw 5/13/2004 07:39'!topic	^channel topic! !!IRCChannelObserver methodsFor: 'topic pane' stamp: 'sbw 5/13/2004 07:39'!updateTopicPaneState	self canChangeTopic		ifTrue: [self enableTopicEdits]		ifFalse: [self disableTopicEdits]! !!IRCChannelObserver methodsFor: 'logging' stamp: 'sbw 5/13/2004 07:34'!closeLog	logFile == nil ifFalse: [logFile close]! !!IRCChannelObserver methodsFor: 'logging' stamp: 'sbw 5/25/2004 18:15'!ensureIRCLogFileForChannel	| path |	path := ExternalIRCFiles ensuredLogFilePathForServerAddress: connection server channelName: self channelNameWithoutSymbol.	logFile := CrLfFileStream fileNamed: path! !!IRCChannelObserver methodsFor: 'logging' stamp: 'sbw 6/2/2004 07:52'!logChannelTraffic: aText 	self logFile.	logFile closed		ifTrue: [logFile reopen; setToEnd].	logFile nextPutAll: '[' , DateAndTime current printString , '] ';		 nextPutAll: aText asString;		 flush! !!IRCChannelObserver methodsFor: 'logging' stamp: 'sbw 5/13/2004 07:37'!logFile	logFile == nil		ifTrue: [self ensureIRCLogFileForChannel].	^ logFile! !!IRCChannelObserver methodsFor: 'logging' stamp: 'fc 3/7/2005 21:39'!playlist		| a |		a _ Applescript doIt: 'tell application "iTunes"	if player state = playing then		set a to (get name of current track)		set b to (get artist of current track)		set c to (get album of current track)		set d to (get year of current track)	end if	return b & "; " & c & "; " & a & "; " & d	end tell'.	a _ 'On iTunes now: ', a, Character cr asString.	Transcript show: a.	self acceptChannelString: a! !!IRCChannelObserver commentStamp: '<historical>' prior: 0!Converts IRC messages forwarded to it, into a textual format that may be displayed.  Messages may additionally be sent *from* it, to a specified target.!!IRCChannelObserver class methodsFor: 'irc color text support' stamp: 'sbw 5/13/2004 07:30'!convertTextUsingMIRCColors: aTextOrString 	"We need to answer Text having the colors converted as required.  	A color sequence ends with each line of text or an empty trap  	character. The trap character having a 1 or 2 digit numerical value  	directly following is the mIRC code for a foreground color change. An  	optional comma directly following the number means there is also a  	background color parameter directly after the comma. Foreground and  	background colors stick, once set, until they are terminated as described 	above. You can set both the foreground and background color, change 	just the foreground color later and then set both again if we receive a 	message formatted this way. Note there is no way to just change the  	background color alone. It's possible we may have multiple lines in the  	given text so we'll have to watch for end of line characters since colors 	reset upon a new line."	| trapCharacter cr locs char |	trapCharacter _ IRCClientColors colorTrapCharacter.	cr _ Character cr.	locs _ Dictionary new.	1		to: aTextOrString size		do: [:index | 			char _ aTextOrString at: index.			(char = trapCharacter					or: [char = cr])				ifTrue: [locs at: index put: char]].	^ self convertTextUsingMIRCColors: aTextOrString locs: locs! !!IRCChannelObserver class methodsFor: 'private' stamp: 'sbw 5/13/2004 07:30'!convertTextUsingMIRCColors: aTextOrString locs: locs 	| cr colors result posn piece attr |	cr _ Character cr.	result _ TextStream on: '' asText.	posn _ 1.	attr _ TextColor black.	locs keys asSortedCollection		do: [:key | 			piece _ aTextOrString copyFrom: posn to: key - 1.			result				withAttribute: attr				do: [result nextPutAll: piece].			(locs at: key)					= cr				ifTrue: [attr _ TextColor black.					result						nextPut: (locs at: key).					posn _ key + 1]				ifFalse: [(self isNextCharacterANumberIn: aTextOrString startingAt: key)						ifTrue: [colors _ self extractColorCodesFrom: aTextOrString at: key.							posn _ key + 1										+ (colors at: #skipped).							(colors at: #foreground)									== nil								ifFalse: [attr _ IRCClientColors mircColorFor: (colors at: #foreground) asNumber].							(colors at: #background)									== nil								ifFalse: [(colors at: #background)]]						ifFalse: [attr _ TextColor black.							posn _ key + 1]]].	posn < aTextOrString size		ifTrue: [piece _ aTextOrString copyFrom: posn to: aTextOrString size.			result nextPutAll: piece].	^ result contents! !!IRCChannelObserver class methodsFor: 'private' stamp: 'sbw 5/13/2004 07:30'!extractColorCodesFrom: aText at: anInteger 	"Should find any of:  	nABC  	nnABC  	n,nABC  	nn,nABC  	nn,nnABC  	(where ABC is following text containing letters but not beginning with  	a digit if only one value of 'n' is found. The ABC could start with a  	comma). Answer a dictionary containing settings found for foreground  	and background colors. If no background color setting is found the  	value will be returned as nil. The amount of characters we skip are  	included in the result too."	| result start stop extract commaPos limit foregroundString backgroundString |	result _ Dictionary new.	result at: #foreground put: nil.	result at: #background put: nil.	start _ anInteger.	stop _ start.	[(self isNextCharacterACommaIn: aText startingAt: stop)		or: [self isNextCharacterANumberIn: aText startingAt: stop]]		whileTrue: [stop _ stop + 1].	stop = start		ifFalse: [extract _ aText copyFrom: start + 1 to: stop.			commaPos _ extract indexOf: $,.			limit _ commaPos = 0						ifTrue: [stop]						ifFalse: [start + commaPos - 1].			foregroundString _ aText copyFrom: start + 1 to: limit.			backgroundString _ commaPos = 0						ifFalse: [aText copyFrom: limit + 2 to: stop]].	foregroundString isNil		ifFalse: [result at: #foreground put: foregroundString].	backgroundString isNil		ifFalse: [result at: #background put: backgroundString].	result at: #skipped put: stop - start.	^ result! !!IRCChannelObserver class methodsFor: 'private' stamp: 'sbw 5/13/2004 07:30'!isNextCharacterACommaIn: aText startingAt: anInteger 	"Actually checks if the next character is a comma  	AND  	if the character after that is a digit."	| index commaResult |	anInteger < aText size		ifFalse: [^ false].	index _ anInteger + 1.	commaResult _ (aText at: index)				= $,.	commaResult		ifFalse: [^ false].	(anInteger + 1) < aText size		ifFalse: [^ false].	^ self isNextCharacterANumberIn: aText startingAt: anInteger + 1! !!IRCChannelObserver class methodsFor: 'private' stamp: 'sbw 5/13/2004 07:30'!isNextCharacterANumberIn: aText startingAt: anInteger 	| index |	index _ anInteger + 1.	^(aText at: index) isDigit! !!IRCChannelObserver class methodsFor: 'instance creation' stamp: 'sbw 5/13/2004 07:42'!openForChannelNamed: channelName onCaptiveConnection: connection 	^ (super new connection: connection channelName: channelName) openCapturedView! !!IRCChannelObserver class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 08:56'!openForChannelNamed: channelName  onConnection: connection 	^(super new connection: connection  channelName: channelName) openView! !!IRCChannelSummary methodsFor: 'private-initialization' stamp: 'ls 9/2/1998 22:38'!initializeName: aString  numUsers: anInteger  topic: anotherString	name _ aString.	numUsers _ anInteger.	topic _ anotherString.! !!IRCChannelSummary methodsFor: 'access' stamp: 'ls 9/2/1998 22:39'!name	"the name of the channel"	^name! !!IRCChannelSummary methodsFor: 'access' stamp: 'ls 9/2/1998 22:40'!numUsers	"number of users currently on the channel"	^numUsers! !!IRCChannelSummary methodsFor: 'access' stamp: 'ls 9/2/1998 22:40'!topic	"the current topic of discussion"	^topic! !!IRCChannelSummary methodsFor: 'printing' stamp: 'sbw 3/10/2005 21:01'!printOn: aStream	aStream nextPutAll: self class name;	space;	 nextPutAll: self name;	 nextPutAll: ' (';	 nextPutAll: numUsers printString;	 nextPutAll: ')'; cr! !!IRCChannelSummary commentStamp: '<historical>' prior: 0!very basic info on an IRC channel; specifically, that returned by a LIST command!!IRCChannelSummary class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 22:39'!name: cname  numUsers: numUsers  topic: topic	^super new initializeName: cname  numUsers: numUsers  topic: topic! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:17'!onChannel: aChannel	channel _ aChannel.	userList _ #().	userIndex _ 0.	channel addDependent: self.	self refreshUserList.! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'sbw 5/11/2004 21:50'!openAsMorph	| win listView talkToButton |	win := SystemWindow labelled: 'users in ' , channel name.	win model: self.	listView := PluggableListMorph				on: self				list: #userList				selected: #userIndex				changeSelected: #userIndex:.	win		addMorph: listView		frame: (0 @ 0 extent: 1 @ 0.9).	talkToButton := PluggableButtonMorph				on: self				getState: nil				action: #talkTo.	talkToButton hResizing: #spaceFill;		 vResizing: #spaceFill;		 label: 'talk to selected user'.	win		addMorph: talkToButton		frame: (0 @ 0.9 extent: 1 @ 0.1).	win openInWorld! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:18'!openView	^self openAsMorph! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:22'!refreshUserList	"update the user list from the channel"	|oldName |	(userIndex > 0) ifTrue: [		oldName _ userList at: userIndex ].	userList _ channel memberNames asSortedCollection asArray.	userIndex _ 0.	oldName ifNotNil: [		"try to select the same user again"		userIndex _ userList indexOf: oldName ].	self changed: #userList.	self changed: #userIndex.! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:42'!selectedUser	"return the name of the selected user, or nil if none"	^userList at: userIndex ifAbsent: [nil ].! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 08:08'!talkTo	"open a window for talking to the selected user"	| user |	user := self selectedUser.	user		ifNil: [^ self].	^ IRCDirectMessagesObserver openForConnection: channel connection talkingTo: user! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:17'!update: aSymbol	aSymbol == #memberNames ifTrue: [ self refreshUserList ].! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:16'!userIndex	"return the index in userList of the user currently selected"	^userIndex! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:25'!userIndex: anInteger	"change which user is selected"	userIndex _ anInteger.	self changed: #userIndex.! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:16'!userList	"return the current list of user names"	^userList! !!IRCChannelUsersBrowser commentStamp: '<historical>' prior: 0!Used for browsing the list of users on a particular channel.!!IRCChannelUsersBrowser class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 09:20'!onChannel: channel	^self new onChannel: channel! !!IRCChannelUsersBrowser class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 09:20'!openOnChannel: channel	^(self onChannel: channel) openView! !!IRCClientColors class methodsFor: 'colors' stamp: 'sbw 2/24/2002 00:29'!channelListBuilding	"Color to use to indicate that the channel list is building."^Color lightGreen! !!IRCClientColors class methodsFor: 'colors' stamp: 'sbw 3/11/2005 14:23'!channelListIdle	^ Color paleTan lighter! !!IRCClientColors class methodsFor: 'colors' stamp: 'sbw 3/12/2005 13:58'!channelListRowHighlight	^ Color brown! !!IRCClientColors class methodsFor: 'colors' stamp: 'sbw 2/25/2002 09:16'!channelTopicPane	^ Color veryVeryLightGray! !!IRCClientColors class methodsFor: 'colors' stamp: 'sbw 1/10/2003 20:36'!channelTopicPaneEnabled	^ Color white! !!IRCClientColors class methodsFor: 'colors' stamp: 'sbw 3/1/2002 22:49'!consolePaneBackground	^Color white darker! !!IRCClientColors class methodsFor: 'colors' stamp: 'sbw 2/24/2002 00:16'!messageArrived	"The color used to highlight the border around the tab of a pane if text was added while we were looking at another pane."	^Color lightRed! !!IRCClientColors class methodsFor: 'colors' stamp: 'fc 3/4/2005 11:37'!messageContainsAction	"Style of messages that have the ACTION keyword set."	^Array with: TextEmphasis italic with:  (TextColor new color: (Color r: 1.0 g: 0.544 b: 0.27))! !!IRCClientColors class methodsFor: 'colors' stamp: 'sbw 2/24/2002 10:47'!messageContainsNick	"Color of messages that we receive which contain our Nick."	^ TextColor new color: Color magenta darker! !!IRCClientColors class methodsFor: 'colors' stamp: 'sbw 3/1/2002 11:47'!nickIsOperator	^ Color red! !!IRCClientColors class methodsFor: 'colors' stamp: 'sbw 3/1/2002 13:09'!nickIsVoiced	^ Color blue! !!IRCClientColors class methodsFor: 'colors' stamp: 'sbw 3/12/2005 13:59'!profilesRowHighlight	^ Color blue! !!IRCClientColors class methodsFor: 'colors' stamp: 'sbw 2/24/2002 00:19'!swappedPaneInFocus	"The color for the tab of the swapped pane currently in focus."	^Color lightYellow! !!IRCClientColors class methodsFor: 'colors' stamp: 'sbw 2/24/2002 10:32'!transmittedMessage	"Color of messages that we send."	^ TextColor blue! !!IRCClientColors class methodsFor: 'colors' stamp: 'fc 8/6/2004 14:57'!userListPane	"The list pane showing users on a channel."	^Color veryVeryLightGray	! !!IRCClientColors class methodsFor: 'colors' stamp: 'sbw 2/24/2002 00:32'!usersPopulationPaneBackground	"The color of the population pane background."	^Color white! !!IRCClientColors class methodsFor: 'mIRC colors' stamp: 'sbw 11/17/2002 18:59'!colorTrapCharacter	ColorTrapCharacter == nil ifTrue: [ColorTrapCharacter _ Character value: 3].	^ColorTrapCharacter! !!IRCClientColors class methodsFor: 'mIRC colors' stamp: 'sbw 5/13/2004 07:43'!exampleTest	"IRCClientColors exampleTest"	| testMessage stream trap part text |	testMessage := 'This should be a simple string.And this is the second line.'.	stream := WriteStream on: ''.	trap := IRCClientColors colorTrapCharacter.	part := testMessage copyFrom: 1 to: 18.	stream nextPutAll: part.	stream nextPut: trap.	stream nextPutAll: '04'.	part := testMessage copyFrom: 19 to: 38.	stream nextPutAll: part.	stream nextPut: trap.	stream nextPutAll: '02,09'.	part := testMessage copyFrom: 39 to: 48.	stream nextPutAll: part.	stream nextPut: trap.	part := testMessage copyFrom: 49 to: testMessage size.	stream nextPutAll: part.	text := IRCChannelObserver convertTextUsingMIRCColors: stream contents.	(Workspace new contents: text)		openLabel: 'test'! !!IRCClientColors class methodsFor: 'mIRC colors' stamp: 'sbw 11/21/2002 20:26'!initializeTextColorMap	"Be sure to reinitialize the color map if you make edits here."	"IRCClientColors initializeTextColorMap"	TextColorMap _ Dictionary new.	TextColorMap		at: 0		put: (TextColor color: Color white);				at: 1		put: (TextColor color: Color black);				at: 2		put: (TextColor color: Color blue darker);				at: 3		put: (TextColor color: Color green darker);				at: 4		put: (TextColor color: Color red darker);				at: 5		put: (TextColor color: Color brown);				at: 6		put: (TextColor color: Color magenta darker);				at: 7		put: (TextColor color: Color orange darker);				at: 8		put: (TextColor color: Color yellow);				at: 9		put: (TextColor color: Color lightGreen);				at: 10		put: (TextColor color: Color cyan darker);				at: 11		put: (TextColor color: Color cyan);				at: 12		put: (TextColor color: Color lightBlue);				at: 13		put: (TextColor color: Color magenta);				at: 14		put: (TextColor color: Color darkGray);				at: 15		put: (TextColor color: Color gray)! !!IRCClientColors class methodsFor: 'mIRC colors' stamp: 'sbw 11/17/2002 18:11'!mircColorFor: anInteger 	| factoredColorCode |	anInteger == 99		ifTrue: [^ TextColor color: Color transparent]		ifFalse: [factoredColorCode _ anInteger \\ 16.			^ self textColorMap at: factoredColorCode]! !!IRCClientColors class methodsFor: 'mIRC colors' stamp: 'sbw 11/17/2002 17:51'!textColorMap	TextColorMap == nil ifTrue: [self initializeTextColorMap].	^ TextColorMap! !!IRCClientSounds commentStamp: '<historical>' prior: 0!Manages audio for IRC client.See API class methods for how it is used.!!IRCClientSounds class methodsFor: 'private' stamp: 'sbw 6/11/2004 05:06'!advanceLastSoundTime	self lastSoundTime: self currentTimeValue + 2! !!IRCClientSounds class methodsFor: 'private' stamp: 'sbw 6/11/2004 04:54'!currentTimeValue	^ Time totalSeconds! !!IRCClientSounds class methodsFor: 'private' stamp: 'sbw 6/8/2004 22:31'!generatePulseSound1	"(IRCClientSounds generatePulseSound1) play"	| snd |	snd _ FMSound new.	snd		addEnvelope: (VolumeEnvelope exponentialDecay: 0.96).	snd		addEnvelope: (PitchEnvelope exponentialDecay: 0.98).	^ snd		setPitch: 2938		dur: 0.02		loudness: 0.5! !!IRCClientSounds class methodsFor: 'private' stamp: 'sbw 6/8/2004 22:33'!generatePulseSound2	"(IRCClientSounds generatePulseSound2) play"	| snd |	snd _ FMSound new.	snd		addEnvelope: (VolumeEnvelope exponentialDecay: 0.7).	snd		addEnvelope: (PitchEnvelope exponentialDecay: 0.6).	^ snd		setPitch: 1238		dur: 0.02		loudness: 0.5! !!IRCClientSounds class methodsFor: 'private' stamp: 'sbw 6/8/2004 22:35'!generatePulseSound3	"(IRCClientSounds generatePulseSound3) play"	| snd p |	snd _ FMSound new.	snd		addEnvelope: (VolumeEnvelope exponentialDecay: 0.3).	p _ Array				with: 0 @ 0				with: 100 @ 1.0				with: 250 @ 0.7				with: 400 @ 1.0				with: 500 @ 0.	snd		addEnvelope: (PitchEnvelope				points: p				loopStart: 2				loopEnd: 4).	^ snd		setPitch: 1498		dur: 0.1		loudness: 0.5! !!IRCClientSounds class methodsFor: 'private' stamp: 'sbw 6/11/2004 04:56'!initialize	"IRCClientSounds initialize"	LastSoundTime _ nil.	self initializeSoundsCaches! !!IRCClientSounds class methodsFor: 'private' stamp: 'sbw 6/8/2004 22:37'!initializeSoundsCaches	"IRCClientSounds initializeSoundsCaches"	Sounds _ Dictionary new.	Sounds 		 at: 'pulse1' put: self generatePulseSound1;		 at: 'pulse2' put: self generatePulseSound2;		 at: 'pulse3' put: self generatePulseSound3! !!IRCClientSounds class methodsFor: 'private' stamp: 'sbw 5/27/2004 20:54'!lastSoundTime	^LastSoundTime! !!IRCClientSounds class methodsFor: 'private' stamp: 'sbw 5/27/2004 20:58'!lastSoundTime: aTime	LastSoundTime _ aTime! !!IRCClientSounds class methodsFor: 'private' stamp: 'sbw 6/8/2004 07:01'!playSound: soundMethodSelector	self advanceLastSoundTime.	self perform: soundMethodSelector! !!IRCClientSounds class methodsFor: 'private' stamp: 'sbw 6/11/2004 04:52'!playSoundFor: soundMethodSelector 	(IRCOptionsManagement option: #playSoundOnMessage)		ifFalse: [^ nil].	self lastSoundTime isNil		ifTrue: [self playSound: soundMethodSelector]		ifFalse: [self currentTimeValue > self lastSoundTime				ifTrue: [self playSound: soundMethodSelector]]! !!IRCClientSounds class methodsFor: 'private' stamp: 'sbw 6/8/2004 22:22'!sounds	Sounds isNil ifTrue: [self initializeSoundsCaches].	^Sounds! !!IRCClientSounds class methodsFor: 'API' stamp: 'sbw 6/8/2004 22:16'!channelNickMessageArrived	self playSoundFor: #channelNickMessageSound! !!IRCClientSounds class methodsFor: 'API' stamp: 'sbw 6/8/2004 22:16'!genericPrivateMessageArrived	self playSoundFor: #genericPrivateMessageSound! !!IRCClientSounds class methodsFor: 'API' stamp: 'sbw 6/8/2004 22:17'!specificPrivateMessageArrived	self playSoundFor: #specificPrivateMessageSound! !!IRCClientSounds class methodsFor: 'sound definitions' stamp: 'sbw 6/8/2004 22:36'!channelNickMessageSound	(self sounds at: 'pulse3') play! !!IRCClientSounds class methodsFor: 'sound definitions' stamp: 'sbw 6/8/2004 22:32'!genericPrivateMessageSound	(self sounds at: 'pulse1') play! !!IRCClientSounds class methodsFor: 'sound definitions' stamp: 'sbw 6/8/2004 22:33'!specificPrivateMessageSound	(self sounds at: 'pulse2') play! !!IRCClientSounds class methodsFor: 'read me' stamp: 'sbw 6/10/2004 20:32'!readMe	"To add new sounds, to the following.	Add a new class method to IRCClientSounds.  This method should be called whenever you want to perform your new sound.Note that #playSoundFor: method will check that the sound option for IRC client is enabled, so you do not need to concern yourself with that in your sender method.Create the method that will play your new sound in the 'sound definitions' class method protocol.  By convention, I've been using the same method name prefix as the one defined in the API protocol."! !!IRCConnection methodsFor: 'msg process outgoing new' stamp: 'sbw 5/8/2004 16:50'!acceptConsoleString: aString 	"New message path logic."	^ self sendConsoleString: aString from: self! !!IRCConnection methodsFor: 'msg process outgoing new' stamp: 'sbw 5/8/2004 16:51'!addCrLfAndSendString: aString 	"Handy for diagnostics. We're taking advantage of the fact that the  	outgoing message sender converts all objects to strings first. So we can  	just send a string."	| stream |	stream _ ReadWriteStream on: ''.	stream nextPutAll: aString.	stream nextPut: Character cr.	stream nextPut: Character lf.	^ self sendMessage: stream contents! !!IRCConnection methodsFor: 'msg process outgoing new' stamp: 'sbw 6/20/2004 16:00'!checkLastActionsFor: msg 	| channelName |	msg command = 'join'		ifTrue: [channelName _ msg arguments first.			(IRCOptionsManagement option: #forceChannelsToHaveLeadingPoundSign)				ifTrue: [(channelName beginsWith: '#')						ifFalse: [channelName _ '#' , channelName]].			self openChannelCaptured: channelName]! !!IRCConnection methodsFor: 'msg process outgoing new' stamp: 'sbw 5/8/2004 16:53'!convertCmdToProtocolMessage: aString idString: idString 	| words command rest msg |	words _ aString asString substrings.	command _ words first.	rest _ words size > 1				ifTrue: [aString copyFrom: command size + 2 to: aString size]				ifFalse: [''].	msg _ [IRCProtocolMessage				command: command				arguments: (Array with: idString with: rest asString)] ifError: [:a :b | nil].	^ msg! !!IRCConnection methodsFor: 'msg process outgoing new' stamp: 'sbw 5/8/2004 17:07'!sendChannelString: aString from: observer channelName: cName 	"New message logic."	^self sendString: aString from: observer to: cName! !!IRCConnection methodsFor: 'msg process outgoing new' stamp: 'sbw 6/5/2004 21:38'!sendConsoleString: aString from: observer 	"New message logic."	| result msg |	result := true.	aString isEmpty 		ifFalse: 			[msg := [IRCProtocolMessage fromString: aString asString] 						ifError: [:a :b | nil].			result := msg isNil 						ifTrue: 							[self addToConsole: 'ERROR: Could not decode command: "' , aString , '"' 										, String cr.							false]						ifFalse: 							[msg isLocal 								ifTrue: [self sendLocalMessage: msg from: observer]								ifFalse: 									[self checkLastActionsFor: msg.									self sendMessage: msg]].			result ifTrue: [observer textWasSent: aString]].	^result! !!IRCConnection methodsFor: 'msg process outgoing new' stamp: 'fc 3/7/2005 12:38'!sendLocalMessage: msg from: observer 	| handler |	handler _ self class localMessageHandlers				at: msg command				ifAbsent: [].	handler isNil ifFalse: [		observer perform: handler.		^true		].	^false! !!IRCConnection methodsFor: 'msg process outgoing new' stamp: 'sbw 5/8/2004 17:08'!sendPrivateString: aString from: observer to: talkingTo 	"New message logic."	^self sendString: aString from: observer to: talkingTo! !!IRCConnection methodsFor: 'msg process outgoing new' stamp: 'sbw 6/5/2004 21:38'!sendString: aString from: observer to: idString 	"New message logic."	| result msg |	result := true.	aString isEmpty 		ifFalse: 			[aString asString linesDo: 					[:line | 					result 						ifTrue: 							[line isEmpty ifTrue: [line := ' '].							"Needed to handle blank lines from, e.g., cut 'n' 							paste. "							result := line first = $/ 										ifTrue: 											[msg := self convertCmdToProtocolMessage: line idString: idString.											msg isNil 												ifTrue: [false]												ifFalse: 													[msg isLocal 														ifTrue: [self sendLocalMessage: msg from: observer]														ifFalse: 															[msg isSpecial 																ifTrue: 																	[self 																		privmsgFrom: nil																		to: idString																		text: msg specialConvertedForm]																ifFalse: 																	[self checkLastActionsFor: msg.																	self sendMessage: msg]]]]										ifFalse: 											[self 												privmsgFrom: nil												to: idString												text: line].							result ifTrue: [observer textWasSent: line]]]].	^result! !!IRCConnection methodsFor: 'msg process outgoing new' stamp: 'sbw 5/8/2004 17:09'!textWasSent: aText 	"New message logic."	"We are console here."	self consoleMessagePlayback addMessage: aText.	self addToConsole: 'Command: ' , aText , String cr! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 16:50'!addChannelObserver: obj 	self channelObservers add: obj! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'fc 6/8/2005 21:25'!addModelItemsToWindowMenu: aMenu	"Add model-related item to the window menu"	super addModelItemsToWindowMenu: aMenu. 	aMenu addLine.	aMenu add: 'release notes...' target: IRCConnection action: #releaseNotes ! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 16:52'!channelMembersLoaded: aChannelInfo	(self channelObservers		select: [:each | each channelName = aChannelInfo name])		do: [:obs | obs updateUsers]! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 16:52'!channelObservers	channelObservers isNil ifTrue: [channelObservers _ OrderedCollection new].	^ channelObservers! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 16:52'!channelsBrowser	^channelsBrowser! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 16:52'!channelsBrowser: aIRCChannelListBrowserEnhanced	channelsBrowser _ aIRCChannelListBrowserEnhanced! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 16:52'!channelsBrowserShouldClose	| window coll |	self channelsBrowser isNil		ifTrue: [^ nil].	coll _ self channelsBrowser dependents				select: [:x | x isKindOf: SystemWindow].	coll isEmpty		ifTrue: [^ nil].	window _ coll first.	window isInWorld		ifTrue: [window delete].	self channelsBrowser: nil! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'fc 1/14/2005 20:59'!connectToggle	| reconnect success |	reconnect := false.	success := true.	self connected		ifTrue: [self manualDisconnect.			^false]		ifFalse: [dropped isNil				ifFalse: [dropped						ifTrue: [reconnect := true]].			dropped := false.			success := self connect.			reconnect				ifTrue: [self reconnectBecauseDropped]].	^ success! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/29/2004 06:57'!connected	^ socket ~~ nil		and: [socket isConnected]! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 16:53'!consoleMessagePlayback	consoleMessagePlayback == nil		ifTrue: [consoleMessagePlayback _ IRCMessagePlayback new].	^ consoleMessagePlayback! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/23/2004 13:31'!firstTimePromptsCheck	| success |	success := true.	self nick = IRCConnectionProfile defaultDefaultNick		ifTrue: [self inform: 'No default profile values were found.  You will be prompted for a few parameters and then the window will open.  If you choose cancel at any of these prompts, the IRC browser cannot be launched.You should only be asked these questions once.'.			success := IRCConnectionProfile initializeDefaultsPrompted.			success				ifTrue: [self loadProfile: IRCConnectionProfile default]].	^ success! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 6/3/2004 21:56'!loadProfile: anIRCConnectionProfile 	"Don't do this while connected."	self connected		ifTrue: [^ nil].	IRCOptionsManagement populateOptionsFromProfile: anIRCConnectionProfile.	self server: anIRCConnectionProfile server address;		 portAsString: anIRCConnectionProfile server port asString;		 nick: anIRCConnectionProfile nick;		 userName: anIRCConnectionProfile userName;		 fullName: anIRCConnectionProfile fullName.	self changed: #server;		 changed: #portAsString;		 changed: #nick;		 changed: #userName;		 changed: #fullName.	self updateGuiNick! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 16:56'!manualDisconnect	self quit.	dropped _ nil.	self disconnect.	self closeTabs.! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 16:56'!msgObserver	^msgObserver! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 16:56'!msgObserver: aIRCDirectMessagesObserver	msgObserver _ aIRCDirectMessagesObserver! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 16:56'!msgObserverShouldClose	| window coll |	self msgObserver isNil		ifTrue: [^ nil].	coll _ self msgObserver dependents				select: [:x | x isKindOf: SystemWindow].	coll isEmpty		ifTrue: [^ nil].	window _ coll first.	window isInWorld		ifTrue: [window delete].	self msgObserver: nil! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 18:48'!newConsole	"This is attached to the new console button. One difference between  	doing this and just opening up a new console from the World menu is  	that this action will copy the options forward."	| consoleModel |	consoleModel := self class new.	consoleModel openWindows! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 6/5/2004 15:57'!openChannelCaptured: aString 	| observer |	observer _ IRCChannelObserver openForChannelNamed: aString onCaptiveConnection: self.	self addChannelObserver: observer;		 recentChannelName: aString! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/23/2004 13:28'!openWindows	| success |	success := self firstTimePromptsCheck.	success		ifTrue: [self openView; openDirectMessagesObserver]		ifFalse: [self inform: 'Open could not continue.']! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 16:59'!port	^port! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 16:59'!portAsStringButton	"From dialog"	^ self! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'fc 3/9/2005 12:48'!quitMessage	^'Using  Squeak Enhanced IRC client - IRCe. (See http://www.squeak.org)'! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 08:09'!reconnectBecauseDropped	"The user has manually reconnected us because of a server connection  	drop. See if we can restore some things."	| panes |	panes := gui allSwappedPaneNamesWithModels.	panes		do: [:each | 			(each isKindOf: IRCChannelObserver)				ifTrue: [self reconnectChannelChat: each].			(each isKindOf: IRCDirectMessagesObserver)				ifTrue: [self reconnectPrivateChat: each]]! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 17:07'!reconnectChannelChat: model 	model reconnect! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 17:07'!reconnectPrivateChat: model 	model class privateMessagesLabel.! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 17:07'!removeChannelObserver: obj 	self channelObservers remove: obj ifAbsent: [nil]! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 17:08'!serverButton! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'fc 6/16/2005 10:15'!spawn: aMessage	"sent by text morph when user blue-mouse clicks."	self newConsole! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/8/2004 17:08'!subscribedChannelsHavingMemberNamed: aString 	^	subscribedChannels select: [:channel | channel hasMember: aString]! !!IRCConnection methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 08:09'!talkTo: user 	user isNil		ifTrue: [^ self].	^ IRCDirectMessagesObserver openForConnection: self talkingTo: user! !!IRCConnection methodsFor: 'console text management' stamp: 'sbw 6/7/2004 22:43'!addToConsole: aText 	| |	consoleTextLines add: aText.	self changed: #consoleText! !!IRCConnection methodsFor: 'console text management' stamp: 'sbw 6/7/2004 22:44'!clearTextPane	consoleTextLines clear.	self changed: #consoleText! !!IRCConnection methodsFor: 'console text management' stamp: 'sbw 6/7/2004 22:45'!consoleText	^ consoleTextLines text! !!IRCConnection methodsFor: 'console text management' stamp: 'fc 10/10/2005 15:57'!initializeConsoleText	consoleTextLines _ IRCTextLines new initialize! !!IRCConnection methodsFor: 'factored swapper' stamp: 'sbw 5/8/2004 16:51'!alreadyShowingPrivateMessagesFrom: aNick 	^ gui alreadyShowingPrivateMessagesFrom: aNick! !!IRCConnection methodsFor: 'factored swapper' stamp: 'sbw 5/8/2004 16:52'!closeTabs	"Close all the closeable tabs."	gui closeTabs! !!IRCConnection methodsFor: 'factored swapper' stamp: 'sbw 5/8/2004 16:54'!frontMost	^ gui frontMost! !!IRCConnection methodsFor: 'factored swapper' stamp: 'sbw 5/8/2004 16:54'!frontMostPaneIsCloseable	^ gui frontMostPaneIsCloseable! !!IRCConnection methodsFor: 'factored swapper' stamp: 'sbw 5/8/2004 16:54'!gui	^gui! !!IRCConnection methodsFor: 'factored swapper' stamp: 'sbw 5/8/2004 16:59'!possibleTabStateChange: paneName 	gui possibleTabStateChange: paneName! !!IRCConnection methodsFor: 'UI' stamp: 'sbw 5/29/2004 06:09'!assignAsGui: someView	gui _ someView.	self subscribeToProtocolMessages: self.! !!IRCConnection methodsFor: 'UI' stamp: 'sbw 6/2/2004 23:07'!consoleMenu: menu 	^ self gui consoleMenu: menu! !!IRCConnection methodsFor: 'UI' stamp: 'fc 10/7/2005 15:27'!consoleTextSelection	| size |	size _ self consoleText size.	^size+1 to: size! !!IRCConnection methodsFor: 'UI' stamp: 'sbw 5/30/2004 10:09'!inform: aString 	self gui isNil		ifFalse: [self gui inform: aString]! !!IRCConnection methodsFor: 'UI' stamp: 'sbw 5/30/2004 10:07'!informUser: aString during: aBlock 	self gui isNil ifFalse: [self gui informUser: aString during: aBlock]! !!IRCConnection methodsFor: 'UI' stamp: 'sbw 5/13/2004 07:21'!openChannelList	"open a view on the list of channels"	self channelsBrowser isNil		ifTrue: [self				channelsBrowser: (IRCChannelListBrowser openForCaptiveConnection: self)]		ifFalse: [gui showPaneNamed: IRCChannelListBrowser tabbedPaneName]! !!IRCConnection methodsFor: 'UI' stamp: 'sbw 5/13/2004 08:08'!openDirectMessagesObserver	self		msgObserver: (IRCDirectMessagesObserver openForConnection: self)! !!IRCConnection methodsFor: 'UI' stamp: 'sbw 5/9/2004 21:01'!openView	gui := IRCMainWindow labelled: IRCMainWindow baseWindowTitle.	gui model: self.	gui buildMorphicWindow.	self subscribeToProtocolMessages: self.	gui openInWorld! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/4/1998 23:36'!release	super release.	self disconnect.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/4/1998 18:06'!subscribeToDirectMessages: anObject	"send all messages directly to the user's nick to anObject.  anObject must implemented #ircMessageReceieved:"	directMessageSubscribers add: anObject.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/15/1998 06:30'!subscribeToProtocolMessages: anObject	"anObject should respond to #ircProtocolMessage:.  It will be sent all incoming messages"	protocolMessageSubscribers add: anObject! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/5/1998 00:38'!unsubscribe: anObject fromChannel: channelName	"see subscribe:toChannel:"	|  lChannelName info |	lChannelName _ channelName asIRCLowercase.	info _ subscribedChannels at: lChannelName ifAbsent: [ ^self ].	info unsubscribe: anObject.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/5/1998 00:10'!unsubscribeFromDirectMessages: anObject 	"see #subscribeFromDirectMessages:"	directMessageSubscribers remove: anObject ifAbsent: []! !!IRCConnection methodsFor: 'server info' stamp: 'sbw 5/13/2004 07:27'!channelInfo: channelName 	"return cached info on a channel"	| lChannelName |	lChannelName := channelName asIRCLowercase.	^ subscribedChannels		at: lChannelName		ifAbsent: ["no info available--create and return a skeleton"			subscribedChannels				at: lChannelName				put: (IRCChannelInfo forChannelNamed: channelName onConnection: self)]! !!IRCConnection methodsFor: 'server info' stamp: 'ls 9/2/1998 23:35'!channelList	"returns the list of channels, or nil if it hasn't been retrieved yet"	^channelList! !!IRCConnection methodsFor: 'server info' stamp: 'sbw 3/10/2005 21:44'!channelList: aCollection	channelList _ aCollection! !!IRCConnection methodsFor: 'server info' stamp: 'sbw 3/11/2005 19:16'!filteredChannelList: anIRCChannelFilter 	self channelList isNil ifTrue: [^nil].	^ anIRCChannelFilter isNil		ifTrue: [self channelList]		ifFalse: [anIRCChannelFilter filter: self channelList]! !!IRCConnection methodsFor: 'server info' stamp: 'ls 9/2/1998 23:18'!motd	"return the most recently seen Message of the Day, or nil if none has been seen yet"	^motd! !!IRCConnection methodsFor: 'keys intercept management' stamp: 'sbw 5/8/2004 16:52'!checkForScrollPlaybackDownOn: morph 	| previous |	self consoleMessagePlayback rollIndexForward.	previous _ self consoleMessagePlayback getIndexedMessage.	previous isNil		ifFalse: [morph setText: previous.			morph				setSelection: (previous size + 1 to: previous size + 1).			morph hasUnacceptedEdits: true].	^ false! !!IRCConnection methodsFor: 'keys intercept management' stamp: 'sbw 5/8/2004 16:52'!checkForScrollPlaybackUpOn: morph 	| previous |	previous _ self consoleMessagePlayback getIndexedMessage.	self consoleMessagePlayback rollIndexBack.	previous isNil		ifFalse: [morph setText: previous.			morph				setSelection: (previous size + 1 to: previous size + 1).			morph hasUnacceptedEdits: true].	^ false! !!IRCConnection methodsFor: 'keys intercept management' stamp: 'sbw 5/8/2004 16:56'!keyInterceptEndedFrom: morph 	self consoleMessagePlayback resetIndex! !!IRCConnection methodsFor: 'keys intercept management' stamp: 'sbw 6/4/2004 06:32'!keyInterceptedEvent: evt morph: morph 	"Answer true if we want the pane to have the event anyway.  	There are 3 classes involved here.  	TextMorphForInterceptingIRCEditView intercepts the keystrokes.  	PluggableInterceptingIRCTextMorph is the morph holding the text.  	IRCConnection (this class) decides what to do with  	the intercepts.  	Once an intercept is tripped we will recieve ALL keystrokes until we  	tell the text morph #clearInterceptActive"	| char |	char := evt keyCharacter.	char = Character arrowUp		ifTrue: [^ self checkForScrollPlaybackUpOn: morph].	char = Character arrowDown		ifTrue: [^ self checkForScrollPlaybackDownOn: morph].	self keyInterceptEndedFrom: morph.	^ true! !!IRCConnection methodsFor: 'network IO' stamp: 'sbw 5/30/2004 23:10'!checkSocketStatusFromPollingLoop	(socket isNil			or: [socket isValid not					or: [socket isConnected not]])		ifTrue: [dropped isNil				ifFalse: [dropped						ifFalse: [dropped := true]].			^ false].	^true! !!IRCConnection methodsFor: 'network IO' stamp: 'sbw 6/3/2004 19:58'!connect	"connect to a server"	| success |	success := self connectToSever.	success		ifFalse: [^ false].	self		sendMessage: (IRCProtocolMessage fromString: 'NICK ' , nick).	self		sendMessage: (IRCProtocolMessage fromString: 'USER ' , userName , ' * * :' , fullName).	^ success! !!IRCConnection methodsFor: 'network IO' stamp: 'sbw 3/10/2005 20:22'!connectToSever	"Connect to a server. Answers true/false"	| addr |	Socket initializeNetwork.	socket		ifNotNil: [socket destroy].	self reset.	addr := NetNameResolver addressForName: server.	addr		ifNil: [^ false].	socket := Socket new.	socket connectTo: addr port: port.	^ true! !!IRCConnection methodsFor: 'network IO' stamp: 'sbw 5/29/2004 06:38'!disconnect	"disconnect from the server"	socket		ifNotNil: [socket isValid				ifTrue: [					socket close]].	socket := nil.	self topView isNil		ifFalse: [self topView setLabel: IRCMainWindow baseWindowTitle]! !!IRCConnection methodsFor: 'network IO' stamp: 'fc 1/12/2005 13:16'!emptyOutProtocolMessagesToSend	| amount |	[socket sendDone		and: [sendBuffer isNil not				or: [protocolMessagesToSend size > 0]]]		whileTrue: [sendBuffer				ifNil: [protocolMessagesToSend isEmpty						ifFalse: [sendBuffer := protocolMessagesToSend removeFirst asString ]].			sendBuffer				ifNotNil: [IRCConnection trace: 'sendBufer: "' , sendBuffer , '"'.					amount := socket sendSomeData: sendBuffer.					sendBuffer := sendBuffer copyFrom: amount + 1 to: sendBuffer size.					sendBuffer isEmpty						ifTrue: [sendBuffer := nil]]]! !!IRCConnection methodsFor: 'network IO' stamp: 'fc 1/12/2005 13:17'!populateReceiveBufferFromPollingLoop	| idx messageText message |	[socket dataAvailable]		whileTrue: [recieveBuffer := recieveBuffer , socket receiveData ].	"parse as many messages as possible"	[idx := recieveBuffer indexOf: Character lf.	idx > 0]		whileTrue: [messageText := recieveBuffer copyFrom: 1 to: idx.			IRCConnection trace: 'rcvd message: "' , messageText , '"'.			message := IRCProtocolMessage fromString: messageText.			self processMessage: message.			recieveBuffer := recieveBuffer copyFrom: idx + 1 to: recieveBuffer size]! !!IRCConnection methodsFor: 'network IO' stamp: 'sbw 6/3/2004 20:16'!processIO	"do as much network IO as is immediately possible"	"do nothing if the socket isn't ready for work"	"THIS IS A POLLING LOOP DRIVEN BY MORPHIC'S STEP ENGINE."	self updateGuiConnectStatusFromPollingLoop.	self checkSocketStatusFromPollingLoop		ifFalse: [^ self].	"first do sending"	self emptyOutProtocolMessagesToSend.	"now do receiving"	self populateReceiveBufferFromPollingLoop! !!IRCConnection methodsFor: 'network IO' stamp: 'sbw 6/5/2004 17:07'!sendMessage: aMessage 	"queue a message for sending"	protocolMessagesToSend addLast: aMessage.	^ true! !!IRCConnection methodsFor: 'network IO' stamp: 'sbw 5/30/2004 23:01'!updateGuiConnectStatusFromPollingLoop	gui isNil		ifFalse: [self connected				ifTrue: [gui updateButtonNamed: 'connect' newTag: 'disconnect']				ifFalse: [gui updateButtonNamed: 'connect' newTag: 'connect']].! !!IRCConnection methodsFor: 'network IO' stamp: 'sbw 6/3/2004 21:54'!updateGuiNick	gui isNil		ifFalse: [gui updateNickLabel]! !!IRCConnection methodsFor: 'IRC commands' stamp: 'sbw 6/10/2004 20:18'!docs	IRCConnection showDocs! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 21:59'!join: channelName	"join a channel"	self sendMessage: (IRCProtocolMessage		command: 'join'		arguments: (Array with: channelName))! !!IRCConnection methodsFor: 'IRC commands' stamp: 'sbw 5/8/2004 16:56'!leave: channelName 	"leave a channel"	self		sendMessage: (IRCProtocolMessage				command: 'part'				arguments: (Array with: channelName with: self quitMessage))! !!IRCConnection methodsFor: 'IRC commands' stamp: 'fc 3/7/2005 21:41'!playlist! !!IRCConnection methodsFor: 'IRC commands' stamp: 'sbw 5/8/2004 16:59'!privmsgFrom: from to: to text: text 	"send a private message. 'to' can be a channel name...."	| msg |	msg := IRCProtocolMessage				prefix: from				command: 'privmsg'				arguments: (Array with: to with: text).	"sbw - The next line is to force behavior as if we received the message  	we will send. This is because these PRIVMSGs are not echoed back to us."	self processMessage: msg.	^ self sendMessage: msg! !!IRCConnection methodsFor: 'IRC commands' stamp: 'sbw 5/8/2004 17:06'!quit	"tell the server we are leaving"	"self addCrLfAndSendString: 'QUIT :' , self quitMessage."	self		sendMessage: (IRCProtocolMessage				command: 'quit'				arguments: (Array with: self quitMessage))! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 23:36'!requestChannelList	"request a list of all channels"	self sendMessage: (IRCProtocolMessage command: 'list')! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 23:18'!requestMotd	self sendMessage: (IRCProtocolMessage command: 'motd')! !!IRCConnection methodsFor: 'IRC commands' stamp: 'sbw 6/2/2004 09:59'!traceOff	IRCConnection tracing: false! !!IRCConnection methodsFor: 'IRC commands' stamp: 'sbw 6/2/2004 10:00'!traceOn	IRCConnection tracing: true! !!IRCConnection methodsFor: 'private' stamp: 'fc 3/3/2005 14:26'!endOfURL: urlTextOrString startingAt: urlStart	|   urlEnd urlString |	urlString _ urlTextOrString asString.	urlEnd _  urlString asString findString: ' ' startingAt: urlStart.	urlEnd == 0		ifTrue: [urlEnd _  urlString size ]		ifFalse: [urlEnd _ urlEnd - 1].	(urlString at: urlEnd) isSeparator ifTrue: [urlEnd _ urlEnd - 1].	urlEnd to: urlStart by: -1 do: [ :index |		#($] $) $. $, $> $? $" $' ) detect: [:each | each == (urlString at: index)] ifNone: [^index ].	].	^urlEnd ! !!IRCConnection methodsFor: 'private' stamp: 'sbw 3/10/2005 20:23'!initialize	ExternalIRCFiles initialize.	IRCConnection tracing: false.	self reset.	self initializeFromDefaults.	directMessageSubscribers := IdentitySet new.	protocolMessageSubscribers := IdentitySet new.	self initializeConsoleText.	channelObservers := OrderedCollection new.! !!IRCConnection methodsFor: 'private' stamp: 'sbw 5/22/2004 20:33'!initializeFromDefaults	IRCConnectionProfile default.	server := IRCConnectionProfile defaultServer.	port := IRCConnectionProfile defaultPort.	nick := IRCConnectionProfile defaultNick.	userName := IRCConnectionProfile defaultUserName.	fullName := IRCConnectionProfile defaultFullName! !!IRCConnection methodsFor: 'private' stamp: 'fc 3/3/2005 14:28'!markIfURL: messageTextOrString startingAt: start	|  messageText urlStart urlEnd |	messageText _ messageTextOrString asText.	urlStart _ messageText findString: 'http://' startingAt: start caseSensitive: false.	urlStart  == 0		ifTrue: [^messageText].	urlEnd _ self endOfURL: messageText startingAt: urlStart.	messageText addAttribute: 		(TextURL new url: ((messageText copyFrom: urlStart to: urlEnd) asString)) from: urlStart to: urlEnd.	^self markIfURL: messageText startingAt: urlEnd! !!IRCConnection methodsFor: 'private' stamp: 'sbw 5/17/2004 21:18'!nickIsNil	^nick isNil! !!IRCConnection methodsFor: 'private' stamp: 'sbw 3/10/2005 21:45'!reset	"prepare for a new connection"	recieveBuffer := String new.	protocolMessagesToSend := OrderedCollection new.	sendBuffer := nil.	socket := nil.	self channelList: nil.	channelListBeingBuilt := nil.	motd := nil.	motdBeingBuilt := nil.	subscribedChannels := Dictionary new! !!IRCConnection methodsFor: 'private' stamp: 'ls 9/4/1998 23:22'!step	self processIO! !!IRCConnection methodsFor: 'private' stamp: 'di 1/14/1999 09:12'!wantsSteps	^ true! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:04'!fullName	^fullName! !!IRCConnection methodsFor: 'access' stamp: 'sbw 5/16/2004 08:00'!fullName: aString 	fullName := aString asString.	^true! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/2/1998 18:23'!nick	^nick ifNil: [ '(not set)' ]! !!IRCConnection methodsFor: 'access' stamp: 'sbw 5/22/2004 20:56'!nick: aString 	nick := aString asString.	^ true! !!IRCConnection methodsFor: 'access' stamp: 'sbw 3/10/2005 20:24'!port: aNumber	port _ aNumber.	^true! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/2/1998 18:24'!portAsString	^port printString! !!IRCConnection methodsFor: 'access' stamp: 'sbw 5/22/2004 20:56'!portAsString: aString 	port := aString asString asNumber.	^ true! !!IRCConnection methodsFor: 'access' stamp: 'sbw 5/23/2004 12:45'!recentChannelName	^recentChannelName! !!IRCConnection methodsFor: 'access' stamp: 'sbw 5/23/2004 12:45'!recentChannelName: aString	recentChannelName _ aString! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/2/1998 18:23'!server	^server ifNil: [ '(not set)' ]! !!IRCConnection methodsFor: 'access' stamp: 'sbw 5/22/2004 20:56'!server: aString 	server := aString asString.	^ true! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:04'!userName	^userName! !!IRCConnection methodsFor: 'access' stamp: 'sbw 5/22/2004 20:57'!userName: aText 	userName := aText asString.	^ true! !!IRCConnection methodsFor: 'naval mode' stamp: 'sbw 6/8/2004 22:44'!ircMessageRecieved: aMessage 	| sender newLine |	sender _ aMessage sender				ifNil: [self nick].	sender _ IRCProtocolMessage cleanSenderString: sender.	newLine _ (Text				string: sender				emphasis: (Array with: TextEmphasis bold))				, ': ' , aMessage text , String cr.	IRCClientSounds genericPrivateMessageArrived.	self addToConsole: newLine.	self possibleTabStateChange: IRCDirectMessagesObserver privateMessagesLabel! !!IRCConnection methodsFor: 'naval mode' stamp: 'sbw 5/13/2004 19:24'!ircProtocolMessage: msg 	"a new message. log it on the console, unless it's a channel listing"	(msg command ~= IRCMessagePattern RPLList printString			and: [msg command ~= IRCMessagePattern RPLMotd])		ifTrue: [self addToConsole: msg asString]! !!IRCConnection methodsFor: 'private-message handling' stamp: 'sbw 5/8/2004 17:00'!processChannelList: aMessage 	"an item has arrived in the list of channels"	| chanName chanNumUsers chanTopic |	aMessage arguments size < 4		ifTrue: [^ self].	chanName := aMessage arguments at: 2.	chanNumUsers := (aMessage arguments at: 3) asNumber.	chanTopic := aMessage arguments at: 4.	chanName = '*'		ifTrue: [^ self].	channelListBeingBuilt		ifNil: [channelListBeingBuilt := OrderedCollection new].	channelListBeingBuilt		add: (IRCChannelSummary				name: chanName				numUsers: chanNumUsers				topic: chanTopic).	self channelsBrowser isNil		ifFalse: [self channelsBrowser channelListDownloading: channelListBeingBuilt size]! !!IRCConnection methodsFor: 'private-message handling' stamp: 'sbw 3/14/2005 21:49'!processChannelListEnd: aMessage 	"a complete channel listing has arrived"	"end of a channel listing"	aMessage isNil		ifTrue: [^ nil].	channelListBeingBuilt isNil ifFalse: [		self channelList: channelListBeingBuilt asArray].	channelListBeingBuilt := nil.	self changed: #channelList.	self channelsBrowser isNil		ifFalse: [self channelsBrowser channelListDownloadCompleted]! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:37'!processChannelListStart: aMessage	"start of a channel listing"	channelListBeingBuilt _ OrderedCollection new.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'sbw 5/27/2004 19:20'!processJoin: aMessage 	"a user is joining a channel"	| channelName user textMessage |	channelName := aMessage arguments first.	user := aMessage prefix.	(user includes: $!!)		ifTrue: [user := user copyFrom: 1 to: (user indexOf: $!!)							- 1].	(self channelInfo: channelName)		addMember: user.	(self channelObservers		select: [:each | each channelName = channelName])		do: [:obs | obs updateUsers].	user = self nick		ifTrue: [^ nil].	(IRCOptionsManagement option: #showJoinsInChannel)		ifTrue: [textMessage := user , ' has joined the channel.'.			self				sendString: textMessage				withNickTag: self serverPrefixMessageNick				ifFrontChannelObserverIs: channelName]! !!IRCConnection methodsFor: 'private-message handling' stamp: 'fc 1/20/2005 19:08'!processMessage: aMessage 	| handler |		protocolMessageSubscribers		do: [:subscriber | subscriber ircProtocolMessage: aMessage].	handler _ self class messageHandlers				at: aMessage command				ifAbsent: [].	handler		ifNil: [^ self].	^ self perform: handler with: aMessage! !!IRCConnection methodsFor: 'private-message handling' stamp: 'fc 3/3/2005 14:02'!processMotd: aMessage	"a new line has arrived for the MOTD"	motdBeingBuilt nextPutAll:  (self markIfURL:  (aMessage arguments second) startingAt: 1).	motdBeingBuilt cr.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:36'!processMotdEnd: aMessage	"the whole MOTD has arrived"	motd _ motdBeingBuilt contents.	motdBeingBuilt _ nil.	self changed: #motd.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'fc 1/20/2005 20:04'!processMotdStart: aMessage	"MOTD is being transmitted"	motdBeingBuilt _ TextStream on: Text new.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'fc 1/18/2005 16:25'!processNamReply: aMessage 	"list of names for a channel, probably a channel being joined"	| names lChannelName channelInfo channelMembers channelMember |	lChannelName := (aMessage arguments at: 3) asIRCLowercase.	channelMembers := OrderedCollection new.	names := aMessage arguments last findTokens: ' '.	names		do: [:origName | 			channelMember := IRCChannelMember fromString: origName.			channelMember channel: lChannelName.			channelMembers add: channelMember].	channelInfo := subscribedChannels				at: lChannelName				ifAbsent: [].	channelInfo		ifNotNil: [channelInfo addMembers: channelMembers]! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 10:07'!processNoTopic: aMessage	"remove a channel's topic"	(self channelInfo: (aMessage arguments at: 2)) topic: ''! !!IRCConnection methodsFor: 'private-message handling' stamp: 'sbw 5/27/2004 19:20'!processPart: aMessage 	"a user is leaving a channel"	| channelName user textMessage |	channelName := aMessage arguments first.	user := aMessage prefix.	(user includes: $!!)		ifTrue: [user := user copyFrom: 1 to: (user indexOf: $!!)							- 1].	(self channelInfo: channelName)		removeMember: user.	(self channelObservers		select: [:each | each channelName = channelName])		do: [:obs | obs updateUsers].	(IRCOptionsManagement option: #showPartsInChannel)		ifTrue: [textMessage := user , ' has left the channel.  '.			aMessage arguments size > 1				ifTrue: [textMessage := textMessage								, (aMessage arguments at: 2)].			self				sendString: textMessage				withNickTag: self serverPrefixMessageNick				ifFrontChannelObserverIs: channelName]! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/15/1998 06:35'!processPing: aMessage	"ping request"	self sendMessage: (IRCProtocolMessage command: 'pong' arguments: aMessage arguments).! !!IRCConnection methodsFor: 'private-message handling' stamp: 'fc 3/7/2005 13:11'!processPrivmsg: aMessage 	"handle a PRIVMSG or NOTICE message"	"put together the message"	| sender recipient text privMessage aChannelInfo |	sender _ aMessage prefix.	recipient _ aMessage arguments at: 1.	text _ aMessage arguments at: 2.	privMessage _ IRCMessage				sender: sender				recipient: recipient				text: text.	"If the recipient is a channel name, broadcast the message to all  	channel subscribers."	aChannelInfo _ subscribedChannels				at: recipient asIRCLowercase				ifAbsent: [].	aChannelInfo		ifNotNil: [aChannelInfo subscribers				do: [:sub | sub ircMessageRecieved: privMessage].			^ self].	"If the recipient is a nick, or if the message did not originate from a user,	broadcast to all private message subscribers."	(recipient asIRCLowercase = nick asIRCLowercase			or: [sender isNil])		ifTrue: ["We need to do a copy here before we start looping since the  			collection size can grow while we are processing."			directMessageSubscribers copy				do: [:sub | sub ircMessageRecieved: privMessage]]! !!IRCConnection methodsFor: 'private-message handling' stamp: 'fc 3/3/2005 14:27'!processQuit: aMessage 	"a user has left IRC. Remove them from all chanels"	| user textMessage |	user _ aMessage prefix.	(user includes: $!!)		ifTrue: [user _ user copyFrom: 1 to: (user indexOf: $!!)							- 1].	subscribedChannels		do: [:channel | (channel hasMember: user)				ifTrue: [channel removeMember: user]].	self channelObservers		do: [:obs | obs updateUsers].	(IRCOptionsManagement option: #showQuitsInChannel)		ifTrue: [textMessage _ user , ' has quit IRC.'.			aMessage arguments isEmpty ifFalse: [				textMessage _ textMessage, '  '						, (self markIfURL: (aMessage arguments at: 1) startingAt: 1)].			self				sendString: textMessage				withNickTag: self serverPrefixMessageNick				ifFrontChannelObserverIs: nil]! !!IRCConnection methodsFor: 'private-message handling' stamp: 'fc 3/3/2005 14:03'!processTopic: aMessage 	"change a channel topic"	| args |	args := aMessage arguments.	args size < 2 		ifTrue: 			["malformed message"			^self].	(self channelInfo: (args at: args size - 1)) 		topic: (self markIfURL: (args at: args size) startingAt: 1)! !!IRCConnection methodsFor: 'msg process incoming' stamp: 'sbw 5/8/2004 17:03'!processChannelsServerLoadTooHigh: aMessage 	self processChannelListEnd: nil.	self channelsBrowser isNil		ifFalse: [self channelsBrowser channelListDownloadAborted]! !!IRCConnection methodsFor: 'msg process incoming' stamp: 'sbw 5/8/2004 17:03'!processEndOfWhoIs: aMessage ! !!IRCConnection methodsFor: 'msg process incoming' stamp: 'sbw 5/29/2004 06:41'!processIdleTime: aMessage 	| string |	string := IRCProtocolMessage extractIdleTimeStringFromProtocolMessage: aMessage.	self		sendString: string		withNickTag: self serverPrefixMessageNick		ifFrontChannelObserverIs: nil! !!IRCConnection methodsFor: 'msg process incoming' stamp: 'sbw 5/27/2004 19:20'!processInvite: aMessage 	"a user is inviting us to join a channel"	| channelName user observer |	(IRCOptionsManagement option: #acceptChannelInvites)		ifFalse: [^ nil].	channelName := aMessage arguments second.	user := aMessage prefix.	(user includes: $!!)		ifTrue: [user := user copyFrom: 1 to: (user indexOf: $!!)							- 1].	observer := IRCChannelObserver openForChannelNamed: channelName onCaptiveConnection: self.	(self channelInfo: channelName)		addMember: self nick.	self addChannelObserver: observer.	observer addTextToChannelPane: user , ' has invited you to this channel.' , Character cr asString usingUnpreparedNick: self serverPrefixMessageNick;		 updateUsers! !!IRCConnection methodsFor: 'msg process incoming' stamp: 'sbw 5/27/2004 19:20'!processMode: aMessage 	| channelName memberName modeVerb modeChange textMessage user |	channelName := aMessage arguments at: 1.	modeChange := aMessage arguments at: 2.	('vo' includes: modeChange second)		ifFalse: [^ nil].	memberName := aMessage arguments at: 3.	user := aMessage prefix.	(user includes: $!!)		ifTrue: [user := user copyFrom: 1 to: (user indexOf: $!!)							- 1].	modeVerb := 'modified status for'.	modeChange = '+v'		ifTrue: [modeVerb := 'voiced'].	modeChange = '-v'		ifTrue: [modeVerb := 'un-voiced'].	modeChange = '+o'		ifTrue: [modeVerb := 'opped'].	modeChange = '-o'		ifTrue: [modeVerb := 'de-opped'].	(self channelInfo: channelName)		modeChanged: modeChange		forMemberNamed: memberName.	(self channelObservers		select: [:each | each channelName asIRCLowercase = channelName asIRCLowercase])		do: [:obs | obs updateUsers].	(IRCOptionsManagement option: #showModeChangesInChannel)		ifTrue: [textMessage := user , ' has ' , modeVerb , ' ' , memberName , '.'.			self				sendString: textMessage				withNickTag: self serverPrefixMessageNick				ifFrontChannelObserverIs: channelName]! !!IRCConnection methodsFor: 'msg process incoming' stamp: 'sbw 5/8/2004 17:05'!processNickChanged: aMessage 	| newNick user channelName textMessage |	newNick _ aMessage arguments first.	user _ aMessage prefix.	(user includes: $!!)		ifTrue: [user _ user copyFrom: 1 to: (user indexOf: $!!)							- 1].	(self subscribedChannelsHavingMemberNamed: user)		do: [:chanInfo | 			chanInfo nickFor: user changedTo: newNick.			channelName _ chanInfo name.			(self channelObservers				select: [:each | each channelName = channelName])				do: [:obs | 					obs updateUsers.					textMessage _ 'User ' , user , ' has changed nick to: ' , newNick.					self						sendString: textMessage						withNickTag: self serverPrefixMessageNick						ifFrontChannelObserverIs: channelName]].	user = nick ifTrue: [self nick: newNick]! !!IRCConnection methodsFor: 'msg process incoming' stamp: 'sbw 5/29/2004 06:41'!processNickIdentified: aMessage 	| string |	string := IRCProtocolMessage extractNickIdentifiedStringFromProtocolMessage: aMessage.	self		sendString: string		withNickTag: self serverPrefixMessageNick		ifFrontChannelObserverIs: nil! !!IRCConnection methodsFor: 'msg process incoming' stamp: 'sbw 5/29/2004 06:42'!processReplyAway: aMessage 	| string |	string := IRCProtocolMessage extractReplyAwayStringFromProtocolMessage: aMessage.	self		sendString: string		withNickTag: self serverPrefixMessageNick		ifFrontChannelObserverIs: nil! !!IRCConnection methodsFor: 'msg process incoming' stamp: 'sbw 5/29/2004 06:43'!processReplyWhoIsServer: aMessage 	| string |	string := IRCProtocolMessage extractWhoIsServerStringFromProtocolMessage: aMessage.	self		sendString: string		withNickTag: self serverPrefixMessageNick		ifFrontChannelObserverIs: nil! !!IRCConnection methodsFor: 'msg process incoming' stamp: 'sbw 5/29/2004 06:44'!processReplyWhoIsUser: aMessage 	| string |	string := IRCProtocolMessage extractWhoIsUserStringFromProtocolMessage: aMessage.	self		sendString: string		withNickTag: self serverPrefixMessageNick		ifFrontChannelObserverIs: nil! !!IRCConnection methodsFor: 'msg process incoming' stamp: 'sbw 5/29/2004 06:43'!processWhoIsChannels: aMessage 	| string |	string := IRCProtocolMessage extractWhoIsChannelsStringFromProtocolMessage: aMessage.	self		sendString: string		withNickTag: self serverPrefixMessageNick		ifFrontChannelObserverIs: nil! !!IRCConnection methodsFor: 'msg process incoming' stamp: 'sbw 5/13/2004 08:09'!sendString: aString withNickTag: nickTag ifFrontChannelObserverIs: channelName 	"Utility method. If you don't know the channelName just use nil."	| frontModel |	self frontMost isNil		ifTrue: [^ nil].	self frontMost externalName = 'console'		ifTrue: [^ nil].	channelName isNil		ifFalse: [self frontMost externalName asIRCLowercase = channelName asIRCLowercase				ifFalse: [^ nil]].	(self frontMost hasProperty: #swapModel)		ifFalse: [^ nil].	frontModel := self frontMost valueOfProperty: #swapModel.	(frontModel isKindOf: IRCChannelObserver)		ifTrue: [frontModel addTextToChannelPane: aString , Character cr asString usingUnpreparedNick: nickTag].	(frontModel isKindOf: IRCDirectMessagesObserver)		ifTrue: [frontModel addToChatText: aString , Character cr asString]! !!IRCConnection methodsFor: 'msg process incoming' stamp: 'sbw 5/8/2004 17:08'!serverPrefixMessageNick	"This is the prefix we use when posting messages from the server."	^'***'! !!IRCConnection methodsFor: 'menu' stamp: 'sbw 5/8/2004 17:08'!talkTo	"talk to some user using 1-to-1 chat messages"	| user |	user := FillInTheBlank request: 'user to talk to'.	user := user withBlanksTrimmed.	user isEmpty		ifTrue: [^ self].	self talkTo: user! !!IRCConnection commentStamp: '<historical>' prior: 0!A connection to an IRC server.  This handles spooling messages in and out, and converts between network commands and more convenient data structures.Start up an instance along with an interface with:		IRCConnection new openView<tabs> holds a Set of pane names that are being swapped.We recv text from any one of three kinds of panes.	#sendChannelString:from:channelName:	(channel chat)	#sendConsoleString:from:				(our own console text)	#sendPrivateString:from:to:				(a private chat)After processing through a bunch of decisions concerning if the text represents a local commmand (not for IRC consumption) or a special command (requiring unique reformatting of the output message package) we eventually let the calling pane we sent the text through #textWasSent:.  The caller can then update the display or whatever.NOTE:  If you make changes to the enhanced IRC client, edit the revisionsString class method and then perform a	IRCConnectionEnhanced installNewPreambleForIRCChangeSetto install the edit history into the change set preamble.!!IRCConnection class methodsFor: 'utility' stamp: 'sbw 6/4/2004 06:11'!features	"IRCConnection features"	"Puts the window in the top right corner and resizes it."	| wkspace wkWindow wkWinExt orgPt |	wkWinExt := 650 @ 430.	wkspace := Workspace new contents: self featuresString.	wkWindow := wkspace embeddedInMorphicWindowLabeled: 'IRCe Features'.	wkWindow extent: wkWinExt.	orgPt := self currentWorld bounds topRight - (wkWinExt x @ 0).	wkWindow position: orgPt + (-80 @ 80).	wkWindow openAsIsIn: self currentWorld.	wkWindow		setWindowColor: (Color				r: 0.997				g: 0.975				b: 0.957)! !!IRCConnection class methodsFor: 'utility' stamp: 'sbw 6/10/2004 20:21'!featuresString	^ 'For background IRC protocol information please see http://www.irchelp.org/irchelp/rfc/.See (IRCConnection releaseNotes) for a workspace window containingrecent release notes.Key new features include:	A new user interface having one console window per connection 	and then having all console messages, channel messages and private 	messages contained inside the main console window using tabbed 	swapped panes.	Support was added for /WHOIS and /ACTION from the channel chat	windows.  Other windows do not have complete support for these 	commands yet.	The channel messages text, private messages text, and console messages	text panes are read-only.  This allows you to put the cursor over either	the input pane at the bottom or the actual text pane and begin typing.	The input text you type is sent only to the input pane at the bottom.	Copy and Find operations are still possible with the read-only text pane	content.	You can jump to a channel from the channels listing pane by one ot	two techniques.  First you can select a channel from the produced list.	Second, you can use the Prompted Channel button and be asked for	the name of a channel you want to join.  The channel name does not	need to appear in the list.  Further a check is made against the channel	name you enter and a # is prefixed if you left it off.	A small graphic "icon" in the top left corner of the main window shows	connect status.		The Channels list pane is a multi-column pane.  The Refresh button also	changes color to indicate that a refresh is active.  A channel refresh	action can take a while so the tag of the Refresh button also attempts	to update with an indication of the number of channels fetched so far	as an indicator of progress.	The channel chat input pane performs Nick Completion.  Anywhere on	the input text line you are typing you can begin to type a few characters	from the beginning of a channel Nick and hit the tab key.  This will	complete the nick tag for you.  If there is more than one Nick that	begin with the same characters, the tab key will rotate through them	for you.  You can also do Nick Completion multiple times on the same	line of text.	A leading tab on a channel chat input line is invalid and ignored.	Also empty input lines are ignored.	Your own transmitted messages in the channel chat pane are highlighted	with a color.  Also, messages that have your nick in them on the channel	chat pane will be highlighted in another color.	/ACTION is supported from the channel chat input.  You can type in	a command like		/action looks around room	and that message will be sent as an ACTION message to the channel.	All ACTION messages are highlighed in the channel chat text pane in	italics.	The channell chat pane is formatted into 2 columns.  The left most	column is the nick and the next column to the right shows the	typed text.	New server configuraton dialogs.  Includes the ability to tailor options	while connected.  Modification of connection parameters for the current	session is prohibited while connected.	Connection Profiles are supported.  You can specify a unique	set of connection parameters for any session and save them in a	list.  The options you select when you create a new profile are those	of the current profile.	Added a built-in table of many IRC servers you can choose from with	a dialog window.  localhost is now a valid server name.	You mayhave multiple console sessions open at the same time, each	having a unique IRC server connection.  The title of the console window	reflects the basic parameters of that connected session.	Added support for roll back/forward of previously typed text.  Use the	up and down arrow keys to scroll through text lines.	/WHOIS command sends response from the server to your channel chat	window now.	Only sends private message to the Provate pane that are NOT already	being sent to another private messages pane.  That is, if you have a 	private messages pane open the responses there are no longer duplicated	in the Private Messages window.	Tabbed channel text and private chat panes have their tabs highlighted	if messages appear there while you have another pane in front.  You	can use this feature to watch for activity on a channel or private	chat.	Channel member JOINS and PARTS are now logged to the channel chat	text.  There are options to disable this.	An option is provided that supported INVITE requests.  When you get an	INVITE request to join another channel this option will allow automatic	opening of that channel then adding you to the members there.	An option is provided that automatically opens up a private chat	window if you receive an unsolicitied private message.  This can	include server messages and NICKSERV messages.	Added support for multiple line input to a channel and private chat	pane.  This allows you to know PASTE into a channel.	Channel members are now listed in a logical order.  Channel operators	are at the top, followed by +voiced channel members and then	normal members.  Also, the nicks for operators are shown in red	on the channel members list and the voiced members are show in	another color.	Added support for the /CLEAR command to console, private chat and	channel chat windows.  /CLEAR will clear the contents of the text	pane.  This command is not sent to the IRC server of course.	Added /INSPECT to console, private and channel chat input pane	commands.  This will cause a Squeak Inspector to open up on the model	for that text pane.		Added /DOCS to supported local commands.  Opens up workspace windows	with features and release notes.	Support provided for NICK change messages receieved from the IRC server.	/NICK command is now supported from the channel chat input pane.'! !!IRCConnection class methodsFor: 'utility' stamp: 'sbw 6/3/2004 20:21'!handyExpressions	"IRCConnection handyExpressions"	"Puts the window in the top right corner and resizes it."	| wkspace wkWindow wkWinExt orgPt |	wkWinExt := 408 @ 300.	wkspace := Workspace new contents: self handyExpressionsString.	wkWindow := wkspace embeddedInMorphicWindowLabeled: 'Handy IRC Development Expressions'.	wkWindow extent: wkWinExt.	orgPt := self currentWorld bounds topRight - (wkWinExt x @ 0).	wkWindow position: orgPt + (-4 @ 2).	wkWindow openAsIsIn: self currentWorld.	wkWindow		setWindowColor: (Color				r: 0.997				g: 0.975				b: 0.957)! !!IRCConnection class methodsFor: 'utility' stamp: 'sbw 6/3/2004 20:20'!handyExpressionsString	"IRCConnection handyExpressions"	^ 'IRCConnectionProfile wipeOutProfilesIRCConnectionProfile profilesself halt.IRCConnection openEnhancedIRC.self halt.IRCConnection initialize.server _ IRCTestServer createDefaultTestServer.server startserver runserver stopIRCConnection tracing: trueIRCConnection tracing'! !!IRCConnection class methodsFor: 'utility' stamp: 'sbw 5/28/2004 06:14'!releaseNotes	"IRCConnection releaseNotes"	"Puts the window in the top right corner and resizes it."	| wkspace wkWindow wkWinExt orgPt |	wkWinExt := 650 @ 430.	wkspace := Workspace new contents: self releaseNotesString.	wkWindow := wkspace embeddedInMorphicWindowLabeled: 'IRCe Release Notes'.	wkWindow extent: wkWinExt.	orgPt := self currentWorld bounds topRight - (wkWinExt x @ 0).	wkWindow position: orgPt + (-40 @ 40).	wkWindow openAsIsIn: self currentWorld.	wkWindow		setWindowColor: (Color				r: 0.997				g: 0.975				b: 0.957)! !!IRCConnection class methodsFor: 'utility' stamp: 'fc 10/10/2005 16:25'!releaseNotesString	^ 'Changes to IRCe	Name: Network-IRC-fc.10.7.5Author: fcTime: 10 October 2005, 4:12:22 pmUUID: f1bc6568-da54-4263-8c61-fcc4be283cc2Ancestors: Network-IRC-fc.10.7.4Fixed init bug-----------------Name: Network-IRC-fc.10.7.4Author: fcTime: 16 June 2005, 10:30:00 pmRemoved catogory Network-IRC-GUI-Morph from package.This was a holdover from pre Morphic IRC and was causing problems with the New Objects menu.Assed nethod spawn: aMessage to IRCConnection and IRCChannelObserver. This message is sent by text morphs if the user blue-clicks, it is a way to duplicate. We call IRCConnection>>newConsole.--------------06 June 2005 fc 10.7.1Many changes over the last year. Current version has clickable http links, message coloring,timestamped message lines retain the textline formatting.--------------20 June 2004 sbwBug fix associated with joining channel explicitly.  I had a method from anotherpackage accidently included.19 June 2004 sbwChanged behavior of tabbed channel windows.  When a tabbed pane is closedthe next left-most tabbed pane is selected to be active.13 June 2004 sbwAdded option to allow channel windows to be tabbed or not.  When option is on,channel windows behave as before and remain captured in the parent windowunder a tab.  When the option is off, the channel windows open in their ownwindows.11 June 2004 sbwAdded option for timestamps on all channel messages.Fixed a problem where sounds did not play.10 June 2004 sbwAdded /DOCS command to open up local windows with features and release notes.Added initial support for low level quoting protocol, and ctcp quoting protocol.  It may not ever get used, but it is a starting point for hopefully deploying with DCC support.  My ideal would be that an IRC user could send Squeak MORPHS over IRC to other Squeakers using the same IRC client.Added FINGER command support.Added VERSION commands support.VERSION is currently disabled, and FINGER is incomplete.Created IRCTextLines objects to handle lines of text.Factored IRCClientSounds and added new/modified sounds.Added a read me class method for developers who may want to add their own sounds.More cleanup of instance variables in IRCConnection.Collapse the packages for model and GUI together.  Change the system category for IRC Tests.06 June 2004 sbwAdded /me support.Fixed problems with /JOIN not opening channel browsers.Implemented low level quoting for future protocol work (DCC).Implemented CTCP level quoting.03 June 2004 sbwSupport for basic functionality in new IRCeMorph.Created a test server.Added localhost as a server configuration option in profiles.Added IRCErrorLog to handle messages that would have gone to a gui.Added /traceon /traceoff to other slash commands: /clear, /inspect, and /explorePut back features window report (see IRCConnection class>>features).Options listed in options pane are no longer dictionary key but are now normal English words.28 May 2004 sbwFactored classes into categories for model and GUI.Reduced total number of classes.  Renamed several classes.Merged enhanced client behavior into standard client.Added initialize/unload logic to work cleanly with Monticello.Unit tests for portions of the IRC model.Improved management of profiles.Improved use of IRC multicolumn panes (channels list and profiles list).Re-established proper color list annotations for channel members.Allow channel names to begin with letters other than just the letter #.Cache the previous channel name to make it easier for the user.Added a class to manage the external file/folder definitions for channel lists, and channel logs.  Better messages and list of channels in logs.More options in setup panes.  Rewrite of much of the setup dialog screens.Factored a lot of the logic away from the connection class.Added IRCConnection handyExpressions for my tools space.Included portion of BNF document for protocol messages as a workspace that can be referenced.Fixed the IPv6 bug.Removed the old documentation scheme (release notes, features, to-do list, etc....).Added support for playing a sound when someone sends a message in a channel with your nick in the text.Fixed problem in connection setup dialog when full name was longer than a certain length, the entry field displayed the value indented.  Problem was related to improper declaration of scrollbars.'! !!IRCConnection class methodsFor: 'utility' stamp: 'sbw 6/10/2004 20:20'!showDocs	self features; releaseNotes! !!IRCConnection class methodsFor: 'profiles' stamp: 'sbw 5/17/2004 20:05'!fixAllBadProfileKeys	IRCConnectionProfile fixAllBadProfileKeys! !!IRCConnection class methodsFor: 'profiles' stamp: 'sbw 5/17/2004 20:08'!removeProfile: anIRCProfile 	IRCConnectionProfile removeProfileNamed: anIRCProfile name! !!IRCConnection class methodsFor: 'initialization' stamp: 'sbw 6/5/2004 08:11'!initialize	"IRCConnection initialize"	self		fixAllBadProfileKeys; 		registerInOpenMenu; 		initializeAllMessageHandlers.	IRCServer populateServersDatabaseWithBuiltIn! !!IRCConnection class methodsFor: 'initialization' stamp: 'sbw 6/5/2004 08:12'!initializeAllMessageHandlers	"IRCConnection initializeAllMessageHandlers"	self		initializeMessageHandlers; 		initializeLocalMessageHandlers; 		initializeOutgoingMessageHandlers.! !!IRCConnection class methodsFor: 'initialization' stamp: 'sbw 5/24/2004 23:04'!registerInOpenMenu	"IRCConnection registerInOpenMenu"	TheWorldMenu registerOpenCommand: {'IRC'. {IRCConnection. #openEnhancedIRC}. 'Enhanced Internet Relay Chat'}! !!IRCConnection class methodsFor: 'initialization' stamp: 'sw 11/11/2002 00:02'!unload	"Called when the class is being removed"	TheWorldMenu unregisterOpenCommandWithReceiver: self! !!IRCConnection class methodsFor: 'message handlers' stamp: 'fc 3/7/2005 11:54'!initializeLocalMessageHandlers	"initilize the table mapping local commands to processing methods"	"IRCConnection initializeLocalMessageHandlers"	"Keys in the dictionary should all be lowercase for later matching."	LocalMessageHandlers _ Dictionary new.	{		{#clear. #clearTextPane}. 		{#inspect. #inspect}. 		{#explore. #explore}. 		{#traceon. #traceOn}. 		{#traceoff. #traceOff}.		{#docs. #docs}.		{#playlist. #playlist}	}		do: [:pair | LocalMessageHandlers at: pair first asString put: pair second]! !!IRCConnection class methodsFor: 'message handlers' stamp: 'sbw 6/5/2004 08:33'!initializeMessageHandlers	"initilize the table mapping IRC commands to processing methods"	"IRCConnection initializeMessageHandlers"	MessageHandlers := Dictionary new.	{		{#ping.		#processPing:}.		{#join.		#processJoin:}.		{#nick.		#processNickChanged:}.		{#part.		#processPart:}.		{#quit.		#processQuit:}.		{#privmsg.	#processPrivmsg:}.		{#notice.	#processPrivmsg:}.		{#topic.		#processTopic:}.		{#invite.	#processInvite:}.		{#mode.		#processMode:}.		{263.		#processChannelsServerLoadTooHigh:}.		{301.		#processReplyAway:}.		{307.		#processNickIdentified:}.		{311.		#processReplyWhoIsUser:}.		{312.		#processReplyWhoIsServer:}.		{317.		#processIdleTime:}.		{318.		#processEndOfWhoIs:}.		{319.		#processWhoIsChannels:}.		{321.		#processChannelListStart:}.		{322.		#processChannelList:}.		{323.		#processChannelListEnd:}.		{331.		#processNoTopic:}.		{332.		#processTopic:}.		{353.		#processNamReply:}.		{372.		#processMotd:}.		{377.		#processMotd:}.		{375.		#processMotdStart:}.		{376.		#processMotdEnd:}	} do: [:pair | MessageHandlers at: pair first asString put: pair second]! !!IRCConnection class methodsFor: 'message handlers' stamp: 'fc 1/20/2005 19:01'!initializeOutgoingMessageHandlers	"initilize the table mapping /commands to processing methods. Note that  	these conversion are all performed as IRCProtocolMessage instance  	methods."	"IRCConnection initializeOutgoingMessageHandlers"	"Keys in the dictionary should all be lowercase for later matching."	OutgoingMessageHandlers := Dictionary new.	{		{#whois.	#processWhoisCommand}.		{#nick.		#processNickCommand}.		{#join.		#processJoinCommand}.		{#part.		#processPartCommand}.		{#away.		#processAwayCommand}	} do: [:pair | OutgoingMessageHandlers at: pair first asString put: pair second]! !!IRCConnection class methodsFor: 'message handlers' stamp: 'sbw 5/8/2004 17:36'!localMessageHandlers	LocalMessageHandlers isNil ifTrue: [self initializeLocalMessageHandlers].	^LocalMessageHandlers! !!IRCConnection class methodsFor: 'message handlers' stamp: 'sbw 6/5/2004 08:19'!messageHandlers	MessageHandlers isNil ifTrue: [self initializeMessageHandlers].	^MessageHandlers! !!IRCConnection class methodsFor: 'message handlers' stamp: 'sbw 5/8/2004 17:36'!outgoingMessageHandlers	OutgoingMessageHandlers isNil		ifTrue: [self initializeOutgoingMessageHandlers].	^ OutgoingMessageHandlers! !!IRCConnection class methodsFor: 'message handlers' stamp: 'fc 1/18/2005 10:34'!specialCommands	"Answers the list of special commands that require some additional  	translation before they are sent."	"See http://www.irchelp.org/irchelp/rfc/ctcpspec.html"	"We should rewrite these guys using handlers as well, at some point. -  	sbw"	^ {'action'. 'dcc'. 'sed'. 'me'. 'finger'. 'version'}! !!IRCConnection class methodsFor: 'instance creation' stamp: 'sbw 6/20/2004 16:00'!openAndJoinChannelNamed: aString 	| connection channelName |	connection _ self new.	connection openWindows.	connection connect.	(aString beginsWith: '#')		ifTrue: [channelName _ aString]		ifFalse: [(IRCOptionsManagement option: #forceChannelsToHaveLeadingPoundSign)				ifTrue: [channelName _ '#' , aString]].	connection openChannelCaptured: channelName.	^ connection! !!IRCConnection class methodsFor: 'instance creation' stamp: 'sbw 5/24/2004 23:03'!openAndJoinSqueakChannel	"IRCConnection openAndJoinSqueakChannel."	^ self openAndJoinChannelNamed: #squeak! !!IRCConnection class methodsFor: 'instance creation' stamp: 'sbw 5/16/2004 07:50'!openEnhancedIRC	^ Preferences autoJoinSqueakChannel		ifTrue: [self openAndJoinSqueakChannel]		ifFalse: [self new openWindows]			! !!IRCConnection class methodsFor: 'diagnostic' stamp: 'sbw 6/5/2004 10:58'!trace: aString 	"Will log <aString> if tracing is on.  	Turns on and off via /traceon and /traceoff commands."	self tracing		ifFalse: [^ self].	self tracePrivate: aString! !!IRCConnection class methodsFor: 'diagnostic' stamp: 'sbw 6/5/2004 10:57'!tracePrivate: aString 	IRCErrorLog log: aString forClass: 'TRACE'! !!IRCConnection class methodsFor: 'diagnostic' stamp: 'sbw 6/2/2004 09:42'!tracing	Tracing isNil ifTrue: [Tracing _ false].	^Tracing! !!IRCConnection class methodsFor: 'diagnostic' stamp: 'sbw 6/5/2004 10:59'!tracing: aBoolean 	Tracing _ aBoolean.	self tracePrivate: 'Tracing turned ', (Tracing ifTrue: ['ON'] ifFalse: ['OFF'])! !!IRCConnectionDialog methodsFor: 'configuration' stamp: 'sbw 3/16/2005 06:43'!addConfigurationControlsTo: aPane 	| rowHeight offset row rowSpacing rowPosn topOffset str |	rowHeight := 22.	rowSpacing := 36.	offset := 10 @ 14.	rowPosn := offset copy.	topOffset := 24.	rowPosn := rowPosn + (0 @ topOffset).	aPane color: self configurationPaneBackgroundColor.	str := StringMorph				contents: 'These are your current parameter values'				font: (StrikeFont familyName: 'NewYork' size: 12).	str emphasis: 1.	aPane		addMorph: str		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (10 @ 6 corner: -10 @ 20)).	self configurationSpecs		do: [:array | 			row := self configurationRowFor: array.			aPane				addMorph: row				fullFrame: (LayoutFrame						fractions: (0 @ 0 corner: 1 @ 0)						offsets: (rowPosn corner: offset x negated @ (rowPosn y + rowHeight))).			rowPosn := rowPosn + (0 @ rowSpacing)]! !!IRCConnectionDialog methodsFor: 'configuration' stamp: 'sbw 3/4/2002 09:45'!buildConfigurationDenialPane	| deniedMorph |	denialPane _ AlignmentMorph newColumn hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 0;				 layoutPolicy: ProportionalLayout new.	denialPane color: Color transparent.	deniedMorph _ self denialTrueTypeMorph.	denialPane		addMorph: deniedMorph		fullFrame: (LayoutFrame				fractions: (0.1 @ 0.1 corner: 0.9 @ 0.9)				offsets: (0 @ 0 corner: 0 @ 0))! !!IRCConnectionDialog methodsFor: 'configuration' stamp: 'sbw 5/9/2004 23:13'!buildConfigurationPane	configurationPane := AlignmentMorph newColumn hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 0;				 layoutPolicy: ProportionalLayout new.	self addConfigurationControlsTo: configurationPane.	self buildConfigurationDenialPane.	self connectionStateChanged.	^configurationPane! !!IRCConnectionDialog methodsFor: 'configuration' stamp: 'sbw 5/8/2004 10:36'!configurationPaneBackgroundColor	^ Color		r: 0.84		g: 0.80		b: 0.76! !!IRCConnectionDialog methodsFor: 'configuration' stamp: 'sbw 3/16/2005 20:57'!configurationRowFor: specArray 	| alignPane |	alignPane := IRCGUIHelper				entryFieldRowFor: connection				tag: specArray first				backLabel: specArray second				textGetter: specArray third				textSetter: specArray fourth				color: self configurationPaneBackgroundColor				tagColumnWidth: 60				tagPad: 20				tagInset: 2.	^ alignPane! !!IRCConnectionDialog methodsFor: 'configuration' stamp: 'sbw 3/16/2005 06:51'!configurationSpecs	"tag, back getter setter"	^ {		{'full name'. 'John Squeaker <john@squeaker.com>'. #fullName. #fullName:}. 		{'nick'. 'nick'. #nick. #nick:}. 		{'username'. 'username'. #userName. #userName:}. 		{'server'. 'irc.server.com'. #server. #server:}. 		{'port'. '1234'. #portAsString. #portAsString:}	}! !!IRCConnectionDialog methodsFor: 'configuration' stamp: 'sbw 3/4/2002 09:44'!denialTrueTypeMorph	| ttMorph |	ttMorph _ TTSampleStringMorph font: TTFontDescription default.	ttMorph		string: 'Connected';		color: (Color red alpha: 0.3);		borderColor: Color transparent.	^ ttMorph! !!IRCConnectionDialog methodsFor: 'configuration' stamp: 'sbw 5/8/2004 11:17'!showConfigDenial: boolean 	"boolean is true if we are connected."	self myDependents isNil		ifFalse: [			boolean				ifTrue: [configurationPane						addMorph: denialPane						fullFrame: (LayoutFrame								fractions: (0 @ 0 corner: 1 @ 1)								offsets: (0 @ 0 corner: 0 @ 0))]				ifFalse: [denialPane isNil ifFalse: [denialPane delete]]]! !!IRCConnectionDialog methodsFor: 'options' stamp: 'sbw 5/27/2004 19:48'!addOptionPaneHeaderTo: aPane offset: aPoint 	| str |	str := StringMorph				contents: 'Options are for all console windows'				font: (StrikeFont familyName: 'NewYork' size: 12).	str emphasis: 1.	aPane		addMorph: str		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (aPoint corner: 0 @ 14))! !!IRCConnectionDialog methodsFor: 'options' stamp: 'sbw 5/27/2004 20:29'!addOptionsList: aList to: aPane fractions: frac offsets: off 	| rowHeight rowSpacing rowPosn button |	rowHeight := self optionRowHeight.	rowSpacing := self optionRowSpacing.	rowPosn := off origin copy.	aList		do: [:each | 			button := self createOptionButtonForOption: each.			aPane				addMorph: button				fullFrame: (LayoutFrame						fractions: frac						offsets: (rowPosn corner: off corner copy x @ (rowPosn y + rowHeight))).			rowPosn := rowPosn + (0 @ rowSpacing)].	^ aPane! !!IRCConnectionDialog methodsFor: 'options' stamp: 'sbw 5/27/2004 20:30'!buildOptionsPane	| aPane indentLevel fullList leftCount leftList rightList |	indentLevel := 160.	aPane := AlignmentMorph newColumn hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 0;				 color: self optionsPaneBackgroundColor;				 layoutPolicy: ProportionalLayout new.	self addOptionPaneHeaderTo: aPane offset: indentLevel @ 0.	fullList := IRCOptionsManagement optionKeys asSortedCollection.	leftCount := fullList size even				ifTrue: [fullList size // 2]				ifFalse: [fullList size // 2 + 1].	leftList := fullList copyFrom: 1 to: leftCount.	rightList := fullList copyFrom: leftCount + 1 to: fullList size.	self		addOptionsList: leftList		to: aPane		fractions: (0 @ 0 corner: 0.5 @ 0)		offsets: (10 @ 32 corner: 10 negated @ 0).	self		addOptionsList: rightList		to: aPane		fractions: (0.5 @ 0 corner: 1 @ 0)		offsets: (10 @ 32 corner: 10 negated @ 0).	^ aPane! !!IRCConnectionDialog methodsFor: 'options' stamp: 'sbw 5/27/2004 20:34'!createOptionButtonForOption: aSymbol 	| button wrapper str |	wrapper := AlignmentMorph newRow height: self optionRowHeight.	wrapper color: Color white.	wrapper hResizing: #spaceFill;		 vResizing: #shrinkWrap.	button := UpdatingThreePhaseIRCButtonMorph checkBox.	wrapper addTransparentSpacerOfSize: 2 @ 0.	wrapper addMorphBack: button.	button target: IRCOptionsManagement;		 actionSelector: #toggleOption:;				arguments: (Array with: aSymbol);		 getSelector: #option:;		 getArgument: aSymbol.	button setBalloonText: (IRCOptionsManagement helpForOption: aSymbol).	wrapper addTransparentSpacerOfSize: 2 @ 0.	str := StringMorph				contents: (IRCOptionsManagement descriptionForOption: aSymbol)				font: (StrikeFont familyName: 'NewYork' size: 12).	wrapper addMorphBack: str.	^ wrapper! !!IRCConnectionDialog methodsFor: 'options' stamp: 'sbw 5/9/2004 22:19'!optionRowHeight	^ 16! !!IRCConnectionDialog methodsFor: 'options' stamp: 'sbw 5/27/2004 19:52'!optionRowSpacing	^20! !!IRCConnectionDialog methodsFor: 'options' stamp: 'sbw 5/9/2004 21:55'!optionsPaneBackgroundColor	^ Color		r: 0.88		g: 0.84		b: 0.88! !!IRCConnectionDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/28/2002 07:25'!addPane: pane toSwapper: swapper paneName: aString default: default 	swapper		addPane: pane		named: aString		hidden: default not		closeable: false		swapModel: self.	default		ifTrue: [swapper defaultPaneName: aString]! !!IRCConnectionDialog methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 22:17'!buildSwapper	^ TabbedSwappingControl newSwapControlPaneOrientation: #bottom showMover: false! !!IRCConnectionDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/19/2002 17:01'!connection: conn	connection _ conn! !!IRCConnectionDialog methodsFor: 'as yet unclassified' stamp: 'sbw 3/4/2002 10:44'!connectionStateChanged	connectedState _ connection connected.	self showConfigDenial: connectedState.	self disableProfileSelectButton: connectedState.! !!IRCConnectionDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 01:32'!hideWindow	self topView hide! !!IRCConnectionDialog methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 20:20'!initialExtent	^ 600 @ 260! !!IRCConnectionDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/22/2002 11:56'!okToChange	(self topView submorphs select: [:m | m isKindOf: PluggableTextMorph]) do: [:textMorph |		textMorph hasUnacceptedEdits ifTrue: [^false]].	^true! !!IRCConnectionDialog methodsFor: 'as yet unclassified' stamp: 'sbw 6/5/2004 10:49'!openDialog	"open a dialogue for making new connections"	| dialogue swappingControl configurationPaneName |	configurationPaneName _ 'Current Configuration'.	dialogue _ SystemWindow new.	dialogue model: self.	swappingControl _ self buildSwapper.	self		addPane: self buildConfigurationPane		toSwapper: swappingControl		paneName: configurationPaneName		default: true.	self		addPane: self buildOptionsPane		toSwapper: swappingControl		paneName: 'Current Options'		default: false.	self		addPane: self buildProfilesPane		toSwapper: swappingControl		paneName: 'Profiles'		default: false.	dialogue		addMorph: swappingControl		frame: (0 @ 0 extent: 1 @ 1).	swappingControl color: Color white darker darker.	swappingControl goBehind.	swappingControl showPaneNamed: configurationPaneName.	dialogue setLabel: 'setup for IRC cllient'.	dialogue openInWorld! !!IRCConnectionDialog methodsFor: 'as yet unclassified' stamp: 'sbw 3/12/2005 13:59'!rowHighlightColor	^ IRCClientColors profilesRowHighlight! !!IRCConnectionDialog methodsFor: 'as yet unclassified' stamp: 'sbw 3/3/2002 21:37'!showWindow	self topView show! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 5/27/2004 19:22'!addProfile	| dlg |	dlg := self setupProfileDialog.	dlg openForAddWithOptions: IRCOptionsManagement savedOptions copy! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 5/23/2004 07:37'!addProfile: aConnectionProfile 	IRCConnectionProfile addProfile: aConnectionProfile.	self updateProfilesList.	self changed: #profileDescriptions.! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 5/11/2004 21:50'!buildProfileActionButtons	| alignMorph btn |	alignMorph := AlignmentMorph newRow.	alignMorph beSticky; layoutInset: 5 @ 3; cellInset: 6; clipSubmorphs: true; borderWidth: 0; color: self profilesPaneBackgroundColor.	self profileButtonSpecs		do: [:spec | 			btn := PluggableButtonMorph						on: self						getState: nil						action: spec second.			Preferences alternativeWindowLook				ifTrue: [btn borderWidth: 2;						 borderColor: #raised].			btn label: spec first.			btn color: self profileActionButtonColor.			btn onColor: Color white offColor: self profileActionButtonColor.			alignMorph addMorphBack: btn.			btn setBalloonText: spec fourth.			btn setNameTo: spec third].	^ alignMorph! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 3/11/2005 13:47'!buildProfilesList	| theList |	theList := PluggableMultiColumnIRCListMorph				on: self				list: #profileDescriptions				selected: #profilesIndex				changeSelected: #profilesIndex:				headerStrings: #('Profile' 'Nick' 'Server' ).	theList color: Color white;		 name: 'theProfilesList'.	theList headerBackColor: Color paleTan muchLighter.	^ theList! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 5/9/2004 21:57'!buildProfilesPane	| aPane |	aPane := AlignmentMorph newColumn beSticky; borderWidth: 0.	aPane color: self profilesPaneBackgroundColor;		 layoutPolicy: ProportionalLayout new.	aPane		addMorph: self buildProfileActionButtons		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (self horizPaneMargin @ self vertPaneMargin corner: self horizPaneMargin negated @ (self vertPaneMargin + self profileButtonHeight))).	aPane		addMorph: self buildProfilesList		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (self horizPaneMargin @ (self vertPaneMargin + self profileButtonHeight + self vertPaneMargin) corner: self horizPaneMargin negated @ self vertPaneMargin negated)).	^ aPane! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 5/23/2004 09:09'!deleteProfile	| key |	profilesIndex == nil		ifTrue: [^ nil].	key := profilesIndex.	key = IRCConnectionProfile defaultProfileName ifTrue: [^self inform: 'Cannot remove ', IRCConnectionProfile defaultProfileName].	IRCConnectionProfile removeProfileNamed: key.	self changed: #profileDescriptions! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 3/4/2002 10:54'!disableProfileSelectButton: boolean 	| morph |	self topView isNil		ifTrue: [^ nil].	morph _ self topView				submorphNamed: 'selectProfile'				ifNone: [].	morph isNil		ifTrue: [^ nil].	boolean		ifTrue: [morph offColor: Color veryVeryLightGray]		ifFalse: [morph offColor: self profileActionButtonColor]! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 5/17/2004 20:06'!editProfile	| key profile dlg |	profilesIndex == nil		ifTrue: [^ nil].	key := profilesIndex.	profile := IRCConnectionProfile getProfileNamed: key.	profile isNil		ifTrue: [^ self inform: 'Could not find the selected profile'].	dlg := self setupProfileDialog.	dlg openDialogOn: profile	"disableAdvanced: true"! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 5/17/2004 20:04'!editedProfile: aProfile 	self changed: #profileDescriptions.	"Check if we need to fix the key to agree with the name of the profile."	IRCConnectionProfile checkKeyForProfileNamed: aProfile name! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 3/3/2002 15:35'!horizPaneMargin	^ 12! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 3/4/2002 10:48'!profileActionButtonColor	^Color paleTan muchLighter! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 3/3/2002 14:18'!profileButtonHeight	^26! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 5/9/2004 20:29'!profileButtonSpecs	"tag, selector, button name, help text"	^ #(#('new' #addProfile 'addProfile' 'Add a new profile') #('delete' #deleteProfile 'deleteProfile' 'Delete the selected profile') #('edit' #editProfile 'editProfile' 'Edit the selected profile') #('select' #selectProfile 'selectProfile' 'Load the selected profile into your current configuration') #('Save current...' #saveCurrentToProfile 'saveCurrent' 'Save your current configuration to a new profile') )! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 5/23/2004 09:14'!profileDescriptions	| list |	list := Array new: 3.	1		to: list size		do: [:index | list at: index put: OrderedCollection new].	(IRCConnectionProfile profiles		asSortedCollection: [:a :b | a name asLowercase < b name asLowercase])		do: [:profile | 			(list at: 1)				add: profile name.			(list at: 2)				add: profile nick.			(list at: 3)				add: profile server profileListString].	^ list! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 3/3/2002 15:20'!profilesIndex	^profilesIndex! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 3/4/2002 01:04'!profilesIndex: string 	profilesIndex _ string.	self changed: #profilesIndex! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 5/9/2004 21:58'!profilesPaneBackgroundColor	^ (Color r: 0.841 g: 0.802 b: 0.713)! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 5/23/2004 07:38'!saveCurrentToProfile	"Ask the user for a new profile name and then save the current setup  	to that profile."	| newName newProfile keepLooping |	[newName := FillInTheBlank request: 'New profile name?'.	newName isEmpty		ifTrue: [^ nil].	keepLooping := IRCConnectionProfile hasProfileNamed: newName.	keepLooping		ifTrue: [self inform: 'That profile name is already in use.'].	keepLooping] whileTrue.	newProfile := IRCConnectionProfile fromConnection: connection.	newProfile name: newName.	IRCConnectionProfile addProfile: newProfile.	self updateProfilesList.	self changed: #profileDescriptions! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 5/17/2004 20:07'!selectProfile	| key profile |	connectedState		ifTrue: [^ nil].	key := profilesIndex.	profile := IRCConnectionProfile getProfileNamed: key.	profile isNil		ifTrue: [^ self inform: 'Could not find selected profile.'].	connection loadProfile: profile! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 5/9/2004 21:30'!setupProfileDialog	| dlg |	dlg := IRCProfileDialog new.	dlg parentDialog: self.	dlg referenceConnection: connection.	self hideWindow.	^dlg! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 5/23/2004 08:02'!updateProfilesList	| listM |	listM := self myDependents				detect: [:dep | dep externalName = 'theProfilesList']				ifNone: [].	listM isNil		ifFalse: [			listM changed]! !!IRCConnectionDialog methodsFor: 'profiles' stamp: 'sbw 3/3/2002 15:13'!vertPaneMargin	^ 5! !!IRCConnectionDialog class methodsFor: 'as yet unclassified' stamp: 'sbw 2/19/2002 17:01'!on: anIRCConnection 	^ self new connection: anIRCConnection! !!IRCConnectionProfile methodsFor: 'as yet unclassified' stamp: 'sbw 5/19/2004 22:07'!fullName	fullName == nil		ifTrue: [nick := self class defaultFullName].	^ fullName! !!IRCConnectionProfile methodsFor: 'as yet unclassified' stamp: 'sbw 3/3/2002 23:58'!fullName: str	fullName _ str! !!IRCConnectionProfile methodsFor: 'as yet unclassified' stamp: 'sbw 3/3/2002 10:23'!name	name == nil ifTrue: [name _ 'unnamed'].	^name! !!IRCConnectionProfile methodsFor: 'as yet unclassified' stamp: 'sbw 3/3/2002 10:22'!name: aString	"The name of thiss profile."	name _ aString! !!IRCConnectionProfile methodsFor: 'as yet unclassified' stamp: 'sbw 5/19/2004 22:08'!nick	nick == nil		ifTrue: [nick := self class defaultNick].	^ nick! !!IRCConnectionProfile methodsFor: 'as yet unclassified' stamp: 'sbw 3/3/2002 10:23'!nick: aString	"The nick used with this profile."	nick _ aString! !!IRCConnectionProfile methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 19:15'!options	^IRCOptionsManagement savedOptions! !!IRCConnectionProfile methodsFor: 'as yet unclassified' stamp: 'sbw 3/3/2002 11:09'!options: dict	options _ dict! !!IRCConnectionProfile methodsFor: 'as yet unclassified' stamp: 'sbw 5/18/2004 09:51'!printOn: aStream 	super printOn: aStream.	aStream nextPutAll: ' (', self name, ' / ', self nick, ')'! !!IRCConnectionProfile methodsFor: 'as yet unclassified' stamp: 'sbw 3/3/2002 10:28'!server	server = nil ifTrue: [server _ IRCServer defaultServer].	^server! !!IRCConnectionProfile methodsFor: 'as yet unclassified' stamp: 'sbw 3/3/2002 10:28'!server: anIRCServer	server _ anIRCServer! !!IRCConnectionProfile methodsFor: 'as yet unclassified' stamp: 'sbw 5/19/2004 22:08'!userName	userName == nil		ifTrue: [nick := self class defaultUserName].	^ userName! !!IRCConnectionProfile methodsFor: 'as yet unclassified' stamp: 'sbw 3/3/2002 23:59'!userName: str	userName _ str! !!IRCConnectionProfile class methodsFor: 'profiles' stamp: 'sbw 5/17/2004 22:23'!addDefaultProfile	"Do NOT overwrite values already defined."	(self profiles includesKey: self defaultProfileName)		ifFalse: [self updateDefaultProfile]! !!IRCConnectionProfile class methodsFor: 'profiles' stamp: 'sbw 5/17/2004 20:01'!addProfile: anIRCProfile 	(self profiles includesKey: anIRCProfile name)		ifTrue: [^ self inform: 'Profile "' , anIRCProfile name , '" already defined.'].	self profiles at: anIRCProfile name put: anIRCProfile! !!IRCConnectionProfile class methodsFor: 'profiles' stamp: 'sbw 5/17/2004 20:03'!checkKeyForProfileNamed: aString 	"Ensure that the key we are using is the same the profile name. Assume 	that the profile name is the correct one if they differ."	| badKeys profile |	(self profiles keys includes: aString)		ifFalse: [badKeys := Set new.			self profiles keys				do: [:ky | 					profile := self profiles at: ky.					profile name = aString						ifTrue: [ky = profile name								ifFalse: [self profiles at: aString put: profile copy.									badKeys add: ky]]].			badKeys				do: [:badKey | self profiles removeKey: badKey]]! !!IRCConnectionProfile class methodsFor: 'profiles' stamp: 'sbw 5/17/2004 20:04'!fixAllBadProfileKeys	"Ensure that the keys we are using are the same their profile name.  	Assume that the profile name is the correct one if they differ."	(self profiles		collect: [:each | each name])		do: [:pName | self checkKeyForProfileNamed: pName]! !!IRCConnectionProfile class methodsFor: 'profiles' stamp: 'sbw 5/17/2004 20:06'!getProfileNamed: aString 	(self profiles includesKey: aString)		ifFalse: [^ nil].	^ self profiles at: aString! !!IRCConnectionProfile class methodsFor: 'profiles' stamp: 'sbw 5/17/2004 20:07'!hasProfileNamed: aString 	^ self profiles includesKey: aString! !!IRCConnectionProfile class methodsFor: 'profiles' stamp: 'sbw 5/18/2004 22:57'!initializeProfiles	"IRCConnectionProfile initializeProfiles"	self profiles: Dictionary new.	"Always ensure the default profile is here."	self updateDefaultProfile! !!IRCConnectionProfile class methodsFor: 'profiles' stamp: 'sbw 5/17/2004 22:20'!profiles	"IRCConnectionProfile profiles"	Profiles == nil ifTrue: [self initializeProfiles].	^ Profiles! !!IRCConnectionProfile class methodsFor: 'profiles' stamp: 'sbw 5/18/2004 10:35'!profiles: aDictionary 	Profiles _ aDictionary! !!IRCConnectionProfile class methodsFor: 'profiles' stamp: 'sbw 5/18/2004 22:58'!removeProfileNamed: aString 	"Never remove default profile."	aString = self defaultProfileName ifTrue: [^nil].	(self profiles includesKey: aString)		ifFalse: [^ self inform: 'Profile "' , aString , '" does not exist.'].	self profiles removeKey: aString! !!IRCConnectionProfile class methodsFor: 'profiles' stamp: 'sbw 5/18/2004 09:37'!updateDefaultProfile	"IRCConnectionProfile updateDefaultProfile"	self updateProfileNamed: self defaultProfileName with: self default! !!IRCConnectionProfile class methodsFor: 'profiles' stamp: 'sbw 5/18/2004 09:36'!updateProfileNamed: aString with: aProfile	self profiles at: aString put: aProfile! !!IRCConnectionProfile class methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 18:27'!createDefault	| model server |	model := self new.	server := IRCServer serverWithAddress: self defaultServer.	model nick: self defaultNick;		 fullName: self defaultFullName;		 userName: self defaultUserName;		 server: server;		 options: IRCOptionsManagement savedOptions.	model name: self defaultProfileName.	self updateProfileNamed: self defaultProfileName with: model.	^ model! !!IRCConnectionProfile class methodsFor: 'as yet unclassified' stamp: 'sbw 5/18/2004 09:26'!default	"IRCConnectionProfile default"	| model |	model := self getProfileNamed: self defaultProfileName.	model isNil		ifTrue: [model := self createDefault].	^ model! !!IRCConnectionProfile class methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 19:24'!fromConnection: anIRCConnectionEnhanced 	| model server |	model := self new.	server := IRCServer serverWithAddress: anIRCConnectionEnhanced server.	server isNil		ifTrue: [server := IRCServer defaultServer]		ifFalse: [server port: anIRCConnectionEnhanced port].	model nick: anIRCConnectionEnhanced nick;		 fullName: anIRCConnectionEnhanced fullName;		 userName: anIRCConnectionEnhanced userName;		 server: server;		 options: IRCOptionsManagement savedOptions.	^ model! !!IRCConnectionProfile class methodsFor: 'as yet unclassified' stamp: 'sbw 5/22/2004 20:53'!initializeDefaultsPrompted	"We DO NOT want to execute this when doing automated installs."	| fullName dServer dPort dNick dUserName dFullName |	dServer := FillInTheBlank request: 'Default squeak server?' initialAnswer: 'irc.freenode.net'.	dServer isEmpty		ifTrue: [^ false].	dPort := 6667.	dNick := FillInTheBlank request: 'Your channel nickname?'.	dNick isEmpty		ifTrue: [^ false].	dUserName := FillInTheBlank request: 'Your user name (squeak initials)?' initialAnswer: Utilities authorInitialsPerSe.	self flag: #noteToFc.	"When Utilities>>AuthorName cs goes in this can come out."	fullName := Utilities authorNamePerSe				ifNil: [''].	fullName := FillInTheBlank request: 'Your full name.' initialAnswer: fullName.	fullName isEmpty		ifTrue: [^ false].	dServer isEmpty		ifTrue: [dServer := self defaultDefaultServer].	self defaultServer: dServer.	self defaultPort: dPort.	dNick isEmpty		ifTrue: [dNick := self defaultDefaultNick].	self defaultNick: dNick.	dUserName isEmpty		ifTrue: [dUserName := self defaultDefaultUserName].	self defaultUserName: dUserName.	fullName isEmpty		ifTrue: [fullName := self defaultDefaultFullName].	dFullName := fullName , ' <' , (MailSender setUserName; userName) , '>'.	self defaultFullName: dFullName.	self createDefault.	^ true! !!IRCConnectionProfile class methodsFor: 'as yet unclassified' stamp: 'sbw 5/16/2004 23:06'!initializeDefaultsToPresets	"IRCConnectionProfile initializeDefaultsToPresets"	self defaultServer: self defaultDefaultServer.	self defaultPort: self defaultDefaultPort.	self defaultNick: self defaultDefaultNick.	self defaultUserName: self defaultDefaultUserName.	self defaultFullName: self defaultDefaultFullName! !!IRCConnectionProfile class methodsFor: 'as yet unclassified' stamp: 'sbw 5/22/2004 11:25'!resetDefault	"IRCConnectionProfile resetDefault"	self defaultServer: nil.	self defaultPort: nil.	self defaultNick: nil.	self defaultUserName: nil.	self defaultFullName: nil.	(self hasProfileNamed: self defaultProfileName)		ifTrue: [self profiles removeKey: self defaultProfileName]! !!IRCConnectionProfile class methodsFor: 'as yet unclassified' stamp: 'sbw 5/19/2004 22:03'!wipeOutProfiles	"IRCConnectionProfile wipeOutProfiles"	"This one will remove all the profiles and even DELETES the default profile."	self initializeProfiles; resetDefault! !!IRCConnectionProfile class methodsFor: 'default defaults' stamp: 'sbw 5/16/2004 23:02'!defaultDefaultFullName	^'fullName < mailname@mailsite.ext >'! !!IRCConnectionProfile class methodsFor: 'default defaults' stamp: 'sbw 5/16/2004 23:00'!defaultDefaultNick	^'channelNickname'! !!IRCConnectionProfile class methodsFor: 'default defaults' stamp: 'sbw 5/16/2004 22:59'!defaultDefaultPort	^6667! !!IRCConnectionProfile class methodsFor: 'default defaults' stamp: 'sbw 5/16/2004 22:58'!defaultDefaultServer	^'irc.freenode.net'! !!IRCConnectionProfile class methodsFor: 'default defaults' stamp: 'sbw 5/16/2004 23:01'!defaultDefaultUserName	^'userName'! !!IRCConnectionProfile class methodsFor: 'default defaults' stamp: 'sbw 3/3/2002 10:51'!defaultProfileName	^'Default Profile'! !!IRCConnectionProfile class methodsFor: 'accessing' stamp: 'sbw 5/18/2004 09:18'!defaultFullName	DefaultFullName isNil ifTrue: [self defaultFullName: self defaultDefaultFullName].	^ DefaultFullName! !!IRCConnectionProfile class methodsFor: 'accessing' stamp: 'sbw 5/16/2004 08:01'!defaultFullName: aString	DefaultFullName _ aString! !!IRCConnectionProfile class methodsFor: 'accessing' stamp: 'sbw 5/18/2004 09:19'!defaultNick	DefaultNick isNil ifTrue: [self defaultNick: self defaultDefaultNick].	^ DefaultNick! !!IRCConnectionProfile class methodsFor: 'accessing' stamp: 'sbw 5/16/2004 08:02'!defaultNick: aString 	DefaultNick := aString! !!IRCConnectionProfile class methodsFor: 'accessing' stamp: 'sbw 5/18/2004 09:18'!defaultPort	DefaultPort isNil ifTrue: [self defaultPort: self defaultDefaultPort].	^ DefaultPort! !!IRCConnectionProfile class methodsFor: 'accessing' stamp: 'sbw 5/16/2004 21:36'!defaultPort: aString 	DefaultPort := aString! !!IRCConnectionProfile class methodsFor: 'accessing' stamp: 'sbw 5/18/2004 09:17'!defaultServer	DefaultServer isNil ifTrue: [self defaultServer: self defaultDefaultServer].	^ DefaultServer! !!IRCConnectionProfile class methodsFor: 'accessing' stamp: 'sbw 5/16/2004 08:07'!defaultServer: anIRCServer 	DefaultServer := anIRCServer! !!IRCConnectionProfile class methodsFor: 'accessing' stamp: 'sbw 5/18/2004 09:20'!defaultUserName	DefaultUserName isNil ifTrue: [self defaultUserName: self defaultDefaultUserName].	^ DefaultUserName! !!IRCConnectionProfile class methodsFor: 'accessing' stamp: 'sbw 5/16/2004 08:05'!defaultUserName: aString 	DefaultUserName := aString! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 08:06'!aboutToBeClosed	talkingTo isNil		ifTrue: [connection msgObserver: nil.			self release].	^ true! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/5/1998 00:12'!chatAreaSelection 	^self chatTextSelection! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 08:06'!checkForScrollPlaybackDownOn: morph 	| previous |	self messagePlayback rollIndexForward.	previous _ self messagePlayback getIndexedMessage.	previous isNil		ifFalse: [morph setText: previous.			morph				setSelection: (previous size + 1 to: previous size + 1).			morph hasUnacceptedEdits: true].	^ false! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 08:06'!checkForScrollPlaybackUpOn: morph 	| previous |	previous _ self messagePlayback getIndexedMessage.	self messagePlayback rollIndexBack.	previous isNil		ifFalse: [morph setText: previous.			morph				setSelection: (previous size + 1 to: previous size + 1).			morph hasUnacceptedEdits: true].	^ false! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 08:06'!closeFrontMostWindow	connection gui closeTab! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'sbw 6/10/2004 20:19'!docs	IRCConnection showDocs! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 08:06'!initialExtent	^ 450 @ 160! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'sbw 6/7/2004 23:11'!initialize: aConnection 	connection _ aConnection.	self initializeChatTextLines.	connection subscribeToDirectMessages: self! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'fc 11/9/2005 14:14'!ircMessageRecieved: aMessage 	| sender newLine nickText pvt messageText messageWords actionFlag |"	aMessage text = 'VERSION'		ifTrue: [aMessage inspect]."	sender := aMessage sender				ifNil: ['Server'].	sender := IRCProtocolMessage cleanSenderString: sender.	"Check if someone else is handling this for us if we are the  	generic private messages handler."	talkingTo isNil		ifTrue: [(connection gui alreadyShowingPrivateMessagesFrom: sender)				ifTrue: [^ nil]].	"Should open a new window and let that one have this  	message?"	(talkingTo isNil			and: [aMessage sender isNil not])		ifTrue: [(IRCOptionsManagement option: #privateMessageOpensNewWindow)				ifTrue: [pvt := connection talkTo: sender.					^ pvt ircMessageRecieved: aMessage]].	talkingTo		ifNotNil: [aMessage sender isNil				ifFalse: ["only display messages to or from talkingTo"					sender asIRCLowercase = talkingTo asIRCLowercase						ifFalse: [^ self]]].	(talkingTo isNil			and: [aMessage sender isNil])		ifTrue: [^ self].	"Check if we should be posting our own message here."	aMessage sender isNil		ifTrue: [aMessage recipient = talkingTo				ifFalse: [^ nil]].	aMessage sender isNil		ifTrue: [sender := self nick].	nickText := Text				string: sender				emphasis: (Array with: TextEmphasis bold).	messageText := aMessage text asText.	messageWords := messageText asString substrings.	actionFlag := false.	messageWords size > 1		ifTrue: [messageWords first asUppercase = (IRCProtocolMessage extendedDelimeterCharacter asString , 'ACTION')				ifTrue: [actionFlag := true.					messageText := messageText copyFrom: 9 to: messageText size - 1]].		aMessage sender isNil		ifTrue: ["message is going out"			messageText addAttribute: IRCClientColors transmittedMessage]		ifFalse: [IRCClientSounds specificPrivateMessageArrived].	actionFlag		ifTrue: [ newLine :=  nickText , ' ', (Text string: messageText asString   attributes: IRCClientColors messageContainsAction), String cr]		ifFalse: [newLine := nickText , ': ' , messageText , String cr.].		newLine := connection markIfURL: newLine startingAt: 1.	self addToChatText: newLine.	talkingTo isNil		ifTrue: [connection gui possibleTabStateChange: self class privateMessagesLabel]		ifFalse: [connection gui possibleTabStateChange: sender]! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 08:06'!keyInterceptEndedFrom: morph 	self messagePlayback resetIndex! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'sbw 6/9/2004 03:54'!keyInterceptedEvent: evt morph: morph 	"Answer true if we want the pane to have the event anyway.  	There are 3 classes involved here.  	TextMorphForInterceptingIRCEditView intercepts the keystrokes.  	PluggableInterceptingIRCTextMorph is the morph holding the text.  	IRCDirectMessagesObserver (this class) decides what to do with  	the intercepts.  	Once an intercept is tripped we will recieve ALL keystrokes until we  	tell the text morph #clearInterceptActive"	| char |	char _ evt keyCharacter.	char = Character arrowUp		ifTrue: [^ self checkForScrollPlaybackUpOn: morph].	char = Character arrowDown		ifTrue: [^ self checkForScrollPlaybackDownOn: morph].	self keyInterceptEndedFrom: morph.	^ true! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 08:07'!messagePlayback	messagePlayback == nil		ifTrue: [messagePlayback _ IRCMessagePlayback new].	^ messagePlayback! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'sbw 6/8/2004 06:46'!nick	^connection nick! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'fc 1/17/2005 14:40'!openMorphicView	"We do it inside the console window!!"	"open a view for messages sent here"	| paneName alignMorph |	paneName := talkingTo				ifNil: [self class privateMessagesLabel]				ifNotNil: [talkingTo].	alignMorph := AlignmentMorph newColumn hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 0;				 layoutPolicy: ProportionalLayout new.	alignMorph color: Color paleYellow.	self buildMorphIn: alignMorph.	connection gui		addSwapPane: alignMorph		named: paneName		hidden: talkingTo isNil		closeable: talkingTo isNil not		swapModel: self! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/4/1998 23:53'!openView	^self openMorphicView! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 08:08'!perform: aSelector orSendTo: rcvr 	(self respondsTo: aSelector)		ifTrue: [^ self perform: aSelector].	^ rcvr perform: aSelector! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/8/1998 04:55'!release	connection unsubscribeFromDirectMessages: self.	super release.! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'md 10/22/2003 16:16'!sendMessage: aString	"send a message to the user we are talking to"	| newLine |	talkingTo ifNil: [Beeper beep. ^ self].	connection privmsgFrom: nil  to: talkingTo  text: aString.	newLine _ (Text string: 'me' attribute: TextEmphasis bold),		': ', aString, String cr.	self addToChatText: newLine.	^true! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:38'!talkingTo: aName	"set who this window is for talking to"	talkingTo _ aName! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'sbw 6/2/2004 10:00'!traceOff	IRCConnection tracing: false! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'sbw 6/2/2004 10:00'!traceOn	IRCConnection tracing: true! !!IRCDirectMessagesObserver methodsFor: 'messages' stamp: 'sbw 5/13/2004 08:06'!acceptPrivateString: aString 	"New send message logic."	talkingTo isNil		ifTrue: [^ true].	^ connection				sendPrivateString: aString				from: self				to: talkingTo! !!IRCDirectMessagesObserver methodsFor: 'messages' stamp: 'sbw 5/13/2004 08:06'!addWithNickToChatText: aText 	"new message logic."	| newLine |	newLine _ (Text string: connection nick attribute: TextEmphasis bold)				, ': ' , aText , String cr.	self addToChatText: newLine! !!IRCDirectMessagesObserver methodsFor: 'messages' stamp: 'sbw 5/13/2004 08:08'!talkingTo	^talkingTo! !!IRCDirectMessagesObserver methodsFor: 'messages' stamp: 'sbw 5/13/2004 08:08'!textWasSent: aText 	"new message logic."	self messagePlayback addMessage: aText.	true		ifFalse: ["Bypass this for now..."			self addWithNickToChatText: aText]! !!IRCDirectMessagesObserver methodsFor: 'text pane' stamp: 'sbw 6/7/2004 23:12'!addToChatText: aString 	chatTextLines add: aString.	self changed: #chatText! !!IRCDirectMessagesObserver methodsFor: 'text pane' stamp: 'sbw 6/7/2004 23:12'!chatText	^ chatTextLines text! !!IRCDirectMessagesObserver methodsFor: 'text pane' stamp: 'sbw 6/7/2004 23:13'!chatTextSelection	| theSize |	theSize _ self chatText size.	^ theSize + 1 to: theSize! !!IRCDirectMessagesObserver methodsFor: 'text pane' stamp: 'sbw 6/7/2004 23:13'!clearTextPane	chatTextLines clear.	self changed: #chatText! !!IRCDirectMessagesObserver methodsFor: 'text pane' stamp: 'fc 10/10/2005 15:59'!initializeChatTextLines	chatTextLines _ IRCTextLines new initialize! !!IRCDirectMessagesObserver methodsFor: 'pane building' stamp: 'fc 12/4/2004 20:56'!buildMorphIn: parentMorph 	| textArea inputHeight inputArea |	textArea := PluggableIRCTextMorph				on: self				text: #chatText				accept: nil				readSelection: #chatTextSelection				menu: #channelTextMenu:.	inputHeight := talkingTo isNil				ifTrue: [0]				ifFalse: [26].	parentMorph		addMorph: textArea		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ inputHeight negated)).	talkingTo isNil		ifFalse: [inputArea := PluggableInterceptingIRCTextMorph						on: self						text: nil						accept: #acceptPrivateString:.			inputArea acceptOnCR: true;				 addIntercept: Character arrowUp;				 addIntercept: Character arrowDown;				 hideScrollBarsIndefinitely.			parentMorph				addMorph: inputArea				fullFrame: (LayoutFrame						fractions: (0 @ 1 corner: 1 @ 1)						offsets: (0 @ inputHeight negated corner: 0 @ 0)).			textArea keysInputPane: inputArea]! !!IRCDirectMessagesObserver methodsFor: 'pane building' stamp: 'sbw 5/13/2004 08:06'!channelTextMenu: aMenu 	aMenu 		addList: #(#('find' #find) #('find again' #findAgain) #('set search string' #setSearchString) #('copy' #copySelection)).	connection gui frontMostPaneIsCloseable 		ifTrue: [aMenu addList: #(#('close' #closeFrontMostWindow))].	^aMenu! !!IRCDirectMessagesObserver class methodsFor: 'instance creation' stamp: 'ls 9/5/1998 00:00'!forConnection: aConnection	^super new initialize: aConnection! !!IRCDirectMessagesObserver class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 09:38'!forConnection: aConnection  talkingTo: aName	^(super new initialize: aConnection) talkingTo: aName! !!IRCDirectMessagesObserver class methodsFor: 'instance creation' stamp: 'ls 9/5/1998 00:00'!openForConnection: aConnection	^(self forConnection: aConnection) openView! !!IRCDirectMessagesObserver class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 09:38'!openForConnection: aConnection  talkingTo: aName	^(self forConnection: aConnection talkingTo: aName) openView! !!IRCDirectMessagesObserver class methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 07:44'!privateMessagesLabel	^'private messages'! !!IRCErrorLog commentStamp: '<historical>' prior: 0!We manage output message logs for the model since it does not have a GUI.!!IRCErrorLog class methodsFor: 'API' stamp: 'sbw 5/30/2004 09:43'!defaultLogName	^ self defaultLogNamePrefix, self logNameSuffix! !!IRCErrorLog class methodsFor: 'API' stamp: 'sbw 5/30/2004 09:30'!log: aString 	self log: aString named: 'default'! !!IRCErrorLog class methodsFor: 'API' stamp: 'sbw 5/30/2004 10:01'!log: aString forClass: aClass 	self log: aString named: aClass asString! !!IRCErrorLog class methodsFor: 'private' stamp: 'sbw 5/30/2004 09:42'!defaultLogNamePrefix	^'default'! !!IRCErrorLog class methodsFor: 'private' stamp: 'sbw 5/30/2004 09:42'!log: aString named: logName 	| dir fName fStream |	dir := ExternalIRCFiles errorsFolder.	fName := logName , self logNameSuffix.	[fStream := self logStreamNamed: fName existsIn: dir.	self logPrivate: aString on: fStream]		ensure: [fStream close]! !!IRCErrorLog class methodsFor: 'private' stamp: 'sbw 5/30/2004 09:42'!logNameSuffix	^'.txt'! !!IRCErrorLog class methodsFor: 'private' stamp: 'sbw 6/2/2004 07:52'!logPrivate: aString on: fStream 	fStream setToEnd.	fStream nextPutAll: '[' , DateAndTime current printString , '] ';		 nextPutAll: aString;		 cr;		 flush! !!IRCErrorLog class methodsFor: 'private' stamp: 'sbw 5/30/2004 09:25'!logStreamNamed: logName existsIn: aDirectory 	"This creates the loog file if required.  Always answers the file stream."	^ (aDirectory fileExists: logName)		ifTrue: [aDirectory oldFileNamed: logName]		ifFalse: [aDirectory newFileNamed: logName]! !!IRCGUIHelper commentStamp: '<historical>' prior: 0!Provides a common place for common IRC client GUI component building operations.!!IRCGUIHelper class methodsFor: 'private' stamp: 'sbw 4/3/2005 09:55'!addBackLabel: aString toEntryField: entry 	| emptyText |	emptyText := TextMorph new.	emptyText contents: aString.	emptyText		beAllFont: (StrikeFont familyName: #ComicPlain size: 12);		 color: Color lightGray.	emptyText lock.	entry tagWhenEmpty: emptyText! !!IRCGUIHelper class methodsFor: 'private' stamp: 'fc 4/13/2005 11:17'!textEntryMorphOn: target textGetter: getterSymbol textSetter: setterSymbol 	| entryMorph |	entryMorph := PluggableIRCTextEntryMorph				on: target				text: getterSymbol				accept: setterSymbol.	entryMorph color: Color white;		 acceptOnCR: true;		 hideScrollBarsIndefinitely;		 borderColor: Color lightGray.	^ entryMorph! !!IRCGUIHelper class methodsFor: 'private' stamp: 'sbw 3/16/2005 07:27'!textTagField: aString 	^ StringMorph		contents: aString		font: (StrikeFont familyName: 'NewYork' size: 12)! !!IRCGUIHelper class methodsFor: 'entry field' stamp: 'sbw 3/16/2005 20:34'!entryFieldRowFor: target tag: tag backLabel: backLabel textGetter: getterSymbol textSetter: setterSymbol color: aColor tagColumnWidth: tagWidth tagPad: tagPad tagInset: tagInset 	| descMorph textEntry alignPane |	descMorph := self textTagField: tag.	textEntry := self				textEntryMorphOn: target				textGetter: getterSymbol				textSetter: setterSymbol.	self addBackLabel: backLabel toEntryField: textEntry.	alignPane := AlignmentMorph newRow hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 0;				 color: aColor;				 layoutPolicy: ProportionalLayout new.	alignPane		addMorph: descMorph		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 0 @ 1)				offsets: (tagPad @ (2 + tagInset) corner: tagPad + tagWidth @ 0));				addMorph: textEntry		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (tagWidth + tagPad @ tagInset corner: 0 @ tagInset negated)).	^ alignPane! !!IRCMainWindow methodsFor: 'buttons' stamp: 'sbw 5/7/2004 20:26'!addActionButtonsWithFractions: fractions offsets: offsets 	| alignMorph buttons indicator |	buttons := self buttonRow.	Preferences alternativeWindowLook		ifTrue: [buttons color: Color transparent.			buttons				submorphsDo: [:m | m borderWidth: 2;						 borderColor: #raised]].	alignMorph := AlignmentMorph newRow hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 2;				 layoutPolicy: ProportionalLayout new.	indicator := SketchMorph withForm: self scaledDisconnectedForm.	indicator name: 'indicator'.	alignMorph		addMorph: indicator		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 0 @ 0)				offsets: (0 @ 0 corner: self indicatorExtent)).	alignMorph		addMorph: buttons		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (self indicatorWidth @ 0 corner: 0 @ 0)).	self		addMorph: alignMorph		fullFrame: (LayoutFrame fractions: fractions offsets: offsets).	Preferences alternativeWindowLook		ifTrue: [alignMorph borderWidth: 2]		ifFalse: [alignMorph borderWidth: 0]! !!IRCMainWindow methodsFor: 'buttons' stamp: 'sbw 5/11/2004 21:51'!buttonRow	| aRow btn onColor offColor |	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent.	aRow clipSubmorphs: true.	aRow layoutInset: 5 @ 1;		 cellInset: 6.	btns := Dictionary new.	self buttonSpecs		do: [:spec | 			btn := PluggableButtonMorph						on: self						getState: ((spec at: 'status')									= #none								ifFalse: [spec at: 'status'])						action: (spec at: 'selector').			btn color: Color transparent;				 hResizing: #spaceFill;				 vResizing: #spaceFill;				 useRoundedCorners;				 label: (spec at: 'label') asString.			onColor := (spec at: 'on')							= #none						ifTrue: [Color transparent]						ifFalse: [self								perform: (spec at: 'on')].			offColor := (spec at: 'off')							= #none						ifTrue: [Color transparent]						ifFalse: [self								perform: (spec at: 'off')].			btn onColor: onColor offColor: offColor.			aRow addMorphBack: btn.			btn				setBalloonText: (spec at: 'help').			btns				at: (spec at: 'name')				put: btn].	^ aRow! !!IRCMainWindow methodsFor: 'buttons' stamp: 'sbw 5/4/2004 07:56'!buttonSpecs	^ OrderedCollection new add: self connectButtonSpecification;		 add: self setupButtonSpecification;		 add: self motdButtonSpecification;		 add: self channelsButtonSpecification;		 add: self privateMessageButtonSpecification;		 add: self newConsoleButtonSpecification;		 yourself! !!IRCMainWindow methodsFor: 'buttons' stamp: 'sbw 5/4/2004 11:52'!updateButtonNamed: aString newTag: newTag 	| btn |	btns isNil		ifTrue: [^ nil].	(btns includesKey: aString)		ifFalse: [^ nil].	btn := btns at: aString.	btn label: newTag.	"Need to do something about the connect button and we could do that  	here..."	aString = 'connect'		ifTrue: [self updateIndicator.			self notifyConfigDialogConnectState]! !!IRCMainWindow methodsFor: 'buttons' stamp: 'sbw 6/3/2004 21:55'!updateNickLabel	"Do nothing when we see this message from <connection>"! !!IRCMainWindow methodsFor: 'connect indicator' stamp: 'sbw 5/5/2004 22:49'!addConnectedIndicator	| indicator |	indicator := SketchMorph withForm: self scaledDisconnectedForm.	indicator name: 'indicator'.	self		addMorph: indicator		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 0 @ 0)				offsets: (0 @ 0 corner: self indicatorExtent))! !!IRCMainWindow methodsFor: 'connect indicator' stamp: 'sbw 5/11/2004 21:35'!connected	^model connected! !!IRCMainWindow methodsFor: 'connect indicator' stamp: 'sbw 5/7/2004 20:19'!scaledConnectedForm	^self class connectedForm scaledToSize: self scaledIndicatorExtent! !!IRCMainWindow methodsFor: 'connect indicator' stamp: 'sbw 5/7/2004 20:19'!scaledDisconnectedForm	^self class disconnectedForm scaledToSize: self scaledIndicatorExtent! !!IRCMainWindow methodsFor: 'connect indicator' stamp: 'sbw 5/7/2004 20:19'!scaledIndicatorExtent	^self indicatorWidth @ (self buttonHeight - 8)! !!IRCMainWindow methodsFor: 'connect indicator' stamp: 'sbw 5/29/2004 06:56'!updateIndicator	| morph |	morph := self submorphNamed: 'indicator'.	morph		newForm: (model connected				ifTrue: [self scaledConnectedForm]				ifFalse: [self scaledDisconnectedForm])! !!IRCMainWindow methodsFor: 'swapper' stamp: 'sbw 5/6/2004 21:36'!addSwapPane: aPane named: aString hidden: hidden closeable: closeable swapModel: swapModel 	self swapper 		addPane: aPane		named: aString		hidden: hidden		closeable: closeable		swapModel: swapModel! !!IRCMainWindow methodsFor: 'swapper' stamp: 'sbw 5/6/2004 21:36'!allSwappedPaneNamesWithModels	^ self swapper allSwappedPaneNamesWithModels! !!IRCMainWindow methodsFor: 'swapper' stamp: 'sbw 5/6/2004 21:37'!alreadyShowingPrivateMessagesFrom: aNick 	^self swapper swappedPanesIncludePaneNamed: aNick! !!IRCMainWindow methodsFor: 'swapper' stamp: 'sbw 5/4/2004 07:17'!buildSwapper	^ TabbedSwappingControl newSwapControlPaneOrientation: #top showMover: true! !!IRCMainWindow methodsFor: 'swapper' stamp: 'sbw 5/6/2004 21:38'!closeTab	"Action from the close button in the swapper movers pane."	self swapper closeFrontPane! !!IRCMainWindow methodsFor: 'swapper' stamp: 'sbw 5/6/2004 21:38'!closeTabs	"Close all the closeable tabs."	self swapper closeAllPanes! !!IRCMainWindow methodsFor: 'swapper' stamp: 'sbw 5/6/2004 21:38'!frontMost	^self swapper frontMost! !!IRCMainWindow methodsFor: 'swapper' stamp: 'sbw 5/6/2004 21:38'!frontMostPaneIsCloseable	^self swapper frontMostPaneIsCloseable! !!IRCMainWindow methodsFor: 'swapper' stamp: 'sbw 5/6/2004 21:38'!possibleTabStateChange: paneName 	self swapper possibleTabStateChange: paneName! !!IRCMainWindow methodsFor: 'swapper' stamp: 'sbw 5/6/2004 21:36'!showPaneNamed: aString 	self swapper showPaneNamed: aString! !!IRCMainWindow methodsFor: 'swapper' stamp: 'sbw 5/4/2004 08:07'!swapper	^swapper! !!IRCMainWindow methodsFor: 'console' stamp: 'fc 12/4/2004 20:56'!buildCombinedConsoleTextAndInputPane	| consolePane inputPane alignMorph inputHeight |	inputHeight := self inputHeight.	alignMorph := AlignmentMorph newColumn hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 0;				 layoutPolicy: ProportionalLayout new.	consolePane := PluggableIRCTextMorph				on: model				text: #consoleText				accept: nil				readSelection: #consoleTextSelection				menu: #consoleMenu:.	consolePane name: 'text'.	inputPane := PluggableInterceptingIRCTextMorph				on: model				text: nil				accept: #acceptConsoleString:.	inputPane acceptOnCR: true;		 color: Color white;		 addIntercept: Character arrowUp;		 addIntercept: Character arrowDown;		 name: 'consoleInput';		 hideScrollBarsIndefinitely.	consolePane keysInputPane: inputPane.	alignMorph color: IRCClientColors consolePaneBackground;				addMorph: consolePane		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ inputHeight negated)).	alignMorph		addMorph: inputPane		fullFrame: (LayoutFrame				fractions: (0 @ 1 corner: 1 @ 1)				offsets: (0 @ inputHeight negated corner: 0 @ 0)).	^ alignMorph! !!IRCMainWindow methodsFor: 'console' stamp: 'sbw 5/4/2004 08:25'!consoleMenu: aMenu 	aMenu addList: self consoleMenuSpecification.	^ aMenu! !!IRCMainWindow methodsFor: 'console' stamp: 'sbw 5/4/2004 08:25'!consoleMenuSpecification 	| list |	list _ OrderedCollection new.	list		add: #('find (f)' #find);		add: #('find again (g)' #findAgain);		add: #('set search string' #setSearchString);		add: #('copy (c)' #copySelection).	self frontMostPaneIsCloseable		ifTrue: [list add: #('close' #closeTab)].	^ list! !!IRCMainWindow methodsFor: 'console' stamp: 'sbw 5/4/2004 09:07'!consoleText	^model consoleText! !!IRCMainWindow methodsFor: 'console' stamp: 'sbw 5/4/2004 09:07'!consoleTextSelection	^ model consoleTextSelection! !!IRCMainWindow methodsFor: 'initialization' stamp: 'sbw 5/12/2004 20:42'!buildMorphicWindow	| buttonHeight consolePane |	buttonHeight := self buttonHeight.	self		addActionButtonsWithFractions: (0 @ 0 corner: 1 @ 0)		offsets: (0 @ 0 corner: 0 @ buttonHeight).	swapper := self buildSwapper.	self		addMorph: self swapper		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ buttonHeight corner: 0 @ 0)).	consolePane := self buildCombinedConsoleTextAndInputPane.	self		addSwapPane: consolePane		named: 'console'		hidden: false		closeable: false		swapModel: self.	self swapper defaultPaneName: 'console'.	self swapper fillWithRamp: self paneColorRamp oriented: 6;				setMoverButtonColors: self moverButtonColor! !!IRCMainWindow methodsFor: 'constants' stamp: 'sbw 5/4/2004 07:04'!buttonHeight	^ 26! !!IRCMainWindow methodsFor: 'constants' stamp: 'sbw 5/4/2004 10:35'!indicatorExtent	^ self indicatorWidth@self buttonHeight! !!IRCMainWindow methodsFor: 'constants' stamp: 'sbw 5/7/2004 20:18'!indicatorWidth	^ 32! !!IRCMainWindow methodsFor: 'constants' stamp: 'sbw 5/4/2004 08:20'!initialExtent	"Oh, so fussy about pane size..."	^ 690 @ 460! !!IRCMainWindow methodsFor: 'constants' stamp: 'sbw 5/4/2004 07:18'!inputHeight	^ 25! !!IRCMainWindow methodsFor: 'constants' stamp: 'sbw 5/13/2004 07:04'!moverButtonColor	^ Color		r: 0.92		g: 0.92		b: 0.72! !!IRCMainWindow methodsFor: 'channels' stamp: 'sbw 5/4/2004 08:04'!channelsBrowser	^ channelsBrowser! !!IRCMainWindow methodsFor: 'channels' stamp: 'sbw 5/4/2004 08:04'!channelsBrowser: aIRCChannelListBrowserEnhanced 	channelsBrowser := aIRCChannelListBrowserEnhanced! !!IRCMainWindow methodsFor: 'buttons-specs' stamp: 'sbw 5/4/2004 07:52'!channelsButtonSpecification	^ Dictionary new at: 'label' put: 'channels';		 at: 'name' put: 'channels';		 at: 'selector' put: #openChannelList;		 at: 'status' put: #none;		 at: 'help' put: 'Open Channels List Window';		 at: 'on' put: #none;		 at: 'off' put: #none;		 yourself! !!IRCMainWindow methodsFor: 'buttons-specs' stamp: 'sbw 5/12/2004 06:54'!connectButtonSpecification	^ Dictionary new at: 'label' put: 'connect';		 at: 'name' put: 'connect';		 at: 'selector' put: #connectToggle;		 at: 'status' put: #connected;		 at: 'help' put: 'Connect/Disconnect IRC server';		 at: 'on' put: #none;		 at: 'off' put: #none;		 yourself! !!IRCMainWindow methodsFor: 'buttons-specs' stamp: 'sbw 5/4/2004 07:53'!motdButtonSpecification	^ Dictionary new at: 'label' put: 'MOTD';		 at: 'name' put: 'motd';		 at: 'selector' put: #openMotd;		 at: 'status' put: #none;		 at: 'help' put: 'Read Message Of The Day';		 at: 'on' put: #none;		 at: 'off' put: #none;		 yourself! !!IRCMainWindow methodsFor: 'buttons-specs' stamp: 'sbw 5/4/2004 07:54'!newConsoleButtonSpecification	^ Dictionary new at: 'label' put: 'new console';		 at: 'name' put: 'newConsole';		 at: 'selector' put: #newConsole;		 at: 'status' put: #none;		 at: 'help' put: 'Open up a new IRC console using same options';		 at: 'on' put: #none;		 at: 'off' put: #none;		 yourself! !!IRCMainWindow methodsFor: 'buttons-specs' stamp: 'sbw 5/4/2004 07:52'!privateMessageButtonSpecification	^ Dictionary new at: 'label' put: 'pvt msg';		 at: 'name' put: 'pvt';		 at: 'selector' put: #talkTo;		 at: 'status' put: #none;		 at: 'help' put: 'Private Message for Individual';		 at: 'on' put: #none;		 at: 'off' put: #none;		 yourself! !!IRCMainWindow methodsFor: 'buttons-specs' stamp: 'sbw 5/4/2004 07:53'!setupButtonSpecification	^ Dictionary new at: 'label' put: 'setup';		 at: 'name' put: 'setup';		 at: 'selector' put: #openConnectionDialogue;		 at: 'status' put: #none;		 at: 'help' put: 'Open up connection setup dialog';		 at: 'on' put: #none;		 at: 'off' put: #none;		 yourself! !!IRCMainWindow methodsFor: 'actions' stamp: 'sbw 5/29/2004 07:15'!connectDialog	^connectDialog! !!IRCMainWindow methodsFor: 'actions' stamp: 'sbw 5/29/2004 07:15'!connectDialog: obj 	connectDialog := obj! !!IRCMainWindow methodsFor: 'actions' stamp: 'sbw 5/30/2004 10:23'!connectToggle	| titleString |	titleString _ IRCMainWindow baseWindowTitle.	model connectToggle ifTrue: [		titleString _ titleString, ' [' , model nick , ' @ ' , model server , ']'].	self setLabel: titleString! !!IRCMainWindow methodsFor: 'actions' stamp: 'sbw 5/16/2004 07:48'!newConsole	model newConsole! !!IRCMainWindow methodsFor: 'actions' stamp: 'sbw 5/29/2004 07:12'!notifyConfigDialogConnectState	self connectDialog isNil		ifTrue: [^ nil]		ifFalse: [self connectDialog connectionStateChanged]! !!IRCMainWindow methodsFor: 'actions' stamp: 'sbw 5/4/2004 11:25'!openChannelList	model openChannelList! !!IRCMainWindow methodsFor: 'actions' stamp: 'sbw 5/29/2004 07:14'!openConnectionDialogue	self		connectDialog: (IRCConnectionDialog on: model).	self connectDialog openDialog! !!IRCMainWindow methodsFor: 'actions' stamp: 'sbw 6/4/2004 06:48'!openMotd	| paneName alignMorph textView updateButton buttonHeight |	buttonHeight := 22.	motdPane isNil		ifFalse: [^ nil].	paneName := 'MOTD'.	alignMorph := AlignmentMorph newColumn hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 2;				 layoutPolicy: ProportionalLayout new.	textView := PluggableTextMorph				on: model				text: #motd				accept: nil.	alignMorph		addMorph: textView		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ buttonHeight negated)).	updateButton := PluggableButtonMorph				on: model				getState: nil				action: #requestMotd.	updateButton hResizing: #spaceFill;		 vResizing: #spaceFill;		 label: 'update'.	alignMorph		addMorph: updateButton		fullFrame: (LayoutFrame				fractions: (0 @ 1 corner: 1 @ 1)				offsets: (0 @ buttonHeight negated corner: 0 @ 0)).	alignMorph color: Color white.	self		addSwapPane: alignMorph		named: paneName		hidden: false		closeable: true		swapModel: model.	motdPane := alignMorph! !!IRCMainWindow methodsFor: 'actions' stamp: 'sbw 5/4/2004 11:26'!talkTo	model talkTo! !!IRCMainWindow commentStamp: '<historical>' prior: 0!Primary IRC window.!!IRCMainWindow class methodsFor: 'as yet unclassified' stamp: 'sbw 5/4/2004 06:57'!baseWindowTitle	^ 'Enhanced IRC Console'! !!IRCMainWindow class methodsFor: 'stored graphics' stamp: 'sbw 5/4/2004 10:53'!connectedForm	ConnectedForm isNil ifTrue: [self initializeConnectedForm].	^ ConnectedForm! !!IRCMainWindow class methodsFor: 'stored graphics' stamp: 'sbw 5/8/2004 11:35'!connectedFullSizeMorph	"IRCMainWindow connectedFullSizeMorph openInHand"	| encoded zippedString data rwStream |	encoded := self connectedMorphCompressedEncoded.	zippedString := Base64MimeConverter mimeDecode: encoded as: String.	data := zippedString unzipped.	rwStream := RWBinaryOrTextStream with: data.	rwStream reset; fileInAnnouncing: ''.	^ SmartRefStream scannedObject! !!IRCMainWindow class methodsFor: 'stored graphics' stamp: 'sbw 5/8/2004 11:40'!connectedMorphCompressedEncoded	^ 'H4sIAAAAAAAAAM1bfXQUVZavJulOOh9F6jFwZObgSZwDTJwJa3BQyRzG4SsrMwSBGPfgDKyV7kpSoT9CdXVCoiCgREFBiSYKCgoKCgoKCiqKigoqKiqKCgoETKLsOc4Me9bZ45zVt++9e191VSdxUEd380fd+t17633cd+9991VXRpZb8Whh5bykoc+9cNTF1YatF8ZrCkeOLC0c32CZkcLRF1zw65EjC/8Y0W0jYRcmG8Lspqzw52MuufiS2YXxWOElhRV6s1Ar1O3C0tKyC8eW8fvoyKL8/KLLq+uNkF0Z0mMxwyqMGU2FZsy0TT1ithhMzjQSRqSmMBHVLXumUVNpW4YeLcpUFCUzm1+0gaGInkgUJmwrGbKTlhFk3IxAziQzZJvxmG41c90Srns1iHLHJxLxkKlzcSA4odk2xluW3sw1fFxX8fl8BRnKbwIBGJtbIPj+8khcd7GBOTEeiVtiSIKpZVi11VpuSA/VGeFJRoNdpxUAmGDa03XbNqyYeDBYbkYilXZzxOjVUe6EuBU2rL6F/oq41VDH2VnQYaA6noyFE5o/3sRMqQUTyeooV0loOTXJSGQCSkN8nFrQmG8bsQQzAW8shz1fyJvKgKb8th6JNGt+nRtG9jc9bsZsl5JvvuZrFiLtXy09bBox2zOVbBxW3DJrzZgWDJuWIdZEC8TiVlSPaEExlpl6tEELNpjzjYi4DfDGmDTfTFxh6bFEJBliTYuO8qbrCduoanCmfo7ogw3fN4hffsYv5/FLCb+M5ZffabnVwoz/ZobZIiCYCFZosIwEa5yZyx+Nh42IFgglrQSTZDXo4bAZq9UGVuuhubUWN57oVStgTmZHDDY0M5IoZxPRgsCZbsS0QcwX7SsAxhMmny0zv5mYzrw3MYFZQdWTdnyqGTOm6s3xpK2pZixshljETIR+c9mAmOdfES83bW1Qkx6zExXxZMK4vNGwLtMjcdZaU9yKhCtt9oyWU2uZYpiXgy8FmG9F9YZevkKmhNksTbs5FRWpheRGmsMvBrp9ZXO0Oh7p1UhgWjJabVieOJGhkls517BDdc665J3NuuSBZ+gRYcV8K26LmBQOpOUkQjo3IvM5Lb/G0qNG4or4pCYjEmE24ppGmD8G3avCUWoYdkaQczYjCNryORYu0XjcruNLnhuJs74hXtAitsUEaRH/k6m6VYvL3GhMYV5U67aO0MmfZCYaInpzhRE2k9HeKUbKe2UamJaYzWQZqSnDagE2xLlGWMtqNBNmNTNXIGGbobnNzL1Z5MbjsStYfGuDXKDSiLAemIfl8ci3mNWnMZtqeeibk+IsJrUcnauAbwX4uAyu38h85zI9Fo4wNJDZyLCmW/EGw7JNIwEDHeTYX6zgt1oEdsks55cZ/PInnPlMNlg9VhsxnLaCZ9fWgF/xy1hoZkilwTauWMjQmY1YyEcgAaUvEqRZI/xd+3IFgna5xRMhc053Ksx02tvCLzv4ZY8Mq+nCzq6dIydsNBgxHrEJLSsUT9hJtlDZeJPAx/IqzWhDxIChux4OVusJA7Ibpnp/E0984qFMHjJcOQDKmdUm6wMUtECdYdbW2Zo/LHarQLymJmFA3s0Z7/hFyjwsfptiLCxg/CxjGrFJjCNuKlkO07LZDYyEsACGxBORaVErMmMJtsRsq2fWqkqwbS5kmQ3ME50UpeWzBtjeHG+qM3S2deXYPOcKo8LOOTUen5ts+IMhktkA3HbnGs2p1RA7uxHua+kdpaDja67NTe5agVDcYrupUCyoiiXEGI1w+pqxBQ18zC+f8csZUMfYdmIjze1yWRTZ8b4jP1ih17IyKBk20iU5/boxKwjYDpYyhRiTkGT1nZz8aXWPYGZUGnZfe4MsE37jEWYP1fyNeiQJC1IgAsgMeWacKQ0q3InVFNzSml+kdy0vkWSJRFRwBs+1haliTXZ4Ge9mBC4WZ4Q546UUvpZdMhISrRIqEh0QKKXb7cW+AR7tQnYJzkpJLbfUt4Ib9C6J/sbRVEQZQ3CQEo8SzTnwjzy1RVPiBFc/kUobnHerGI+EmaqAEkVF+xJdz8dZItGD/PJKqqXMV2CSEnZ7oH+laN2BJ8Q8JAyM4B19KdFUGJNnoIG7hGFTmNs4OMjBWT5haIkuEkOUKOa2aHamYwbJGSHG4Ob8wfOELTqU6H6P7CUtI2ZGnAdPeKad/aVbNzjIg0rcHhSc5LZ1cJbbIDhsKWsXgygI+k8MzCloH7w9O+dSSqkIkIIc/8qB6mNbBi32M6W8W0SUFeRl3Drw68uP+l7g88xbnw1hnamsYm6fQbnvF+YuCviyqKLQgrzM7owBGcwUGUwl2/aJR7hhMkZxzQyxwWIOU2XxNFFUswUZPku9tFNRMEzzf456BSwqm3QrPEnW4qqCf5CS+ObBinkexAWBrItyF/1lIlUGqCN78pUc+t/nKD3DlJ8Kmq+cL6hPGcVp91fKRYKeUX4r6Gnl94KeRHpMmSnoEaSHlasEfVOZI+hrDq324HeUK5Fe5cFH0to7okzz0GNp/adouaDd/crT9b4fTc1/mof2Hv/MPvUkTY1ngqCfo50/V8oE/QLt/2Ua7Y//bfX6k49Tsjh9GuEYZQinWxGWKiM43eiF6x0ofGdt37AEaLsj7QuucmCZFwrrrPDCZc4gPbAUTLrUkaZBYfjFjrJYzwWO1ANLYRWTjvSboXDlqAOv6gOaCMdCPBiOtNoLazid7cD6PuAsBwoaBFL1jVw0cz6QGV5dDUiFV3cwkCle3TQu6g4DMt6rm8ZF3eFAxnp1kTsGwwB1i4GUYJCMkfD3MJlyt26p0uFWGqO0uaVjlZVuBxunLHdLxyutbulkZaG7qSlKC8IysFMMl7IMTFyDEVQGiwWJbTxAEweJBpM+UyH9XBWwyon+Msy+3mzQm//j6vX/3Nnq/d/OaxZkt3aEVZDdZFqZAelsMUorIH81O3C0G04BOs+BvwV4EcJyWHWQTgZPlcE/GTYBA6XjIY/I4B8PnqM78Co3HAeJY7YDq91wLDjhLAemZYqYN0VY3tzQ6E4KCKuc9N3ilpbABP3eRFIM3KA3kQyXcerhFgFX8yYSL1fqDgNuWtJB7lAvdyhwMelM9nKLvNzBwB3uTVBertTVYG4lXl3klnq5mJIwb4zzcsd6uUHgjvOmQy9X6vqBO96ri9zJ4E7YabcPuFNg+yv2ciuA4BS7vgI4A0iRlzsLCBq06wuwzmzgDvVyDeDiQnWdkX5f7lpUyZ0HI5Pcz+XWW+ZyFsld5tnNurAaxcD1e7mrwMu7sCRshxjowgpuLUIswNZDwEi4EeExgJshuiTcivAIwO0QihLuhECV8GmIavnsHoj5fuBeIF1Y5r4G2UTCN8EmEh6GxNSFtegRKN0l7OyGkl7Ov/MMlPpdp3/g0vgflczfn36/9vsrxY/1Omp8X73/n/0dO2u7fFd7/rDP9X7+7PTT/eU0HrlOYzWZOgqNxiMwHIX9UA70aFAl9BRB8cAwO677buaXKnHEF6832Ok6i526T7Lj9e/+q8dA3aXYhgF99ZSwQo+9CxgMuaFnKOuKwTl4BB/BQQw7P5eDFhwR4WAlDleANTgHATbgBHM42IbWEW8dduPpXID9eBQ/KOg+5X1B9yjHBd2pdPaIm61K53+Im81K53+Km/VK59/EzVql8+/iZrXS+bW4aVdODhA3q1w3AXGzInXjKGM7rME/yy6g0+3KUUH3KodwdJLuxynsxlXdwamYD5vxJg5UBMIMwiDMMMJAQwT4HM4APxXgDJT85yIQBf95AnwB5b5YBeYNovwR68PehohVGcUBW42aFAjCdiKeYStYA7ufGB17tyJgz5g0WgrPuOjZyXvzvbQERtkf7dbhlLEX4QzYRrZCFSgr2I0IJ8v90cIqdBrsnjF3jdruSD0Qa9RVCLEoXYHPjgO4zFGuh/O5bLkeinApjXmhBUWCVLagJpfSRoBS2ghnLSldCAfyRhzVEqhNWrxQSluhnmlxQ905EC4HKKUroVCS0jaAUtoGhbSUdgCU0g4ovSRcB/VZI455HRRxEm4AKM2+AQo/uWSboDqMIdwCtWMM19cDJyvboIaU0h1QPHpgqQN39QGlX1VAaBY70uegtpTSvmCR44QvQnEppfuhqpTSvuBgBx6CUlHCGqgGj+Phrm94FGE9FJTvu6X5mHRm9QMhcc4GqCkHvHC/Gw72wqEwbRaDfUNIbgbAYWBfJq13w9kwUQlnARwOC8mg5YZV4DLDYdW70d2KwUWktAQcSEpLwNu60VVLIYdKKTqulKZgC/hVG65CCzhhGy5oC7joSpQ2gnsvRykeOSXEA+lydCQLThqt6LEWBJ0HGhC3MhVEMcowFczDwOmVKCzIOfVuuAzf4IwFuApfWY+FNlLQglw3x32IXu2Fa/HtD8L1DozBsWIaNhWDDFzuzoQ7sS7BSN2D1f5OyN445n1QWHRtBmkShn4Eyo6u7dBEFCe0DDpA7+peCtUH+l73AvlGAWAzHHJmoW2SQOXbLUymFShF+07BEEyDUbn4Ei4BT7EQLgRPAWh6pSYsMxqfRcZygH1KdXAvKXVgI8ZNGzisB0plBzaiO69xK1dBSOA69oYb3HBGOtwEYdT4jVIJt0AINn6j1AOltAJivsSBOyDWG93ZutjZ53dDYrDc2boIlSdDPi5ypJieJcR8LJUPAJTSA5D5pPQgQCk9CGlSQkzeUvko5GO5lR2HbC1h5yk3xq1cZm+EMl3jVq4hHAO+omH2RjgUs3cpONZQTNcIh8G8JRyO6dqBu92wGGEJuF0x5meEJQ5cDmu2C1+VLQdv2OGGYxEOBzgOkznC8QiLYAq4o0tYgXAYQPQgBpdAPEu4EKJ9A74XWwK5YJ0bGggHy6JoDcJWSCsd+O6rFXJsG8LlAFe6YRJhPsAFmL0RLsbsjXAZVkEIVyAM9glltYlwNWaZIHS4GjMUQnztw96VtUFCrkbYAXAOwjVQA1/phlsxXfvBKtsxXfvAhHuct3AbIDGPcsMj+GZfQ3t/gZb9shdd0yf+yqEdSPt7XrbfH/Xqn71e+ng68EjahufUNsQd30Rd8+ibftnv+Dbh76Jb8MC7Dc+6O/A4uBtfkjzXJz2MgfyOQ/fj79Qvojz9ud14fJZ0R1p/Xtrt0G2e8Z3G8X6O4z+D8znj4E1pckn7trc/zd6Sonv3YMT0YEwyugR/32/BlxciWHqKnTNhPZ45RSD04O+RPfhbRE8FvDzpqcIXFwa+HKkQLz828cscePkRwK9/4RuFF/7nT2Oqy/9dvfT116+c9vWyJZn4cST/JuLCf/m6xvVNxBt0teubiIKg+Jgk7y/4dQreF2QG23nLmZR+/Wd2ob9Qnz80NUzDF/5CvfSv8KkDb3MAfIyhvb3+J7ftc77QUEQzb6R1I7++GDURv4OBDzCUbPyKjIui3u8y/PiJSP7Fng8sOOdKfPWTcf4XrxYpJ4fQoqKiMd+ansvJcTqhmJ77T2YM4YxWevwgS1s/QPPfgXEuZ8zhI6r5J7Q2gjMm8NZafpTRn88Zo3l/rT+6+b6rdwGNshzEyOZ/TGawnzKKi4vFfXcrvz15Hou9/ed/79uehfyex9VMfpmU6f6uLn9g+odOo/MgHJ9ll5JnQHrylzvJMzN+xdT+yv/OQIoR4Z97wa6C6X8/y/AfPaHf8B8dOfvwF8NzJsAfzu49ZsxUnpQl02Jh9gAx/tTnYalBif+JKUh9lh+24g2TY/zr5/AAF1OvTTHhe9Ma+blyQbZvhUigrKH1/NIukRhEQqLdjg3ER4qpefIhlo26eZMrc3/22WmhI2cjdM4Z4l/q0rn6aj130alHT7H6h6kT+umnnxHa0/MpYS9qe1Ta1dVN6CefdBF66tQnhJ48eUqlnZ0nCT1xopPQ48dPEHrs2HGVfvzxMUI/+uhjQo8e/YjQI0eOqvTDD48Q+sEHHxL6/vsfEHr48PuEvvfeYZW+++57hB469C6h77xziNC3335HpW+99TahBw++Reibbx4k9I033lTp66+/QeiBA68T+tprBwh99dXXVPrKK68Sun//K4Tu27ef0Jdf3kfoSy+9rNIXX3yJ0L17XyT0hRf2Evr88y+o9Lnnnid0z57nCH322T2EPvPMsyrdvfsZQp9+ejehTz31NKFPPvmUSnftepLQnTt3EfrEEzsJffzxJwjdseNxlW7fvoPQxx7bTuijjz5G6LZtj6p069ZthD7yyFZCH374EUK3bHlYpZs3byH0oYc2E/rggw8RumnTgyrduHEToQ88sJHQ++9/gNANG+4ndP36DSq97771hN57732Erlt3L6Fr165T6T33rCX07rvvIXTNmrsJXb16jUrvums1oXfeeRehHR13Etre3qHSO+5oJ/T22+8gtK3tdkJXrWoj9LbbVqn01ltvI3TlylsJXbFiJaG33LJCpTfffAuhy5ffTOiyZcsJvemmZSq98cabCG1tvZHQpUtbCb3hhqUqvf76GwhdsuR6QhcvXkLookWLCb3uukUqXbjwOkIXLFhI6LXXLiD0mmuuVWlLyzWENje3EDp/fjOhTU3zVdrY2ERoMtlIqG0nCU0kbJVaVoLQefMsQhsa5hEajzcQGovFVRqNxgiNRKKEzp0bIbS+fq5KTbOe0Lo6k9Da2jpCa2pqVWoYNYSGwwahoVCY0OrqkEp1vVq4bEYGxlR16j+1CjKzfPKjTgga56NOH5QePvn59EXri/Lz/xdCft+bYjcAAA=='! !!IRCMainWindow class methodsFor: 'stored graphics' stamp: 'sbw 5/4/2004 10:52'!convertRectangleMorphToForm: rectMorph	| canvas orgPosn |	orgPosn := rectMorph position copy.	rectMorph position: 0 @ 0.	canvas := FormCanvas extent: rectMorph extent depth: 32.	rectMorph drawOnCanvas: canvas.	rectMorph position: orgPosn.	^ canvas form! !!IRCMainWindow class methodsFor: 'stored graphics' stamp: 'sbw 5/8/2004 11:34'!convertSavedMorphFile: fileName 	"Save the Rectangle morph, compress it in FileList and then copy the file 	name (path) for this method. Copy the ASCII text into the source pane."	| fileStream encoded |	fileStream := FileStream oldFileNamed: fileName.	encoded := Base64MimeConverter mimeEncode: fileStream.	fileStream close.	encoded contents openInWorkspaceWithTitle: 'Copy this to compressed method source pane.'! !!IRCMainWindow class methodsFor: 'stored graphics' stamp: 'sbw 5/4/2004 10:55'!disconnectedForm	DisconnectedForm isNil		ifTrue: [self initializeDisconnectedForm].	^ DisconnectedForm! !!IRCMainWindow class methodsFor: 'stored graphics' stamp: 'sbw 5/8/2004 11:35'!disconnectedFullSizeMorph	"IRCMainWindow disconnectedFullSizeMorph openInHand"	| encoded zippedString data rwStream |	encoded := self disconnectedMorphCompressedEncoded.	zippedString := Base64MimeConverter mimeDecode: encoded as: String.	data := zippedString unzipped.	rwStream := RWBinaryOrTextStream with: data.	rwStream reset; fileInAnnouncing: ''.	^ SmartRefStream scannedObject! !!IRCMainWindow class methodsFor: 'stored graphics' stamp: 'sbw 5/4/2004 10:33'!disconnectedMorphCompressedEncoded	^ 'H4sIAAAAAAAAAL0YWZAURbZ7urumu6enpuuxQRixsUaPGyGBK6zLaij44TKMqLEgIzMEERprmF2V3VNMdVVTVT0zjYiIMoiIgBeXgqIip+CBB3ghCAjIoXiiCMi14Y/7se7HfrzNzKrq7uHYdV3X+XiV78h35Xsvs2fQaNsqZNonlyjp+uPQq7PUJRkrlxk06A+ZkUVbNzLDrrjiykGDMrcZxKWOmykVNbYYkfntVddcfc1fMpaZuTIzlpSFWIa4meEjrhw24iq2LAxqbmxsHpedRFW3XSWmSe2MSXsyuqm7OjH0KZTxmYRDjVzGKRDbHU9z7a5NSaE5GgqFonEOlCbVII6TcVy7pLolmyYYNSIlW3XV1S2T2GUuO5jL3uGxGkY6jqXqhLOlREvZpSNtm5S5RJjLhsLhcDoSulaSPN9qGYIeG21YpIbsEUdZhmULlwRRidj5rNKgErWTaq206HYqaQ9p0d024rrUNsXGxGjdMNrdskHPMdTQYtkatc/PjI217GInJ9d7BqWsVTI1R4lZPSyVSsIpZQtcxFGSuZJhtPhclfupJGivS02HpYArS7L9Ga4q4qmKucQwykqM8MT49pQbbKLp1HT7+Rv3bVu2ntdNJaHpNhWJVyTTsgvEUBLC4HhSKCqJot5LDbGUuDLGbdSdDpuYjlFSmWovsDZLN90ab8K9SrgsWKk24rh0QrES+kVCgrkfHsDBrzm4hIMhHAzn4E9KQ1akcaKusUPwkVFeFoo2dZhdlq5YwdKooUhqyXYYp75INE0380pTlqhdeZsnT1hV0qzIXIMyr3XDGc1iVBIepY2aygBWi26Hh1qOzhPB0q87bax6nRaWIJmUXGuMbtIxpGyVXEXWTU1XWcOM8uw2MIdY5XdYo3VXGdBDTNcZa5UcOq6b2jcSw2Laeizb0NpdtkdJ5m1duDnOqyWJ1VaBFM+pFbhJY1HqbrnaFdX88iTdzgH1y769XMhaxjlKpJtLhSy1+/VJ0CoN7V3UVTsr55L6MeeS8oqGGCKLjbblip4UtaUkHZXwJLJSUBpzNilQp8Nq7aGGwXLEJanGt/n2G1t1p2iQ8liq6aXCWa35qzHEzvvn0U1vYsedrw3DD9q1WR7PHQKB5nNmgeDKIuLrg16qhq5IhqV2UU2p79YdPcsCkhxXV7vKrABZb1mW2cE6UBlQg7RTg1lgNZDivWmzvNzMolZSfvW0WqyhlCThIt7pS9wvyuW72eneSEzNYFiT5XZSu822itR2deoEgcjjmXZi5g1aOaXEjzglBuou52C4p2ZgO2VXgalSwoJiXWR47X5WOhu9yUW1n2qrpraUcTYfO+y8awdPtKJvHgcLOVgRVGqbSEzNME5qtEhN3gSOUq9ajltimY37C8fflmrXC0WDeq7XbE5kiUO9geFPz1gPnyViU5RXIReWPOFoVmc2PAFF6qR6vtNVYpq4ACQrl3OoN+WSIysHWU0Pa4kek5Wh5z8bQtRsZRSxaGdjQYmzhecJsJ7wetkIJo3SrJsOO2J2e7JsTXDYzaHaepGVTqXrlUamgF13Vk8nJew2SLp8jImkepfRGMvqKhX/TMV8qPNvsi5arp6GuCypdr6jrwglKrVWM8aDO0JSLZtdUEIwPcF0hI9UO/vM2IFKv+eA305SqzdmWFm71gWu5cRYkmdPh5JGz+7S5AXrlF2ibOpXYxVGBaf+/HMidtZbQRAj7dQ93zwNrtZr+zHrDSXWTYwSDSspp8S6VDxgqMOkM9W3SrD3Rr6j7CeWEzRO+KGKT2Ug4gTYAiESYLsFVpU92R8P1/WTzjAQn1vl2gzEvguww7Wy4R84b7mPRQb6Tgb4UKGugt7GQLStyna4oQHVFuc00cV1FTzaxIEeYHwqxEmAtZ2Vk6juxRWgs/wwA0JsmPC2gpa5tiEBtty3XOtO7DuRvgou/YZvuaGKd4h0Bths4XGAba3NVP3ESrABpSx8qKUs67djpzAYYD8oEVM3KrLxAf1ijQ+p3Rq/oR9Gaksj3itsB9jc2hz4nobTidiwpsj3w5vmr0teh4iiMdKpyLymho3Xy0We5oaJca+xoqEFrFojyEs20zBdCtdjKITpVHRWpC7CYoukE9LWdLR+Z5jvMvzsRoaKNhAD00+54K+q8CKclwwureBRMEq80tKR8GH5uqOhkN9KDf/05dI5y+4httYaPD/lkP/nzQ0+wdn7tdipq2lJml3PzFz2913NoWMDsbm5+ar/+nsx/xzBlsF48c9MGMgJfXhkX2j0/0P9TyBczAm3c49yP4O2SzmhhWub8ot4fxknDOP2+n7x9P3U6vK+hdAK/ln9nz+3hG7FwYMHi/XJPr48dgnr3h2X/c/LU9P4mrfleA5aRbP7PZtiDy3vN57Xlsd+twm23HI568/v+d/fot7VzKdHLH1r8oplNdODL2dcYFY0rfn3s6LpUP9ZkfKHWMNpDv7hY6mmyggI95/tqaHCeS8Erq/P8/97T7qyiPq/Avigy8TrRCwVh2scrAsc9EdN9Td7Oip1BIPS01cZlOL1UOe9W3LBuzYdD4sRx3nXcTA8wMRmJ8A2V/IiNFRnHTc1YuiclTWmzpz5q5AJohIyFw2MzayRueMO0jD9+IbjIZmLA54+fQbw1KnTgCdPnpLxxImTgN9+ewLw+PFvAY8dOy7j0aPHAL/55ijgkSPfAH799REZv/rqa8DDh78C/PLLw4BffPGljJ9//gXgZ599Dvjpp58BfvLJp4CHDn0i48cfHwL86KOPAQ8e/AjwwIGDMu7ffwBw3779gB9+uA9w794PZdyzZy/g7t17AD/4YDfgrl0fyLhz5y7AHTt2Ar7//g7A7dvfB9y2bbuM7723DXDr1vcA3313K+A777wr49tvvwP41ltvA7755luAW7a8KePmzVsA33hjM+Drr78B+Nprr8v46quvAW7a9CrgK69sAnz55VcAX3rpZRlffPElwI0bXwTcsGEj4AsvbJBx/foXANetWw+4du06wDVr1sq4evUawFWrVgM+//wqwJUrn5fxuedWAj777HOAzzzzLOCKFc8APv30ChmfeuppwOXLnwJctmw54JNPLpPxiSeeBFy69AnAJUuWAi5evETGRYsWAy5cuAjw8ccXAj722OMyPvroY4CPPPIo4MMPPwK4YMHDgPPnL5Bx3rz5gA89NA9w7tyHAB98cK6Mc+Y8CPjAA3MAZ89+APD++2fLOGvW/YB9fbMAZ87sA7zvvpky3nvvfYAzZtwLeM89MwCnT78H8O67p8s4bdrdgHfdNQ1w6tS7AO+8c6qMU6bcCVguTwHs7S0D9vT0ytjd3QNYKnUDum4J0HFcGW3bAZw82QYsFicDWlYR0DQtGQsFE9AwCoBdXQbgpEldMur6JMDOTh0wn+8EzOXyMlKaA9Q0CqiqGmA2q8pISFaUbCQSDp7U6bXsX4X/Apme+3CpFAAA'! !!IRCMainWindow class methodsFor: 'stored graphics' stamp: 'sbw 5/8/2004 11:42'!initializeCachedForms	"IRCMainWindow initializeCachedForms"	self initializeConnectedForm.	self initializeDisconnectedForm! !!IRCMainWindow class methodsFor: 'stored graphics' stamp: 'sbw 5/4/2004 10:53'!initializeConnectedForm	ConnectedForm _ self convertRectangleMorphToForm: self connectedFullSizeMorph! !!IRCMainWindow class methodsFor: 'stored graphics' stamp: 'sbw 5/4/2004 10:54'!initializeDisconnectedForm	DisconnectedForm := self convertRectangleMorphToForm: self disconnectedFullSizeMorph! !!IRCMessage methodsFor: 'private-initialization' stamp: 'ls 9/2/1998 17:14'!initializeSender: sender0  recipient: recipient0  text: text0	sender _ sender0.	recipient _ recipient0.	text _ text0.! !!IRCMessage methodsFor: 'access' stamp: 'ls 9/2/1998 17:15'!recipient	"name the message is destined to"	^recipient! !!IRCMessage methodsFor: 'access' stamp: 'ls 9/2/1998 17:15'!sender	"name of the message's sender"	^sender! !!IRCMessage methodsFor: 'access' stamp: 'ls 9/2/1998 17:15'!text	"message text"	^text! !!IRCMessage methodsFor: 'access' stamp: 'ls 7/4/2001 23:28'!textForDisplay	"text to display in a chat window"	| senderToDisplay |	senderToDisplay _ sender ifNil: [ 'me' ].	(senderToDisplay includes: $!!) ifTrue: [ senderToDisplay _ senderToDisplay copyFrom: 1 to: (sender indexOf: $!!)-1 ].	(text beginsWith: (Character value: 1) asString) ifTrue: [		"an emote"		| endMarker |		endMarker := text indexOf: (Character space) startingAt: 2 ifAbsent: [ 0 ].		endMarker > 0 ifTrue: [			| emoteType |			emoteType := text copyFrom: 2 to: endMarker-1.			emoteType := emoteType asLowercase.			emoteType = 'action' ifTrue: [				"definitely an emote"				| action |				action := text copyFrom: endMarker +1 to: text size.				^senderToDisplay, ' ', action ] ] ].	^(Text string: senderToDisplay emphasis: (Array with: TextEmphasis bold)), 		': ', self text! !!IRCMessage commentStamp: '<historical>' prior: 0!A message on IRC.  It has a sender (usually a username), a recipient (usually a user or channel name), and some text.!!IRCMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 17:15'!sender: sender  recipient: recipient  text: text	"create a new message with the given sender, recipient, and text"	^super new initializeSender: sender  recipient: recipient text: text! !!IRCMessagePattern methodsFor: 'filtering' stamp: 'ls 9/2/1998 17:42'!matches: aMessage	"decide whether the message matches this pattern"	sender ifNotNil: [ sender = aMessage sender ifFalse: [ ^false ] ].	recipient ifNotNil: [ recipient = aMessage recipient ifFalse: [ ^false ] ].	^true! !!IRCMessagePattern methodsFor: 'private-initialization' stamp: 'ls 9/2/1998 17:41'!sender: sender0  recipient: recipient0	sender _ sender0.	recipient _ recipient0.! !!IRCMessagePattern commentStamp: '<historical>' prior: 0!A pattern for matching IRC messages.  Currently one can only match on the sender or the reciever.!!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 22:59'!RPLAway	"someone has marked themselves as away"	^301! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:09'!RPLBanList	""	^367! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:04'!RPLChannelModeIs	""	^324! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:09'!RPLEndOfBanList	""	^368! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:08'!RPLEndOfLinks	""	^365! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:10'!RPLEndOfMotd	"the MOTD has been completely transmitted"	^376! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:08'!RPLEndOfNames	""	^366! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:07'!RPLEndOfWho	"end of responses to a WHO"	^315! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:02'!RPLEndOfWhoIs	""	^318! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:03'!RPLEndOfWhoWas	""	^369! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:05'!RPLInviting	"inform that you are inviting someone to a channel"	^341! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:08'!RPLLinks	""	^364! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:04'!RPLList	"one item in a list command"	^322! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:04'!RPLListEnd	"marks end of listing from a LIST command"	^323! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:04'!RPLListStart	"start of response to a LIST command"	^321! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:45'!RPLMotd	"a line from the MOTD"	^372! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/3/1998 18:17'!RPLMotd2	"secondd version of a line from the MOTD"	^377! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:09'!RPLMotdStart	"a MOTD listing is beginning"	^375! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:08'!RPLNamReply	""	^353! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:05'!RPLNoTopic	"no topic is set for the given channel"	^331! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 22:59'!RPLNowaway	"something to do with AWAY"	^306! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:06'!RPLSummoning	"inform that you are summoning a user"	^342! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:05'!RPLTopic	"topic for the given channel"	^332! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 22:59'!RPLUnaway	"someone has marked themselves as unaway"	^305! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:06'!RPLVersion	"version info for the server"	^351! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:02'!RPLWhoIsIdle	""	^317! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:00'!RPLWhoIsOperator	""	^313! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:00'!RPLWhoIsServer	""	^312! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:00'!RPLWhoIsUser	""	^311! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:07'!RPLWhoReply	"response to a WHO"	^352! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:03'!RPLWhoWasUser	""	^314! !!IRCMessagePattern class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:02'!RPLWhoisChannels	""	^319! !!IRCMessagePattern class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 18:11'!recipient: recipient	"create a pattern matching messages to the given recipient"	^self sender: nil  recipient: recipient! !!IRCMessagePattern class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 18:10'!sender: sender	"create a pattern for messages from the given sender"	^self sender: sender  recipient: nil! !!IRCMessagePattern class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 18:11'!sender: sender  recipient: recipient	"create a pattern matching messages from the given sender and to the given recipient"	^super new sender: sender  recipient: recipient! !!IRCMessagePlayback methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 09:56'!addMessage: aString 	self playBack add: aString.	self playBack size > self class rollbackLimit ifTrue: [self playBack removeFirst]! !!IRCMessagePlayback methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 10:24'!getIndexedMessage	self playBack isEmpty		ifTrue: [^ nil].	self index == nil		ifTrue: [self index: self playBack size].	^self playBack at: self index.! !!IRCMessagePlayback methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 09:52'!index	^index! !!IRCMessagePlayback methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 09:52'!index: num	index _ num! !!IRCMessagePlayback methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 09:49'!playBack	playBack == nil		ifTrue: [playBack _ OrderedCollection new].	^ playBack! !!IRCMessagePlayback methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 10:29'!resetIndex	self index: nil! !!IRCMessagePlayback methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 10:23'!rollIndexBack	self index == nil ifTrue: [^nil].	self index <= 1 ifTrue: [^nil].	self index: self index - 1! !!IRCMessagePlayback methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 10:24'!rollIndexForward	self index == nil		ifTrue: [^ nil].	self index = self playBack size ifTrue: [^nil].	self index: self index + 1! !!IRCMessagePlayback class methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 09:49'!rollbackLimit	RollbackLimit == nil ifTrue: [RollbackLimit _ 40].	^RollbackLimit! !!IRCOptionsManagement commentStamp: '<historical>' prior: 0!Collection of all irc client options.!!IRCOptionsManagement class methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 18:34'!addDefaultPreferences	Preferences		addPreference: #autoJoinSqueakChannel		category: #IRC		default: false		balloonHelp: 'If true, the IRC client will automatically join the #squeak IRC channel as soon as the client opens.'! !!IRCOptionsManagement class methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 19:40'!checkForMissingOptions	self defaultOptionKeys		do: [:key | (SavedOptions includesKey: key)				ifFalse: [self optionKeyMissing: key]]! !!IRCOptionsManagement class methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 19:14'!initialize	self initializePreferences! !!IRCOptionsManagement class methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 19:13'!initializeOptions	"IRCOptionsManagement initializeOptions"	self savedOptions: self defaultOptionValues.	self optionsHelp: self defaultOptionHelp.	self optionsDescriptions: self defaultOptionDescriptions! !!IRCOptionsManagement class methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 18:35'!initializePreferences	"IRCOptionsManagement initializePreferences"	Preferences		preferenceAt: #autoJoinSqueakChannel		ifAbsent: [self addDefaultPreferences]! !!IRCOptionsManagement class methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 21:07'!optionKeyMissing: aString 	| defaultValue |	defaultValue _ self defaultOptionValues at: aString.	SavedOptions at: aString put: defaultValue.	OptionsDescriptions at: aString put: aString.	OptionsHelp at: aString put: aString! !!IRCOptionsManagement class methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 21:08'!optionsDescriptions	"IRCOptionsManagement optionsDescriptions"	OptionsDescriptions == nil		ifTrue: [self initializeOptions]		ifFalse: [self checkForMissingOptions].	^ OptionsDescriptions! !!IRCOptionsManagement class methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 19:12'!optionsDescriptions: aDictionary	OptionsDescriptions _ aDictionary! !!IRCOptionsManagement class methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 21:09'!optionsHelp	"IRCOptionsManagement optionsHelp"	OptionsHelp == nil		ifTrue: [self initializeOptions]		ifFalse: [self checkForMissingOptions].	^ OptionsHelp! !!IRCOptionsManagement class methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 19:11'!optionsHelp: aDictionary	OptionsHelp _ aDictionary! !!IRCOptionsManagement class methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 19:25'!populateOptionsFromProfile: anIRCConnectionProfile 	anIRCConnectionProfile options keysAndValuesDo: [:key :value |		self option: key value: value]! !!IRCOptionsManagement class methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 19:30'!savedOptions	"IRCOptionsManagement savedOptions"	SavedOptions == nil		ifTrue: [self initializeOptions]		ifFalse: [self checkForMissingOptions].	^ SavedOptions! !!IRCOptionsManagement class methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 18:53'!savedOptions: aDictionary	SavedOptions _ aDictionary! !!IRCOptionsManagement class methodsFor: 'options defined' stamp: 'sbw 6/13/2004 21:11'!defaultOptionDescriptions	"IRCOptionsManagement initializeOptions"	"IRCOptionsManagement optionsIntegrityCheck"	"This is where we define options."	| dict |	dict _ Dictionary new.	dict at: #acceptChannelInvites put: 'Accept invites';		 at: #playSoundOnMessage put: 'Play sound on message';		 at: #privateMessageOpensNewWindow put: 'New windows for private messages';		 at: #showJoinsInChannel put: 'Show joins';		 at: #showPartsInChannel put: 'Show parts';		 at: #showQuitsInChannel put: 'Show quits';		 at: #showModeChangesInChannel put: 'Show mode changes';		 at: #usemIRCColors put: 'Use MIRC colors';		 at: #tabbedChannelWindows put: 'Tab channel windows';		 at: #logChannelTraffic put: 'Log channels';		 at: #saveChannelLists put: 'Auto-save channels list';		 at: #forceChannelsToHaveLeadingPoundSign put: 'Add # to channel names';		 at: #timeStampMessages put: 'Prepend time stamps to messages'.	^ dict! !!IRCOptionsManagement class methodsFor: 'options defined' stamp: 'sbw 6/13/2004 21:12'!defaultOptionHelp	"IRCOptionsManagement optionsIntegrityCheck"	"This is where we define options."	| dict |	dict _ Dictionary new.	dict at: #acceptChannelInvites put: 'Accept channel invites';		 at: #playSoundOnMessage put: 'Play sound on new message arrival.  This is handy when you have the window in the background.';		 at: #privateMessageOpensNewWindow put: 'Open new window for private messages';		 at: #showJoinsInChannel put: 'Show joins in channel window';		 at: #showPartsInChannel put: 'Show parts in channel window';		 at: #showQuitsInChannel put: 'Show quits in channel window';		 at: #showModeChangesInChannel put: 'Show mode changes in channel window';		 at: #usemIRCColors put: 'Use MIRC colors decoding in channel window';		 at: #tabbedChannelWindows put: 'When true, channels share same window using tabs';		 at: #logChannelTraffic put: 'Log channel traffic in external file';		 at: #saveChannelLists put: 'Save channels list upon completion to external file';		 at: #forceChannelsToHaveLeadingPoundSign put: 'Add # to channel names as required';		 at: #timeStampMessages put: 'Prepend a time stamp to every message in a channel window'.	^ dict! !!IRCOptionsManagement class methodsFor: 'options defined' stamp: 'sbw 6/13/2004 21:13'!defaultOptionKeys	"IRCOptionsManagement optionsIntegrityCheck"	"This is where we define which keys exists."	^ {#acceptChannelInvites. #playSoundOnMessage. #privateMessageOpensNewWindow. #showJoinsInChannel. #showPartsInChannel. #showQuitsInChannel. #showModeChangesInChannel. #usemIRCColors. #tabbedChannelWindows. #logChannelTraffic. #saveChannelLists. #forceChannelsToHaveLeadingPoundSign. #timeStampMessages}! !!IRCOptionsManagement class methodsFor: 'options defined' stamp: 'sbw 6/13/2004 21:14'!defaultOptionValues	"IRCOptionsManagement optionsIntegrityCheck"	"This is where we define options."	| dict |	dict _ Dictionary new.	dict at: #acceptChannelInvites put: true;		 at: #playSoundOnMessage put: false;		 at: #privateMessageOpensNewWindow put: true;		 at: #showJoinsInChannel put: true;		 at: #showPartsInChannel put: true;		 at: #showQuitsInChannel put: true;		 at: #showModeChangesInChannel put: true;		 at: #usemIRCColors put: false;		 at: #tabbedChannelWindows put: true;		 at: #logChannelTraffic put: false;		 at: #saveChannelLists put: true;		 at: #forceChannelsToHaveLeadingPoundSign put: true;		 at: #timeStampMessages put: false.	^ dict! !!IRCOptionsManagement class methodsFor: 'options defined' stamp: 'sbw 5/27/2004 19:38'!optionsIntegrityCheck	"IRCOptionsManagement optionsIntegrityCheck"	"Do this as a developer to verify you have all option definitions synchd."	| desc help values stream keys |	keys := self defaultOptionKeys.	desc := self defaultOptionDescriptions.	help := self defaultOptionHelp.	values := self defaultOptionValues.	((desc keys size = help keys size				and: [desc keys size = values keys size])			and: [keys size = desc keys size])		ifTrue: [^ self inform: 'All keys match'].	stream := WriteStream on: ''.	keys asSortedCollection = desc keys asSortedCollection ifFalse: [stream nextPutAll: 'keys do not match.'; cr].	desc keys asSortedCollection = help keys asSortedCollection		ifFalse: [stream nextPutAll: '#defaultOptionDescriptions and #defaultOptionHelp keys do not match.';				 cr].	desc keys asSortedCollection = values keys asSortedCollection		ifFalse: [stream nextPutAll: '#defaultOptionDescriptions and #defaultOptionValues keys do not match.';				 cr].	help keys asSortedCollection = values keys asSortedCollection		ifFalse: [stream nextPutAll: '#defaultOptionHelp and #defaultOptionValues keys do not match.';				 cr].	self inform: stream contents! !!IRCOptionsManagement class methodsFor: 'API' stamp: 'sbw 5/27/2004 19:41'!descriptionForOption: aString	^self optionsDescriptions at: aString! !!IRCOptionsManagement class methodsFor: 'API' stamp: 'sbw 5/27/2004 19:42'!helpForOption: aString 	^ self optionsHelp at: aString! !!IRCOptionsManagement class methodsFor: 'API' stamp: 'sbw 5/27/2004 19:18'!option: key 	"Get the option value.  If it's missing it's false."	^ self savedOptions		at: key		ifAbsent: [false]! !!IRCOptionsManagement class methodsFor: 'API' stamp: 'sbw 5/27/2004 19:17'!option: key value: value 	"Set the option value."	self savedOptions at: key put: value! !!IRCOptionsManagement class methodsFor: 'API' stamp: 'sbw 5/27/2004 19:41'!optionKeys	^ self defaultOptionKeys! !!IRCOptionsManagement class methodsFor: 'API' stamp: 'sbw 5/27/2004 19:17'!toggleOption: aSymbol 	self option: aSymbol value: (self option: aSymbol) not! !!IRCProfileDialog methodsFor: 'as yet unclassified' stamp: 'sbw 5/16/2004 19:53'!addActionButtonsTo: parentMorph fractions: fractions offsets: offsets 	| pane |	pane := self buildActionButtons.	parentMorph		addMorph: pane		fullFrame: (LayoutFrame fractions: fractions offsets: offsets).	pane  borderWidth: 0! !!IRCProfileDialog methodsFor: 'as yet unclassified' stamp: 'sbw 5/16/2004 19:54'!addFullNamePaneTo: parentMorph fractions: fractions offsets: offsets 	| pane |	pane := self buildFullNamePane.	parentMorph		addMorph: pane		fullFrame: (LayoutFrame fractions: fractions offsets: offsets).	pane borderWidth: 0! !!IRCProfileDialog methodsFor: 'as yet unclassified' stamp: 'sbw 5/16/2004 19:54'!addNickPaneTo: parentMorph fractions: fractions offsets: offsets 	| pane |	pane := self buildNickPane.	parentMorph		addMorph: pane		fullFrame: (LayoutFrame fractions: fractions offsets: offsets).	pane borderWidth: 0! !!IRCProfileDialog methodsFor: 'as yet unclassified' stamp: 'sbw 5/16/2004 19:54'!addProfileNamePaneTo: parentMorph fractions: fractions offsets: offsets 	| pane |	pane := self buildProfileNamePane.	parentMorph		addMorph: pane		fullFrame: (LayoutFrame fractions: fractions offsets: offsets).	pane borderWidth: 0! !!IRCProfileDialog methodsFor: 'as yet unclassified' stamp: 'sbw 5/16/2004 19:54'!addServerAddressPaneTo: parentMorph fractions: fractions offsets: offsets 	| pane |	pane := self buildServerAddressPane.	parentMorph		addMorph: pane		fullFrame: (LayoutFrame fractions: fractions offsets: offsets).	pane borderWidth: 0! !!IRCProfileDialog methodsFor: 'as yet unclassified' stamp: 'sbw 5/16/2004 19:54'!addUserNamePaneTo: parentMorph fractions: fractions offsets: offsets 	| pane |	pane := self buildUserNamePane.	parentMorph		addMorph: pane		fullFrame: (LayoutFrame fractions: fractions offsets: offsets).	pane borderWidth: 0! !!IRCProfileDialog methodsFor: 'as yet unclassified' stamp: 'sbw 5/16/2004 10:13'!buildDialogOn: window 	| coll rowHeight rowSpacing offset rowPosn frac off |	coll := OrderedCollection new.	coll add: #addProfileNamePaneTo:fractions:offsets:;		 add: #addNickPaneTo:fractions:offsets:;		 add: #addFullNamePaneTo:fractions:offsets:;		 add: #addUserNamePaneTo:fractions:offsets:;		 add: #addServerAddressPaneTo:fractions:offsets:;		 add: #addActionButtonsTo:fractions:offsets:.	rowHeight := 22.	rowSpacing := 36.	offset := 10 @ 14.	rowPosn := offset copy.	frac := 0 @ 0 corner: 1 @ 0.	coll		do: [:selector | 			off := rowPosn corner: offset x negated @ (rowPosn y + rowHeight).			self				perform: selector				with: window				with: frac				with: off.			rowPosn := rowPosn + (0 @ rowSpacing)].	window color: self dialogBackgroundColor.! !!IRCProfileDialog methodsFor: 'as yet unclassified' stamp: 'sbw 5/16/2004 10:06'!initialExtent	^ 500 @ 260! !!IRCProfileDialog methodsFor: 'as yet unclassified' stamp: 'sbw 5/9/2004 21:51'!openDialog	"private"	"Get here after we do the server dialog window."	self openDialogLabeled: 'add a profile'! !!IRCProfileDialog methodsFor: 'as yet unclassified' stamp: 'sbw 5/9/2004 21:50'!openDialogLabeled: aString	| dialogue |	dialogue := SystemWindow new.	dialogue model: self.	self buildDialogOn: dialogue.	dialogue setLabel: aString.	canceled := false.	dialogue openInWorld! !!IRCProfileDialog methodsFor: 'as yet unclassified' stamp: 'sbw 5/9/2004 21:51'!openDialogOn: anIRCConnectionProfile 	"Get here after we do the server dialog window."	| |	editing := true.	profile := anIRCConnectionProfile.	self openDialogLabeled: 'edit a profile'.! !!IRCProfileDialog methodsFor: 'as yet unclassified' stamp: 'sbw 5/22/2004 21:42'!openForAddWithOptions: options 	"Get a server first."	editing := false.	profile := IRCConnectionProfile default deepCopy.	profile options: options.	self serverButton! !!IRCProfileDialog methodsFor: 'as yet unclassified' stamp: 'sbw 3/3/2002 21:04'!parentDialog: morph 	parentDialog _ morph! !!IRCProfileDialog methodsFor: 'as yet unclassified' stamp: 'sbw 3/4/2002 07:50'!referenceConnection: anIRCConnectionEnhanced	referenceConnection _ anIRCConnectionEnhanced! !!IRCProfileDialog methodsFor: 'local action buttons' stamp: 'sbw 11/16/2002 12:29'!buildActionButtons	| buttons alignMorph |	buttons _ self buttonRow.	Preferences alternativeWindowLook		ifTrue: [buttons				submorphsDo: [:m | m borderWidth: 2;						 borderColor: #raised]].	alignMorph _ AlignmentMorph newRow hResizing: #spaceFill;				 vResizing: #shrinkWrap;				 layoutInset: 0;				 borderWidth: 0;				 layoutPolicy: ProportionalLayout new.	alignMorph		addMorph: buttons		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ 0)).	^ alignMorph! !!IRCProfileDialog methodsFor: 'local action buttons' stamp: 'sbw 5/16/2004 12:08'!buttonRow	| aRow btn |	aRow := AlignmentMorph newRow beSticky.	aRow color: self dialogBackgroundColor.	aRow layoutInset: 30 @ 1;		 cellInset: 34.	self buttonSpecs		do: [:spec | 			btn := PluggableButtonMorph						on: self						getState: nil						action: spec second.			btn color: Color white;				 hResizing: #spaceFill;				 vResizing: #spaceFill;				 useRoundedCorners;				 setNameTo: spec third;				 label: spec first asString.			btn onColor: Color veryVeryLightGray offColor: Color white.			aRow addMorphBack: btn.			btn setBalloonText: spec fourth].	^ aRow! !!IRCProfileDialog methodsFor: 'local action buttons' stamp: 'sbw 3/4/2002 00:42'!buttonSpecs	"button label, selector, button name, help text"	^ #(#('Okay' #profileSelected 'okayButton' 'Accept these values for a new profile.') #('Cancel' #cancelSelected 'cancelButton' 'Discard values') )! !!IRCProfileDialog methodsFor: 'local action buttons' stamp: 'sbw 3/4/2002 01:25'!cancelSelected	canceled _ true.	self topView delete! !!IRCProfileDialog methodsFor: 'local action buttons' stamp: 'sbw 5/17/2004 20:08'!profileSelected	| targetName |	editing		ifTrue: [parentDialog editedProfile: profile]		ifFalse: [targetName := profile name.			(IRCConnectionProfile hasProfileNamed: targetName)				ifTrue: [^ self inform: 'That profile name is already taken.']				ifFalse: [parentDialog addProfile: profile]].	self topView delete! !!IRCProfileDialog methodsFor: 'local action buttons' stamp: 'sbw 5/23/2004 07:37'!windowIsClosing	parentDialog isNil		ifTrue: [^ nil].	parentDialog showWindow.	parentDialog updateProfilesList.	parentDialog changed: #profileDescriptions.! !!IRCProfileDialog methodsFor: 'full name' stamp: 'sbw 5/16/2004 09:54'!buildFullNamePane	^ self		entryPane: 'Full Name'		set: #fullName:		get: #fullName		canEdit: true		rightEdgeOffset: 0! !!IRCProfileDialog methodsFor: 'full name' stamp: 'sbw 3/4/2002 00:37'!fullName	^ profile fullName! !!IRCProfileDialog methodsFor: 'full name' stamp: 'sbw 3/4/2002 01:30'!fullName: str 	profile fullName: str.	^true! !!IRCProfileDialog methodsFor: 'nick' stamp: 'sbw 5/16/2004 09:54'!buildNickPane	^ self		entryPane: 'Nick'		set: #nick:		get: #nick		canEdit: true		rightEdgeOffset: 0! !!IRCProfileDialog methodsFor: 'nick' stamp: 'sbw 3/4/2002 00:37'!nick	^ profile nick! !!IRCProfileDialog methodsFor: 'nick' stamp: 'sbw 3/4/2002 01:30'!nick: aString 	profile nick: aString.	^true! !!IRCProfileDialog methodsFor: 'profile name' stamp: 'sbw 5/16/2004 09:54'!buildProfileNamePane	^ self		entryPane: 'Profile Name'		set: #profileName:		get: #profileName		canEdit: true		rightEdgeOffset: 0! !!IRCProfileDialog methodsFor: 'profile name' stamp: 'sbw 3/4/2002 00:36'!profileName	^ profile name! !!IRCProfileDialog methodsFor: 'profile name' stamp: 'sbw 3/7/2002 02:26'!profileName: aString 	profile name: aString asString withBlanksTrimmed.	^ true! !!IRCProfileDialog methodsFor: 'server address' stamp: 'sbw 5/16/2004 09:56'!buildServerAddressPane	| alignPane btn offset |	offset := 90.	alignPane := self				entryPane: 'Server Address'				set: #serverAddressString:				get: #serverAddressString				canEdit: false				rightEdgeOffset: offset.	btn := PluggableButtonMorph				on: self				getState: nil				action: #serverButton.	Preferences alternativeWindowLook		ifTrue: [btn borderWidth: 2;				 borderColor: #raised].	btn label: 'Choose Server'.	btn useRoundedCorners.	btn color: Color veryVeryLightGray.	btn onColor: Color white offColor: Color veryVeryLightGray.	btn setBalloonText: 'Opens up a server list dialog.'.	alignPane addMorph: btn		fullFrame: (LayoutFrame				fractions: (1 @ 0 corner: 1 @ 1)				offsets: (offset negated @ 0 corner: 0 @ 0)).	^ alignPane! !!IRCProfileDialog methodsFor: 'server address' stamp: 'sbw 3/4/2002 00:37'!serverAddressString	^ profile server address! !!IRCProfileDialog methodsFor: 'server address' stamp: 'sbw 3/4/2002 01:29'!serverAddressString: aString 	^ false! !!IRCProfileDialog methodsFor: 'user name' stamp: 'sbw 5/16/2004 09:54'!buildUserNamePane	^ self		entryPane: 'User Name'		set: #userName:		get: #userName		canEdit: true		rightEdgeOffset: 0! !!IRCProfileDialog methodsFor: 'user name' stamp: 'sbw 3/4/2002 00:38'!userName	^ profile userName! !!IRCProfileDialog methodsFor: 'user name' stamp: 'sbw 3/4/2002 01:30'!userName: str 	profile userName: str.	^true! !!IRCProfileDialog methodsFor: 'common entry' stamp: 'sbw 5/16/2004 09:36'!dialogBackgroundColor	^ Color		r: 0.84		g: 0.8		b: 0.76! !!IRCProfileDialog methodsFor: 'common entry' stamp: 'sbw 5/16/2004 09:21'!doNothing! !!IRCProfileDialog methodsFor: 'common entry' stamp: 'sbw 5/16/2004 19:56'!entryPane: aString set: setSymbol get: getSymbol canEdit: boolean rightEdgeOffset: offset 	| tagMorph editMorph buttonColumnWidth alignPane |	buttonColumnWidth := 90.	tagMorph := self entryTagMorph: aString.	editMorph := self				textEntryMorphForSet: setSymbol				get: getSymbol				canEdit: boolean.	editMorph borderColor: Color transparent.	buttonColumnWidth := 90.	alignPane := AlignmentMorph newRow hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 0;				 color: self dialogBackgroundColor;				 layoutPolicy: ProportionalLayout new.	alignPane		addMorph: tagMorph		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 0 @ 1)				offsets: (0 @ 0 corner: buttonColumnWidth @ 0));				addMorph: editMorph		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (buttonColumnWidth + 4 @ 0 corner: offset negated @ 0)).	^ alignPane! !!IRCProfileDialog methodsFor: 'common entry' stamp: 'sbw 5/16/2004 09:21'!entryTagMorph: aString	| tagMorph |	tagMorph := PluggableButtonMorph				on: self				getState: nil				action: #doNothing.	tagMorph hResizing: #spaceFill;		 vResizing: #spaceFill;		 label: aString;		 color: Color white.	tagMorph setBalloonText: 'This is not a real button.  Use the text entry field to the right to change the value.'.	^ tagMorph! !!IRCProfileDialog methodsFor: 'common entry' stamp: 'fc 12/4/2004 20:56'!textEntryMorphForSet: setSymbol get: getSymbol canEdit: boolean 	| textEntry classToUse colorToUse |	classToUse := boolean				ifTrue: [PluggableTextMorph]				ifFalse: [PluggableIRCTextMorph].	colorToUse := boolean				ifTrue: [Color white]				ifFalse: [Color transparent].	textEntry := classToUse				on: self				text: getSymbol				accept: setSymbol.	textEntry color: colorToUse;		 acceptOnCR: true;		 hideScrollBarsIndefinitely.	^ textEntry! !!IRCProfileDialog methodsFor: 'remote window actions' stamp: 'sbw 3/3/2002 21:13'!hideWindow	self topView hide! !!IRCProfileDialog methodsFor: 'remote window actions' stamp: 'sbw 3/4/2002 23:46'!noServerSelected	"The user aborted the selection from the server dialog. Open our own  	window and get busy."	self topView isNil		ifTrue: [self openDialog]		ifFalse: [self showWindow]! !!IRCProfileDialog methodsFor: 'remote window actions' stamp: 'sbw 5/25/2004 19:38'!serverButton	"From dialog"	| dlg |	dlg := IRCServerDialog on: IRCServer serversListByGroups.	dlg parentDialog: self.	self topView isNil		ifFalse: [self hideWindow].	dlg openDialog! !!IRCProfileDialog methodsFor: 'remote window actions' stamp: 'sbw 3/3/2002 21:13'!showWindow	self topView show! !!IRCProfileDialog methodsFor: 'remote window actions' stamp: 'sbw 3/4/2002 23:47'!useValuesFromServer: anIRCServer port: portNumber 	"We have a valid choice from the server dialog. Open our own  	window and get busy."	anIRCServer port: portNumber.	profile server: anIRCServer.	profile name: anIRCServer nameToUseForProfile.	self topView isNil		ifTrue: [self openDialog]		ifFalse: [self showWindow; changed: #profileName; changed: #serverAddressString]! !!IRCProfileDialog commentStamp: '<historical>' prior: 0!We are invoked because the user wants to:	1) add a new profile	2) edit an existing profileWhen you want an add, send #openForAddWithOptions: to us.When you want to edit, send #openDialogOn: to us.In both cases we assume that you have hidden your window just before calling us.Do not call our #openDialog method, it is private.!!IRCProfileDialog class methodsFor: 'as yet unclassified' stamp: 'sbw 5/16/2004 21:04'!example	"IRCProfileDialog example"	| profile dlg |	profile := IRCConnectionProfile default.	dlg := self new.	dlg openDialogOn: profile! !!IRCProtocolMessage methodsFor: 'access' stamp: 'ls 9/2/1998 21:49'!arguments	"return the arguments to the command"	^arguments! !!IRCProtocolMessage methodsFor: 'access' stamp: 'ls 9/2/1998 21:48'!command	"return the main command, in lowercase"	^command! !!IRCProtocolMessage methodsFor: 'access' stamp: 'sbw 3/2/2002 09:59'!isLocal	^isLocal! !!IRCProtocolMessage methodsFor: 'access' stamp: 'sbw 2/26/2002 17:30'!isSpecial	^isSpecial! !!IRCProtocolMessage methodsFor: 'access' stamp: 'ls 9/2/1998 21:49'!prefix	"return the prefix of the message, or nil if none"	^prefix! !!IRCProtocolMessage methodsFor: 'access' stamp: 'sbw 2/26/2002 17:32'!specialConvertedForm	^ self arguments last! !!IRCProtocolMessage methodsFor: 'encoding' stamp: 'sbw 2/26/2002 16:52'!asString	"encode in the format used for transferral over the network"	^ String		streamContents: [:stream | 			prefix				ifNotNil: [stream nextPut: $:.					stream nextPutAll: prefix.					stream space].			stream nextPutAll: command asUppercase.			stream space.			arguments isEmpty				ifFalse: ["print out all but the last argument"					(arguments copyFrom: 1 to: arguments size - 1)						do: [:arg | 							stream nextPutAll: arg.							stream space].					"print the last as a trailer, just to be safe"					stream nextPut: $:.					stream nextPutAll: arguments last].			stream nextPut: Character cr.			stream nextPut: Character lf]! !!IRCProtocolMessage methodsFor: 'encoding' stamp: 'sbw 6/2/2004 07:42'!printOn: stream 	| indent |	indent := '    '.	super printOn: stream.	self printOn: stream indentString: indent ! !!IRCProtocolMessage methodsFor: 'encoding' stamp: 'sbw 6/2/2004 07:41'!printOn: stream indentString: indent	| argCount |	prefix		ifNotNil: [stream cr; nextPutAll: indent.			stream nextPutAll: 'PREFIX: '.			stream nextPut: $:.			stream nextPutAll: prefix.			stream space].	stream cr; nextPutAll: indent; nextPutAll: 'COMMAND: '; nextPutAll: command asUppercase.	stream space.	arguments isEmpty		ifFalse: ["print out all but the last argument"			argCount := 0.			stream cr; nextPutAll: indent; nextPutAll: 'ARGUMENTS:'.			(arguments copyFrom: 1 to: arguments size - 1)				do: [:arg | 					argCount := argCount + 1.					stream cr; nextPutAll: indent; nextPutAll: indent.					stream nextPutAll: argCount printString , ': '.					stream nextPutAll: arg.					stream space].			"print the last as a trailer, just to be safe"			argCount := argCount + 1.			stream cr; nextPutAll: indent; nextPutAll: indent.			stream nextPutAll: argCount printString , ': '.			stream nextPut: $:.			self isLocal				ifTrue: [stream nextPutAll: 'an' , arguments last class name]				ifFalse: [stream nextPutAll: arguments last]]! !!IRCProtocolMessage methodsFor: 'private-initialization' stamp: 'sbw 5/26/2004 06:03'!checkForCommandHandling	"We will intercept /commands entered by the user and adjust as we can.  	See IRCConnection initializeOutgoingMessageHandlers"	command first = $/		ifTrue: [command _ command copyFrom: 2 to: command size.			self performSlashCommandHandler: command]! !!IRCProtocolMessage methodsFor: 'private-initialization' stamp: 'sbw 5/26/2004 06:03'!checkForLocalCommandHandling	"Local commands are never sent to the connection socket (over the  	wire). See IRCConnection localMessageHandlers."	isLocal := IRCConnection localMessageHandlers keys includes: command asLowercase! !!IRCProtocolMessage methodsFor: 'private-initialization' stamp: 'fc 1/18/2005 10:35'!checkForSpecialCommandHandling	"See http://www.irchelp.org/irchelp/rfc/ctcpspec.html"	| lastArg controlChar stream convertedArg savedCommand |	isSpecial _ IRCConnection specialCommands includes: command.	isSpecial		ifFalse: [^ nil].	savedCommand _ command asUppercase copy.	savedCommand = 'ME'		ifTrue: [savedCommand _ 'ACTION'].	command _ 'PRIVMSG'.	lastArg _ arguments last.	controlChar _ self class extendedDelimeterCharacter.	stream _ ReadWriteStream on: ''.	stream nextPut: controlChar;		 nextPutAll: savedCommand;		 nextPut: $ ;		 nextPutAll: lastArg;		 nextPut: controlChar.	convertedArg _ stream contents.	arguments at: arguments size put: convertedArg! !!IRCProtocolMessage methodsFor: 'private-initialization' stamp: 'sbw 5/26/2004 19:08'!prefix: aString command: anotherString arguments: aCollection 	prefix := aString.	command := anotherString asIRCLowercase.	arguments := aCollection.	self checkForCommandHandling.	self checkForLocalCommandHandling.	self checkForSpecialCommandHandling.! !!IRCProtocolMessage methodsFor: 'slash commands translation' stamp: 'fc 1/20/2005 19:14'!performSlashCommandHandler: aString 	| handler |	handler := IRCConnection outgoingMessageHandlers				at: aString asLowercase asSymbol				ifAbsent: [#processInvalidCommand].	self perform: handler! !!IRCProtocolMessage methodsFor: 'slash commands translation' stamp: 'fc 1/20/2005 19:02'!processAwayCommand	self stripOffFirstArgument! !!IRCProtocolMessage methodsFor: 'slash commands translation' stamp: 'sbw 3/2/2002 16:21'!processInvalidCommand! !!IRCProtocolMessage methodsFor: 'slash commands translation' stamp: 'sbw 6/5/2004 10:21'!processJoinCommand	self stripOffFirstArgument! !!IRCProtocolMessage methodsFor: 'slash commands translation' stamp: 'sbw 6/5/2004 10:21'!processNickCommand	self stripOffFirstArgument! !!IRCProtocolMessage methodsFor: 'slash commands translation' stamp: 'sbw 3/2/2002 16:20'!processPartCommand! !!IRCProtocolMessage methodsFor: 'slash commands translation' stamp: 'sbw 6/5/2004 10:21'!processWhoisCommand	self stripOffFirstArgument! !!IRCProtocolMessage methodsFor: 'slash commands translation' stamp: 'sbw 6/5/2004 10:20'!stripOffFirstArgument	"Everything is okay except we need to strip off the first argument if 	there is a 2nd."	arguments size > 1		ifTrue: [arguments _ Array with: arguments second]! !!IRCProtocolMessage methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 21:57'!quit	self sendMessage: (IRCProtocolMessage command: 'quit')! !!IRCProtocolMessage commentStamp: '<historical>' prior: 0!A low-level IRC message; this is an internal format for what actually goes over the wire.!!IRCProtocolMessage class methodsFor: 'documentation' stamp: 'sbw 5/26/2004 05:55'!bnfDocument	"IRCProtocolMessage bnfDocument"	(Workspace new contents: self protocolMessageBNFSpecificationString)		openLabel: 'IRC Protocol Message BNF'! !!IRCProtocolMessage class methodsFor: 'documentation' stamp: 'sbw 5/26/2004 05:56'!protocolMessageBNFSpecificationString	^'   The protocol messages must be extracted from the contiguous stream of   octets.  The current solution is to designate two characters, CR and   LF, as message separators.  Empty messages are silently ignored,   which permits use of the sequence CR-LF between messages without   extra problems.   The extracted message is parsed into the components <prefix>,   <command> and list of parameters (<params>).    The Augmented BNF representation for this is:    message    =  [ ":" prefix SPACE ] command [ params ] crlf    prefix     =  servername / ( nickname [ [ "!!" user ] "@" host ] )    command    =  1*letter / 3digit    params     =  *14( SPACE middle ) [ SPACE ":" trailing ]               =/ 14( SPACE middle ) [ SPACE [ ":" ] trailing ]    nospcrlfcl =  %x01-09 / %x0B-0C / %x0E-1F / %x21-39 / %x3B-FF                    ; any octet except NUL, CR, LF, " " and ":"    middle     =  nospcrlfcl *( ":" / nospcrlfcl )    trailing   =  *( ":" / " " / nospcrlfcl )    SPACE      =  %x20        ; space character    crlf       =  %x0D %x0A   ; "carriage return" "linefeed"   NOTES:      1) After extracting the parameter list, all parameters are equal         whether matched by <middle> or <trailing>. <trailing> is just a         syntactic trick to allow SPACE within the parameter.      2) The NUL (%x00) character is not special in message framing, and         basically could end up inside a parameter, but it would cause         extra complexities in normal C string handling. Therefore, NUL         is not allowed within messages.   Most protocol messages specify additional semantics and syntax for   the extracted parameter strings dictated by their position in the   list.  For example, many server commands will assume that the first   parameter after the command is the list of targets, which can be   described with:  target     =  nickname / server  msgtarget  =  msgto *( "," msgto )  msgto      =  channel / ( user [ "%" host ] "@" servername )  msgto      =/ ( user "%" host ) / targetmask  msgto      =/ nickname / ( nickname "!!" user "@" host )  channel    =  ( "#" / "+" / ( "!!" channelid ) / "&" ) chanstring                [ ":" chanstring ]  servername =  hostname  host       =  hostname / hostaddr  hostname   =  shortname *( "." shortname )  shortname  =  ( letter / digit ) *( letter / digit / "-" )                *( letter / digit )                  ; as specified in RFC 1123 [HNAME]  hostaddr   =  ip4addr / ip6addr  ip4addr    =  1*3digit "." 1*3digit "." 1*3digit "." 1*3digit  ip6addr    =  1*hexdigit 7( ":" 1*hexdigit )  ip6addr    =/ "0:0:0:0:0:" ( "0" / "FFFF" ) ":" ip4addr  nickname   =  ( letter / special ) *8( letter / digit / special / "-" )  targetmask =  ( "$" / "#" ) mask                  ; see details on allowed masks in section 3.3.1  chanstring =  %x01-07 / %x08-09 / %x0B-0C / %x0E-1F / %x21-2B  chanstring =/ %x2D-39 / %x3B-FF                  ; any octet except NUL, BELL, CR, LF, " ", "," and ":"  channelid  = 5( %x41-5A / digit )   ; 5( A-Z / 0-9 )  Other parameter syntaxes are:  user       =  1*( %x01-09 / %x0B-0C / %x0E-1F / %x21-3F / %x41-FF )                  ; any octet except NUL, CR, LF, " " and "@"  key        =  1*23( %x01-05 / %x07-08 / %x0C / %x0E-1F / %x21-7F )                  ; any 7-bit US_ASCII character,                  ; except NUL, CR, LF, FF, h/v TABs, and " "  letter     =  %x41-5A / %x61-7A       ; A-Z / a-z  digit      =  %x30-39                 ; 0-9  hexdigit   =  digit / "A" / "B" / "C" / "D" / "E" / "F"  special    =  %x5B-60 / %x7B-7D                   ; "[", "]", "\", "`", "_", "^", "{", "|", "}"  NOTES:      1) The <hostaddr> syntax is given here for the sole purpose of         indicating the format to follow for IP addresses.  This         reflects the fact that the only available implementations of         this protocol uses TCP/IP as underlying network protocol but is         not meant to prevent other protocols to be used.      2) <hostname> has a maximum length of 63 characters.  This is a         limitation of the protocol as internet hostnames (in         particular) can be longer.  Such restriction is necessary         because IRC messages are limited to 512 characters in length.         Clients connecting from a host which name is longer than 63         characters are registered using the host (numeric) address         instead of the host name.      3) Some parameters used in the following sections of this         documents are not defined here as there is nothing specific         about them besides the name that is used for convenience.         These parameters follow the general syntax defined for         <params>.'.! !!IRCProtocolMessage class methodsFor: 'ctcp quoting - private' stamp: 'sbw 6/6/2004 08:47'!charactersForCtcpQuoting	^ {self ctcpQuotingCharacter. self extendedDelimeterCharacter}! !!IRCProtocolMessage class methodsFor: 'ctcp quoting - private' stamp: 'sbw 6/6/2004 08:47'!ctcpDequote: aString 	| input output char |	input _ ReadStream on: aString.	output _ WriteStream on: ''.	[input atEnd]		whileFalse: [char _ input next.			char = self ctcpQuotingCharacter				ifTrue: [char _ self ctcpDequoteNextCharacterFrom: input].			output nextPut: char].	^ output contents! !!IRCProtocolMessage class methodsFor: 'ctcp quoting - private' stamp: 'sbw 6/6/2004 08:47'!ctcpDequoteNextCharacterFrom: aStream 	| char |	char _ aStream next.	char = $a		ifTrue: [^ self extendedDelimeterCharacter].	"Assume it's extendedDelimeterCharacter."	^ char! !!IRCProtocolMessage class methodsFor: 'ctcp quoting - private' stamp: 'sbw 6/6/2004 08:47'!ctcpExtract: aString 	^ self! !!IRCProtocolMessage class methodsFor: 'ctcp quoting - private' stamp: 'sbw 6/6/2004 08:47'!ctcpQuote: aString 	| stream exclude |	exclude _ self charactersForCtcpQuoting.	stream _ WriteStream on: ''.	aString		do: [:char | (exclude includes: char)				ifTrue: [self ctcpQuote: char on: stream]				ifFalse: [stream nextPut: char]].	^ stream contents! !!IRCProtocolMessage class methodsFor: 'ctcp quoting - private' stamp: 'sbw 6/6/2004 08:47'!ctcpQuote: char on: stream 	char = self extendedDelimeterCharacter		ifTrue: [^ stream nextPut: self ctcpQuotingCharacter;				 nextPut: $a].	char = self ctcpQuotingCharacter		ifTrue: [^ stream nextPut: self ctcpQuotingCharacter;				 nextPut: self ctcpQuotingCharacter]! !!IRCProtocolMessage class methodsFor: 'ctcp quoting - private' stamp: 'sbw 6/6/2004 08:47'!ctcpQuotingCharacter	^ $\! !!IRCProtocolMessage class methodsFor: 'ctcp quoting - private' stamp: 'sbw 6/6/2004 08:48'!extendedDelimeterCharacter	^ Character value: 1! !!IRCProtocolMessage class methodsFor: 'low level quoting - private' stamp: 'sbw 6/6/2004 08:48'!charactersForLowQuoting	^ {self nulCharacter. self nlCharacter. self crCharacter. self messageQuotingCharacter}! !!IRCProtocolMessage class methodsFor: 'low level quoting - private' stamp: 'sbw 6/6/2004 08:48'!crCharacter	^ Character value: 13! !!IRCProtocolMessage class methodsFor: 'low level quoting - private' stamp: 'sbw 6/6/2004 08:48'!lowDequote: aString 	"The message has been received. Handle the special case characters and  	decode them as found."	| input output char |	input _ ReadStream on: aString.	output _ WriteStream on: ''.	[input atEnd]		whileFalse: [char _ input next.			char = self messageQuotingCharacter				ifTrue: [char _ self lowDequoteNextCharacterFrom: input].			output nextPut: char].	^ output contents! !!IRCProtocolMessage class methodsFor: 'low level quoting - private' stamp: 'sbw 6/6/2004 08:48'!lowDequoteNextCharacterFrom: aStream 	| char |	char _ aStream next.	char = $0		ifTrue: [^ self nulCharacter].	char = $n		ifTrue: [^ self nlCharacter].	char = $r		ifTrue: [^ self crCharacter].	"Assume it's messageQuotingCharacter."	^ char! !!IRCProtocolMessage class methodsFor: 'low level quoting - private' stamp: 'sbw 6/6/2004 08:48'!lowQuote: aString 	"The message is about to be sent. Handle the special case characters and  	encode them as found."	| stream exclude |	exclude _ self charactersForLowQuoting.	stream _ WriteStream on: ''.	aString		do: [:char | (exclude includes: char)				ifTrue: [self lowQuote: char on: stream]				ifFalse: [stream nextPut: char]].	^ stream contents! !!IRCProtocolMessage class methodsFor: 'low level quoting - private' stamp: 'sbw 6/6/2004 08:49'!lowQuote: char on: stream 	char = self nulCharacter		ifTrue: [^ stream nextPut: self messageQuotingCharacter;				 nextPut: $0].	char = self nlCharacter		ifTrue: [^ stream nextPut: self messageQuotingCharacter;				 nextPut: $n].	char = self crCharacter		ifTrue: [^ stream nextPut: self messageQuotingCharacter;				 nextPut: $r].	char = self messageQuotingCharacter		ifTrue: [^ stream nextPut: self messageQuotingCharacter;				 nextPut: self messageQuotingCharacter]! !!IRCProtocolMessage class methodsFor: 'low level quoting - private' stamp: 'sbw 6/6/2004 08:49'!messageQuotingCharacter	^ Character value: 16! !!IRCProtocolMessage class methodsFor: 'low level quoting - private' stamp: 'sbw 6/6/2004 08:49'!nlCharacter	^ Character value: 10! !!IRCProtocolMessage class methodsFor: 'low level quoting - private' stamp: 'sbw 6/6/2004 08:49'!nulCharacter	^ Character value: 0! !!IRCProtocolMessage class methodsFor: 'utility' stamp: 'sbw 6/8/2004 06:24'!cleanSenderString: sender	^(sender includes: $!!)		ifTrue: [sender copyFrom: 1 to: (sender indexOf: $!!)							- 1]		ifFalse: [sender]! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 21:52'!command: anotherString	^self command: anotherString  arguments: Array new! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 21:52'!command: anotherString  arguments: aCollection	^self prefix: nil  command: anotherString  arguments: aCollection! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'sbw 5/26/2004 20:01'!extractPrefixAndCommandFrom: aString 	| stream command prefix arguments trailer |	stream _ ReadStream on: aString.	command _ stream upTo: $ .	command first = $: ifTrue: [		prefix _ command copyFrom: 2 to: command size.		command _ stream upTo: $ ].	arguments _ stream upTo: $:.	stream atEnd ifFalse: [trailer _ stream upToEnd].	^ Array		with: prefix		with: command		with: arguments		with: trailer! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'sbw 6/2/2004 09:07'!fromString: aString 	"parse an IRC message from its network format"	"USER sbw * * :Stephan B. Wessels <swessels@cox.net>"	| messageString command arguments prefix array argumentString trailer |	messageString := self peelOffCrLfFrom: aString.	array := self extractPrefixAndCommandFrom: messageString.	prefix := array at: 1.	command := array at: 2.	argumentString := array at: 3.	trailer := array at: 4.	arguments := OrderedCollection new.	argumentString isNil		ifFalse: [arguments				addAll: (argumentString findTokens: ' ')].	trailer isNil		ifFalse: [arguments add: trailer].	^ self		prefix: prefix		command: command		arguments: arguments! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'sbw 5/26/2004 12:34'!peelOffCrLfFrom: aString 	| remainder idx |	remainder := aString.	idx := remainder indexOf: Character cr.	idx > 0		ifTrue: [remainder := remainder copyFrom: 1 to: idx - 1].	idx := remainder indexOf: Character lf.	idx > 0		ifTrue: [remainder := remainder copyFrom: 1 to: idx - 1].	^ remainder! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 19:34'!prefix: aString  command: anotherString  arguments: aCollection	^super new prefix: aString  command: anotherString  arguments: aCollection! !!IRCProtocolMessage class methodsFor: 'ctcp quoting - public' stamp: 'sbw 6/6/2004 08:46'!decodeHighLevelMessageFromCtcp: aString 	| ctcpQuoted |	ctcpQuoted _ self lowDequote: aString.	^ self ctcpDequote: ctcpQuoted! !!IRCProtocolMessage class methodsFor: 'ctcp quoting - public' stamp: 'sbw 6/6/2004 08:46'!encodeHighLevelMessageForCtcp: aString 	| ctcpQuoted |	ctcpQuoted _ self ctcpQuote: aString.	^ self lowQuote: ctcpQuoted! !!IRCProtocolMessage class methodsFor: 'extracted' stamp: 'sbw 5/29/2004 06:40'!extractIdleTimeStringFromProtocolMessage: aMessage 	| stream array idleTime |	stream := ReadWriteStream on: ''.	array := aMessage arguments.	idleTime := Time fromSeconds: (array at: 3) asNumber.	stream		nextPutAll: (array at: 2);		 nextPutAll: ' has'.	idleTime hours > 0		ifTrue: [stream nextPutAll: ' ' , idleTime hours printString , ' hour'.			idleTime hours > 1				ifTrue: [stream nextPut: $s]].	idleTime minutes > 0		ifTrue: [stream nextPutAll: ' ' , idleTime minutes printString , ' minute'.			idleTime minutes > 1				ifTrue: [stream nextPut: $s]].	idleTime seconds > 0		ifTrue: [stream nextPutAll: ' ' , idleTime seconds printString , ' second'.			idleTime seconds > 1				ifTrue: [stream nextPut: $s]].	stream nextPutAll: ' idle time'.	^ stream contents! !!IRCProtocolMessage class methodsFor: 'extracted' stamp: 'sbw 5/29/2004 06:41'!extractNickIdentifiedStringFromProtocolMessage: aMessage 	| stream array |	stream := ReadWriteStream on: ''.	array := aMessage arguments.	stream		nextPutAll: (array at: 3).	^ stream contents! !!IRCProtocolMessage class methodsFor: 'extracted' stamp: 'sbw 5/29/2004 06:42'!extractReplyAwayStringFromProtocolMessage: aMessage 	| stream array |	stream := ReadWriteStream on: ''.	array := aMessage arguments.	stream		nextPutAll: (array at: 2);		 nextPutAll: ' is away: ';				nextPutAll: (array at: 3).	^ stream contents! !!IRCProtocolMessage class methodsFor: 'extracted' stamp: 'sbw 5/29/2004 06:42'!extractWhoIsChannelsStringFromProtocolMessage: aMessage 	| stream array |	stream := ReadWriteStream on: ''.	array := aMessage arguments.	stream nextPutAll: 'on channels: ';				nextPutAll: (array at: 3).	^ stream contents! !!IRCProtocolMessage class methodsFor: 'extracted' stamp: 'sbw 5/29/2004 06:43'!extractWhoIsServerStringFromProtocolMessage: aMessage 	| stream array |	stream := ReadWriteStream on: ''.	array := aMessage arguments.	stream nextPutAll: 'on irc via server ';				nextPutAll: (array at: 3);		 nextPutAll: ' (';				nextPutAll: (array at: 4);		 nextPut: $).	^ stream contents! !!IRCProtocolMessage class methodsFor: 'extracted' stamp: 'sbw 5/29/2004 06:44'!extractWhoIsUserStringFromProtocolMessage: aMessage 	| stream array |	stream := ReadWriteStream on: ''.	array := aMessage arguments.	stream		nextPutAll: (array at: 2);		 nextPutAll: ' is ';				nextPutAll: (array at: 3);		 nextPut: $@;				nextPutAll: (array at: 4);		 nextPutAll: ' (';				nextPutAll: (array at: 6);		 nextPut: $).	^ stream contents! !!IRCServer methodsFor: 'access' stamp: 'sbw 1/11/2003 18:40'!= anIRCServer 	anIRCServer == nil ifTrue: [^false].	^ ((self nameToUseForProfile = anIRCServer nameToUseForProfile				and: [self address = anIRCServer address])			and: [self group = anIRCServer group])		and: [self ports = anIRCServer ports]! !!IRCServer methodsFor: 'access' stamp: 'sbw 5/16/1999 10:27'!address	^address! !!IRCServer methodsFor: 'access' stamp: 'sbw 5/16/1999 10:27'!address: aString	address _ aString! !!IRCServer methodsFor: 'access' stamp: 'sbw 3/3/2002 10:33'!defaultPort	^self ports last! !!IRCServer methodsFor: 'access' stamp: 'sbw 5/16/1999 10:49'!group	^group! !!IRCServer methodsFor: 'access' stamp: 'sbw 5/16/1999 10:49'!group: aString	group _ aString! !!IRCServer methodsFor: 'access' stamp: 'sbw 1/11/2003 18:31'!hash	^ self nameToUseForProfile hash + self address hash + self group hash + self ports hash! !!IRCServer methodsFor: 'access' stamp: 'sbw 5/16/2004 08:53'!key	^self class keyConstructionFromNameToUseForProfile: self nameToUseForProfile andAddress: self address! !!IRCServer methodsFor: 'access' stamp: 'sbw 5/23/2004 22:37'!nameToUseForProfile	^self nameToUseWithSeperator: ' '! !!IRCServer methodsFor: 'access' stamp: 'sbw 5/23/2004 22:37'!nameToUseWithSeperator: sepString	| part2 part1 |	part2 := self serverName withBlanksTrimmed.	self group isNil		ifTrue: [^ part2].	self group isEmpty		ifTrue: [^ part2].	part1 := self group withBlanksTrimmed.	^ part1 , sepString, part2! !!IRCServer methodsFor: 'access' stamp: 'sbw 3/3/2002 10:44'!port	port == nil ifTrue: [port _ self defaultPort].	^port! !!IRCServer methodsFor: 'access' stamp: 'sbw 3/3/2002 10:44'!port: num	port _ num! !!IRCServer methodsFor: 'access' stamp: 'sbw 5/16/1999 10:27'!ports	^ports! !!IRCServer methodsFor: 'access' stamp: 'sbw 5/16/1999 10:28'!ports: aCollection	ports _ aCollection! !!IRCServer methodsFor: 'access' stamp: 'sbw 2/29/2000 21:17'!serverName	^serverName! !!IRCServer methodsFor: 'access' stamp: 'sbw 2/29/2000 21:17'!serverName: aString	serverName _ aString! !!IRCServer methodsFor: 'parse mIRC entries' stamp: 'sbw 5/8/2004 21:24'!configureFromString: aString 	| tempString groupName theServerName serverAddress portNumbers |	tempString := self extractGroupAndServerStringFrom: aString.	groupName := self extractGroupNameFrom: tempString.	theServerName := self extractServerNameFrom: tempString.	tempString := self extractServerAddressAndPortStringFrom: aString.	serverAddress := self extractServerAddressFrom: tempString.	portNumbers := self extractPortsFrom: tempString.	self address: serverAddress.	self group: groupName.	self ports: portNumbers.	self serverName: theServerName! !!IRCServer methodsFor: 'parse mIRC entries' stamp: 'sbw 5/9/2004 12:23'!extractGroupAndServerStringFrom: aString 	| index start end |	index := aString indexOf: $= startingAt: 1.	start := index + 1.	index := aString				findString: self class serverStringTag				startingAt: start				caseSensitive: true.	end := index - 1.	^ aString copyFrom: start to: end! !!IRCServer methodsFor: 'parse mIRC entries' stamp: 'sbw 5/9/2004 12:23'!extractGroupNameFrom: aString 	| start colonPos end |	start := 1.	colonPos := aString indexOf: $: startingAt: start.	colonPos > 0		ifTrue: [end := colonPos - 1.			^ aString copyFrom: start to: end]		ifFalse: [^ ''"none defined"]! !!IRCServer methodsFor: 'parse mIRC entries' stamp: 'sbw 5/9/2004 12:24'!extractPortsFrom: aString 	"The only safe way to do this is scan from the tail looking for a 	non-digit char that is not a comma or dash."	| posn char start end portsString portTokens portNumbers index first last |	posn := aString size.	[char := aString at: posn.	posn > 1		and: [(char isDigit					or: [char = $,])				or: [char = $-]]]		whileTrue: [posn := posn - 1].	start := posn + 1.	end := aString size.	portsString := aString copyFrom: start to: end.	portTokens := portsString findTokens: ','.	portNumbers := OrderedCollection new.	portTokens		do: [:each | 			index := each indexOf: $-.			index > 0				ifTrue: ["range"					first := (each copyFrom: 1 to: index - 1) asNumber.					last := (each copyFrom: index + 1 to: each size) asNumber.					first						to: last						do: [:intval | portNumbers add: intval]]				ifFalse: [portNumbers add: each asNumber]].	^ portNumbers! !!IRCServer methodsFor: 'parse mIRC entries' stamp: 'sbw 5/9/2004 12:24'!extractServerAddressAndPortStringFrom: aString 	| start index offset end |	start := 1.	index := aString				findString: self class serverStringTag				startingAt: start				caseSensitive: true.	offset := self class serverStringTag size.	start := index + offset + 1.	index := aString				findString: self class groupStringTag				startingAt: start				caseSensitive: true.	end := index = 0				ifTrue: [aString size]				ifFalse: [index - 1].	^ aString copyFrom: start to: end! !!IRCServer methodsFor: 'parse mIRC entries' stamp: 'sbw 5/9/2004 12:24'!extractServerAddressFrom: aString 	"The only safe way to do this is scan from the tail looking for a 	non-digit char that is not a comma or dash."	| posn char start end |	posn := aString size.	[char := aString at: posn.	posn > 1		and: [(char isDigit					or: [char = $,])				or: [char = $-]]]		whileTrue: [posn := posn - 1].	start := 1.	end := posn - 1.	^ aString copyFrom: start to: end! !!IRCServer methodsFor: 'parse mIRC entries' stamp: 'sbw 5/13/2004 11:16'!extractServerNameFrom: aString 	| start index end |	start := 1.	index := aString indexOf: $: startingAt: start.	index > 0		ifTrue: [start := index + 1].	end := aString size.	^ (aString copyFrom: start to: end) withBlanksTrimmed! !!IRCServer methodsFor: 'printing' stamp: 'sbw 2/29/2000 22:05'!printOn: aStream 	super printOn: aStream.	aStream		cr;		nextPutAll: '  ';		nextPutAll: 'Group: ';		nextPutAll: self group asString;		cr;		nextPutAll: '  ';		nextPutAll: 'Name: ';		nextPutAll: self serverName asString;		cr;		nextPutAll: '  ';		nextPutAll: 'Addr: ';		nextPutAll: self address asString.	self ports do: [:each |		aStream			cr;			nextPutAll: '    Port: ';			nextPutAll: each printString]! !!IRCServer methodsFor: 'printing' stamp: 'sbw 3/4/2002 00:55'!profileListString	| stream |	stream _ ReadWriteStream on: ''.	stream 		 nextPutAll: self address asString;		 nextPutAll: ':';		 nextPutAll: self port printString.	^ stream contents! !!IRCServer methodsFor: 'printing' stamp: 'sbw 3/4/2002 00:55'!profileString	| stream |	stream _ ReadWriteStream on: ''.	stream nextPut: $";		 nextPutAll: self serverName asString;		 nextPut: $";		 nextPutAll: '  ';		 nextPutAll: self profileListString contents.	^ stream contents! !!IRCServer commentStamp: '<historical>' prior: 0!The Servers class variable holds server definitions.  This used to be held on the connection class.!!IRCServer class methodsFor: 'test' stamp: 'sbw 6/2/2004 07:23'!addLocalHost	"IRCServer addLocalHost"	self addServer: (self from: 'Local HostSERVER:localhost:6667')! !!IRCServer class methodsFor: 'test' stamp: 'sbw 5/25/2004 19:31'!addOpenProjectsNetServer	"IRCServer addOpenProjectsNetServer"	self addServer: self defaultServer! !!IRCServer class methodsFor: 'test' stamp: 'sbw 6/2/2004 07:22'!populateServersDatabaseWithBuiltIn	"IRCServer populateServersDatabaseWithBuiltIn"	"Test populate from internal information."	| stream |	stream := ReadStream on: self serversList.	self initializeServers.	self buildServersListFrommIRCIniStream: stream reset.	self addOpenProjectsNetServer.	self addLocalHost! !!IRCServer class methodsFor: 'test' stamp: 'sbw 5/8/2004 20:59'!serversList	^ 'n0=Random US DALnet serverSERVER:irc.dal.net:7000,6667,6668,6669GROUP:01n1=powertech.no.eu.dal.netSERVER:powertech.no.eu.dal.net:6667n2=Random EU DALnet serverSERVER:irc.eu.dal.net:6667GROUP:02n3=Random US EFnet serverSERVER:us.rr.efnet.net:6667GROUP:03n4=Random EU EFnet serverSERVER:eu.rr.efnet.net:6667GROUP:04n5=Random CA EFnet serverSERVER:ca.rr.efnet.net:6667GROUP:05n6=Random AU EFnet serverSERVER:au.rr.efnet.net:6667GROUP:06n7=Random US IRCnet serverSERVER:us.ircnet.org:6665,6666,6668GROUP:07n8=Random EU IRCnet serverSERVER:eu.ircnet.org:6665,6666,6668GROUP:08n9=Random AU IRCnet serverSERVER:au.ircnet.org:6667GROUP:09n10=Random US Undernet serverSERVER:us.undernet.org:6667GROUP:10n11=Random EU Undernet serverSERVER:eu.undernet.org:6667GROUP:11n12=Accessirc: Random serverSERVER:irc.accessirc.net:6667GROUP:Accessircn13=Acestar: Random serverSERVER:irc.acestar.org:6667GROUP:Acestarn14=Action-IRC: Random serverSERVER:irc.action-irc.net:6661,6662,6664GROUP:Action-IRCn15=Afternet: Random serverSERVER:irc.afternet.org:6667GROUP:Afternetn16=Alternativenet: Random serverSERVER:irc.altnet.org:6667GROUP:Alternativenetn17=Animenet: Random serverSERVER:irc.animenet.org:6663,6666,6668GROUP:Animenetn18=AnotherNet: Random serverSERVER:irc.another.net:6667,7000GROUP:Anothernetn19=ArabChat: Random serverSERVER:irc.arabchat.org:6663,6664,6665GROUP:ArabChatn20=AsiaChat: Random serverSERVER:irc.asiachat.org:6668,6669,7000GROUP:AsiaChatn21=AstroLink: Random serverSERVER:irc.astrolink.org:6661,6663,6665GROUP:AstroLinkn22=Asylumnet: Random serverSERVER:irc.asylum-net.org:6661,6664,6665GROUP:Asylumnetn23=Austnet: Random AU serverSERVER:au.austnet.org:6667GROUP:Austnetn24=Austnet: Random NZ serverSERVER:nz.austnet.org:6667GROUP:Austnetn25=Austnet: Random SG serverSERVER:sg.austnet.org:6667GROUP:Austnetn26=Austnet: Random US serverSERVER:us.austnet.org:6667GROUP:Austnetn27=AwesomeChat: Random serverSERVER:irc.awesomechat.net:6662,6663,6668GROUP:AwesomeChatn28=Axenet: Random serverSERVER:irc.axenet.org:6660,6661,6662GROUP:Axenetn29=BeyondIRC: Random serverSERVER:irc.beyondirc.net:6660,6664,6668GROUP:Beyondircn30=Blabbernet: Random serverSERVER:irc.blabber.net:6667,7000GROUP:Blabbernetn31=Blitzed: Random serverSERVER:irc.blitzed.org:6667,7000GROUP:Blitzedn32=Bohemians: Random serverSERVER:irc.bohemians.org:6667,7000GROUP:Bohemiansn33=Bohika: Random serverSERVER:irc.bohika.net:6663,6665,6666GROUP:Bohikan34=Brasirc: Random serverSERVER:irc.brasirc.net:6666,6667GROUP:Brasircn35=Brasirc: BR, PA, BelemSERVER:irc.libnet.com.br:6666,6668,7777GROUP:Brasircn36=Brasirc: BR, SC, FlorianopolisSERVER:irc.intergate.com.br:6667GROUP:Brasircn37=Brasnet: Random European serverSERVER:eu.brasnet.org:6665,6666,6668GROUP:Brasnetn38=Brasnet: Random serverSERVER:irc.brasnet.org:6665,6666,6668GROUP:Brasnetn39=Brasnet: Random US serverSERVER:us.brasnet.org:6665,6666,6668GROUP:Brasnetn40=Castlenet-irc: Random serverSERVER:irc.castlenet-irc.org:6667GROUP:Castlenet-ircn41=CCnet: Random serverSERVER:irc.cchat.net:6667,7000GROUP:CCnetn42=CCnet: US, TX, DallasSERVER:irc2.cchat.net:6667,7000GROUP:CCnetn43=ChatArea: Random serverSERVER:irc.chatarea.net:6667GROUP:ChatArean44=Chatcafe: Random serverSERVER:irc.chatcafe.net:6667GROUP:Chatcafen45=ChatCentral2: Random serverSERVER:irc.cc2.org:6665,6666,6668GROUP:ChatCentral2n46=ChatCircuit: Random serverSERVER:irc.chatcircuit.com:6667GROUP:ChatCircuitn47=ChatCity: Random serverSERVER:irc.chatcity.org:6668,6669,7000GROUP:ChatCityn48=ChatIRC: Random serverSERVER:irc.chatirc.net:6667GROUP:ChatIRCn49=Chatlink: Random serverSERVER:irc.chatlink.org:6667GROUP:Chatlinkn50=Chatlink: US, CA, DavisSERVER:cool.ca.us.chatlink.org:6667GROUP:Chatlinkn51=Chatlink: US, OH, AthensSERVER:dream.oh.us.chatlink.org:6667GROUP:Chatlinkn52=Chatnet: Random AU serverSERVER:au.chatnet.org:6667GROUP:Chatnetn53=Chatnet: Random EU serverSERVER:eu.chatnet.org:6667GROUP:Chatnetn54=Chatnet: Random US serverSERVER:us.chatnet.org:6667GROUP:Chatnetn55=Chatpinoy: Random serverSERVER:irc.chatpinoy.com:6667GROUP:Chatpinoyn56=ChatPR: Random serverSERVER:irc.chatpr.org:6667GROUP:ChatPRn57=Chatroom: Random serverSERVER:irc.chatroom.org:6667GROUP:Chatroomn58=ChatX: Random serverSERVER:irc.chatx.net:6667GROUP:ChatXn59=Circanet: Random serverSERVER:irc.circanet.org:6664,6666,6668GROUP:Circanetn60=CNN: CNN News discussionsSERVER:chat.cnn.com:6668,6669,7000GROUP:CNNn61=Coolchat: Random serverSERVER:irc.coolchat.net:6667GROUP:Coolchatn62=Criten: Random serverSERVER:irc.criten.net:6667GROUP:Critenn63=Cyberchat: Random serverSERVER:irc.cyberchat.org:6667,6668GROUP:Cyberchatn64=Cyberchat-irc: Random serverSERVER:irc.cyberchat-irc.net:6667GROUP:Cyberchat-ircn65=CyGanet: Random serverSERVER:irc.cyga.net:6667GROUP:CyGanetn66=DALnet: AS, MY, Kuala LumpurSERVER:coins.dal.net:6664,6666,6668GROUP:DALnetn67=DALnet: AU, AdelaideSERVER:ozbytes.dal.net:6667,7000GROUP:DALnetn68=DALnet: CA, BC, VancouverSERVER:vancouver.dal.net:6661,6663,6666GROUP:DALnetn69=DALnet: EU, DE, FrankfurtSERVER:nexgo.de.eu.dal.net:6664,6668,6669GROUP:DALnetn70=DALnet: EU, NO, OsloSERVER:powertech.no.eu.dal.net:6666,6667,7000GROUP:DALnetn71=DALnet: EU, NO, TromsoSERVER:viking.dal.net:6666,6668,6669GROUP:DALnetn72=DALnet: EU, SE, GoteborgSERVER:ced.dal.net:6667,7000GROUP:DALnetn73=DALnet: EU, SE, StockholmSERVER:paranoia.dal.net:6661,6662,6664GROUP:DALnetn74=DALnet: EU, UK, LondonSERVER:defiant.dal.net:6666,6668,6669GROUP:DALnetn75=DALnet: US, FL, HollywoodSERVER:sodre.dal.net:6661,6662,6663GROUP:DALnetn76=DALnet: US, IN, HebronSERVER:hebron.dal.net:6662,6666,6669GROUP:DALnetn77=DALnet: US, MD, ManchesterSERVER:qis.md.us.dal.net:6662,6663,6668GROUP:DALnetn78=DALnet: US, NY, New York CitySERVER:liberty.dal.net:6663,6666,6668GROUP:DALnetn79=DALnet: US, OH, ToledoSERVER:glass.dal.net:6660,6661,6662GROUP:DALnetn80=DALnet: US, OK, TulsaSERVER:webzone.dal.net:6665,6666,6669GROUP:DALnetn81=Darkernet: Random serverSERVER:irc.darker.net:6667GROUP:Darkernetn82=Darkfire: Random serverSERVER:irc.darkfire.net:6667,7000,8000GROUP:Darkfiren83=Darkfyre: Random serverSERVER:irc.darkfyre.net:6667GROUP:Darkfyren84=DarkMyst: Random serverSERVER:irc.darkmyst.org:6667GROUP:DarkMystn85=Darktree: Random serverSERVER:irc.darktree.net:6667GROUP:Darktreen86=Deepspace: Disability networkSERVER:irc.deepspace.org:6667GROUP:Deepspacen87=Different: Random serverSERVER:irc.different.net:6667GROUP:Differentn88=Digarix: Random serverSERVER:irc.digarix.net:6667GROUP:Digarixn89=Digitalirc: Random serverSERVER:irc.digitalirc.net:6667GROUP:Digitalircn90=Dobbernet: Random serverSERVER:irc.dobber.net:6667GROUP:Dobbernetn91=Dreamcast: Random serverSERVER:irc0.dreamcast.com:6667GROUP:Dreamcastn92=Dreamnet: Random serverSERVER:irc.dreamnet.org:6664,6665,6666GROUP:Dreamnetn93=DS2: Random serverSERVER:irc.ds2.net:6667GROUP:DS2n94=Duh-net: Random serverSERVER:irc.duh-net.org:6667GROUP:Duhnetn95=Dynastynet: Random serverSERVER:irc.dynastynet.net:6667GROUP:Dynastynetn96=EFnet: CA, AB, EdmontonSERVER:irc.powersurfr.com:6667GROUP:EFnetn97=EFnet: CA, ON, TorontoSERVER:irc2.magic.ca:6667GROUP:EFnetn98=EFnet: CA, QB, MontrealSERVER:irc.etsmtl.ca:6667GROUP:EFnetn99=EFnet: EU, FI, HelsinkiSERVER:efnet.cs.hut.fi:6667GROUP:EFnetn100=EFnet: EU, FR, ParisSERVER:irc.isdnet.fr:6667,6668,6669GROUP:EFnetn101=EFnet: EU, NL, AmsterdamSERVER:efnet.vuurwerk.nl:6667GROUP:EFnetn102=EFnet: EU, NO, HomelienSERVER:irc.homelien.no:6666,7000,7001GROUP:EFnetn103=EFnet: EU, RU, MoscowSERVER:irc.rt.ru:6664,6665,6666GROUP:EFnetn104=EFnet: EU, SE, DalarnaSERVER:irc.du.se:6666,6668,6669GROUP:EFnetn105=EFnet: EU, SE, SwedenSERVER:irc.light.se:6667GROUP:EFnetn106=EFnet: EU, UK, DemonSERVER:efnet.demon.co.uk:6665,6666,6668GROUP:EFnetn107=EFnet: EU, UK, LondonSERVER:irc.ins.net.uk:6665,6666,6668GROUP:EFnetn108=EFnet: ME, IL, InterSERVER:irc.inter.net.il:6665,6666,6668GROUP:EFnetn109=EFnet: US, CA, Los AngelesSERVER:irc.west.gblx.net:6667GROUP:EFnetn110=EFnet: US, CA, San Luis ObispoSERVER:irc.prison.net:6666,6667GROUP:EFnetn111=EFnet: US, CA, StanfordSERVER:irc.stanford.edu:6667GROUP:EFnetn112=EFnet: US, CO, ColoradoSERVER:irc.colorado.edu:5555,6665,6666GROUP:EFnetn113=EFnet: US, GA, Atlanta (Emory)SERVER:irc.emory.edu:6667GROUP:EFnetn114=EFnet: US, GA, Atlanta (Mindspring)SERVER:irc.mindspring.com:6661,6662,6663GROUP:EFnetn115=EFnet: US, IL, ChicagoSERVER:irc.mcs.net:6666,6667,6668GROUP:EFnetn116=EFnet: US, IL, ChicagoSERVER:irc.plur.net:6667GROUP:EFnetn117=EFnet: US, MI, Ann ArborSERVER:irc.umich.edu:6667GROUP:EFnetn118=EFnet: US, MN, Twin CitiesSERVER:irc.umn.edu:6665,6666,6668GROUP:EFnetn119=EFnet: US, NY, New YorkSERVER:irc.east.gblx.net:6667GROUP:EFnetn120=EgyptianIRC: Random serverSERVER:irc.egyptianirc.net:6667,6668,6669GROUP:EgyptianIRCn121=EliteOrbit: Random serverSERVER:irc.eliteorbit.net:6667GROUP:EliteOrbitn122=EntertheGame: Random serverSERVER:irc.enterthegame.com:6667,6668,6669GROUP:EntertheGamen123=Escaped: Random serverSERVER:irc.escaped.net:6662,6663,6664GROUP:Escapedn124=Esprit: Random serverSERVER:irc.esprit.net:6667GROUP:Espritn125=euIRC: Random serverSERVER:irc.euirc.net:6665,6666,6668GROUP:euIRCn126=Exedor: Random serverSERVER:irc.exedor.net:6660,6663,6664GROUP:Exedorn127=ExodusIRC: Random serverSERVER:irc.exodusirc.net:6661,6664,6666GROUP:ExodusIRCn128=Fancynet: Random serverSERVER:irc.fancynet.com:6660,6662,6665GROUP:Fancynetn129=FastIRC: Random serverSERVER:irc.fastirc.net:6667GROUP:FastIRCn130=FDFnet: US, CA, BerkeleySERVER:transbay.fdf.net:6666,6668,9999GROUP:FDFnetn131=FDFnet: US, WA, SilverdaleSERVER:europa.fdf.net:6666,6668,6669GROUP:FDFnetn132=FDFnet: US, WI, MadisonSERVER:tower.fdf.net:6664,6665,6666GROUP:FDFnetn133=FEFnet: Random serverSERVER:irc.fef.net:6667GROUP:FEFnetn134=FEFnet: US, CA, San JoseSERVER:vendetta.fef.net:6666,8888,9999GROUP:FEFnetn135=FEFnet: US, NY, Long IslandSERVER:liii.fef.net:8888,9999GROUP:FEFnetn136=FireChat: Random serverSERVER:irc.firechat.org:6667GROUP:FireChatn137=Forestnet: Random serverSERVER:irc.forestnet.org:6667,7000GROUP:Forestnetn138=FreedomChat: Random serverSERVER:chat.freedomchat.net:6667GROUP:FreedomChatn139=Fuelienet: Random serverSERVER:irc.fuelie.net:6667,7000GROUP:Fuelienetn140=FunNet: Random serverSERVER:irc.funnet.org:6667GROUP:FunNetn141=Galaxynet: Random serverSERVER:irc.galaxynet.org:6665,6666,6668GROUP:GalaxyNetn142=Galaxynet: AU, NZ, AucklandSERVER:auckland.nz.galaxynet.org:6661,6663,6665GROUP:GalaxyNetn143=Galaxynet: EU, BE, OnlineSERVER:online.be.galaxynet.org:6663,6664,6668GROUP:GalaxyNetn144=Galaxynet: EU, SE, VltmediaSERVER:vltmedia.se.galaxynet.org:6661,6662,6668GROUP:GalaxyNetn145=Galaxynet: US, FL, FloridaSERVER:gymnet.us.galaxynet.org:6662,6663,6664GROUP:GalaxyNetn146=Galaxynet: US, WA, SeattleSERVER:freei.us.galaxynet.org:6663,6666,6668GROUP:GalaxyNetn147=Gamesnet: Random east US serverSERVER:east.gamesnet.net:6667GROUP:Gamesnetn148=Gamesnet: Random west US serverSERVER:west.gamesnet.net:6667GROUP:Gamesnetn149=Gammaforce: Random serverSERVER:irc.gammaforce.org:6663,6665,6666GROUP:Gammaforcen150=Ghostnet: Random serverSERVER:irc.ghostnet.org:6660,6662,6663GROUP:Ghostnetn151=GizNet: Random serverSERVER:irc.giznet.com:6666,6668,6669GROUP:GizNetn152=Global-irc: Random serverSERVER:irc.global-irc.net:6667GROUP:Global-ircn153=Globalchat: Random serverSERVER:irc.globalchat.org:6667GROUP:Globalchatn154=Go2Chat: China, Hong KongSERVER:irc.go2chat.net:6668,6669,7000GROUP:Go2Chatn155=Grnet: Random EU serverSERVER:gr.irc.gr:6667,7000GROUP:GRnetn156=Grnet: Random serverSERVER:srv.irc.gr:6667,7000GROUP:GRnetn157=Grnet: Random US serverSERVER:us.irc.gr:6667,7000GROUP:GRnetn158=Hellenicnet: Random serverSERVER:irc.mirc.gr:6667,7000GROUP:Hellenicnetn159=Hugsnet: Random serverSERVER:irc.hugs.net:6667,7000GROUP:Hugsnetn160=Hybnet: Random serverSERVER:irc.hybnet.net:6667GROUP:Hybnetn161=iChatZone: Random serverSERVER:irc.ichatzone.com:6667GROUP:iChatZonen162=ICQnet: Random serverSERVER:irc.icq.com:6667GROUP:ICQnetn163=Infatech: Random serverSERVER:irc.infatech.net:6660,6664,6666GROUP:Infatechn164=Infinity: Random serverSERVER:irc.infinity-irc.org:6667GROUP:Infinityn165=Insiderz: Random serverSERVER:irc.insiderz.net:6667GROUP:Insiderzn166=IRC-Hispano: Random serverSERVER:irc.irc-hispano.org:6667GROUP:IRC-Hispanon167=IRChat: Random serverSERVER:irc.irchat.net:6661,6664,6666GROUP:IRChatn168=IRChat-br: Random serverSERVER:irc.irchat.com.br:6667GROUP:IRChat-brn169=IRCLink: EU, NO, AlesundSERVER:alesund.no.eu.irclink.net:6667,6668,6669GROUP:IRCLinkn170=IRCLink: EU, NO, OsloSERVER:frogn.no.eu.irclink.net:6667,6668,6669GROUP:IRCLinkn171=IRCLink: US, SC, Rock HillSERVER:rockhill.sc.us.irclink.net:6667,6668,6669GROUP:IRCLinkn172=IRCnet: EU, IT, RandomSERVER:irc.ircd.it:6665,6666,6668GROUP:IRCnetn173=IRCnet: AS, JP, TokyoSERVER:irc.tokyo.wide.ad.jp:6667GROUP:IRCnetn174=IRCnet: AU, MelbourneSERVER:yoyo.cc.monash.edu.au:6668,6669,9990GROUP:IRCnetn175=IRCnet: AU, SydneySERVER:irc.usyd.edu.au:6667GROUP:IRCnetn176=IRCnet: EU, AT, LinzSERVER:linz.irc.at:6666,6667,6668GROUP:IRCnetn177=IRCnet: EU, AT, WienSERVER:vienna.irc.at:6666,6668,6669GROUP:IRCnetn178=IRCnet: EU, BE, BrusselsSERVER:irc.belnet.be:6667GROUP:IRCnetn179=IRCnet: EU, BE, ZaventemSERVER:ircnet.wanadoo.be:6661,6665,6668GROUP:IRCnetn180=IRCnet: EU, CZ, PragueSERVER:irc.felk.cvut.cz:6667GROUP:IRCnetn181=IRCnet: EU, DE, BerlinSERVER:irc.fu-berlin.de:6665,6666,6668GROUP:IRCnetn182=IRCnet: EU, DE, DusseldorfSERVER:irc.freenet.de:6665,6666,6668GROUP:IRCnetn183=IRCnet: EU, DE, StuttgartSERVER:irc.belwue.de:6665,6666,6668GROUP:IRCnetn184=IRCnet: EU, DK, CopenhagenSERVER:irc.ircnet.dk:6667GROUP:IRCnetn185=IRCnet: EU, EE, TallinnSERVER:irc.estpak.ee:6666,6667,6668GROUP:IRCnetn186=IRCnet: EU, FI, EspooSERVER:irc.funet.fi:6661,6663,6665GROUP:IRCnetn187=IRCnet: EU, FI, HelsinkiSERVER:irc.cs.hut.fi:6667GROUP:IRCnetn188=IRCnet: EU, FR, NiceSERVER:irc.eurecom.fr:6667GROUP:IRCnetn189=IRCnet: EU, FR, ParisSERVER:ircnet.grolier.net:6667GROUP:IRCnetn190=IRCnet: EU, FR, PolySERVER:sil.polytechnique.fr:6667GROUP:IRCnetn191=IRCnet: EU, GR, ThessalonikiSERVER:irc.ee.auth.gr:6666,6668,6669GROUP:IRCnetn192=IRCnet: EU, HU, BudapestSERVER:irc.elte.hu:6667GROUP:IRCnetn193=IRCnet: EU, IL, HaifaSERVER:ircnet.netvision.net.il:6662,6664,6665GROUP:IRCnetn194=IRCnet: EU, IS, ReykjavikSERVER:irc.ircnet.is:6663,6664,6665GROUP:IRCnetn195=IRCnet: EU, IS, ReykjavikSERVER:irc.ircnet.is:6663,6665,6668GROUP:IRCnetn196=IRCnet: EU, IT, RomeSERVER:irc.tin.it:6665,6666,6668GROUP:IRCnetn197=IRCnet: EU, LV, RigaSERVER:irc.telia.lv:6666,6668,6669GROUP:IRCnetn198=IRCnet: EU, NL, Amsterdam (nlnet)SERVER:irc.nl.uu.net:6663,6664,6666GROUP:IRCnetn199=IRCnet: EU, NL, Amsterdam (xs4all)SERVER:irc.xs4all.nl:6661,6662,6665GROUP:IRCnetn200=IRCnet: EU, NL, EnschedeSERVER:irc.snt.utwente.nl:6660,6664,6665GROUP:IRCnetn201=IRCnet: EU, NL, NijmegenSERVER:irc.sci.kun.nl:6661,6664,6666GROUP:IRCnetn202=IRCnet: EU, NO, OsloSERVER:irc.ifi.uio.no:6667GROUP:IRCnetn203=IRCnet: EU, NO, TrondheimSERVER:irc.pvv.ntnu.no:6667GROUP:IRCnetn204=IRCnet: EU, PL, WarsawSERVER:warszawa.irc.pl:6666,6667,6668GROUP:IRCnetn205=IRCnet: EU, RU, MoscowSERVER:irc.msu.ru:6667GROUP:IRCnetn206=IRCnet: EU, SE, LuleaSERVER:irc.ludd.luth.se:6661,6663,6668GROUP:IRCnetn207=IRCnet: EU, UK, London (Btnet)SERVER:chat.bt.net:6660,6663,6666GROUP:IRCnetn208=IRCnet: EU, UK, London (Demon)SERVER:ircnet.demon.co.uk:6665,6666,6668GROUP:IRCnetn209=IRCnet: EU, UK, London (Netcom)SERVER:irc.netcom.net.uk:6660,6661,6662GROUP:IRCnetn210=IRCnet: EU, UK, Warrington (u-net)SERVER:irc.u-net.com:6662,6665,6666GROUP:IRCnetn211=IRCnet: US, NY, New YorkSERVER:irc.stealth.net:6661,6663,6665GROUP:IRCnetn212=IRCStorm: Random serverSERVER:irc.ircstorm.net:6667GROUP:IRCStormn213=IrcTalk: Random serverSERVER:irc.irctalk.net:6667GROUP:IrcTalkn214=IRCworld: Random serverSERVER:irc.ircworld.org:6667GROUP:IRCworldn215=Israelnet: Random serverSERVER:irc.israel.net:6667GROUP:Israelnetn216=K0wNet: Random serverSERVER:irc.k0w.net:6660,6661,6664GROUP:K0wNetn217=Kewl.org: Random serverSERVER:irc.kewl.org:6667GROUP:KewlOrgn218=Kewl.org: EU, FR, NanterreSERVER:nanterre.fr.eu.kewl.org:6667GROUP:KewlOrgn219=Kewl.org: EU, UK, LondonSERVER:london.uk.eu.kewl.org:6667GROUP:KewlOrgn220=Kidsworld: EU, FR, ParisSERVER:paris.fr.eu.kidsworld.org:6661,6662,6666GROUP:KidsWorldn221=Kidsworld: US, CO, DenverSERVER:denver.co.us.kidsworld.org:6666,6668,6669GROUP:KidsWorldn222=Kidsworld: US, MD, BaltimoreSERVER:baltimore.md.us.kidsworld.org:6666,6668,6669GROUP:KidsWorldn223=KissLand: Random serverSERVER:irc.kissland.com:6667GROUP:KissLandn224=Knightnet: AF, ZA, DurbanSERVER:orc.dbn.za.knightnet.net:6667,5555GROUP:Knightnetn225=Knightnet: US, CA, GoldengateSERVER:goldengate.ca.us.knightnet.net:6667,5555GROUP:Knightnetn226=KreyNet: Random serverSERVER:irc.krey.net:6667GROUP:Kreynetn227=Krushnet: Random serverSERVER:irc.krushnet.org:6667GROUP:Krushnetn228=LagNet: Random serverSERVER:irc.lagnet.org.za:6667GROUP:LagNetn229=LagNet: AF, ZA, Cape TownSERVER:reaper.lagnet.org.za:6667GROUP:LagNetn230=LagNet: AF, ZA, JohannesburgSERVER:mystery.lagnet.org.za:6667GROUP:LagNetn231=Librenet: Random serverSERVER:irc.librenet.net:6667GROUP:Librenetn232=Lunatics: Random serverSERVER:irc.lunatics.net:6667,6668,6669GROUP:Lunaticsn233=MagicStar: Random serverSERVER:irc.magicstar.net:6667GROUP:MagicStarn234=MavraNet: Random serverSERVER:irc.mavra.net:6663,6664,6668GROUP:MavraNetn235=MediaDriven: Random serverSERVER:irc.mediadriven.com:6667,6668,6669GROUP:MediaDrivenn236=Messique: Random serverSERVER:irc.messique.org:6663,6664,6665GROUP:Messiquen237=Millenia: Random serverSERVER:irc.millenia.org:6664,6668,6669GROUP:Millenian238=mIRCnet: Random serverSERVER:irc.mirc.net:6667GROUP:mIRCnetn239=Mozilla: Random serverSERVER:irc.mozilla.org:6667,7000GROUP:Mozillan240=Muhabbet: Random serverSERVER:irc.muhabbet.net:6667,8888,9000GROUP:Muhabbetn241=Mysteria: Random serverSERVER:irc.mysteria.net:6667,7000GROUP:Mysterian242=Mystical: Random serverSERVER:irc.mystical.net:6667,7000GROUP:Mysticaln243=NdrsNet: Random serverSERVER:irc.ndrsnet.com:6661,6663,6665GROUP:NdrsNetn244=Nebulanet: Random serverSERVER:irc.nebulanet.org:6661,6663,6668GROUP:Nebulanetn245=Net-France: Random serverSERVER:irc.net-france.com:6667GROUP:Net-Francen246=Nevernet: Random serverSERVER:irc.nevernet.net:6667GROUP:Nevernetn247=Newnet: Random serverSERVER:irc.newnet.net:6665,6666,6667GROUP:Newnetn248=Newnet: EU, DE, TrustedSERVER:irc.trusted-network.de:6666,7000GROUP:Newnetn249=Newnet: EU, UK, OasisSERVER:irc.oasis-net.net:6666,7000GROUP:Newnetn250=Newnet: NZ, AucklandSERVER:irc.uplink.net.nz:6666,6668,6669GROUP:Newnetn251=Newnet: US, CA, FlagglerockSERVER:irc.fragglerock.org:6666,7000GROUP:Newnetn252=Newnet: US, MA, ChelmsfordSERVER:irc.chelmsford.com:6663,6664,6666GROUP:Newnetn253=Newnet: US, VA, RandolphSERVER:irc.rma.edu:6660,6661,6669GROUP:Newnetn254=Nightstar: Random serverSERVER:irc.nightstar.net:6665,6666,6668GROUP:NightStarn255=Nitro: Random serverSERVER:irc.nitroirc.net:6667GROUP:Nitron256=Novernet: Random serverSERVER:irc.novernet.com:6665,6668,6669GROUP:Novernetn257=Novernet: US, GA, AugustaSERVER:irc.c-plusnet.com:6665,6666,6668GROUP:Novernetn258=Novernet: US, MN, MinneapolisSERVER:chat.novernet.com:6667GROUP:Novernetn259=OpenMind: Random serverSERVER:irc.openmind.net:6667GROUP:OpenMindn260=Opennet: Random serverSERVER:irc.opennetirc.org:6667GROUP:Opennetn261=Othernet: Random serverSERVER:irc.othernet.org:6667GROUP:Othernetn262=Othernet: US, FL, MiamiSERVER:miami.fl.us.othernet.org:6667GROUP:Othernetn263=Othernet: US, MO, StLouisSERVER:stlouis.mo.us.othernet.org:6667GROUP:Othernetn264=Otherside: Random serverSERVER:irc.otherside.com:6667GROUP:OtherSiden265=Outsiderz: Random serverSERVER:irc.outsiderz.com:6667GROUP:Outsiderzn266=OzChat: Random serverSERVER:irc.ozchat.org:6667GROUP:OzChatn267=OzOrg: AU, AdelaideSERVER:chariot.adelaide.oz.org:6666,6668,7000GROUP:OzOrgn268=OzOrg: AU, PerthSERVER:iinet.perth.oz.org:6667GROUP:OzOrgn269=OzOrg: AU, SydneySERVER:aussie.sydney.oz.org:6668,6669,7000GROUP:OzOrgn270=OzTic: Random serverSERVER:irc.oztic.net:6668,6669,7000GROUP:OzTicn271=Phishynet: Random serverSERVER:irc.phishy.net:6667,7000GROUP:Phishynetn272=Pinoycentral: Random serverSERVER:chat.abs-cbn.com:6667GROUP:Pinoycentraln273=Planetarion: Random serverSERVER:irc.planetarion.com:6667GROUP:Planetarionn274=PowerChat: Random serverSERVER:irc.powerchat.org:6729,6793,6997GROUP:PowerChatn275=Pseudonet: Random serverSERVER:irc.pseudonet.org:6667GROUP:Pseudonetn276=PTlink: Random serverSERVER:irc.ptlink.net:6667GROUP:PTlinkn277=PTnet: EU, PT, FaroSERVER:ualg.ptnet.org:6667GROUP:PTnetn278=PTnet: EU, PT, LisboaSERVER:telepac2.ptnet.org:6667GROUP:PTnetn279=QChat: Random serverSERVER:irc.qchat.net:6667GROUP:QChatn280=QuakeNet: Random serverSERVER:irc.quakenet.eu.org:6667,6668,6669GROUP:QuakeNetn281=Raptanet: Random serverSERVER:irc.rapta.net:6667GROUP:Raptanetn282=Raptornet: Random serverSERVER:irc.raptornet.org:6667GROUP:Raptornetn283=Rebelchat: Random serverSERVER:irc.rebelchat.org:6667GROUP:Rebelchatn284=Red-Latina: Random serverSERVER:irc.red-latina.org:6667GROUP:Red-Latinan285=Red-Latina: NA, MX, SanJoseSERVER:irc.dalsom.net:6666,6667GROUP:Red-Latinan286=RedeBrasil: BR, DF, BrasiliaSERVER:irc.persocom.com.br:6668,6669,7001GROUP:RedeBrasiln287=RedeBrasil: BR, PE, CaruaruSERVER:irc.netstage.com.br:6669,7000,7001GROUP:RedeBrasiln288=RedeBrasil: BR, PE, RecifeSERVER:irc.elogica.com.br:6669,7000,7001GROUP:RedeBrasiln289=RedeSul: BR, PR, MaringaSERVER:irc.wnet.com.br:6667GROUP:RedeSuln290=RedeSul: BR, SC, BlumenauSERVER:irc.braznet.com.br:6667,9001GROUP:RedeSuln291=RedLatona: Random serverSERVER:irc.redlatona.net:6667,6668GROUP:RedLatonan292=RekorNet: Random serverSERVER:irc.rekor.net:6664,6666,6669GROUP:RekorNetn293=Relicnet: Random serverSERVER:irc.relic.net:6667GROUP:Relicnetn294=Relicnet: US, MA, CycloneSERVER:cyclone.us.relic.net:6661,6663,6664GROUP:Relicnetn295=Risanet: Random serverSERVER:irc.risanet.com:6667,6668,6669GROUP:Risanetn296=Rootshell: Random serverSERVER:irc.rootshell.za.org:6667GROUP:Rootshelln297=Rusnet: EU, RU, TomskSERVER:irc.tsk.ru:6668,7770,7772GROUP:Rusnetn298=Rusnet: EU, RU, VladivostokSERVER:irc.vladivostok.ru:7772,7773,7774GROUP:Rusnetn299=Rusnet: EU, UA, KievSERVER:irc.kar.net:7772,7773,7774GROUP:Rusnetn300=SamShark: Random serverSERVER:irc.samshark.com:6667GROUP:SamSharkn301=Sandnet: Random serverSERVER:irc.sandnet.net:6660,6663,6664GROUP:Sandnetn302=Sandnet: US, CA, MysticSERVER:mystic.tides.sandnet.net:6662,6663,6664GROUP:Sandnetn303=Sandnet: US, NJ, DuneBuggySERVER:dunebuggy.nj.sandnet.net:6661,6664,6665GROUP:Sandnetn304=Seveneagle: Random serverSERVER:irc.seveneagle.net:6667GROUP:Seveneaglen305=SexNet: Random serverSERVER:irc.sexnet.org:6667GROUP:SexNetn306=SgNet: Random serverSERVER:irc.sgnet.org:6660,6663,6665GROUP:SgNetn307=ShadowFire: Random serverSERVER:irc.shadowfire.org:6667GROUP:ShadowFiren308=ShadowWorld: Random serverSERVER:irc.shadowworld.net:6667GROUP:shadowWorldn309=SideNet: Random serverSERVER:irc.sidenet.org:6751,6799,6803GROUP:SideNetn310=Skyyenet: US, VA, ArlingtonSERVER:arlington.va.us.skyyenet.org:6667GROUP:Skyyenetn311=Slashnet: Random serverSERVER:irc.slashnet.org:6667GROUP:Slashnetn312=Solarchat: Random serverSERVER:irc.solarchat.net:6667,7000GROUP:Solarchatn313=Sorcerynet: Random serverSERVER:irc.sorcery.net:6667,7000,9000GROUP:Sorceryn314=Sorcerynet: EU, SE, KarlskronaSERVER:nexus.sorcery.net:6667,7000,9000GROUP:Sorceryn315=Sorcerynet: US, CA, Palo AltoSERVER:kechara.sorcery.net:6667,7000,9000GROUP:Sorceryn316=Spamnet: Random serverSERVER:irc.spamnet.org:6667,6668,6669GROUP:Spamnetn317=StarChat: Random serverSERVER:irc.starchat.net:6668,6669,7000GROUP:StarChatn318=StarChat: AU, QLD, SouthernCrossSERVER:boomer.qld.au.starchat.net:6668,6669,7000GROUP:StarChatn319=StarChat: EU, NO, AskerSERVER:reality.no.eu.starchat.net:6668,6669,7000GROUP:StarChatn320=StarChat: US, CA, San JoseSERVER:sand.ca.us.starchat.net:6668,6669,7000GROUP:StarChatn321=StarLink-irc: Random serverSERVER:irc.starlink-irc.org:6667GROUP:starlink-ircn322=StarLink-irc: US, MI, RochesterSERVER:rochester.mi.us.starlink-irc.org:6667GROUP:Starlink-ircn323=StarLink-irc: US, TX, HoustonSERVER:houston.tx.us.starlink-irc.org:6667GROUP:Starlink-ircn324=StarLink Org: US, CO, DenverSERVER:denver.co.us.starlink.org:6661,6662,6666GROUP:StarlinkOrgn325=StarLink Org: US, NC, DurhamSERVER:durham-r.nc.us.starlink.org:6660,6662,6663GROUP:StarlinkOrgn326=StarLink Org: US, TX, WichitaFallsSERVER:wichitafalls.tx.us.starlink.org:6666,6667,6668GROUP:StarlinkOrgn327=StarWars-IRC: Random serverSERVER:irc.starwars-irc.net:6663,6664,6665GROUP:StarWars-IRCn328=Stormdancing: Random serverSERVER:irc.stormdancing.net:6666,6668,6669GROUP:Stormdancingn329=Styliso: Random serverSERVER:irc.styliso.net:6667GROUP:Stylison330=Sub-city: Random serverSERVER:irc.sub-city.net:6668,6669,7000GROUP:Sub-cityn331=Superchat: Random serverSERVER:irc.superchat.org:6661,6663,6664GROUP:Superchatn332=Superonline: Random serverSERVER:irc.superonline.com:6665,6668,6669GROUP:Superonlinen333=Sysopnet: Random serverSERVER:irc.sysopnet.org:6666,6667,6668GROUP:Sysopnetn334=Techdreams: Random serverSERVER:irc.techdreams.net:6667GROUP:Techdreamsn335=Telstra: Random serverSERVER:irc.telstra.com:6667,6668,6669GROUP:Telstran336=Thunderirc: Random serverSERVER:irc.thunderirc.net:6667GROUP:Thunderircn337=TR-net: EU, TR, AnkaraSERVER:irc.dominet.com.tr:6667GROUP:TR-netn338=TR-net: EU, Tr, IstanbulSERVER:irc.teklan.com.tr:6667GROUP:TR-netn339=TRcom: Random serverSERVER:irc.trcom.net:6666,6668,6669GROUP:TRcomn340=Treklink: Random serverSERVER:irc.treklink.net:6667GROUP:Treklinkn341=UltraIRC: Random serverSERVER:irc.ultrairc.net:6667GROUP:UltraIRCn342=Undernet: CA, ON, TorontoSERVER:toronto.on.ca.undernet.org:6661,6664,6665GROUP:Undernetn343=Undernet: CA, QC, MontrealSERVER:montreal.qu.ca.undernet.org:6662,6664,6665GROUP:Undernetn344=Undernet: EU, AT, GrazSERVER:graz.at.eu.undernet.org:6661,6662,6666GROUP:Undernetn345=Undernet: EU, BE, AntwerpSERVER:flanders.be.eu.undernet.org:6660,6663,6668GROUP:Undernetn346=Undernet: EU, BE, BrusselsSERVER:brussels.be.eu.undernet.org:6660,6662,6664GROUP:Undernetn347=Undernet: EU, FR, CaenSERVER:caen.fr.eu.undernet.org:6666,6668,6669GROUP:undernetn348=Undernet: EU, FR, ParisSERVER:paris.fr.eu.undernet.org:6664,6665,6666GROUP:Undernetn349=Undernet: EU, NL, DiemenSERVER:diemen.nl.eu.undernet.org:6662,6663,6664GROUP:Undernetn350=Undernet: EU, NL, HaarlemSERVER:haarlem.nl.eu.undernet.org:6660,6663,7000GROUP:Undernetn351=Undernet: EU, NO, OsloSERVER:oslo.no.eu.undernet.org:6663,6664,6666GROUP:Undernetn352=Undernet: EU, SE, GothenburgSERVER:gothenburg.se.eu.undernet.org:6661,6666,6668GROUP:Undernetn353=Undernet: EU, UK, LondonSERVER:london.uk.eu.undernet.org:6666,6668,6669GROUP:Undernetn354=Undernet: NZ, AucklandSERVER:auckland.nz.undernet.org:6667,6668GROUP:Undernetn355=Undernet: US, AZ, PhoenixSERVER:phoenix.az.us.undernet.org:6664,6665,6668GROUP:Undernetn356=Undernet: US, CA, Los-AngelesSERVER:los-angeles.ca.us.undernet.org:6660,6661,6664GROUP:Undernetn357=Undernet: US, CA, San DiegoSERVER:sandiego.ca.us.undernet.org:6662,6664,6665GROUP:Undernetn358=Undernet: US, DC, WashingtonSERVER:washington.dc.us.undernet.org:6660,6661,6665GROUP:Undernetn359=Undernet: US, GA, AtlantaSERVER:atlanta.ga.us.undernet.org:6662,6663,6668GROUP:Undernetn360=Undernet: US, KS, ManhattanSERVER:manhattan.ks.us.undernet.org:6661,6665,6668GROUP:Undernetn361=Undernet: US, MD, BaltimoreSERVER:baltimore.md.us.undernet.org:6665,6666,6668GROUP:Undernetn362=Undernet: US, MI, Ann-arborSERVER:ann-arbor.mi.us.undernet.org:6663,6664,6665GROUP:Undernetn363=Undernet: US, NV, Las VegasSERVER:lasvegas.nv.us.undernet.org:6660,6664,6666GROUP:Undernetn364=Undernet: US, NY, NewYorkSERVER:newyork.ny.us.undernet.org:6660,6663,6666GROUP:Undernetn365=Undernet: US, TX, DallasSERVER:dallas.tx.us.undernet.org:6661,6662,6663GROUP:Undernetn366=Undernet: US, UT, SaltlakeSERVER:saltlake.ut.us.undernet.org:6660,6661,6666GROUP:Undernetn367=Undernet: US, VA, ArlingtonSERVER:arlington.va.us.undernet.org:6662,6664,6665GROUP:Undernetn368=Undernet: US, VA, McLeanSERVER:mclean.va.us.undernet.org:6666,6668,6669GROUP:Undernetn369=UnderZ: Random serverSERVER:irc.underz.org:6667,6668GROUP:UnderZn370=Undienet: Random serverSERVER:irc.undienet.org:6662,6663,6664GROUP:Undienetn371=Unfnet: Random serverSERVER:irc.unfnet.net:6668,6669,7000GROUP:Unfnetn372=UnionLatina: Random serverSERVER:irc.unionlatina.org:6667GROUP:UnionLatinan373=UnitedChat Net: Random serverSERVER:irc.unitedchat.net:6667GROUP:UnitedchatNetn374=UnitedChat Org: Random serverSERVER:irc.unitedchat.org:6667GROUP:UnitedchatOrgn375=Univers: Random serverSERVER:irc.univers.org:6665,6666,6668GROUP:Universn376=Vidgamechat: Random serverSERVER:irc.vidgamechat.com:6667GROUP:Vidgamechatn377=Virtuanet: Random serverSERVER:irc.virtuanet.org:6661,6663,6666GROUP:Virtuanetn378=Vitamina: Random serverSERVER:irc-rr.vitamina.ca:6667GROUP:Vitaminan379=Warpednet: Random serverSERVER:irc.warped.net:6667GROUP:Warpednetn380=Webnet: Random serverSERVER:irc.webchat.org:6668,6669,7000GROUP:Webnetn381=Webnet: US, AL, DothanSERVER:wiregrass.al.us.webchat.org:6668,6669,7000GROUP:Webnetn382=Webnet: US, CA, Santa ClaraSERVER:webmaster.ca.us.webchat.org:6662,6665,6668GROUP:Webnetn383=Webnet: US, MA, BostonSERVER:greennet.ma.us.webchat.org:6668,6669,7000GROUP:Webnetn384=Wolfpac: Random serverSERVER:irc.wolfpac.org:6662,6664,6668GROUP:Wolfpacn385=WonKnet: Random serverSERVER:irc.wonk.net:6668,6669,7000GROUP:Wonknetn386=Woot: Random serverSERVER:irc.woot.net:6667GROUP:Wootn387=WorldIRC: Random serverSERVER:irc.worldirc.org:6660,6662,6663GROUP:WorldIRCn388=Xevion: Random serverSERVER:irc.xevion.net:6667,7000GROUP:Xevionn389=Xnet: Random AU serverSERVER:au.xnet.org:6667GROUP:Xnetn390=Xnet: Random EU serverSERVER:eu.xnet.org:6667GROUP:Xnetn391=Xnet: Random US serverSERVER:us.xnet.org:6667GROUP:Xnetn392=XWorld: Random serverSERVER:irc.xworld.org:6667GROUP:XWorldn393=ZAnet Net: AF, ZA, CI (lia)SERVER:lia.zanet.net:6667GROUP:ZAnetNetn394=ZAnet Net: AF, ZA, MWeb (timewiz)SERVER:timewiz.zanet.net:6667GROUP:ZAnetNetn395=ZAnet Org: AF, ZA, Cape Town (gaspode)SERVER:gaspode.zanet.org.za:6667GROUP:ZAnetOrgn396=ZAnet Org: AF, ZA, Johannesburg (is)SERVER:is.zanet.org.za:6667GROUP:ZAnetOrgn397=ZAnet Org: AF, ZA, Midrand (ethereal)SERVER:ethereal.zanet.org.za:6660,6666GROUP:ZAnetOrgn398=ZiRC: Random serverSERVER:irc.zirc.org:6661,6666,6668GROUP:ZiRCn399=ZUHnet: Random serverSERVER:irc.zuh.net:6667GROUP:ZUHnetn400=Zurna: Random serverSERVER:irc.zurna.net:6667GROUP:Zurna'! !!IRCServer class methodsFor: 'servers' stamp: 'sbw 5/16/2004 08:51'!addServer: anIRCServer 	self servers at: anIRCServer key put: anIRCServer! !!IRCServer class methodsFor: 'servers' stamp: 'sbw 5/16/2004 08:51'!addServerCollection: aCollection 	aCollection		do: [:srv | self addServer: srv]! !!IRCServer class methodsFor: 'servers' stamp: 'sbw 5/25/2004 19:22'!buildServersListFrommIRCIniFilePath: aString 	"Populate the available servers class var using an mIRC servers.ini file  	for food. The file is found via <aString>."	| fileStream |	fileStream := FileStream readOnlyFileNamed: aString.	fileStream isNil		ifTrue: [^ nil].	self buildServersListFrommIRCIniStream: fileStream! !!IRCServer class methodsFor: 'servers' stamp: 'sbw 5/25/2004 19:20'!buildServersListFrommIRCIniStream: aStream 	| line candidate |	[line := aStream nextLine withBlanksTrimmed.	aStream atEnd]		whileFalse: [candidate := self from: line.			candidate isNil				ifFalse: [self addServer: candidate]]! !!IRCServer class methodsFor: 'servers' stamp: 'sbw 5/23/2004 22:39'!defaultServer	"IRCServer defaultServer"	^ self from: 'Open Projects NetSERVER:irc.freenode.net:6667'! !!IRCServer class methodsFor: 'servers' stamp: 'sbw 5/16/2004 08:54'!findServerNamed: aString address: addString 	| searchKey |	searchKey _ self keyConstructionFromNameToUseForProfile: aString andAddress: addString. 	^ self servers at: searchKey ifAbsent: []! !!IRCServer class methodsFor: 'servers' stamp: 'sbw 5/16/2004 08:56'!removeServer: anIRCServer 	self servers		removeKey: anIRCServer key		ifAbsent: []! !!IRCServer class methodsFor: 'servers' stamp: 'sbw 5/9/2004 12:35'!removeServerNamed: aString address: addString 	| found |	found := self findServerNamed: aString address: addString..	found isNil		ifFalse: [self removeServer: found]! !!IRCServer class methodsFor: 'servers' stamp: 'sbw 2/24/2002 20:28'!serverStringTag	^ 'SERVER'! !!IRCServer class methodsFor: 'servers' stamp: 'sbw 5/25/2004 19:41'!serverWithAddress: addrString 	"Answers the instance of IRCServer having an  	address <addString>. Answers nil if not found."	^self servers detect: [:each | each address = addrString] ifNone: []! !!IRCServer class methodsFor: 'servers' stamp: 'sbw 5/8/2004 20:14'!servers	Servers isNil		ifTrue: [self initializeServers].	^ Servers! !!IRCServer class methodsFor: 'servers' stamp: 'sbw 5/25/2004 19:38'!serversListByGroups	"IRCServer serversListByGroups"	| dict key undefined |	undefined := self undefinedGroupName.	dict := Dictionary new.	self servers		do: [:entry | 			key := entry group withBlanksTrimmed.			key isEmpty				ifTrue: [key := undefined].			(dict includesKey: key)				ifFalse: [dict at: key put: OrderedCollection new].			(dict at: key)				add: entry].	^ dict! !!IRCServer class methodsFor: 'class initialization' stamp: 'sbw 5/16/2004 09:02'!convertServers	"From OrderedCollection to Dictionary."	| copy |	copy := self servers deepCopy.	 self initializeServers.	copy		do: [:x | self addServer: x]! !!IRCServer class methodsFor: 'class initialization' stamp: 'sbw 5/16/2004 09:01'!initialize	"Trap change in shape."	self servers class = Dictionary		ifFalse: [self convertServers]! !!IRCServer class methodsFor: 'class initialization' stamp: 'sbw 5/16/2004 08:58'!initializeServers	"IRCServer initializeServers"	Servers := Dictionary new! !!IRCServer class methodsFor: 'instance creation' stamp: 'sbw 5/8/2004 21:17'!from: aString 	"Answers either a valid server or nil if the line <aString> is no good."	| candidate |	aString isNil ifTrue: [^nil].	aString isEmpty ifTrue: [^nil].	aString first = $; ifTrue: [^nil].	aString first = $[ ifTrue: [^nil].	candidate := self new.	candidate configureFromString: aString.	^candidate! !!IRCServer class methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 20:27'!groupStringTag	^ 'GROUP'! !!IRCServer class methodsFor: 'as yet unclassified' stamp: 'sbw 5/16/2004 08:53'!keyConstructionFromNameToUseForProfile: string1 andAddress: string2	^ string1 , '|' , string2! !!IRCServer class methodsFor: 'as yet unclassified' stamp: 'sbw 5/25/2004 19:35'!noGroupTag	^ '<blank>'! !!IRCServer class methodsFor: 'as yet unclassified' stamp: 'sbw 2/29/2000 15:46'!undefinedGroupName	^'<undefined>'! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 00:08'!addActionButtonsTo: parentMorph fractions: fractions offsets: offsets 	| buttons alignMorph btn |	buttons _ self buttonRow.	Preferences alternativeWindowLook		ifTrue: [buttons color: Color transparent.			buttons				submorphsDo: [:m | m borderWidth: 2;						 borderColor: #raised]].	alignMorph _ AlignmentMorph newRow hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 2;				 layoutPolicy: ProportionalLayout new.	alignMorph		addMorph: buttons		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ 0)).	parentMorph		addMorph: alignMorph		fullFrame: (LayoutFrame fractions: fractions offsets: offsets).	Preferences alternativeWindowLook		ifTrue: [alignMorph borderWidth: 2]		ifFalse: [alignMorph borderWidth: 0].	btn _ self findMorphNamed: 'okayButton' in: buttons.	btn isNil		ifFalse: [btn				offColor: Color veryVeryLightGray;				setBalloonText: self okayButtonInactiveHelpText]! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 11/16/2002 12:16'!addGroupListTo: parentMorph fractions: fractions offsets: offsets 	| alignMorph topOffset listMorph labelMorph |	topOffset _ 12.	alignMorph _ AlignmentMorph newRow hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 2;				 color: Color paleTan;				 layoutPolicy: ProportionalLayout new.	labelMorph _ TextMorph new.	labelMorph contents: 'Group' asText allBold;		 backgroundColor: Color transparent.	listMorph _ PluggableListMorph				on: self				list: #groupList				selected: #selectedGroupIndex				changeSelected: #selectedGroupIndex:				menu: nil.	alignMorph		addMorph: labelMorph		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (6 @ -2 corner: 0 @ topOffset)).	alignMorph		addMorph: listMorph		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ topOffset corner: 0 @ 0)).	parentMorph		addMorph: alignMorph		fullFrame: (LayoutFrame fractions: fractions offsets: offsets).	Preferences alternativeWindowLook		ifTrue: [alignMorph borderWidth: 2]		ifFalse: [alignMorph borderWidth: 0]! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 23:23'!addPortListTo: parentMorph fractions: fractions offsets: offsets 	| alignMorph topOffset listMorph labelMorph |	topOffset _ 12.	alignMorph _ AlignmentMorph newRow hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 2;				 layoutPolicy: ProportionalLayout new.	labelMorph _ TextMorph new.	labelMorph contents: 'Port' asText allBold.	listMorph _ PluggableListMorph				on: self				list: #portList				selected: #selectedPortIndex				changeSelected: #selectedPortIndex:				menu: nil.	alignMorph		addMorph: labelMorph		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (6 @ -2 corner: 0 @ topOffset)).	alignMorph		addMorph: listMorph		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ topOffset corner: 0 @ 0)).	parentMorph		addMorph: alignMorph		fullFrame: (LayoutFrame fractions: fractions offsets: offsets).	Preferences alternativeWindowLook		ifTrue: [alignMorph borderWidth: 2]		ifFalse: [alignMorph borderWidth: 0]! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 08:53'!addServerAddressTo: parentMorph fractions: fractions offsets: offsets 	| alignMorph labelMorph addressMorph |	alignMorph _ AlignmentMorph newRow hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 2;				 layoutPolicy: ProportionalLayout new.	labelMorph _ TextMorph new.	labelMorph contents: 'Server Address: ' asText allBold;		 lock.	addressMorph _ TextMorph new.	addressMorph contents: self noServerAddress asText;		 setNameTo: 'serverAddress'.	alignMorph		addMorph: labelMorph		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 0 @ 1)				offsets: (6 @ 2 corner: 100 @ 0)).	alignMorph		addMorph: addressMorph		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (100 @ 2 corner: 0 @ 0)).	parentMorph		addMorph: alignMorph		fullFrame: (LayoutFrame fractions: fractions offsets: offsets).	Preferences alternativeWindowLook		ifTrue: [alignMorph borderWidth: 2]		ifFalse: [alignMorph borderWidth: 0]! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 22:59'!addServerListTo: parentMorph fractions: fractions offsets: offsets 	| alignMorph topOffset listMorph labelMorph |	topOffset _ 12.	alignMorph _ AlignmentMorph newRow hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 2;				 layoutPolicy: ProportionalLayout new.	labelMorph _ TextMorph new.	labelMorph contents: 'Server' asText allBold.	listMorph _ PluggableListMorph				on: self				list: #serverList				selected: #selectedServerIndex				changeSelected: #selectedServerIndex:				menu: nil.	alignMorph		addMorph: labelMorph		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (6 @ -2 corner: 0 @ topOffset)).	alignMorph		addMorph: listMorph		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ topOffset corner: 0 @ 0)).	parentMorph		addMorph: alignMorph		fullFrame: (LayoutFrame fractions: fractions offsets: offsets).	Preferences alternativeWindowLook		ifTrue: [alignMorph borderWidth: 2]		ifFalse: [alignMorph borderWidth: 0]! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 21:42'!buildDialog	| window |	window _ (SystemWindow labelled: 'IRC Groups and Servers')				model: self.	self buildMorphIn: window.	^ window! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 21:55'!buildMorphIn: parentMorph 	"IRCServerDialog test"	| buttonHeight addressHeight |	buttonHeight _ 26.	addressHeight _ 26.	self		addGroupListTo: parentMorph		fractions: (0 @ 0 corner: 0.4 @ 1)		offsets: (0 @ 0 corner: 0 @ (buttonHeight + addressHeight) negated);				addServerListTo: parentMorph		fractions: (0.4 @ 0 corner: 0.8 @ 1)		offsets: (0 @ 0 corner: 0 @ (buttonHeight + addressHeight) negated);				addPortListTo: parentMorph		fractions: (0.8 @ 0 corner: 1 @ 1)		offsets: (0 @ 0 corner: 0 @ (buttonHeight + addressHeight) negated);				addServerAddressTo: parentMorph		fractions: (0 @ 1 corner: 1 @ 1)		offsets: (0 @ (buttonHeight + addressHeight) negated corner: 0 @ buttonHeight negated);				addActionButtonsTo: parentMorph		fractions: (0 @ 1 corner: 1 @ 1)		offsets: (0 @ buttonHeight negated corner: 0 @ 0)! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 5/11/2004 21:51'!buttonRow	| aRow btn |	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent.	aRow clipSubmorphs: true.	aRow layoutInset: 10 @ 1;		 cellInset: 14.	self buttonSpecs		do: [:spec | 			btn := PluggableButtonMorph						on: self						getState: nil						action: spec second.			btn color: Color transparent;				 hResizing: #spaceFill;				 vResizing: #spaceFill;				 useRoundedCorners;				 setNameTo: spec third;				 label: spec first asString.			btn onColor: Color veryVeryLightGray offColor: Color transparent.			aRow addMorphBack: btn.			btn setBalloonText: spec fourth].	^ aRow! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 6/2/2004 07:24'!buttonSpecs	"button label, selector, button name, help text"	^ {{'Okay'. #serverSelected. 'okayButton'. ''}. {'Cancel'. #cancelSelected. 'cancelButton'. 'Discard values'}. }! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 00:05'!findMorphNamed: aString 	^ self findMorphNamed: aString  in: self topView! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 00:04'!findMorphNamed: aString in: parentMorph 	parentMorph isNil		ifTrue: [^ nil].	^  parentMorph		submorphNamed: aString		ifNone: []! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 22:26'!groupList	^ self serversDict keys asSortedCollection! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 22:04'!initialExtent	^ 500 @ 400! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 22:07'!initialize	"Place holder."! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 22:18'!initializeServersDict	"Generated - Private. Initialize the value of serversDict."	self serversDict: Dictionary new! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 23:17'!noServerAddress	^ 'none specified'! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 00:06'!okayButtonActiveHelpText	^'Accept the current values for your IRC server connection'! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 00:07'!okayButtonInactiveHelpText	^ 'Currently disabled until all server parameters are selected'! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 21:40'!openDialog	^ self buildDialog openInWorld! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 00:42'!parentDialog: morph	parentDialog _ morph! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 23:28'!portList	| server |	self selectedGroupIndex = 0		ifTrue: [^ #()].	self selectedServerIndex = 0		ifTrue: [^ #()].	server _ self selectedServer.	^ server ports collect: [:x | x asString]! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 22:43'!selectedGroup	selectedGroupIndex = 0 ifTrue: [^nil].	^ self groupList at: self selectedGroupIndex! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 22:43'!selectedGroupIndex	selectedGroupIndex == nil		ifTrue: [selectedGroupIndex _ 0].	^ selectedGroupIndex! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 23:21'!selectedGroupIndex: index 	selectedGroupIndex _ index.	selectedServerIndex _ 0.	selectedPortIndex _ 0.	self changed: #selectedGroupIndex.	self changed: #serverList.	self changed: #portList.	self updateServerAddressDisplay! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 23:31'!selectedPort	| server |	self selectedGroupIndex = 0		ifTrue: [^ nil].	self selectedServerIndex = 0		ifTrue: [^ nil].	self selectedPortIndex = 0		ifTrue: [^nil].	server _ self selectedServer.	^ server ports at: self selectedPortIndex! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 23:20'!selectedPortIndex	selectedPortIndex == nil		ifTrue: [selectedPortIndex _ 0].	^ selectedPortIndex! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 23:33'!selectedPortIndex: index 	selectedPortIndex _ index.	self changed: #selectedPortIndex.	self updateServerAddressDisplay! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 23:13'!selectedServer	| servers |	servers _ self serversDict at: self selectedGroup ifAbsent: [^nil].	self selectedServerIndex = 0 ifTrue: [^nil].	^servers at: self selectedServerIndex.! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 23:33'!selectedServerAddress	| server port |	server _ self selectedServer.	server isNil		ifTrue: [^ self noServerAddress].	port _ self selectedPort.	^port isNil		ifTrue: [server address]		ifFalse: [server address,':', port printString]! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 22:43'!selectedServerIndex	selectedServerIndex == nil		ifTrue: [selectedServerIndex _ 0].	^ selectedServerIndex! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 23:22'!selectedServerIndex: index 	selectedServerIndex _ index.	selectedPortIndex _ 0.	self changed: #selectedServerIndex.	self changed: #portList.	self updateServerAddressDisplay! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 23:09'!selectedServerName	selectedServerIndex = 0		ifTrue: [^ nil].	^ self serverList at: self selectedServerIndex! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 22:40'!serverList	| group servers |	self selectedGroupIndex = 0		ifTrue: [^ #()].	group _ self selectedGroup.	servers _ self serversDict at: group.	^ servers		collect: [:x | x serverName]! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 22:18'!serversDict	"Generated - Return the value of serversDict."	serversDict == nil		ifTrue: [self initializeServersDict].	^ serversDict! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 22:18'!serversDict: anObject 	"Generated - Set the value of serversDict to <anObject>."	serversDict _ anObject! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 00:11'!updateOkayButtonState	| btn |	btn _ self findMorphNamed: 'okayButton'.	btn isNil		ifFalse: [	self validServerSelection		ifTrue: [btn offColor: Color transparent;				 setBalloonText: self okayButtonActiveHelpText]		ifFalse: [btn offColor: Color veryVeryLightGray;				 setBalloonText: self okayButtonInactiveHelpText]]! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 08:18'!updateServerAddressDisplay	| morph |	morph _ self findMorphNamed: 'serverAddress'.	morph isNil ifTrue: [^nil].	morph contents: self selectedServerAddress.	self updateOkayButtonState! !!IRCServerDialog methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 23:47'!validServerSelection	self selectedServer isNil ifTrue: [^false].	^self selectedPort isNil not! !!IRCServerDialog methodsFor: 'exit management' stamp: 'sbw 3/3/2002 21:55'!cancelSelected	"Make the server selection invalid and close our window."	selectedServerIndex _ 0.	self topView delete! !!IRCServerDialog methodsFor: 'exit management' stamp: 'sbw 3/3/2002 21:56'!serverSelected	"Okay button pressed.  If our selection is valid, close the window and tell our caller."	self validServerSelection		ifTrue: [self topView delete.			parentDialog isNil				ifFalse: [parentDialog useValuesFromServer: self selectedServer port: self selectedPort]]! !!IRCServerDialog methodsFor: 'exit management' stamp: 'sbw 3/3/2002 21:58'!windowIsClosing	"If we got here from a #serverSelected, the caller already knows.  If not, then it was either the cancel button or the window close button.  In that case, tell the caller."	self validServerSelection		ifTrue: [^ nil].	parentDialog isNil		ifTrue: [^ nil].	parentDialog noServerSelected! !!IRCServerDialog commentStamp: '<historical>' prior: 0!Use #openDialog to open an instance of ourselves for selection from the user.The user will either	1) close the window (treated like a cancel)	2) press cancel	3) press okayIf window closed via close button or user selected cancel, and if there is a parentDialog defined, we send the #noServerSelected to that parentDialog.If the window closed by the okay button and if there is a parent dialog defined, we send #useValuesFromServer:port: to that parent dialog.In all cases our window is closed when we leave here.!!IRCServerDialog class methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 22:05'!new	^ super new initialize! !!IRCServerDialog class methodsFor: 'as yet unclassified' stamp: 'sbw 2/25/2002 00:30'!on: list 	^self new serversDict: list! !!IRCServerDialog class methodsFor: 'as yet unclassified' stamp: 'sbw 5/25/2004 19:38'!test	"IRCServerDialog test"	self new serversDict: IRCServer serversListByGroups;		 openDialog! !!IRCSystemWindow methodsFor: 'as yet unclassified' stamp: 'sbw 5/30/2004 10:08'!inform: aString 	"Could intercept here."	super inform: aString! !!IRCSystemWindow methodsFor: 'as yet unclassified' stamp: 'sbw 5/30/2004 10:06'!informUser: aString during: aBlock 	(MVCMenuMorph		from: (SelectionMenu labels: '')		title: aString)		displayAt: Sensor cursorPoint		during: [aBlock value]! !!IRCSystemWindow methodsFor: 'constants' stamp: 'sbw 5/27/2004 07:04'!paneColorRamp	^ {0.0 -> Color paleTan darker. 1.0		-> (Color white alpha: 0.8)}! !!IRCSystemWindow commentStamp: '<historical>' prior: 0!Abstract gui layer for IRC windows.!!IRCSystemWindow class methodsFor: 'as yet unclassified' stamp: 'sbw 6/3/2004 19:28'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!IRCSystemWindow class methodsFor: 'as yet unclassified' stamp: 'sbw 5/12/2004 06:47'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference"	^ WindowColorSpec		classSymbol: self name		wording: 'IRC'		brightColor: #tan		pastelColor: #paleTan		helpMessage: 'Internet Relay Chat tool.'! !!IRCTextLines methodsFor: 'as yet unclassified' stamp: 'sbw 6/7/2004 22:43'!add: aTextOrString 	super add: aTextOrString.	[self size > self limit]		whileTrue: [self removeFirst].	self updateTextFromLines! !!IRCTextLines methodsFor: 'as yet unclassified' stamp: 'sbw 6/7/2004 22:44'!clear	self initialize! !!IRCTextLines methodsFor: 'as yet unclassified' stamp: 'sbw 6/7/2004 22:42'!initialize	super initialize.	self limit: self class defaultLimit.	self text: Text new! !!IRCTextLines methodsFor: 'as yet unclassified' stamp: 'sbw 6/7/2004 22:40'!limit	^limit! !!IRCTextLines methodsFor: 'as yet unclassified' stamp: 'sbw 6/7/2004 22:40'!limit: anInteger	limit _ anInteger! !!IRCTextLines methodsFor: 'as yet unclassified' stamp: 'fc 10/7/2005 15:27'!text	^ text! !!IRCTextLines methodsFor: 'as yet unclassified' stamp: 'sbw 6/7/2004 22:42'!text: aText	text _ aText! !!IRCTextLines methodsFor: 'as yet unclassified' stamp: 'sbw 6/7/2004 22:42'!updateTextFromLines	| stream |	stream _ TextStream on: '' asText.	self		do: [:each | stream nextPutAll: each].	self text: stream contents.! !!IRCTextLines commentStamp: '<historical>' prior: 0!Handles quantity of text lines in various IRC client text panes.  Provides simple getter for text contents as a stream, and manages the number of lines limits.!!IRCTextLines class methodsFor: 'as yet unclassified' stamp: 'sbw 6/7/2004 22:39'!defaultLimit	^400! !!IRConstant methodsFor: 'accessing' stamp: 'ajh 3/10/2003 00:43'!constant	^ constant! !!IRConstant methodsFor: 'accessing' stamp: 'ajh 3/10/2003 00:43'!constant: object	constant _ object! !!IRConstant methodsFor: 'accessing' stamp: 'ajh 6/27/2004 21:39'!type	"type is nil, #block, or #blockMethod"	^ type! !!IRConstant methodsFor: 'accessing' stamp: 'ajh 6/27/2004 21:39'!type: symbol	"symbol is nil, #block, or #blockMethod"	type _ symbol! !!IRConstant methodsFor: 'interpret' stamp: 'ajh 6/27/2004 21:41'!executeOn: interpreter	^ type caseOf: {		[nil] -> [interpreter pushLiteral: constant].		[#block] -> [interpreter pushBlock: constant].		[#blockMethod] -> [interpreter pushBlockMethod: constant]	 }! !!IRConstant methodsFor: 'testing' stamp: 'md 11/26/2004 15:35'!isConstant	^ true! !!IRConstant methodsFor: 'testing' stamp: 'ajh 3/10/2003 16:12'!isConstant: valueTest	^ valueTest value: constant! !!IRConstant commentStamp: 'ajh 3/24/2003 23:56' prior: 0!Instruction "pushLiteral: object"!!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/2/2007 21:06'!Assignment	| node |	(node := self stackDown) isAssignment ifTrue: [^ node].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'md 11/12/2004 14:06'!Block	| node |	(node := self stackDown) isBlock ifTrue: [^ node].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/2/2007 21:05'!Dup	| node |	(node := self stackDown) isDup ifTrue: [^ node].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/2/2007 20:50'!Goto	| node |	(node := self stackDown) isGoto ifTrue: [^ node].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/2/2007 21:05'!Goto: seqNum	| goto |	(goto := self Goto) destination = seqNum ifTrue: [^ goto].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/2/2007 21:05'!GotoOrReturn: seqNum	| goto |	goto := self Goto.	(goto destination = seqNum or: [goto isRet]) ifTrue: [^ goto].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/2/2007 21:05'!If	| node |	(node := self stackDown) isIf ifTrue: [^ node].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/2/2007 21:05'!IfGoto: seqNum otherwise: seqNum2	| if |	((if := self If) destination = seqNum and: [if otherwise = seqNum2])		ifTrue: [^ if].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/2/2007 21:04'!Label	| node |	(node := self stackDown) isLabel ifTrue: [^ node].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/2/2007 21:04'!Label: seqNum	| label |	(label := self Label) destination = seqNum ifTrue: [^ label].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/2/2007 21:04'!Pop	| node |	(node := self stackDown) isPop ifTrue: [^ node].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/2/2007 21:04'!Send	| node |	(node := self stackDown) isPseudoSend ifTrue: [^ node].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/10/2007 13:50'!Sequence	| node seq i goto |	seq := RBSequenceNode statements: #().	i := self spIndex.	[node := stack at: i.	node isSequence 		ifTrue: 			[seq addNodesFirst: node statements.			node := stack at: (i := i - 1)].	(node isLabel and: [i > 1]) 		ifFalse: 			[sp := i.			^ seq].	goto := stack at: (i := i - 1).	goto isGoto and: [goto destination = node destination]] 			whileTrue: [i := i - 1].	sp := i + 1.	^ seq! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 7/12/2007 22:43'!Sequence2	| node seq i block temps label |	seq := RBSequenceNode statements: #().	i := self spIndex.	node := stack at: i.	[(node isLabel and: [(stack at: i - 1) isGoto] and:[node destination = (stack at: i - 1) destination])		ifTrue:[			i := i - 2.			node := stack at: i].	(node isLabel not and: [i > 1])] whileTrue: 			[			node isSequence 				ifTrue: [seq addNodesFirst: node statements]				ifFalse: [seq addNodeFirst: node].			i := i - 1.			node := stack at: i].	sp := i.	label := self Label.	block := self Block.	self stackPush: block.	self stackPush: label.	"Add the temporaries find"	temps := scope tempVars asArray allButFirst.	temps := temps select: [:each | ((block arguments 							collect: [:var | var binding])  includes: each) not].	seq temporaries: (temps collect: [:var | self newVar: var]).	^ seq! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/2/2007 21:03'!SequenceBackTo: labelNum 	| node seq i goto |	seq := RBSequenceNode statements: #().	i := self spIndex.	[node := stack at: i.	node isSequence 		ifTrue: 			[seq addNodesFirst: node statements.			node := stack at: (i := i - 1)].	(node isLabel and: [i > 1]) 		ifFalse: 			[sp := i.			^ seq].	node destination = labelNum 		ifTrue: 			[sp := i.			^ seq].	goto := stack at: (i := i - 1).	goto isGoto and: [goto destination = node destination]] 			whileTrue: [i := i - 1].	sp := i + 1.	^ seq! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 7/19/2007 12:21'!SequenceOtherwise	| node seq i |	seq := RBSequenceNode statements: #().	i := self spIndex.	node := stack at: i.	node isSequence ifTrue: [			seq addNodesFirst: node statements.			self stackDown]		ifFalse:[node isLabel ifFalse:[self abort]].	^ seq! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/2/2007 21:03'!Value	| node |	node := self ValueOrNone.	node ifNil: [self abort].	^ node! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/2/2007 21:02'!ValueOrNone	| node i label |	i := self spIndex.	[node := stack at: i.	node isValue 		ifTrue: 			[label ifNotNil: [valueLabelMap at: node put: label].			sp := i - 1.			^ node].	(node isLabel and: [i > 1]) ifFalse: [^ nil].	label := node.	node := stack at: (i := i - 1).	node isGoto and: [node destination = label destination]] 			whileTrue: [i := i - 1].	^ nil! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/2/2007 21:01'!abort	| spWas |	spWas := sp.	sp := nil.	Abort signal! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 8/9/2007 14:53'!fixStack	sp ifNotNil: [stack removeLast: (stack size - sp)].	sp := nil.! !!IRDecompiler methodsFor: 'stack' stamp: 'ms 5/2/2007 20:59'!spIndex	^ sp ifNil: [sp := stack size]! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/22/2003 19:24'!stackDown	| node |	sp ifNil: [sp _ stack size].	sp = 0 ifTrue: [self abort].	node _ stack at: sp.	sp _ sp - 1.	^ node! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 6/22/2003 14:51'!stackPush: node	self fixStack.	stack addLast: node.	node ifNil: [^ self].  "no op"	self mapNode: node.! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ms 9/8/2007 02:30'!addReturn: statements from: goto		| ret |		statements last isReturn ifTrue:[^self].		ret := RBReturnNode value: statements last.		Preferences compileBlocksAsClosures ifTrue:[			scope isHome ifFalse: [ret homeBinding: scope outerEnvScope thisEnvVar]].		goto mapInstr sourceNode: ret.		statements atLast: 1 put: ret.! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ms 7/10/2007 16:07'!block: method env: envRefNode	self stackPush: (IRDecompiler new		scope: (scope newBlockScope "capturedVars: vars");		decompileIR: method ir)		asBlock! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ms 6/20/2007 00:53'!cascade	| messages selector args rcvr |	messages := OrderedCollection new.	"last message"	selector _ self Send selector.	args := OrderedCollection new.	selector numArgs timesRepeat: [args addFirst: self Value].	messages addFirst: selector -> args.	"rest of messages"	[(rcvr := self ValueOrNone) isNil] whileTrue: [		self Pop.		selector := self Send selector.		args := OrderedCollection new.		selector numArgs timesRepeat: [args addFirst: self Value].		self Dup.		messages addFirst: selector -> args.	].	messages := messages collect: [:assoc |		RBMessageNode			receiver: rcvr			selector: assoc key			arguments: assoc value].	self stackPush: (RBCascadeNode messages: messages).! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ms 9/6/2007 01:57'!endAndOr2: seqNum	| goto seq p if2 test else o if1 seqValue elseTest otherwise |	[		goto _ self Goto.		seqValue _ self ValueOrNone.		seq _ self Sequence.		p _ self Label destination.		if2 _ self IfGoto: seqNum otherwise: p.		elseTest _ self Value.		else _ self SequenceBackTo: goto destination.		o _ self Label destination.		o = goto destination ifTrue: [self abort].		if1 _ self IfGoto: seqNum otherwise: o.		test _ self Value.	] on: Abort do: [^ false].	if1 boolean = if2 boolean 		ifFalse: [			otherwise := RBSequenceNode statements: #().			otherwise addNode: (self newLiteral: if2 boolean).			self stackPush: (RBMessageNode				receiver: test 				selector: (if2 boolean ifTrue: [#ifTrue:ifFalse:] ifFalse: [#ifFalse:ifTrue:]) 				arguments: {self newBlock: (else addNode: elseTest).					self newBlock: otherwise}).]		ifTrue:[self stackPush: (RBMessageNode			receiver: test			selector: (if2 boolean ifTrue: [#or:] ifFalse: [#and:])			arguments: {self newBlock: (else addNode: elseTest)})].	stack addLast: if2.	self label: p.	stack addLast: seq.	seqValue ifNotNil: [stack addLast: seqValue].	stack addLast: goto.	^ true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ms 6/17/2007 16:05'!endAndOr: seqNum	| o test branches if body block sel1 sel2 if2 |	branches := OrderedCollection new.	[		(if2 := self If) otherwise = seqNum ifFalse: [self abort].		[	test := self Value.			body := self Sequence.			branches add: {body. test}.			o := self Label destination.			(if := self If) otherwise = o ifFalse: [self abort].			if destination = seqNum		] whileFalse: [			if boolean = if2 boolean ifFalse: [self abort].			if destination = if2 destination ifFalse: [self abort].		].		if boolean = if2 boolean ifTrue: [self abort].		test := self Value.	] on: Abort do: [^ false].	if boolean		ifTrue: [sel1 := #or:. sel2 := #and:]		ifFalse: [sel1 := #and:. sel2 := #or:].	block := self newBlock: (branches first first addNode: branches first second).	branches allButFirstDo: [:pair |		block := self newBlock: (pair first addNode: (RBMessageNode				receiver: pair second				selector: sel2				arguments: {block})).	].	self stackPush: (RBMessageNode		receiver: test		selector: sel1		arguments: {block}).	stack addLast: if2.	^ true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ms 7/19/2007 16:06'!endCase: seqNum	| otherwiseGoto goto node otherwiseValue otherwiseSeq n branchValue branchSeq f caseValue caseSeq rcvr branches message seqEnd afterOterwise seq afterOterwiseValue |	branches := OrderedCollection new.	[	"otherwise"		otherwiseGoto := self Goto.		node := self stackDown.		node isSequence ifTrue: [(node statements size = 1 			and:[node statements first isSend] 			and: [				node := node statements first. 				node selector == #caseError]) ifFalse: [					otherwiseSeq := node] ].		(node isPop or: [node isSend and: [node selector == #caseError]]) ifTrue: [			node isPop ifTrue: [node := self Send].			node selector == #caseError ifFalse: [self abort].		] ifFalse: [			sp := sp + 1.  "stackUp"						seqNum == #lastReturn 				ifFalse: [					otherwiseValue := self ValueOrNone.					otherwiseSeq := self Sequence]				ifTrue: [					afterOterwiseValue := self ValueOrNone.					otherwiseSeq := RBSequenceNode statements: #().					afterOterwise := self SequenceOtherwise].		].		n := self Label destination.		"last case branch"		seqNum == #lastReturn 			ifFalse: [goto := self GotoOrReturn: seqNum]			ifTrue: [				seqEnd := n.				goto := self GotoOrReturn: n.				otherwiseGoto := goto].		branchValue := self ValueOrNone.		branchSeq := self Sequence.		(stack at: sp) isPop ifTrue: [self stackDown].		f := self Label destination.				"last case"		self IfGoto: n otherwise: f.		self Send selector == #= ifFalse: [self abort].		caseValue := self Value.		caseSeq := self Sequence.		otherwiseSeq ifNil: [self Dup].		branches addFirst: ({caseSeq. caseValue} -> {branchSeq. branchValue. goto}).		[(rcvr := self ValueOrNone) isNil] whileTrue: [			"case branch"			n := self Label destination.			seqNum == #lastReturn 				ifFalse: [goto := self GotoOrReturn: seqNum]				ifTrue: [goto := self GotoOrReturn: seqEnd].			branchValue := self ValueOrNone.			branchSeq := self Sequence.			self Pop.			f := self Label destination.			"case"			self IfGoto: n otherwise: f.			self Send selector == #= ifFalse: [self abort].			caseValue := self Value.			caseSeq := self Sequence.			self Dup.			branches addFirst: ({caseSeq. caseValue} -> {branchSeq. branchValue. goto}).		].	] on: Abort do: [^ false].	branches := branches collect: [:assoc |		assoc key second			ifNotNil: [assoc key first addNode: assoc key second].		assoc value second			ifNotNil: [assoc value first addNode: assoc value second].		RBMessageNode			receiver: (self newBlock: assoc key first return: nil)			selector: #->			arguments:				{self newBlock: assoc value first return: assoc value third}	].	message := otherwiseSeq		ifNil: [			RBMessageNode				receiver: rcvr				selector: #caseOf:				arguments: {RBArrayNode statements: branches}]		ifNotNil: [			otherwiseValue				ifNotNil: [otherwiseSeq addNode: otherwiseValue].			RBMessageNode				receiver: rcvr				selector: #caseOf:otherwise:				arguments: 					{RBArrayNode statements: branches.					self newBlock: otherwiseSeq return: otherwiseGoto}.		].	self stackPush: message.	seqNum == #lastReturn ifTrue: [		self popTop.		seq := self Sequence.		afterOterwise ifNotNil:[seq statements addAllLast: afterOterwise statements].		self stackPush: seq.		afterOterwiseValue ifNotNil:[self stackPush: afterOterwiseValue].		branchValue := 1].	branchValue ifNil: [self popTop].	self stackPush: otherwiseGoto.	^ true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ms 7/15/2007 23:33'!endIfNil: seqNum	| goto branch o if rcvr value |	[		goto := self Goto.		value := self Value.		branch := self Sequence.		self Pop.		o := self Label destination.		if := self IfGoto: seqNum otherwise: o.		self Send selector == #== ifFalse: [self abort].		(self Value isLiteral: [:v | v isNil]) ifFalse: [self abort].		self Dup.		rcvr := self Value.	] on: Abort do: [^ false].	branch addNode: value.	self stackPush: (RBMessageNode		receiver: rcvr		selector: (if boolean ifTrue: [#ifNotNil:] ifFalse: [#ifNil:])		arguments: {self newBlock: branch return: goto}).	self goto: seqNum.	^ true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ms 9/6/2007 00:23'!endIfThen2: seqNum	| goto branch o if test value gotoNum branch2 |	[		goto := self Goto.		(goto mapInstr ~= nil 			and: [goto mapInstr isJump]			and: [goto mapInstr destination size = 1]  			and: [goto mapInstr destination last isJump]) 				ifTrue: [gotoNum := goto 					mapInstr destination last destination orderNumber]				ifFalse:[self abort].		(currentInstr ~= nil 			and: [currentInstr isJump] 			and: [currentInstr destination orderNumber = goto destination])				ifFalse: [self abort].		value := self Value.		branch := self Sequence.		o := self Label destination.		seqNum = gotoNum 			ifFalse:[if := self IfGoto: gotoNum otherwise: o]			ifTrue:[self abort].		test := self Value.	] on: Abort do: [^ false].		value ifNotNil: [branch addNode: value].	branch2 := RBSequenceNode statements: #().	branch2 addNode: (self newLiteral: if boolean).	self stackPush: (self simplify: (RBMessageNode		receiver: test		selector: (if boolean ifTrue: [#ifFalse:ifTrue:] ifFalse: [#ifTrue:ifFalse:])		arguments: {self newBlock: branch return: goto.			self newBlock: branch2})).	self goto: goto destination.	^true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ms 9/7/2007 21:47'!endIfThen3: seqNum	| goto branch o if test value |	[		goto := self Goto.		(goto destination == seqNum or: [self isExplicitReturn: goto])			ifFalse: [self abort].		goto isRet ifTrue: [value := self Value].		branch := self Sequence.		o := self Label destination.		if := self If.		((if destination = seqNum 			or: [if destination = (mapEmptyStatement at: seqNum ifAbsent:[seqNum])])				and: [if otherwise = o])			ifFalse:[self abort].		test := self Value.	] on: Abort do: [^ false].		value ifNotNil: [branch addNode: value].	self stackPush: (self simplify: (RBMessageNode		receiver: test		selector: (if boolean ifTrue: [#ifFalse:] ifFalse: [#ifTrue:])		arguments: {self newBlock: branch return: goto})).	self popTop.	self goto: seqNum.	^ true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ms 7/19/2007 16:07'!endIfThen: seqNum	| goto branch o if test value |	[		goto := self Goto.		(goto destination == seqNum or: [self isExplicitReturn: goto])			ifFalse: [self abort].		goto isRet ifTrue: [value := self Value].		branch := self Sequence.		o := self Label destination.		if := self IfGoto: seqNum otherwise: o.		test := self Value.	] on: Abort do: [^ false].		value ifNotNil: [branch addNode: value].	self stackPush: (self simplify: (RBMessageNode		receiver: test		selector: (if boolean ifTrue: [#ifFalse:] ifFalse: [#ifTrue:])		arguments: {self newBlock: branch return: goto})).	self popTop.	self goto: seqNum.	^ true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ms 9/8/2007 02:48'!endIfThenElse: seqNum	| goto2 else d goto1 then o if test value2 value1 |	[		goto2 := self Goto.		value2 := self ValueOrNone.		else := self Sequence.		d := self Label destination.		goto1 := self Goto.		((self isExplicitReturn: goto2) or: [goto2 destination == goto1 destination]) ifFalse: [self abort].		value1 := self ValueOrNone.		then := self Sequence.		o := self Label destination.		if := self IfGoto: d otherwise: o.		test := self Value.	] on: Abort do: [^ false].	value2 ifNotNil: [else addNode: value2].	value1 ifNotNil: [then addNode: value1].	(self isExplicitReturn: goto1) ifTrue:[self addReturn: then statements from: goto1].	(self isExplicitReturn: goto2) ifTrue:[self addReturn: else statements from: goto2].	self stackPush: (self simplify: (else isEmpty		ifTrue: [RBMessageNode			receiver: test			selector: (if boolean ifTrue: [#ifFalse:] ifFalse: [#ifTrue:])			arguments: {self newBlock: then return: goto1}]		ifFalse: [RBMessageNode			receiver: test			selector: (if boolean				ifTrue: [#ifFalse:ifTrue:]				ifFalse: [#ifTrue:ifFalse:])			arguments: {				self newBlock: then return: goto1.				self newBlock: else return: goto2}])).	value1 ifNil: [self popTop].	currentInstr := goto1 mapInstr.	self stackPush: goto1.	(else statements isEmpty and:	 [stack anySatisfy: [:n | n isIf and: [n destination = d]]]	) ifTrue: [		self label: d.		currentInstr := goto2 mapInstr.		self stackPush: goto2.	].	^ true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ms 9/6/2007 04:29'!endToDo: seqNum	| start limit incr iter step loopBlock o if test limitExpr init |	[		start := self Goto destination.		limit := self Value.		incr := self Assignment.		iter := incr variable.		(incr value isMessage and:		 [incr value selector == #+ and:		  [incr value receiver isVariable and: 		   [incr value receiver binding == iter binding]]]		) ifFalse: [self abort].		step := incr value arguments first.		loopBlock := self Sequence.		o := self Label destination.		if := self IfGoto: seqNum otherwise: o.		test := self Value.		(test isMessage and:		 [(test selector == #<= or: [test selector == #>=]) and:		  [(valueLabelMap at: test arguments first ifAbsent: [self abort]) destination = start]]		) ifFalse: [self abort].		limitExpr := test arguments first.		limitExpr isAssignment ifTrue: [			(limitExpr variable binding index == limit binding index 				and:[limitExpr variable binding scope == limit binding scope]) ifFalse: [self abort].			limitExpr := limitExpr value.		].		init := test receiver.		(init isAssignment and: [init variable binding == iter binding])			ifFalse: [self abort].	] on: Abort do: [^ false].	limit isVariable 		ifTrue:[scope 			removeTemp: limit binding 			ifAbsent:[Preferences compileBlocksAsClosures 				ifFalse:[scope removeTempFromOldBlock: limit]]].	loopBlock := self newBlock: loopBlock.	loopBlock arguments: {iter}.	self stackPush: ((step isLiteral: [:c | c = 1])		ifTrue: [RBMessageNode				receiver: init value				selector: #to:do:				arguments: {limitExpr. loopBlock}]		ifFalse: [RBMessageNode				receiver: init value				selector: #to:by:do:				arguments: {limitExpr. step. loopBlock}]).	self popTop.	self goto: seqNum.	^ true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ms 9/7/2007 21:48'!endWhile2: seqNum	| start loopBlock if test sequence o goto previousStack |	[		stack := (previousStack := stack) copy.		start := (goto := self Goto) destination.		self stackPush: goto.		[self endIfThen3: start] whileTrue.		start :=  self Goto destination.		loopBlock _ self Sequence.		o _ self Label destination.		if _ self IfGoto: seqNum otherwise: o.		test _ self Value.		sequence _ self SequenceBackTo: start.		self Label: start.		sp _ sp + 1.  "stackUp"	] on: Abort do: [stack := previousStack. ^ false].	loopBlock isEmpty		ifTrue:[self stackPush: (self simplify: (RBMessageNode			receiver: (self newBlock: (sequence addNode: test))			selector: (if boolean ifTrue: [#whileFalse] ifFalse: [#whileTrue])			arguments: #()))]		ifFalse:[self stackPush: (self simplify: (RBMessageNode			receiver: (self newBlock: (sequence addNode: test))			selector: (if boolean ifTrue: [#whileFalse:] ifFalse: [#whileTrue:])			arguments: {self newBlock: loopBlock}))].	self popTop.	self goto: seqNum.	^ true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ms 9/6/2007 01:54'!endWhile: seqNum	| start loopBlock if test sequence o |	[		start _ self Goto destination.		loopBlock _ self Sequence.		o _ self Label destination.		if _ self IfGoto: seqNum otherwise: o.		test _ self Value.		sequence _ self SequenceBackTo: start.		self Label: start.		sp _ sp + 1.  "stackUp"	] on: Abort do: [^ false].	loopBlock isEmpty		ifTrue:[self stackPush: (self simplify: (RBMessageNode			receiver: (self newBlock: (sequence addNode: test))			selector: (if boolean ifTrue: [#whileFalse] ifFalse: [#whileTrue])			arguments: #()))]		ifFalse:[self stackPush: (self simplify: (RBMessageNode			receiver: (self newBlock: (sequence addNode: test))			selector: (if boolean ifTrue: [#whileFalse:] ifFalse: [#whileTrue:])			arguments: {self newBlock: loopBlock}))].	self popTop.	self goto: seqNum.	^ true! !!IRDecompiler methodsFor: 'init' stamp: 'ms 7/5/2007 20:42'!addTempToScope: ir 	"Temp may be created only if they are not used in the method"	0 to: ir numRargs - 1 do: [:i | (scope 		rawVarAt: i 		ifNone: [			scope capturedVars do: [:each | 				each index = i ifTrue:[					scope tempVarAt: scope capturedVars size + scope tempVars size.					^self]].			scope tempVarAt: i]) markArg]! !!IRDecompiler methodsFor: 'init' stamp: 'ms 9/6/2007 03:52'!decompileIR: ir 	| sequenceNode temps args goto seq value method |	scope isBlockScope 		ifTrue:[(scope addTemp: 'parent env') markArg]		ifFalse:[(scope addTemp: 'self') markArg].	ir tempKeys do: [:temp | scope tempVarAt: temp].	0 to: ir numRargs - 1 do: [:i | (scope tempVarAt: i) markArg].	self interpret: ir.		self addTempToScope: ir.	self label: #return.	self Label: #return.	(self endCase: #lastReturn) ifFalse:[self Label: #return.].	goto := self Goto.	value := self ValueOrNone.	seq := self Sequence.	self removeClosureCreation: seq.	sp = 1 ifFalse: [stack explore. self error: 'error'].	value ifNotNil: [seq addNode: value].	sequenceNode := (self newBlock: seq return: goto) body.	temps := scope compactIndexTemps asArray.	ir tempKeys: temps.	args := (temps first: ir numRargs) allButFirst.	args := args collect: [:var | self newVar: var].	temps := temps allButFirst: ir numRargs.	sequenceNode temporaries: (temps collect: [:var | self newVar: var]), 		((scope capturedVars select:[:var | var name ~= 'self' and: [var sourceTemp == nil]]) 			collect:[:var | self newVar: var]).	method := (RBMethodNode new)				selectorParts: (self 							newSelectorParts: (self class dummySelector: args size));				arguments: args;				body: sequenceNode;				primitiveNode: ir primitiveNode;				scope: scope.	sequenceNode parent: method.	Preferences compileBlocksAsClosures 		ifFalse: [ASTFixDecompileBlockScope new visitNode: method].	^ method! !!IRDecompiler methodsFor: 'init' stamp: 'ms 7/30/2007 13:58'!removeClosureCreation: seq 	(Preferences compileBlocksAsClosures 		and: [seq statements size > 0]		and: [seq statements first isClosureEnvironmentCreation]) ifTrue: [			seq statements removeFirst.			(seq statements size > 0				and: [seq statements first isClosureEnvironmentRegistration])				ifTrue: [seq statements removeFirst]].				[Preferences compileBlocksAsClosures		and: [seq statements size > 0]		and: [seq statements first isClosureRegistrationAndCreation			or: [seq statements first isSelfClosureRegistration]			or: [seq statements first isTempClosureRegistration]]]					whileTrue: [seq statements removeFirst]! !!IRDecompiler methodsFor: 'init' stamp: 'ms 6/15/2007 13:24'!scope: aLexicalScope	scope := aLexicalScope! !!IRDecompiler methodsFor: 'old blocks' stamp: 'md 11/15/2004 15:38'!blockReturnTop	self goto: #return.! !!IRDecompiler methodsFor: 'old blocks' stamp: 'ms 9/8/2007 02:48'!endBlock: seqNum	| blockSeq block goto startBlock |	[		goto := self GotoOrReturn: seqNum.		(goto isRet 			or:[goto mapInstr notNil 				and: [goto mapInstr isBlockReturnTop]]) ifFalse: [self abort].		sp = 0 ifTrue: [self abort].		blockSeq := self Sequence2.		startBlock := self Label.		block := self Block.		(goto isRet not			and:[goto mapInstr notNil] 			and: [goto mapInstr isBlockReturnTop]			and: [block successor ~= seqNum]) ifTrue:[				self stackPush: block.				self stackPush: startBlock.				self stackPush: blockSeq. 				self stackPush: goto.				self abort].		self Send.	] on: Abort do: [^ false].	self stackPush: (self newBlock: blockSeq return: goto).		stack last arguments: block arguments.	"No extra scope is need if we don't use any temporaries and arguments.	so we remove them"	(stack last arguments isEmpty and: [stack last body temporaries isEmpty])		ifTrue:[ASTReplaceVariableScope replace: stack last scope: scope outerScope ].	scope := scope outerScope.	currentInstr := nil.	self goto: block successor.	^ true! !!IRDecompiler methodsFor: 'old blocks' stamp: 'ms 7/15/2007 00:55'!jumpOverBlock: seqNum1  to: seqNum2	| numArgs args oldscope pseudoBlock |	oldscope := scope.	self scope: (scope newBlockScope).	oldscope tempVarAt: 0.	(scope addObjectTemp: (oldscope tempVarAt: 0)).	numArgs := stack last arguments first value.	self stackPush: (pseudoBlock := RBPseudoBlockNode new).		args := OrderedCollection new.	numArgs timesRepeat: [ | var instr |		instr :=  currentInstr blockSequence removeFirst. 		var := oldscope tempVarAt: instr number.		args add: (self newVar: var).		var isUnused ifTrue: [oldscope removeTempFromOldBlock: var].		scope addObjectTemp: var.		currentInstr blockSequence first isPop 			ifFalse: [				currentInstr blockSequence sequence addFirst: (IRInstruction pushTemp: var index)]			ifTrue:[currentInstr blockSequence removeFirst].			].	args := args reverse.	pseudoBlock		block: seqNum1;		successor: seqNum2;		arguments: args	! !!IRDecompiler methodsFor: 'old blocks' stamp: 'ms 7/10/2007 18:05'!storeInstVar: number	| var |	var := scope  instanceScope instVar: number.	self stackPush: (RBAssignmentNode variable: (self newVar: var)  value:  self Value)! !!IRDecompiler methodsFor: 'private' stamp: 'ms 9/7/2007 21:34'!captureEmptyStatement	| by replace node |		[by := self Goto destination.	replace := self Label destination.	replace = 0 ifTrue: [self abort]] 			on: Abort			do: [^ false].	mapEmptyStatement at: by put: replace.	sp := nil.	^ true! !!IRDecompiler methodsFor: 'private' stamp: 'ms 8/8/2007 19:46'!fixInnerFreeVar: aRcvrTemp	| scopeInnerFreeVar |	scopeInnerFreeVar := scope outerScope.	[aRcvrTemp scope = scopeInnerFreeVar] whileFalse:[		scopeInnerFreeVar hasInnerFreeVars: true.		scopeInnerFreeVar := scopeInnerFreeVar outerScope].	aRcvrTemp scope hasInnerFreeVars: true! !!IRDecompiler methodsFor: 'private' stamp: 'ms 9/7/2007 21:33'!initialize	stack := OrderedCollection new.	scope := nil parseScope newMethodScope.  "in case never set"	valueLabelMap := IdentityDictionary new.	mapEmptyStatement := IdentityDictionary new! !!IRDecompiler methodsFor: 'private' stamp: 'ms 7/14/2007 21:45'!isExplicitReturn: goto	Preferences compileBlocksAsClosures 		ifTrue:[^ goto isRet 			and: [goto mapInstr notNil] 			and: [goto mapInstr isRemote or: [scope isBlockScope not]]]		ifFalse: [^goto isRet and: [goto mapInstr isBlockReturnTop not]]! !!IRDecompiler methodsFor: 'private' stamp: 'ajh 3/20/2003 23:21'!mapNode: node	currentInstr ifNil: [^ self].	node isPseudo		ifTrue: [node mapInstr: currentInstr]		ifFalse: [currentInstr sourceNode: node]! !!IRDecompiler methodsFor: 'private' stamp: 'ajh 3/24/2003 12:07'!newBlock: sequence	^ self newBlock: sequence return: nil! !!IRDecompiler methodsFor: 'private' stamp: 'ms 7/14/2007 22:16'!newBlock: sequence return: goto	| statements block |	statements := sequence statements.	(goto notNil and: [self isExplicitReturn: goto]) ifTrue: [		self addReturn: statements from: goto	].	sequence statements: statements.	block := RBBlockNode body: sequence.	sequence parent: block.	Preferences compileBlocksAsClosures ifFalse: [block scope: scope].	^block! !!IRDecompiler methodsFor: 'private' stamp: 'ms 9/6/2007 00:16'!newLiteral: literal	^ RBLiteralNode value: literal! !!IRDecompiler methodsFor: 'private' stamp: 'ms 5/2/2007 10:33'!newSelectorParts: selector	^ selector keywords collect: [:word |		RBLiteralToken value: word]! !!IRDecompiler methodsFor: 'private' stamp: 'ms 5/2/2007 10:35'!newVar: semVar	^ RBVariableNode new		identifierToken: (RBIdentifierToken value: semVar name start: 0);		binding: semVar! !!IRDecompiler methodsFor: 'private' stamp: 'ms 9/6/2007 20:42'!simplify: mess	"mess is a messageNode.  If it is a message created by the compiler convert it back to its normal form"	| rcvr var |"	(mess selector == #value and: [mess receiver isLiteral]) ifTrue: [		^ self newVar: (GlobalVar new assoc: mess receiver value; scope: scope)	]."	(mess selector = #privSetInHolder: and: [mess arguments first isLiteral]) ifTrue: [		^ RBAssignmentNode			variable: (self newVar: (GlobalVar new assoc: mess arguments first value; scope: scope) markWrite)			value: mess receiver	].	(mess selector = #privGetInstVar: and:	 [mess arguments first isLiteral and:	  [mess receiver isVariable]]) ifTrue: [		rcvr := mess receiver binding.		rcvr == scope receiverVar ifTrue: [			^ self newVar: (scope receiverVarAt: mess arguments first value)].		(rcvr isContextVar and: [mess arguments first value == 5]) ifTrue: [			var := scope tempVarAt: -1.			^self newVar: var].		(rcvr isCaptured and:[rcvr sourceTemp = rcvr scope receiverVar])			ifTrue:[				self fixInnerFreeVar: rcvr.				^self newVar: (rcvr scope receiverVarAt: mess arguments first value)].		rcvr isEnv ifTrue: [^self newVar: (rcvr scope captureVarAt: mess arguments first value)]].	(mess selector = #privStoreIn:instVar: and:	 [mess arguments last isLiteral and:	  [mess arguments first isVariable]]) ifTrue: [		rcvr := mess arguments first binding.		(mess receiver name = 'self' and: [rcvr isEnv]) 			ifTrue:[scope captureSelf: mess arguments last value. 				^mess].		rcvr == scope  receiverVar ifTrue: [^ RBAssignmentNode				variable: (self newVar: (scope receiverVarForAssignmentAt: mess arguments last value) markWrite) 				value: mess receiver].		(rcvr isCaptured and:[rcvr sourceTemp = rcvr scope receiverVar])			ifTrue:[				self fixInnerFreeVar: rcvr.				^RBAssignmentNode					variable: (self newVar: (rcvr scope receiverVarForAssignmentAt: mess arguments last value) markWrite) 					value: mess receiver].		mess isClosureEnvironmentRegistration			ifTrue: [				scope captureSelf: mess arguments last value.				^mess].		rcvr isEnv ifTrue:[			mess receiver isTemp 				ifTrue:[var := (scope 					captureVarAt: mess arguments last value  					sourceTemp: mess receiver binding) markWrite.]				ifFalse:[var := (scope 					captureVarAt: mess arguments last value sourceTemp: ((TempVar new)								name: (scope captureVarName: mess arguments last value);								index: mess arguments last value;								scope: self;								cantBeCapture)) markWrite					].			^ RBAssignmentNode				variable: (self newVar: var)				value: mess receiver]].	^mess! !!IRDecompiler methodsFor: 'private' stamp: 'ms 6/16/2007 19:41'!simplifyTempAssign: assignment	"If it is a assignment created by the compiler convert it back to its normal form"	| mess |	((mess := assignment value) isMessage and: 	 [mess selector = #wrapInTempHolder and:	  [mess receiver isLiteral: [:v | v isNil]]]	) ifTrue: [		^ nil  "no-op"	].	^ assignment! !!IRDecompiler methodsFor: 'instructions' stamp: 'ajh 3/23/2003 12:47'!goto: seqNum	self stackPush: (RBPseudoGotoNode new destination: seqNum).! !!IRDecompiler methodsFor: 'instructions' stamp: 'ajh 3/20/2003 17:21'!if: bool goto: seqNum1 otherwise: seqNum2	self stackPush: (RBPseudoIfNode new		boolean: bool;		destination: seqNum1;		otherwise: seqNum2)! !!IRDecompiler methodsFor: 'instructions' stamp: 'ms 9/8/2007 03:20'!label: seqNum	stack isEmpty ifTrue: [  "start"		^ stack addLast: (RBPseudoLabelNode new destination: seqNum)].	self captureEmptyStatement.	"Reduce jump structures to one of the following if possible"	[	(self endBlock: seqNum) or: [		 (self endAndOr: seqNum) or: [		  (self endAndOr2: seqNum) or: [		   (self endIfThen: seqNum) or: [		    (self endIfThen2: seqNum) or:[		      (self endIfThenElse: seqNum) or: [		       (self endCase: seqNum) or: [		        (self endToDo: seqNum) or: [		         (self endWhile: seqNum) or: [			     (self endWhile2: seqNum) or: [			      (self endIfNil: seqNum)]]]]]]]]]]	] whileTrue.	stack addLast: (RBPseudoLabelNode new destination: seqNum).! !!IRDecompiler methodsFor: 'instructions' stamp: 'ms 7/11/2007 23:24'!popTop	| value |	stack last ifNil: [^ stack removeLast].  "pop no-op from #simplifyTempAssign:"	[stack last isLabel 		and: [(stack atLast:2) isGoto] 		and: [stack last destination = (stack atLast: 2) destination]]			whileTrue: [				stack removeLast.				stack removeLast].	stack last isValue ifTrue: [		(stack atLast: 2) isSequence ifTrue: [			value := stack removeLast.			^ stack last addNode: value.		] ifFalse: [(stack atLast: 2) isPseudo ifTrue: [			value := stack removeLast.			^ stack addLast: (RBSequenceNode statements: {value}).		]].	].	stack addLast: RBPseudoPopNode new! !!IRDecompiler methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:35'!pushBlock: irMethod	self block: irMethod env: nil! !!IRDecompiler methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:37'!pushBlockMethod: irMethod	"block will recognized when send: #createBlock:"	self pushLiteral: irMethod! !!IRDecompiler methodsFor: 'instructions' stamp: 'ajh 6/22/2003 14:51'!pushDup	stack addLast: RBPseudoDupNode new! !!IRDecompiler methodsFor: 'instructions' stamp: 'ms 7/11/2007 11:14'!pushInstVar: index		self stackPush: (self newVar: (scope instanceScope instVar: index))! !!IRDecompiler methodsFor: 'instructions' stamp: 'ms 9/6/2007 00:16'!pushLiteral: object	self stackPush: (self newLiteral: object).! !!IRDecompiler methodsFor: 'instructions' stamp: 'ms 7/10/2007 18:50'!pushLiteralVariable: object	| var |	var := scope lookupVar: object key asString.	self stackPush: (self newVar: var)! !!IRDecompiler methodsFor: 'instructions' stamp: 'ms 7/30/2007 11:56'!pushTemp: tempIndex	| var |	var := scope basicTempVarAt: tempIndex.	var isTemp ifTrue: [var cantBeCapture].	self stackPush: (self newVar: var).! !!IRDecompiler methodsFor: 'instructions' stamp: 'ajh 6/22/2003 14:27'!remoteReturn	stack removeLast.  "pop home context free var"	self goto: #return.! !!IRDecompiler methodsFor: 'instructions' stamp: 'md 11/12/2004 18:00'!returnTop	self goto: #return.! !!IRDecompiler methodsFor: 'instructions' stamp: 'ms 7/19/2007 15:13'!send: selector	| args rcvr |	selector = #caseError ifTrue:[^self stackPush: (RBPseudoSendNode new selector: selector)].	args := OrderedCollection new.	[	selector numArgs timesRepeat: [args addFirst: self Value].		rcvr := self Value.	] on: Abort do: [		[self stackPush: (RBPseudoSendNode new selector: selector).		^self cascade] on: Abort do:[^false]	].	Preferences compileBlocksAsClosures 			ifTrue: [ (rcvr isLiteral and: [selector = #createBlock:]) ifTrue: [					 ^ self block: rcvr value env: args first]]			ifFalse: [ (selector = #blockCopy:) ifTrue: [					 ^ self stackPush: (RBPseudoSendNode new selector: selector; arguments: args)]].	self stackPush: (self simplify: (RBMessageNode new		receiver: rcvr		selectorParts: (self newSelectorParts: selector)		arguments: args)).! !!IRDecompiler methodsFor: 'instructions' stamp: 'ms 7/10/2007 17:39'!send: selector toSuperOf: behavior	| args rcvr |	args _ OrderedCollection new.	selector numArgs timesRepeat: [args addFirst: self Value].	rcvr _ self Value.	(rcvr isVariable and: [rcvr name = 'self']) ifFalse: [self patternError].	rcvr identifierToken: (SqueakToken value: 'super' start: 0).	self stackPush: (RBMessageNode new		receiver: rcvr		selectorParts: (self newSelectorParts: selector)		arguments: args).! !!IRDecompiler methodsFor: 'instructions' stamp: 'ms 7/13/2007 00:46'!storeIntoLiteralVariable: association	| var |	var := scope lookupVar: association key asString.	self stackPush: (self simplifyTempAssign:		(RBAssignmentNode variable: (self newVar: (var markWrite)) value: self Value))! !!IRDecompiler methodsFor: 'instructions' stamp: 'ms 7/29/2007 01:24'!storeTemp: tempIndex	| var |	var := scope basicTempVarAt: tempIndex.	var isCaptured ifFalse: [var cantBeCapture].	var isTemp ifTrue:[		var isArg: false].	self stackPush: (self simplifyTempAssign:		(RBAssignmentNode variable: (self newVar: (var markWrite)) value: self Value)).! !!IRDecompiler methodsFor: 'interpret' stamp: 'ms 5/2/2007 10:44'!interpretInstruction: irInstruction	currentInstr := irInstruction.	super interpretInstruction: irInstruction.! !!IRDecompiler methodsFor: 'interpret' stamp: 'ms 7/11/2007 01:01'!interpretSequence: instructionSequence	super interpretSequence: instructionSequence.	"currentInstr := nil."! !!IRDecompiler methodsFor: 'accessing' stamp: 'ms 6/15/2007 13:25'!scope	^scope! !!IRDecompiler commentStamp: 'ajh 3/25/2003 00:37' prior: 0!I interpret IRMethod instructions and generate a Smalltalk abstract syntax tree rooted at a RBMethodNode.This is implemented like a shift-reduce parser.  Each instruction either causes a node to be pushed on the stack (shift), or causes one or more nodes to be popped and combined into a single node which is push back on the stack (reduce).  Most reduction is done at the "label: labelNum" instruction where it tries to reduce jump structures into control messages like #ifTrue:, whileFalse:, etc.Several pseudo nodes (RBPseudoNode and subclasses) are used to represent basic instructions that have not been reduced to real AST nodes yet.!!IRDecompiler class methodsFor: 'as yet unclassified' stamp: 'ajh 6/5/2003 12:34'!dummySelector: numArgs	"Answer a dummy selector with number of args"	| sel |	sel _ 'unknown'.	1 to: numArgs do: [:i |		sel _ sel, 'with:'].	^ sel asSymbol! !!IRDecompilerFromImageTest methodsFor: 'utils' stamp: 'ms 9/6/2007 01:26'!assertDecompile: selector from: aClassName	| originalCM ast |	Smalltalk at: aClassName ifPresent: [:class |		class compileAll.		originalCM := class compiledMethodAt: selector ifAbsent:[			self error:'Original compiled method not found in ', class name].		ast := self decompileToAST: selector in: class.		self assert: ast compiledMethod = originalCM]! !!IRDecompilerFromImageTest methodsFor: 'utils' stamp: 'ms 9/6/2007 02:01'!assertDecompile: selector fromClass: aClassName	| originalCM ast |	Smalltalk at: aClassName ifPresent: [:class |		class class compileAll.		originalCM := class class compiledMethodAt: selector ifAbsent:[			self error:'Original compiled method not found in ', class class name].		ast := self decompileToAST: selector in: class class.		self assert: ast compiledMethod = originalCM]! !!IRDecompilerFromImageTest methodsFor: 'utils' stamp: 'ms 9/6/2007 01:18'!decompileToAST: aSelector in: aClass	| ir ird |	ir := (aClass compiledMethodAt: aSelector) ir.	ird := IRDecompiler new.	ird scope: aClass parseScope newMethodScope.	^ird decompileIR: ir.! !!IRDecompilerFromImageTest methodsFor: 'tests' stamp: 'ms 9/6/2007 20:46'!testBlockClosureTestExempleClosure	self assertDecompile: #exempleClosure from: #BlockClosureTest ! !!IRDecompilerFromImageTest methodsFor: 'tests' stamp: 'ms 9/6/2007 11:41'!testBrowserRenameCategory	self assertDecompile: #renameCategory from: #Browser ! !!IRDecompilerFromImageTest methodsFor: 'tests' stamp: 'ms 9/8/2007 02:50'!testClassSharing	self assertDecompile: #sharing: from: #Class ! !!IRDecompilerFromImageTest methodsFor: 'tests' stamp: 'ms 9/8/2007 03:01'!testColor	self assertDecompile: #alpha from: #Color ! !!IRDecompilerFromImageTest methodsFor: 'tests' stamp: 'ms 9/7/2007 22:09'!testECVarTypeGuesserGetClassFromTypeSuggestingName	self assertDecompile: #getClassFromTypeSuggestingName: fromClass: #ECVarTypeGuesser ! !!IRDecompilerFromImageTest methodsFor: 'tests' stamp: 'ms 9/8/2007 14:57'!testFloatClassNan	self assertDecompile: #nan fromClass: #Float ! !!IRDecompilerFromImageTest methodsFor: 'tests' stamp: 'ms 9/7/2007 19:42'!testInstructionCompaireCompaireWith	self assertDecompile: #compaireWith: from: #InstructionCompaire ! !!IRDecompilerFromImageTest methodsFor: 'tests' stamp: 'ms 9/6/2007 01:29'!testIntegerDiv	self assertDecompile: #// from: #Integer ! !!IRDecompilerFromImageTest methodsFor: 'tests' stamp: 'ms 9/8/2007 15:36'!testMCConfigurationDepsSatisfyingVersionDoDisplayingProgress	self assertDecompile: #depsSatisfying:versionDo:displayingProgress: from: #MCConfiguration ! !!IRDecompilerFromImageTest methodsFor: 'tests' stamp: 'ms 9/6/2007 01:30'!testParagraphEditorSelectWord	self assertDecompile: #selectWord from: #ParagraphEditor ! !!IRDecompilerFromImageTest methodsFor: 'tests' stamp: 'ms 9/6/2007 02:00'!testProjectClassSweep	self assertDecompile: #sweep: fromClass: #Project ! !!IRDecompilerFromImageTest methodsFor: 'tests' stamp: 'ms 9/6/2007 01:30'!testStringWithSeparatorsCompacted	self assertDecompile: #withSeparatorsCompacted from: #String ! !!IRDecompilerTest methodsFor: 'utils' stamp: 'ms 6/14/2007 22:42'!assertSameCompiledMethod: aSelector	| ir1 src ird ir2 |	src :=  self class sourceCodeAt: aSelector.	ir1 := (ClosureCompiler new parseClosure: src in: self class notifying: nil) ir.	ir2 := (ClosureCompiler new parseClosure: src in: self class notifying: nil) ir.	ird := IRDecompiler new.	ird scope: self class parseScope newMethodScope.	self assert: (ird decompileIR: ir1) compiledMethod = ir2 compiledMethod! !!IRDecompilerTest methodsFor: 'utils' stamp: 'ms 9/6/2007 01:16'!decompileToAST: aSelector	| ir ird |	ir := (self class compiledMethodAt: aSelector) ir.	ird := IRDecompiler new.	ird scope: self class parseScope newMethodScope.	^ird decompileIR: ir.! !!IRDecompilerTest methodsFor: 'utils' stamp: 'ms 7/13/2007 00:49'!decompileToASTClass: aSelector	| ir ird |		ir := (self class class compiledMethodAt: aSelector) ir.	ird := IRDecompiler new.	ird scope: self class class parseScope newMethodScope.	^ird decompileIR: ir.! !!IRDecompilerTest methodsFor: 'utils' stamp: 'ms 7/13/2007 00:41'!setUp		ivarA := 10.	ivarB := 11.	ClassVar := 17.	self class compileAll.	self class class compileAll! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:35'!exampleAndAndAndAndFalse	^1 = 1 and: [ 2 = 2 ] and: [3 = 3] and: [4 = 4] and: [6 = 5]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:36'!exampleAndAndAndAndTrue	^1 = 1 and: [ 2 = 2 ] and: [3 = 3] and: [4 = 4] and: [5 = 5]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:35'!exampleAndAndAndFalse	^1 = 1 and: [ 2 = 2 ] and: [3 = 3] and: [5 = 4]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:35'!exampleAndAndAndTrue	^1 = 1 and: [ 2 = 2 ] and: [3 = 3] and: [4 = 4]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:37'!exampleAndAndFalse	^1 = 1 and: [ 2 = 2 ] and: [4 = 3]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:33'!exampleAndAndTrue	^1 = 1 and: [ 2 = 2 ] and: [3 = 3]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:32'!exampleAndFalse	^1 = 1 and: [ 3 = 2 ]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:32'!exampleAndTrue	^1 = 1 and: [ 2 = 2 ]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/20/2007 11:46'!exampleArrayNode	^{3 + 4. 7. 6 gcd: 3}! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:42'!exampleAssignment1		| a |	a := 3.	^a! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:43'!exampleAssignment2		| a b |	b := a := 3.	^a + b! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 5/16/2007 19:19'!exampleBinaryMessage	^(3 @ 4 + 3) * 7! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/15/2007 11:55'!exampleBlockAgrument	^[:a| | b | 		b := 3.		a + b].! !!IRDecompilerTest methodsFor: 'examples' stamp: 'md 11/15/2004 16:08'!exampleBlockParam	^[:a| a].! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/16/2007 21:31'!exampleBlockReturn: a 	| ttttt |	ttttt := $d.	[:t | ^ ttttt] value: 2! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/1/2007 20:04'!exampleBlockSelf	"IRDecompilerTest>>#exampleBlockSelf"	^[self].! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/30/2007 14:00'!exampleCaptureArg: a		^[:each | a + each] value: 4! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 8/8/2007 19:56'!exampleCaptureNestedTemp		| a b |	b := 2.	[:s | [ a := s.	b := a + 3 + b] value] value: 2.	^b! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 8/8/2007 00:38'!exampleCaptureTemp		| a b |	b := 2.	[a := 2.	b := a + 3 + b] value.	^b! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/20/2007 01:16'!exampleCascade	^OrderedCollection new add: 3; add: 4; sum! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/12/2007 13:17'!exampleCaseOf	3 caseOf: {		[4] -> [3].		[3] -> [^7]	}.	^4! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/12/2007 13:27'!exampleCaseOf2	3 caseOf: {		[4] -> [^3].		[3] -> [^7]	}! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/12/2007 13:30'!exampleCaseOf3	3 caseOf: {		[4] -> [^3].		[3] -> [^7]	} otherwise: [1]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/12/2007 13:31'!exampleCaseOf4	3 caseOf: {		[4] -> [^3].		[3] -> [^7]	} otherwise: [^1]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/13/2007 16:59'!exampleCaseOf5	| a |	5 caseOf: {		[4] -> [^3].		[3] -> [^7]	} otherwise: [a := 7 + 4].	^a! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/19/2007 11:28'!exampleCaseOf6	3 caseOf: {		[4] -> [ivarA := 3].		[3] -> [ivarA := 7]	} otherwise: [].! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/19/2007 12:36'!exampleCaseOf7	3 caseOf: {		[4] -> [ivarA := 3].		[3] -> [ivarA := 7]	} otherwise: [].	ivarB := 7.	#(1 2 3) collect: [:each | each].! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/13/2007 00:40'!exampleClassVar	ClassVar := 7! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/11/2007 00:51'!exampleDo	| a |	a := 0.	#(4 3) do: [:each | a := each + a ].	^a! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/11/2007 00:53'!exampleDo2	| a |	a := 0.	#(4 3) do: [:each | [:e | a := e + a] value: each].	^a! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/11/2007 00:56'!exampleDo3	| a |	a := 0.	#(4 3 2 1) do: [:each | each >= 3 ifTrue: [a := each + a]].	^a! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/11/2007 00:57'!exampleDo4	| a |	a := 3.	#(4 3 2 1) do: [:each | each >= 3 ifTrue: [^a := each + a]]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/11/2007 01:40'!exampleDo5	| a |	a := 3.	#(4 3 2 1) do: [:each | each < 4 ifFalse: [^a := each + a]]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/10/2007 18:36'!exampleGlobalVar	^Smalltalk allClasses size! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/11/2007 11:04'!exampleIf	^ true ifTrue: [4 + 3].! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/11/2007 11:06'!exampleIf2	false ifFalse: [^4 + 3].	^8! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/14/2007 20:50'!exampleIf3	[false ifFalse: [false ifFalse: [^7]]] value.	^8! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/15/2007 22:55'!exampleIfNil		^nil ifNil:[7]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/19/2007 18:44'!exampleIfNil2		| a |	a := nil ifNil:[6].	a factorial.	^a + 1! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/23/2007 17:08'!exampleIfNil3			| a |	#(1 2 3) do: [:each | nil ifNil: [a := 7]].	^a! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/15/2007 23:19'!exampleIfNilIfNotNil		^nil ifNil:[7] ifNotNil: [3]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/24/2007 11:57'!exampleIfNilIfNotNil2		| f |	 f:= nil ifNil:[7] ifNotNil: [].	^f - 1 + 1! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/11/2007 11:25'!exampleIfThen	^ true ifTrue: [4 + 3] ifFalse: [8].! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/11/2007 11:29'!exampleIfThen2	| a |	a := 7.	^ true ifTrue: [a] ifFalse: [8].! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/11/2007 11:51'!exampleIfThen3	| a |	a := (3 + 4) asInteger.	^ (a = 7) ifTrue: [		#(1 2  3 4) do: [:each | ivarA - each].		a factorial] ifFalse: [#(1 2  3 4) do: [:each | ivarA - each]. 9].! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/11/2007 16:33'!exampleIfThen3: g	| a |	a := g asInteger.	7 asInteger = 7 		ifTrue: [			ivarA factorial] 		ifFalse: [			ivarA factorial].! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/19/2007 15:49'!exampleIfThen4	#(1 2 3 ) do: [:each |		true ifTrue:[ivarA := 7]		].	^7! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 9/4/2007 02:01'!exampleIfWhile	| b |	[false ifFalse:[true ifTrue: [b := 4 + 3. false]		ifFalse:[false]]] whileTrue.	^b! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/12/2007 16:00'!exampleKeywordMessage	"IRDecompilerTest >>#exampleKeywordMessage"	^((1 to: 4) collect: [:each | each * 3]) inject: 0 into: [:sum :elem | sum + elem]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 23:32'!exampleNestedBlock1	^ 	[:a | 	| b |	b := 3.	a value + b] 			value: [				[| a |				a := 2 + 2.				a] value]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/3/2007 15:31'!exampleNestedBlock2	"IRDecompilerTest >> # exampleNestedBlock2"	^ 	[:a | 	| b |	b := 3.	a value + b] 		value: [ | c|			c := 2.				[| a |				a := 1 + c.				[| d | 				d := 1.				d + a] value] value]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/26/2007 01:30'!exampleNestedBlock3	| b c |	b := [:a | 2 + a].	c := [:a | 3 + a].	^ (b value: 1) + (c value: 1)! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/1/2007 20:36'!exampleNestedBlock4	"IRDecompilerTest>>#exampleNestedBlock4"	| b c |	b := [:a | | z |			z := 2.			z + a].	c := [:a | | z |		 	z := 3.				z + a].	^ (b value: 1) + (c value: 1)! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/26/2007 01:35'!exampleNestedBlock5	| b c z |	b := [:a | 			z := 2.			z + a].	c := [:a |			z + a].	^ (b value: 2) + (c value: 1)! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/12/2007 22:44'!exampleNestedBlock6	ivarA := 0.	#(4 7) do: [:each |		[ivarA < each] whileTrue: [ivarA := ivarA + 1].		ivarA isInteger ifFalse: [self halt]		]	! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:38'!exampleOrFalse	^2 = 1 or: [ 3 = 2 ]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/15/2007 01:53'!exampleOrIfNil		^Array with: (false or: [nil ifNil:[true]])! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:38'!exampleOrOrFalse	^2 = 1 or: [ 3 = 2 ] or: [4 = 3]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:39'!exampleOrOrOrFalse	^2 = 1 or: [ 3 = 2 ] or: [4 = 3] or: [5 = 4]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:39'!exampleOrOrOrOrFalse	^2 = 1 or: [ 3 = 2 ] or: [4 = 3] or: [5 = 4] or: [6 = 5]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:39'!exampleOrOrOrOrTrue	^2 = 1 or: [ 3 = 2 ] or: [4 = 3] or: [5 = 4] or: [5 = 5]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:39'!exampleOrOrOrTrue	^2 = 1 or: [ 3 = 2 ] or: [4 = 3] or: [4 = 4]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:38'!exampleOrOrTrue	^2 = 1 or: [ 3 = 2 ] or: [3 = 3]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/17/2007 15:37'!exampleOrTrue	^1 = 1 or: [ 3 = 2 ]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/20/2007 01:25'!examplePushConstant	^ 7! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/11/2007 11:09'!examplePushInstVar	^ivarA factorial! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/11/2007 11:12'!examplePushInstVar2	^[ivarA factorial] value! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 6/20/2007 01:22'!examplePushLiteral	^OrderedCollection new! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 5/2/2007 10:38'!exampleQuickFalse	^false! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 5/2/2007 16:48'!exampleQuickIVarA	"IRDecompilerTest>>#exampleQuickIVarA"	^ivarA! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 5/2/2007 16:49'!exampleQuickIVarB	"IRDecompilerTest>>#exampleQuickIVarB"	^ivarB! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 5/2/2007 16:41'!exampleQuickMinusOne	"IRDecompilerTest>>#exampleQuickMinusOne"	^-1! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 5/2/2007 10:38'!exampleQuickNil	^nil! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 5/2/2007 16:40'!exampleQuickOne	"IRDecompilerTest>>#exampleQuickOne"	^1! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 5/2/2007 10:39'!exampleQuickSelf	^self! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 5/2/2007 10:39'!exampleQuickTrue	^true! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 5/2/2007 16:39'!exampleQuickTwo	^2! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 5/2/2007 16:47'!exampleQuickZero	"IRDecompilerTest>>#exampleQuickZero"	^0! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/10/2007 19:02'!exampleSelfInBlock		^[self class] value! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/13/2007 01:19'!exampleSend		| a b |	a := #(3 4) inject: 0 into: [:p :s | p + s].	b := #(3 4) inject: 0 into: [:p :s | p + s].	^a + b! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 5/2/2007 10:25'!exampleSimpleBlock	^[1]! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/10/2007 17:45'!exampleStorInstVar	^ivarA := 7! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/10/2007 17:34'!exampleSuper	^super class! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/29/2007 02:05'!exampleSuper2		| a |	a := super class new.	self haltIf:[super class ~= a class].	^super class ~= a class! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/14/2007 22:09'!exampleThisContext	[^thisContext] value! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/13/2007 01:31'!exampleToDo	| a |	a := 0.	1 to: 4 do: [:each | a := each + a ].	^a! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 5/16/2007 19:14'!exampleUnaryMessage	^4 factorial! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/15/2007 01:00'!exampleVar		| b |	b := 0.	nil ifNil:[| a |		a := 3.		b := a + b].	[:a | b := b + a] value: 4.	^b! !!IRDecompilerTest methodsFor: 'examples' stamp: 'ms 7/12/2007 22:10'!exampleWhileTrue		| a |	a := 0.	[a < 7] whileTrue: [a := a + 1].	^a! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/2/2007 10:37'!expectedFailures	^#()! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/17/2007 15:34'!testDecompileAnd	"self debug: #testDecompileAnd"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleAndFalse]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = false.		self shouldnt: [ast := self decompileToAST: #exampleAndTrue]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = true! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/17/2007 15:35'!testDecompileAndAnd	"self debug: #testDecompileAnd"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleAndAndFalse]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = false.		self shouldnt: [ast := self decompileToAST: #exampleAndAndTrue]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = true! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/17/2007 15:36'!testDecompileAndAndAnd	"self debug: #testDecompileAnd"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleAndAndAndFalse]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = false.		self shouldnt: [ast := self decompileToAST: #exampleAndAndAndTrue]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = true! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/17/2007 15:36'!testDecompileAndAndAndAnd	"self debug: #testDecompileAnd"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleAndAndAndAndFalse]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = false.		self shouldnt: [ast := self decompileToAST: #exampleAndAndAndAndTrue]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = true! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/26/2007 01:26'!testDecompileArrayNode	"self debug: #testDecompileArrayNode"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleArrayNode]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = #(7 7 3)! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/17/2007 15:43'!testDecompileAssignment1	"self debug: #testDecompileAssignment1"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleAssignment1]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = 3! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/17/2007 15:43'!testDecompileAssignment2	"self debug: #testDecompileAssignment1"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleAssignment2]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = 6! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/16/2007 19:20'!testDecompileBinaryMessage	| ast |	self shouldnt:[ast := self decompileToAST: #exampleBinaryMessage] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) = (42@49). 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/2/2007 16:34'!testDecompileBlock	| ast  |	self shouldnt:[ast := self decompileToAST: #exampleSimpleBlock] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) value = 1. ! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/16/2007 21:31'!testDecompileBlockArgument	"self debug: #testDecompileBlockParam"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleBlockAgrument]		raise: Error.	self assert: ((ast compiledMethod valueWithReceiver: nil arguments: #()) value: 4) = 7! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/2/2007 16:34'!testDecompileBlockParam	"self debug: #testDecompileBlockParam"	| ast |		self shouldnt:[ast := self decompileToAST: #exampleBlockParam] raise: Error.	self assert: ((ast compiledMethod valueWithReceiver: nil arguments: #()) value: 2) = 2. ! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/10/2007 13:25'!testDecompileBlockReturn	"self debug: #testDecompileBlockParam"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleBlockReturn:]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #(3 )) = $d! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/2/2007 16:34'!testDecompileBlockSelf	| ast |	self shouldnt:[ast := self decompileToAST: #exampleBlockSelf] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) value = self. ! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/30/2007 14:01'!testDecompileCaptureArg	| ast |	self shouldnt:[ast := self decompileToAST: #exampleCaptureArg:] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #(3)) == 7 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 8/8/2007 20:05'!testDecompileCaptureNestedTemp	| ast |	self shouldnt: [ast := self decompileToAST: #exampleCaptureNestedTemp] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = 7! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 8/8/2007 00:38'!testDecompileCaptureTemp	| ast |	self shouldnt: [ast := self decompileToAST: #exampleCaptureTemp] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = 7! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/20/2007 01:16'!testDecompileCascade	| ast |	self shouldnt:[ast := self decompileToAST: #exampleCascade] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/12/2007 13:00'!testDecompileCaseOf	"self debug: #testDecompileCaseOf"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleCaseOf]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7 ! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/12/2007 13:27'!testDecompileCaseOf2	"self debug: #testDecompileCaseOf2"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleCaseOf2]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7 ! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/12/2007 13:32'!testDecompileCaseOf3	"self debug: #testDecompileCaseOf3"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleCaseOf3]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7 ! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/12/2007 13:32'!testDecompileCaseOf4	"self debug: #testDecompileCaseOf4"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleCaseOf4]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7 ! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/13/2007 17:00'!testDecompileCaseOf5	"self debug: #testDecompileCaseOf5"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleCaseOf5]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 11 ! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/19/2007 11:27'!testDecompileCaseOf6	"self debug: #testDecompileCaseOf6"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleCaseOf6]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == self.	self assert: ivarA == 7! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/19/2007 12:37'!testDecompileCaseOf7	"self debug: #testDecompileCaseOf6"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleCaseOf7]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == self.	self assert: ivarA == 7.	self assert: ivarB == 7! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/13/2007 00:50'!testDecompileClassClassVar	"self debug: #testDecompileCaseOf4"	| ast |	self shouldnt: [ast := self decompileToASTClass: #exampleClassVar]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self class arguments: #()) == self class.	self assert: ClassVar == 7! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/13/2007 00:43'!testDecompileClassVar	"self debug: #testDecompileCaseOf4"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleClassVar]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == self.	self assert: ClassVar == 7! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/11/2007 00:51'!testDecompileDo	| ast |	self shouldnt:[ast := self decompileToAST: #exampleDo] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/11/2007 00:53'!testDecompileDo2	| ast |	self shouldnt:[ast := self decompileToAST: #exampleDo2] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/11/2007 00:56'!testDecompileDo3	| ast |	self shouldnt:[ast := self decompileToAST: #exampleDo3] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/11/2007 00:58'!testDecompileDo4	| ast |	self shouldnt:[ast := self decompileToAST: #exampleDo4] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/11/2007 01:40'!testDecompileDo5	| ast |	self shouldnt:[ast := self decompileToAST: #exampleDo5] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/10/2007 18:37'!testDecompileGlobalVar	"self debug: #testDecompileGlobalVar"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleGlobalVar]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = Smalltalk allClasses size! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/11/2007 11:05'!testDecompileIf2	| ast |	self shouldnt:[ast := self decompileToAST: #exampleIf2] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) = 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/14/2007 20:45'!testDecompileIf3	| ast |	self shouldnt:[ast := self decompileToAST: #exampleIf3] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) = 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/15/2007 22:55'!testDecompileIfNil	| ast |	self shouldnt:[ast := self decompileToAST: #exampleIfNil] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/19/2007 18:45'!testDecompileIfNil2	| ast |	self shouldnt:[ast := self decompileToAST: #exampleIfNil2] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/19/2007 18:46'!testDecompileIfNil3	| ast |	self shouldnt:[ast := self decompileToAST: #exampleIfNil3] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/15/2007 23:20'!testDecompileIfNilIfNotNil	| ast |	self shouldnt:[ast := self decompileToAST: #exampleIfNilIfNotNil] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/15/2007 23:24'!testDecompileIfNilIfNotNil2	| ast |	self shouldnt:[ast := self decompileToAST: #exampleIfNilIfNotNil2] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/11/2007 11:25'!testDecompileIfThen	| ast |	self shouldnt:[ast := self decompileToAST: #exampleIfThen] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) = 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/11/2007 11:32'!testDecompileIfThen2	| ast |	self shouldnt:[ast := self decompileToAST: #exampleIfThen2] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) = 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/11/2007 11:51'!testDecompileIfThen3	| ast |	self shouldnt: [ast := self decompileToAST: #exampleIfThen3] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) = 7 factorial! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/11/2007 11:58'!testDecompileIfThen3Arg	| ast |	self shouldnt: [ast := self decompileToAST: #exampleIfThen3:] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #(7)) = self! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/19/2007 15:50'!testDecompileIfThen4	| ast |	self shouldnt: [ast := self decompileToAST: #exampleIfThen4] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) = 7.	self assert: ivarA == 7! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/13/2007 01:04'!testDecompileIfTrue	| ast |	self shouldnt:[ast := self decompileToAST: #exampleIf] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) = 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 9/4/2007 02:03'!testDecompileIfWhile	| ast |	self shouldnt: [ast := self decompileToAST: #exampleIfWhile]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = 7! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/10/2007 12:13'!testDecompileKeywordMessage	| ast |	self shouldnt:[ast := self decompileToAST: #exampleKeywordMessage] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 30. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/17/2007 23:39'!testDecompileNestedBlock1	"self debug: #testDecompileNestedBlock1"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleNestedBlock1]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = 7! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/17/2007 23:39'!testDecompileNestedBlock2	"self debug: #testDecompileNestedBlock1"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleNestedBlock2]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = 7! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/26/2007 01:32'!testDecompileNestedBlock3	"self debug: #testDecompileNestedBlock3"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleNestedBlock3]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = 7! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/26/2007 03:05'!testDecompileNestedBlock4	"self debug: #testDecompileNestedBlock4"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleNestedBlock4]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = 7! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/26/2007 02:14'!testDecompileNestedBlock5	"self debug: #testDecompileNestedBlock5"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleNestedBlock5]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = 7! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/12/2007 22:30'!testDecompileNestedBlock6	"self debug: #testDecompileNestedBlock6"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleNestedBlock6]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == self.	self assert: ivarA == 7! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/17/2007 15:40'!testDecompileOr	"self debug: #testDecompileAnd"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleOrFalse]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = false.		self shouldnt: [ast := self decompileToAST: #exampleOrTrue]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = true! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/15/2007 23:32'!testDecompileOrIfNil	| ast |	self shouldnt:[ast := self decompileToAST: #exampleOrIfNil] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) = #(true). 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/17/2007 15:40'!testDecompileOrOr	"self debug: #testDecompileAnd"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleOrOrFalse]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = false.		self shouldnt: [ast := self decompileToAST: #exampleOrOrTrue]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = true! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/17/2007 15:40'!testDecompileOrOrOr	"self debug: #testDecompileAnd"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleOrOrOrFalse]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = false.		self shouldnt: [ast := self decompileToAST: #exampleOrOrOrTrue]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = true! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/17/2007 15:40'!testDecompileOrOrOrOr	"self debug: #testDecompileAnd"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleOrOrOrOrFalse]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = false.		self shouldnt: [ast := self decompileToAST: #exampleOrOrOrOrTrue]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = true! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/20/2007 01:26'!testDecompilePushConstant	| ast |	self shouldnt:[ast := self decompileToAST: #examplePushConstant] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/11/2007 11:11'!testDecompilePushInstVar	"self debug: #testDecompilePushInstVar"	| ast |	self shouldnt: [ast := self decompileToAST: #examplePushInstVar] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) = 3628800.! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/11/2007 11:13'!testDecompilePushInstVar2	"self debug: #testDecompilePushInstVar"	| ast |	self shouldnt: [ast := self decompileToAST: #examplePushInstVar2] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) = 3628800.! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 6/20/2007 01:22'!testDecompilePushLiteral	| ast |	self shouldnt:[ast := self decompileToAST: #examplePushLiteral] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) class == OrderedCollection. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/2/2007 16:43'!testDecompileQuickFalse	| ast |	self shouldnt:[ast := self decompileToAST: #exampleQuickFalse] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == false. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/2/2007 16:50'!testDecompileQuickIVar	| ast |	self shouldnt:[ast := self decompileToAST: #exampleQuickIVarA] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 10. 		self shouldnt:[ast := self decompileToAST: #exampleQuickIVarB] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 11. ! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/2/2007 16:43'!testDecompileQuickMinusOne	| ast |	self shouldnt:[ast := self decompileToAST: #exampleQuickMinusOne] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == -1. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/2/2007 16:44'!testDecompileQuickNil	| ast |	self shouldnt:[ast := self decompileToAST: #exampleQuickNil] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == nil. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/2/2007 16:44'!testDecompileQuickOne	| ast |	self shouldnt:[ast := self decompileToAST: #exampleQuickOne] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 1. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/2/2007 16:43'!testDecompileQuickSelf	| ast |	self shouldnt:[ast := self decompileToAST: #exampleQuickSelf] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == self. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/2/2007 16:44'!testDecompileQuickTrue	| ast |	self shouldnt:[ast := self decompileToAST: #exampleQuickTrue] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == true. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/2/2007 16:44'!testDecompileQuickTwo	| ast |	self shouldnt:[ast := self decompileToAST: #exampleQuickTwo] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 2. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/2/2007 16:44'!testDecompileQuickZero	| ast |	self shouldnt:[ast := self decompileToAST: #exampleQuickZero] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 0. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/10/2007 19:03'!testDecompileSelfInBlock	"self debug: #testDecompileAssignment1"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleSelfInBlock]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == IRDecompilerTest ! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/13/2007 01:22'!testDecompileSend	"self debug: #testDecompileSend"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleSend] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) = 14! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/10/2007 17:45'!testDecompileStorInstVar	"self debug: #testDecompileBlockParam"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleStorInstVar]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) = 7.	self assert: ivarA = 7! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/29/2007 02:05'!testDecompileSuper	"self debug: #testDecompileSuper"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleSuper]		raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) = IRDecompilerTest! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/29/2007 02:41'!testDecompileSuper2	"self debug: #testDecompileSuper2"	| ast |	self shouldnt: [ast := self decompileToAST: #exampleSuper2] raise: Error.	self deny: (ast compiledMethod valueWithReceiver: self arguments: #())! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/14/2007 22:11'!testDecompileThisContext	"self debug: #testDecompileThisContext"	| ast |		self shouldnt:[ast := self decompileToAST: #exampleThisContext] raise: Error.	self assert: ((ast compiledMethod valueWithReceiver: nil arguments: #()) isKindOf: ContextPart). ! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/13/2007 01:32'!testDecompileToDo	| ast |	self shouldnt:[ast := self decompileToAST: #exampleToDo] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 10. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 5/16/2007 19:14'!testDecompileUnaryMessage	| ast |	self shouldnt:[ast := self decompileToAST: #exampleUnaryMessage] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 24. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/15/2007 01:00'!testDecompileVar	| ast |	self shouldnt:[ast := self decompileToAST: #exampleVar] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7. 	! !!IRDecompilerTest methodsFor: 'testing' stamp: 'ms 7/12/2007 22:08'!testDecompileWhileTrue	| ast |	self shouldnt:[ast := self decompileToAST: #exampleWhileTrue] raise: Error.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) == 7. 	! !!IRDecompilerTest commentStamp: '<historical>' prior: 0!This class tests decompilation if IR Nodes to RB Nodes (class IRDecompiler) !!IRDecompilerTest class methodsFor: 'tests' stamp: 'ms 7/13/2007 00:47'!exampleClassVar	ClassVar := 7! !!IRDup methodsFor: 'interpret' stamp: 'ajh 3/10/2003 00:46'!executeOn: interpreter	^ interpreter pushDup! !!IRDup commentStamp: 'ajh 3/24/2003 23:56' prior: 0!Instruction "pushDup"!!IRInstVarAccess methodsFor: 'testing' stamp: 'md 6/13/2005 11:10'!isInstVarAccess	^true.! !!IRInstVarAccess methodsFor: 'testing' stamp: 'md 3/6/2006 09:14'!varname	name ifNil: [name := self method compiledMethod methodClass allInstVarNames at: self offset].	^name.! !!IRInstVarAccess commentStamp: 'md 11/10/2004 16:07' prior: 0!when closures disabled, Field describes an instVar. With closures, it describes a fieldaccess with receiver to be accessed pushed first.!!IRInstVarRead methodsFor: 'interpret' stamp: 'md 6/14/2005 15:02'!executeOn: interpreter	Preferences compileBlocksAsClosures 		ifFalse: [ interpreter pushInstVar: number] 		ifTrue: [  interpreter pushLiteral: number.				  interpreter send: #privGetInstVar:. ]! !!IRInstVarRead methodsFor: 'testing' stamp: 'md 6/13/2005 11:24'!isRead	^true.! !!IRInstVarRead methodsFor: 'testing' stamp: 'md 6/13/2005 11:24'!isStore	^false.! !!IRInstVarStore methodsFor: 'interpret' stamp: 'md 6/14/2005 15:04'!executeOn: interpreter	Preferences compileBlocksAsClosures 		ifFalse: [interpreter storeInstVar: number] 		ifTrue: [interpreter pushLiteral: number.				interpreter send: #privStoreIn:instVar:].		! !!IRInstVarStore methodsFor: 'testing' stamp: 'md 6/13/2005 11:25'!isRead	^false! !!IRInstVarStore methodsFor: 'testing' stamp: 'md 6/13/2005 11:25'!isStore	^true! !!IRInstruction methodsFor: 'adding' stamp: 'md 7/9/2005 22:41'!addInstructionsAfter: aCollection	sequence addInstructions: aCollection after: self.! !!IRInstruction methodsFor: 'adding' stamp: 'md 7/9/2005 22:41'!addInstructionsBefore: aCollection	sequence addInstructions: aCollection before: self.! !!IRInstruction methodsFor: 'mapping' stamp: 'ajh 3/13/2003 13:07'!bytecodeIndex	^ bytecodeIndex! !!IRInstruction methodsFor: 'mapping' stamp: 'ajh 3/13/2003 13:14'!bytecodeIndex: index	bytecodeIndex _ index! !!IRInstruction methodsFor: 'mapping' stamp: 'md 9/1/2005 21:18'!bytecodeOffset	| startpc |	startpc := self method compiledMethod initialPC.	self bytecodeIndex ifNil: [^startpc].	^self bytecodeIndex + startpc - 1.! !!IRInstruction methodsFor: 'mapping' stamp: 'ajh 3/6/2003 14:32'!sourceNode	^ sourceNode	! !!IRInstruction methodsFor: 'mapping' stamp: 'ajh 3/6/2003 14:32'!sourceNode: parseNode	sourceNode _ parseNode	! !!IRInstruction methodsFor: 'replacing' stamp: 'md 7/9/2005 22:41'!delete	sequence isNil ifTrue: [self error: 'This node doesn''t have a sequence'].	sequence remove: self.! !!IRInstruction methodsFor: 'replacing' stamp: 'md 10/11/2004 15:56'!replaceNode: aNode withNode: anotherNode 	self error: 'I don''t store other nodes'! !!IRInstruction methodsFor: 'replacing' stamp: 'md 7/9/2005 22:41'!replaceWith: aNode	sequence isNil ifTrue: [self error: 'This node doesn''t have a sequence'].	sequence replaceNode: self withNode: aNode! !!IRInstruction methodsFor: 'replacing' stamp: 'md 7/9/2005 22:41'!replaceWithInstructions: aCollection 	sequence isNil ifTrue: [self error: 'This node doesn''t have a sequence'].	sequence replaceNode: self withNodes: aCollection! !!IRInstruction methodsFor: 'interpret' stamp: 'ajh 3/6/2003 14:32'!executeOn: interpreter	"Send approriate message to interpreter"	self subclassResponsibility! !!IRInstruction methodsFor: 'testing' stamp: 'md 10/9/2004 20:14'!isBlockReturnTop	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 11/26/2004 15:35'!isConstant	^ false! !!IRInstruction methodsFor: 'testing' stamp: 'ajh 3/10/2003 16:12'!isConstant: valueTest	^ false! !!IRInstruction methodsFor: 'testing' stamp: 'ajh 3/11/2003 00:19'!isGoto	"is unconditional jump"	^ false! !!IRInstruction methodsFor: 'testing' stamp: 'ajh 3/11/2003 00:21'!isIf	^ false! !!IRInstruction methodsFor: 'testing' stamp: 'abc 1/2/2006 15:41'!isInBlock	| irs |	irs := self method allInstructionsMatching: [:each | each isJumpOverBlock ].	irs detect: [:each | each blockSequence == self sequence ] ifNone: [^false].	^true! !!IRInstruction methodsFor: 'testing' stamp: 'md 6/13/2005 11:10'!isInstVarAccess	^false.! !!IRInstruction methodsFor: 'testing' stamp: 'md 6/13/2005 13:54'!isInstVarRead	^self isInstVarAccess and: [self isRead].! !!IRInstruction methodsFor: 'testing' stamp: 'md 6/13/2005 13:54'!isInstVarStore	^self isInstVarAccess and: [self isStore].! !!IRInstruction methodsFor: 'testing' stamp: 'ajh 3/11/2003 00:22'!isJump	"goto or if"	^ false! !!IRInstruction methodsFor: 'testing' stamp: 'ajh 3/10/2003 16:13'!isJumpOrReturn	^ self isJump or: [self isReturn]! !!IRInstruction methodsFor: 'testing' stamp: 'abc 1/2/2006 15:14'!isJumpOverBlock	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 10/4/2005 16:52'!isLiteralVariable	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 10/4/2005 16:53'!isLiteralVariableAccess	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 10/4/2005 16:53'!isLiteralVariableRead	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 10/4/2005 16:53'!isLiteralVariableStore	^false! !!IRInstruction methodsFor: 'testing' stamp: 'ms 7/10/2007 14:12'!isPop	^ false! !!IRInstruction methodsFor: 'testing' stamp: 'ajh 3/10/2003 16:09'!isReturn	^ false! !!IRInstruction methodsFor: 'testing' stamp: 'md 2/26/2005 16:22'!isSelf	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 11/12/2004 15:57'!isSend	^false.! !!IRInstruction methodsFor: 'testing' stamp: 'md 2/22/2005 11:28'!isTemp	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 6/13/2005 11:05'!isTempAccess	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 4/28/2005 14:26'!isTempRead	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 4/28/2005 14:26'!isTempStore	^false! !!IRInstruction methodsFor: 'accessing' stamp: 'md 7/9/2005 22:42'!method	^sequence method.! !!IRInstruction methodsFor: 'accessing' stamp: 'md 7/9/2005 22:38'!sequence	^sequence! !!IRInstruction methodsFor: 'accessing' stamp: 'md 7/9/2005 22:39'!sequence: aSeq	sequence := aSeq! !!IRInstruction methodsFor: 'accessing' stamp: 'ajh 3/6/2003 14:32'!successorSequences	"sent to last instruction in sequence which is expected to be a jump and return instruction"	^ #()! !!IRInstruction commentStamp: 'ajh 6/27/2004 23:02' prior: 0!I am an instruction in the IR (intermediate representation) language.  The IR serves as the intermediary between the Smalltalk language and the bytecode language.  It is easier to optimize and translate to/from this language than it is to optimize/translate directly from Smalltalk to bytecodes.  The IR is generic and simple consisting of just twelve instructions.  They are:	goto: labelNum	if: boolean goto: labelNum1 otherwise: labelNum2	label: labelNum	popTop	pushDup	pushLiteral: object	pushBlock: irMethod	pushBlockMethod: irMethod	pushTemp: tempIndex	remoteReturn	returnTop	send: selector	send: selector toSuperOf: behavior	storeTemp: tempIndexEach instruction is reified as an instance of one of my eight subclasses and grouped by basic block (IRSequence) into an IRMethod.  IRInterpreter visits each instruction in a IRMethod responding to the above instruction messages sent to it.!!IRInstruction class methodsFor: 'instance creation - old style blocks' stamp: 'md 10/8/2004 16:05'!blockReturnTop	^ IRBlockReturnTop new		! !!IRInstruction class methodsFor: 'instance creation - old style blocks' stamp: 'md 8/10/2005 11:03'!jumpOverBlock: block to: cont	^ (IRJumpOverBlock new)				blockSequence: block;				destination: cont.! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 3/10/2003 01:07'!goto: seq	^ IRJump new		destination: seq! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 3/10/2003 01:07'!if: bool goto: seq1 otherwise: seq2	^ IRJumpIf new		boolean: bool;		destination: seq1;		otherwise: seq2! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 6/29/2005 16:47'!new	^super basicNew.! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 3/10/2003 01:07'!popTop	^ IRPop new! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 6/27/2004 22:58'!pushBlock: irMethod	^ IRConstant new		constant: irMethod;		type: #block! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 6/27/2004 21:40'!pushBlockMethod: irMethod	^ IRConstant new		constant: irMethod;		type: #blockMethod! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 3/10/2003 01:08'!pushDup	^ IRDup new! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 6/13/2005 13:58'!pushInstVar: index	^ IRInstVarRead new number: index.! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 3/10/2003 01:08'!pushLiteral: object	^ IRConstant new		constant: object! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 7/9/2005 21:20'!pushLiteralVariable: object	^ IRLiteralVariableRead new		association: object.	 ! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 4/21/2005 11:38'!pushReceiver	^IRInstruction pushTemp: 0! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 6/12/2005 18:22'!pushTemp: index	^ IRTempRead new		number: index.! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 4/21/2005 12:06'!pushThisContext	^IRInstruction pushTemp: -2! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 3/10/2003 01:08'!remoteReturn	^ IRReturn new		isRemote: true! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 3/10/2003 01:08'!returnTop	^ IRReturn new		isRemote: false! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 3/10/2003 01:08'!send: selector	^ IRSend new		selector: selector! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 7/3/2004 19:10'!send: selector toSuperOf: behavior	behavior ifNil: [self error: 'super of nil does not exist'].	^ IRSend new		selector: selector;		superOf: behavior! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 6/13/2005 13:57'!storeInstVar: index	^ IRInstVarStore new number: index.	! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 7/9/2005 21:20'!storeIntoLiteralVariable: object	^ IRLiteralVariableStore new		association: object! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 6/13/2005 11:50'!storeTemp: index	^ IRTempStore new		number: index.! !!IRInterpreter methodsFor: 'instructions' stamp: 'md 8/12/2005 13:30'!blockReturnTop! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 13:26'!goto: seqNum! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 13:26'!if: bool goto: seqNum1 otherwise: seqNum2! !!IRInterpreter methodsFor: 'instructions' stamp: 'md 7/29/2005 10:44'!jumpOverBlock: blockSeq to: dest! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 13:25'!label: seqNum! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 14:11'!popTop! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:34'!pushBlock: irMethod! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:26'!pushBlockMethod: irMethod! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 14:12'!pushDup! !!IRInterpreter methodsFor: 'instructions' stamp: 'md 10/10/2005 17:38'!pushInstVar: aSmallInteger ! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/2/2003 16:08'!pushLiteral: object! !!IRInterpreter methodsFor: 'instructions' stamp: 'md 7/7/2005 14:17'!pushLiteralVariable: object! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/2/2003 16:09'!pushTemp: index! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/2/2003 16:10'!remoteReturn! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/2/2003 16:08'!returnTop! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/2/2003 16:11'!send: selector! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/2/2003 16:11'!send: selector toSuperOf: behavior! !!IRInterpreter methodsFor: 'instructions' stamp: 'md 7/7/2005 14:17'!storeLiteralVariable: index! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/2/2003 16:11'!storeTemp: index! !!IRInterpreter methodsFor: 'interpret' stamp: 'ajh 3/9/2003 12:33'!interpret: ir	self interpretAll: ir allSequences! !!IRInterpreter methodsFor: 'interpret' stamp: 'ajh 3/10/2003 23:30'!interpretAll: irSequences	irSequences do: [:seq | self interpretSequence: seq]! !!IRInterpreter methodsFor: 'interpret' stamp: 'ajh 3/6/2003 15:31'!interpretInstruction: irInstruction	irInstruction executeOn: self! !!IRInterpreter methodsFor: 'interpret' stamp: 'ajh 3/9/2003 13:20'!interpretSequence: instructionSequence	self label: instructionSequence orderNumber.	instructionSequence do: [:instr | self interpretInstruction: instr].! !!IRInterpreter commentStamp: 'ajh 3/24/2003 23:55' prior: 0!I visit each IRInstruction in an IRMethod in order.  Each instruction sends its instruction message to me upon being visited.  See my 'instructions' method category for complete list of instructions.  Subclasses should override them.!!IRJump methodsFor: 'accessing' stamp: 'ajh 3/10/2003 23:08'!destination	^ destination! !!IRJump methodsFor: 'accessing' stamp: 'pmm 2/2/2007 18:06'!destination: aSequence	destination := aSequence! !!IRJump methodsFor: 'accessing' stamp: 'ajh 3/11/2003 00:02'!successorSequences	^ {destination}! !!IRJump methodsFor: 'interpret' stamp: 'ajh 3/10/2003 00:47'!executeOn: interpreter	^ interpreter goto: destination orderNumber! !!IRJump methodsFor: 'testing' stamp: 'ajh 3/11/2003 00:19'!isGoto	"is unconditional jump"	^ true! !!IRJump methodsFor: 'testing' stamp: 'ajh 3/11/2003 00:22'!isJump	"goto or if"	^ true! !!IRJump commentStamp: 'ajh 3/24/2003 23:56' prior: 0!Instruction "goto: labelNum"!!IRJumpIf methodsFor: 'acessing' stamp: 'ajh 3/10/2003 00:43'!boolean	^ boolean! !!IRJumpIf methodsFor: 'acessing' stamp: 'ajh 3/10/2003 00:43'!boolean: bool	boolean _ bool! !!IRJumpIf methodsFor: 'acessing' stamp: 'ajh 3/10/2003 00:43'!otherwise	^ otherwise! !!IRJumpIf methodsFor: 'acessing' stamp: 'pmm 2/2/2007 18:05'!otherwise: aSequence	otherwise := aSequence! !!IRJumpIf methodsFor: 'acessing' stamp: 'ajh 3/11/2003 00:02'!successorSequences	^ {destination. otherwise}! !!IRJumpIf methodsFor: 'interpret' stamp: 'ajh 3/10/2003 00:47'!executeOn: interpreter	^ interpreter if: boolean goto: destination orderNumber otherwise: otherwise orderNumber! !!IRJumpIf methodsFor: 'testing' stamp: 'ajh 3/11/2003 00:19'!isGoto	"is unconditional jump"	^ false! !!IRJumpIf methodsFor: 'testing' stamp: 'ajh 3/11/2003 00:21'!isIf	^ true! !!IRJumpIf commentStamp: 'ajh 3/24/2003 23:56' prior: 0!Instruction "if: boolean goto: labelNum1 otherwise: labelNum2"!!IRJumpOverBlock methodsFor: 'accessing' stamp: 'md 10/8/2004 15:18'!blockSequence	^blockSequence! !!IRJumpOverBlock methodsFor: 'accessing' stamp: 'md 10/8/2004 15:18'!blockSequence: instr	blockSequence := instr.! !!IRJumpOverBlock methodsFor: 'accessing' stamp: 'md 10/8/2004 15:18'!successorSequences	^ {destination. blockSequence} ! !!IRJumpOverBlock methodsFor: 'interpret' stamp: 'md 10/20/2004 20:44'!executeOn: interpreter	^ interpreter jumpOverBlock:  blockSequence orderNumber to: destination orderNumber! !!IRJumpOverBlock methodsFor: 'testing' stamp: 'md 10/8/2004 15:19'!isJumpOverBlock	^true.! !!IRLiteralVariableAccess methodsFor: 'accessing' stamp: 'md 7/9/2005 21:14'!association: anAssociation	association := anAssociation! !!IRLiteralVariableAccess methodsFor: 'accessing' stamp: 'md 10/4/2005 16:45'!isLiteralVariable	^true! !!IRLiteralVariableAccess methodsFor: 'accessing' stamp: 'md 10/4/2005 16:45'!isLiteralVariableAccess	^true! !!IRLiteralVariableAccess methodsFor: 'accessing' stamp: 'md 10/4/2005 16:53'!isLiteralVariableRead	^self isLiteralVariableAccess and: [self isRead].! !!IRLiteralVariableAccess methodsFor: 'accessing' stamp: 'md 10/4/2005 16:53'!isLiteralVariableStore	^self isLiteralVariableAccess and: [self isStore].! !!IRLiteralVariableRead methodsFor: 'interpret' stamp: 'md 7/9/2005 21:18'!executeOn: interpreter	interpreter pushLiteralVariable: association! !!IRLiteralVariableRead methodsFor: 'testing' stamp: 'md 7/9/2005 21:17'!isRead	^true! !!IRLiteralVariableRead methodsFor: 'testing' stamp: 'md 7/9/2005 21:17'!isStore	^false! !!IRLiteralVariableStore methodsFor: 'interpret' stamp: 'md 7/9/2005 21:18'!executeOn: interpreter	interpreter storeIntoLiteralVariable: association! !!IRLiteralVariableStore methodsFor: 'testing' stamp: 'md 7/9/2005 21:18'!isRead	^false! !!IRLiteralVariableStore methodsFor: 'testing' stamp: 'md 7/9/2005 21:18'!isStore	^true! !!IRMethod methodsFor: 'optimizing' stamp: 'ajh 3/10/2003 15:45'!absorbConstantConditionalJumps	startSequence absorbConstantConditionalJumps: IdentitySet new! !!IRMethod methodsFor: 'optimizing' stamp: 'ajh 3/10/2003 15:45'!absorbJumpsToSingleInstrs	startSequence absorbJumpToSingleInstr: IdentitySet new! !!IRMethod methodsFor: 'optimizing' stamp: 'ms 9/6/2007 20:12'!absorbSinglePredecessor	| predecessor |	startSequence 		detectSinglePredecessor: (predecessor := IdentityDictionary new)		seen: IdentitySet new.	startSequence collapseSinglePredecessor: predecessor seen: IdentitySet new! !!IRMethod methodsFor: 'optimizing' stamp: 'md 8/10/2005 11:45'!maxOrderNumber	maxOrderNumber ifNil: [		maxOrderNumber := self startSequence orderNumber.		self startSequence withAllSuccessorsDo: [:seq | maxOrderNumber := maxOrderNumber max: seq orderNumber].				].	^ maxOrderNumber.! !!IRMethod methodsFor: 'optimizing' stamp: 'md 9/26/2005 13:09'!newSeq	maxOrderNumber _ self maxOrderNumber  +1.	^ IRSequence new  orderNumber:maxOrderNumber! !!IRMethod methodsFor: 'optimizing' stamp: 'ms 12/2/2006 23:03'!optimize	self removeEmptyStart.	self absorbJumpsToSingleInstrs.	self absorbConstantConditionalJumps.	self absorbJumpsToSingleInstrs! !!IRMethod methodsFor: 'optimizing' stamp: 'ajh 3/18/2003 19:25'!removeEmptyStart	startSequence size = 1 ifTrue: [		"startSeq is just unconditional jump, forget it"		startSequence _ startSequence last destination].! !!IRMethod methodsFor: 'inlining' stamp: 'md 9/11/2005 18:52'!addInstructionsAfter: aCollection	| returningSeqs  lastInstr |	aCollection ifEmpty: [^self].	returningSeqs := self allSequences select: [:each | each last isReturn].	lastInstr := returningSeqs last last.	lastInstr addInstructionsBefore: aCollection.	! !!IRMethod methodsFor: 'inlining' stamp: 'md 7/14/2005 12:31'!addInstructionsBefore: aCollection	(self startSequence nextSequence first) addInstructionsBefore: aCollection.	! !!IRMethod methodsFor: 'inlining' stamp: 'md 8/2/2005 15:07'!methodForInlining	^self removeReturnSelf removeEmptyStart.! !!IRMethod methodsFor: 'inlining' stamp: 'md 9/12/2005 12:00'!removeReturn	self allSequences last removeLast.! !!IRMethod methodsFor: 'inlining' stamp: 'md 7/1/2005 17:34'!removeReturnSelf	self removeReturn.	self allSequences last removeLast.! !!IRMethod methodsFor: 'accessing' stamp: 'md 7/11/2005 22:19'!addLiteral: aSymbol		additionalLiterals add: aSymbol.! !!IRMethod methodsFor: 'accessing' stamp: 'md 7/12/2005 00:21'!addLiterals: anArray		additionalLiterals addAll: anArray.! !!IRMethod methodsFor: 'accessing' stamp: 'md 7/10/2005 15:41'!addTemps: newKeys		tempKeys addAll: newKeys.! !!IRMethod methodsFor: 'accessing' stamp: 'md 7/11/2005 22:19'!additionalLiterals	^additionalLiterals.! !!IRMethod methodsFor: 'accessing' stamp: 'md 6/10/2005 16:07'!allInstructions	" return irNodes as a flat collection "	| irInstructions |	irInstructions := OrderedCollection new.	startSequence withAllSuccessorsDo: [:seq | seq do: [:bc | irInstructions add: bc]].	^irInstructions! !!IRMethod methodsFor: 'accessing' stamp: 'md 6/13/2005 10:41'!allInstructionsMatching: aBlock	" return irNodes as a flat collection "	| irInstructions |	irInstructions := OrderedCollection new.	startSequence withAllSuccessorsDo: [:seq | seq do: [:bc | (aBlock value: bc) ifTrue: [irInstructions add: bc]]].	^irInstructions! !!IRMethod methodsFor: 'accessing' stamp: 'md 6/13/2005 10:40'!allSendInstructions	^self allInstructionsMatching: [:bc | bc isSend].! !!IRMethod methodsFor: 'accessing' stamp: 'ajh 3/9/2003 15:35'!allSequences	^ startSequence withAllSuccessors! !!IRMethod methodsFor: 'accessing' stamp: 'md 6/13/2005 11:06'!allTempAccessInstructions	^self allInstructionsMatching: [:bc | bc isTempAccess].! !!IRMethod methodsFor: 'accessing' stamp: 'md 6/13/2005 10:39'!allTempReadInstructions	^self allInstructionsMatching: [:bc | bc isTempRead].! !!IRMethod methodsFor: 'accessing' stamp: 'md 6/13/2005 10:40'!allTempWriteInstructions	^self allInstructionsMatching: [:bc | bc isTempStore].! !!IRMethod methodsFor: 'accessing' stamp: 'md 11/15/2004 17:08'!ir	^self.! !!IRMethod methodsFor: 'accessing' stamp: 'md 6/16/2005 15:02'!method	^self.! !!IRMethod methodsFor: 'accessing' stamp: 'ajh 6/25/2004 10:53'!numArgs	^ self numRargs - 1! !!IRMethod methodsFor: 'accessing' stamp: 'ajh 6/25/2004 10:53'!numRargs	^ numRargs! !!IRMethod methodsFor: 'accessing' stamp: 'ajh 3/10/2003 18:10'!primitiveNode	^ primitiveNode! !!IRMethod methodsFor: 'accessing' stamp: 'md 7/10/2005 22:06'!properties	^properties! !!IRMethod methodsFor: 'accessing' stamp: 'md 7/10/2005 22:06'!properties: propDict	properties := propDict.! !!IRMethod methodsFor: 'accessing' stamp: 'ajh 3/10/2003 17:53'!startSequence	^ startSequence! !!IRMethod methodsFor: 'accessing' stamp: 'ajh 6/25/2004 10:49'!tempKeys	^ tempKeys! !!IRMethod methodsFor: 'accessing' stamp: 'ajh 6/25/2004 10:52'!tempNames	"All temp names in context order"	| varNames |	varNames _ OrderedCollection new.	self tempKeys do: [:var | | name |		name _ var asString.		"vars are unique but inlined to:do: loop vars may have the same name, so munge the names to make them different"		[varNames includes: name] whileTrue: [name _ name, 'X'].		varNames add: name.	].	^ varNames asArray! !!IRMethod methodsFor: 'decompiling' stamp: 'ajh 6/28/2004 13:44'!ast	^ IRDecompiler new decompileIR: self! !!IRMethod methodsFor: 'translating' stamp: 'pmm 8/25/2006 15:02'!compiledMethod	^ compiledMethod ifNil: [self compiledMethodWith: #(0 0 0 0)]! !!IRMethod methodsFor: 'translating' stamp: 'pmm 8/16/2006 20:56'!compiledMethodWith: trailer	^self compiledMethodWith: trailer using: CompiledMethod! !!IRMethod methodsFor: 'translating' stamp: 'pmm 8/16/2006 20:55'!compiledMethodWith: trailer using: aCompiledMethodClass	^ compiledMethod _ IRTranslator new		trailer: trailer;		interpret: self;		compiledMethodUsing: aCompiledMethodClass! !!IRMethod methodsFor: 'translating' stamp: 'ajh 3/10/2003 15:54'!privCompiledMethod: aCompiledMethod	compiledMethod _ aCompiledMethod! !!IRMethod methodsFor: 'initialize' stamp: 'md 11/22/2005 17:59'!initialize	primitiveNode _ PrimitiveNode null.	tempKeys _ OrderedCollection new.	properties _ MethodProperties new. 	additionalLiterals _ OrderedCollection new.! !!IRMethod methodsFor: 'initialize' stamp: 'ajh 6/25/2004 10:53'!numRargs: n	numRargs _ n! !!IRMethod methodsFor: 'initialize' stamp: 'ajh 3/10/2003 23:08'!primitiveNode: aPrimitiveNode	primitiveNode _ aPrimitiveNode! !!IRMethod methodsFor: 'initialize' stamp: 'md 7/9/2005 22:36'!startSequence: irSequence	startSequence _ irSequence.	irSequence method: self.! !!IRMethod methodsFor: 'initialize' stamp: 'ajh 6/25/2004 11:19'!tempKeys: objects	tempKeys _ objects! !!IRMethod methodsFor: 'testing' stamp: 'md 6/21/2005 13:56'!isSend	^false.! !!IRMethod methodsFor: 'printing' stamp: 'ajh 3/9/2003 15:53'!longPrintOn: stream	IRPrinter new		indent: 0;		stream: stream;		interpret: self! !!IRMethod methodsFor: 'mapping' stamp: 'ajh 3/19/2003 13:38'!sourceMap	"Return a mapping from bytecode pcs to source code ranges"	| start map |	"Besides getting start position, make sure bytecodeIndices are filled in"	start _ self compiledMethod initialPC - 1.  	map _ OrderedCollection new.	self allSequences do: [:seq |		seq do: [:instr |  | node |			((node _ instr sourceNode) notNil and: 			 [node debugHighlightStart notNil and:			  [node debugHighlightStop notNil and:			   [instr bytecodeIndex notNil]]]) ifTrue: [				map add:					instr bytecodeIndex + start						-> (node debugHighlightStart to: node debugHighlightStop)]		]	].	^ map! !!IRMethod commentStamp: 'ajh 5/23/2003 11:08' prior: 0!I am a method in the IR (intermediate representation) language consisting of IRInstructions grouped by IRSequence (basic block).  The IRSequences form a control graph (therefore I only have to hold onto the starting sequence).  #compiledMethod will convert me to a CompiledMethod.  #methodNode will convert me back to a parse tree.!!IRPop methodsFor: 'interpret' stamp: 'ajh 3/10/2003 00:47'!executeOn: interpreter	^ interpreter popTop! !!IRPop methodsFor: 'testing' stamp: 'ms 7/10/2007 14:12'!isPop	^true! !!IRPop commentStamp: 'ajh 3/24/2003 23:57' prior: 0!Instruction "popTop"!!IRPrinter methodsFor: 'instructions' stamp: 'md 8/9/2005 17:08'!blockReturnTop	stream nextPutAll: 'blockReturnTop'.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 15:41'!goto: seqNum	stream nextPutAll: 'goto: '.	seqNum printOn: stream.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 15:42'!if: bool goto: seqNum1 otherwise: seqNum2	stream nextPutAll: 'if: '.	bool printOn: stream.	stream nextPutAll: ' goto: '.	seqNum1 printOn: stream.	stream nextPutAll: ' else: '.	seqNum2 printOn: stream.! !!IRPrinter methodsFor: 'instructions' stamp: 'md 8/10/2005 11:23'!jumpOverBlock: blockSeq to: dest	stream nextPutAll: 'jumpOverBlock: '.	stream nextPutAll: ' block '.	blockSeq  printOn: stream.	stream nextPutAll: ' cont: '.	dest  printOn: stream.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/11/2003 00:36'!label: seqNum	"add tab and cr since this does not get called within interpretInstruction:"	stream cr.  "extra cr just to space out sequences"	indent timesRepeat: [stream tab].	stream nextPutAll: 'label: '.	seqNum printOn: stream.	stream cr.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 15:42'!popTop	stream nextPutAll: 'popTop'! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:44'!pushBlock: irMethod	stream nextPutAll: 'pushBlock:'.	IRPrinter new		indent: indent + 1;		stream: stream;		interpret: irMethod removeEmptyStart.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:44'!pushBlockMethod: irMethod	stream nextPutAll: 'pushBlockMethod:'.	IRPrinter new		indent: indent + 1;		stream: stream;		interpret: irMethod removeEmptyStart.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 15:42'!pushDup	stream nextPutAll: 'pushDup'! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/21/2003 01:49'!pushLiteral: object	stream nextPutAll: 'pushLiteral: '.	object isVariableBinding ifTrue: [^ stream nextPutAll: object key].	object printOn: stream.	((object isKindOf: BlockClosure) or: [object isKindOf: CompiledMethod])		ifTrue: [			IRPrinter new				indent: indent + 1;				stream: stream;				interpret: object method ir removeEmptyStart].! !!IRPrinter methodsFor: 'instructions' stamp: 'md 8/10/2005 11:28'!pushLiteralVariable: object	stream nextPutAll: 'pushLiteralVariable: '.	object isVariableBinding ifTrue: [^ stream nextPutAll: object key].	object printOn: stream.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 6/26/2004 18:37'!pushTemp: index	stream nextPutAll: 'pushTemp: '.	index printOn: stream.	index = 0 ifTrue: [stream nextPutAll: ' "receiver"'].	index = -1 ifTrue: [stream nextPutAll: ' "thisEnv"'].	index = -2 ifTrue: [stream nextPutAll: ' "thisContext"'].! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 15:43'!remoteReturn	stream nextPutAll: 'remoteReturn'.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 15:43'!returnTop	stream nextPutAll: 'returnTop'.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 15:44'!send: selector	stream nextPutAll: 'send: '.	selector printOn: stream.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 15:44'!send: selector toSuperOf: behavior	stream nextPutAll: 'send: '.	selector printOn: stream.	stream nextPutAll: ' toSuperOf: '.	behavior printOn: stream.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 6/26/2004 23:15'!storeTemp: index	stream nextPutAll: 'storeTemp: '.	index printOn: stream.	index = -1 ifTrue: [stream nextPutAll: ' "thisEnv"'].! !!IRPrinter methodsFor: 'initialize' stamp: 'ajh 3/9/2003 15:49'!indent: tabs	indent _ tabs! !!IRPrinter methodsFor: 'initialize' stamp: 'ajh 3/9/2003 15:50'!stream: stringWriteStream	stream _ stringWriteStream! !!IRPrinter methodsFor: 'interpret' stamp: 'ajh 3/9/2003 15:48'!interpretInstruction: irInstruction	indent timesRepeat: [stream tab].	super interpretInstruction: irInstruction.	stream cr.! !!IRPrinter commentStamp: 'ajh 3/25/2003 00:22' prior: 0!I interpret IRMethod instructions and write them out to a print stream.!!IRReturn methodsFor: 'interpret' stamp: 'ajh 3/10/2003 00:48'!executeOn: interpreter	^ isRemote		ifTrue: [interpreter remoteReturn]		ifFalse: [interpreter returnTop]! !!IRReturn methodsFor: 'accessing' stamp: 'ajh 3/10/2003 00:44'!isRemote	^ isRemote! !!IRReturn methodsFor: 'accessing' stamp: 'ms 6/17/2007 00:32'!isRemote: boolean	isRemote := boolean! !!IRReturn methodsFor: 'testing' stamp: 'ajh 3/10/2003 16:10'!isReturn	^ true! !!IRReturn commentStamp: 'ajh 3/24/2003 23:57' prior: 0!Instruction "returnTop" or "remoteReturn"!!IRSend methodsFor: 'interpret' stamp: 'ajh 3/10/2003 00:48'!executeOn: interpreter	^ superOf		ifNil: [interpreter send: selector]		ifNotNil: [interpreter send: selector toSuperOf: superOf]! !!IRSend methodsFor: 'testing' stamp: 'md 11/12/2004 15:56'!isMessageSend	^true.! !!IRSend methodsFor: 'testing' stamp: 'md 11/12/2004 15:57'!isSend	^true.! !!IRSend methodsFor: 'testing' stamp: 'md 10/10/2005 17:37'!isSuperSend    ^superOf notNil! !!IRSend methodsFor: 'accessing' stamp: 'md 6/23/2005 13:45'!selector	^selector! !!IRSend methodsFor: 'accessing' stamp: 'ajh 3/10/2003 00:44'!selector: symbol	selector _ symbol! !!IRSend methodsFor: 'accessing' stamp: 'md 6/23/2005 13:49'!senderselector	^self method selector! !!IRSend methodsFor: 'accessing' stamp: 'ajh 3/10/2003 00:45'!superOf	^ superOf! !!IRSend methodsFor: 'accessing' stamp: 'ajh 3/10/2003 00:45'!superOf: behavior	superOf _ behavior! !!IRSend commentStamp: 'ajh 3/24/2003 23:57' prior: 0!Instruction "send: selector" or "send: selector toSuperOf: behavior"!!IRSequence methodsFor: 'copying' stamp: 'dr 9/10/2005 20:59'!, otherCollection 	^sequence, otherCollection! !!IRSequence methodsFor: 'optimizing' stamp: 'md 7/14/2005 11:56'!absorbConstantConditionalJumps: alreadySeen	"Collapse sequences that look like:			[if] goto s1			...		 s1:	pushConst: true/false			goto s2		 s2:	if true/false goto s3 else s4	into:			[if] goto s3/s4	These sequences are produced by and:/or: messages"	| seq bool if |	(alreadySeen includes: self) ifTrue: [^ self].	alreadySeen add: self.	[(seq := self successorSequences) size > 0  "not return"	  and: [(seq := seq first "destination") size = 2	   and: [(seq first isConstant: [:obj | (bool := obj) isKindOf: Boolean])	    and: [seq last isGoto	     and: [(if := seq last destination first) isIf]]]]	] whileTrue: [ "absorb"		self last destination: (bool == if boolean			ifTrue: [if destination]			ifFalse: [if otherwise]).	].	self successorSequences do: [:instrs | instrs absorbConstantConditionalJumps: alreadySeen].! !!IRSequence methodsFor: 'optimizing' stamp: 'md 7/14/2005 11:56'!absorbJumpToSingleInstr: alreadySeen	"Collapse jumps to single return instructions into caller"	| seqs seq |	(alreadySeen includes: self) ifTrue: [^ self].	alreadySeen add: self.	[ (seqs := self successorSequences) size = 1  "unconditional jump..." 	   and: [(seq := seqs first) size = 1  "...to single instruction..."	    and: [seq successorSequences size < 2]		and: [self last isBlockReturnTop not]] "...but don't collapse conditional jumps so their otherwiseSequences can stay right after them"	] whileTrue: [ "replace goto with single instruction"		self removeLast.		seq do: [:instr | self add: instr copy].	].	seqs do: [:instrs | instrs absorbJumpToSingleInstr: alreadySeen].! !!IRSequence methodsFor: 'optimizing' stamp: 'ms 9/6/2007 20:21'!collapseSinglePredecessor: predecessorList seen: alreadySeen	| seqs  seq |	(alreadySeen includes: self) ifTrue: [^ self].	alreadySeen add: self.	[(seqs := self successorSequences) size = 1 		and: [(predecessorList at: (seq := seqs first) ifAbsent:[0]) = 1]		and: [seq orderNumber > self orderNumber]]			whileTrue:[				self removeLast.				seq do: [:instr | self add: instr copy]].	seqs do: [:instrs | instrs collapseSinglePredecessor: predecessorList seen: alreadySeen].! !!IRSequence methodsFor: 'optimizing' stamp: 'ms 9/6/2007 20:26'!detectSinglePredecessor: sequencesPredecessor seen: alreadySeen	| seqs  |	(alreadySeen includes: self) ifTrue: [^ self].	alreadySeen add: self.	seqs := self successorSequences.	seqs do: [:seq | sequencesPredecessor 				at: seq 				put: (sequencesPredecessor at: seq ifAbsent:[0]) + 1].	seqs do: [:instrs | instrs detectSinglePredecessor: sequencesPredecessor seen: alreadySeen].! !!IRSequence methodsFor: 'adding' stamp: 'md 7/14/2005 11:57'!add: anInstruction	sequence add: anInstruction.	anInstruction sequence: self.	^anInstruction.! !!IRSequence methodsFor: 'adding' stamp: 'md 7/14/2005 11:57'!add: instr after: another	sequence add: instr after: another.	instr sequence: self.	^instr.! !!IRSequence methodsFor: 'adding' stamp: 'md 7/14/2005 11:58'!add: instr before: another	sequence add: instr before: another.	instr sequence: self.	^instr.! !!IRSequence methodsFor: 'adding' stamp: 'dr 9/11/2005 15:35'!addAll: aCollection	^sequence addAll: aCollection! !!IRSequence methodsFor: 'adding' stamp: 'md 9/28/2005 17:55'!addAllFirst: aCollection	^sequence addAllFirst: aCollection.! !!IRSequence methodsFor: 'adding' stamp: 'md 7/14/2005 11:58'!addInstructions: aCollection		^aCollection do: [:instr | self add: instr].! !!IRSequence methodsFor: 'adding' stamp: 'md 7/14/2005 11:57'!addInstructions: aCollection after: anInstruction		^aCollection reverseDo: [:instr | self add: instr after: anInstruction].! !!IRSequence methodsFor: 'adding' stamp: 'md 7/14/2005 12:29'!addInstructions: aCollection before: anInstruction	aCollection do: [:instr | self add: instr before: anInstruction].! !!IRSequence methodsFor: 'adding' stamp: 'dr 9/10/2005 20:57'!addLast: anInstruction	^self add: anInstruction.! !!IRSequence methodsFor: 'accessing' stamp: 'md 9/29/2005 11:25'!after: o	^sequence after: o! !!IRSequence methodsFor: 'accessing' stamp: 'dr 9/10/2005 21:01'!at: index	^sequence at: index! !!IRSequence methodsFor: 'accessing' stamp: 'md 7/14/2005 12:31'!first	^sequence first! !!IRSequence methodsFor: 'accessing' stamp: 'md 7/14/2005 12:23'!last	^sequence last! !!IRSequence methodsFor: 'accessing' stamp: 'md 7/14/2005 12:00'!method	^method! !!IRSequence methodsFor: 'accessing' stamp: 'md 7/14/2005 12:00'!method: aIRMethod	method := aIRMethod! !!IRSequence methodsFor: 'accessing' stamp: 'md 7/14/2005 12:00'!orderNumber	"Sequences are sorted by this number"	^ orderNumber! !!IRSequence methodsFor: 'accessing' stamp: 'md 7/14/2005 12:00'!orderNumber: num	"Sequences are sorted by this number"	orderNumber := num.! !!IRSequence methodsFor: 'accessing' stamp: 'md 7/14/2005 12:32'!sequence	^sequence! !!IRSequence methodsFor: 'accessing' stamp: 'md 7/14/2005 12:25'!size	^sequence size.! !!IRSequence methodsFor: 'enumerating' stamp: 'dr 9/10/2005 21:02'!detect: aBlock	^sequence detect: aBlock! !!IRSequence methodsFor: 'enumerating' stamp: 'md 7/14/2005 12:24'!do: aBlock	^sequence do: aBlock.! !!IRSequence methodsFor: 'enumerating' stamp: 'md 7/14/2005 12:28'!reverseDo: aBlock	^sequence reverseDo: aBlock.! !!IRSequence methodsFor: 'enumerating' stamp: 'md 7/14/2005 12:28'!select: aBlock	^sequence select: aBlock.! !!IRSequence methodsFor: 'testing' stamp: 'md 7/14/2005 12:30'!ifEmpty: aBlock	^sequence ifEmpty: aBlock! !!IRSequence methodsFor: 'testing' stamp: 'md 7/14/2005 12:30'!ifNotEmpty: aBlock	^sequence ifNotEmpty: aBlock! !!IRSequence methodsFor: 'testing' stamp: 'md 7/14/2005 12:23'!isEmpty	^sequence isEmpty! !!IRSequence methodsFor: 'testing' stamp: 'dr 9/10/2005 20:55'!notEmpty	^sequence notEmpty! !!IRSequence methodsFor: 'initialize-release' stamp: 'md 7/14/2005 11:56'!initialize	sequence := OrderedCollection new.! !!IRSequence methodsFor: 'successor sequences' stamp: 'md 7/14/2005 11:58'!instructionsDo: aBlock	^self withAllSuccessorsDo: [:seq | seq do: aBlock].! !!IRSequence methodsFor: 'successor sequences' stamp: 'md 7/14/2005 11:58'!nextSequence	| sequences i |	sequences := self withAllSuccessors.	i := sequences findFirst: [:seq | seq orderNumber = self orderNumber].	(i = 0 or: [i = sequences size]) ifTrue: [^ nil].	^ sequences at: i + 1! !!IRSequence methodsFor: 'successor sequences' stamp: 'md 7/14/2005 11:59'!successorSequences	sequence isEmpty ifTrue: [^ #()].	^ sequence last successorSequences! !!IRSequence methodsFor: 'successor sequences' stamp: 'md 7/14/2005 11:59'!withAllSuccessors	"Return me and all my successors sorted by sequence orderNumber"	| list |	list := OrderedCollection new: 20.	self withAllSuccessorsDo: [:seq | list add: seq].	^ list asSortedCollection: [:x :y | x orderNumber <= y orderNumber]! !!IRSequence methodsFor: 'successor sequences' stamp: 'md 7/14/2005 11:59'!withAllSuccessorsDo: block	"Iterate over me and all my successors only once"	self withAllSuccessorsDo: block alreadySeen: IdentitySet new! !!IRSequence methodsFor: 'successor sequences' stamp: 'md 7/14/2005 11:59'!withAllSuccessorsDo: block alreadySeen: set	"Iterate over me and all my successors only once"	(set includes: self) ifTrue: [^ self].	set add: self.	block value: self.	self successorSequences do: [:seq |		seq ifNotNil: [seq withAllSuccessorsDo: block alreadySeen: set]].! !!IRSequence methodsFor: 'printing' stamp: 'md 7/14/2005 11:59'!longPrintOn: stream	[IRPrinter new		indent: 0;		stream: stream;		interpretSequence: self	] onDNU: #orderNumber do: [:ex | ex resume: ex receiver]! !!IRSequence methodsFor: 'printing' stamp: 'md 7/14/2005 12:00'!printOn: stream	stream nextPutAll: 'an '.	self class printOn: stream.	stream space.	stream nextPut: $(.	self orderNumber printOn: stream.	stream nextPut: $).! !!IRSequence methodsFor: 'replacing' stamp: 'md 7/14/2005 12:00'!remove: aNode	aNode sequence: nil.	sequence remove: aNode ifAbsent: [self error].! !!IRSequence methodsFor: 'replacing' stamp: 'md 7/14/2005 12:01'!replaceNode: aNode withNode: anotherNode 	self add: anotherNode before: aNode.	sequence remove: aNode ifAbsent: [self error].! !!IRSequence methodsFor: 'replacing' stamp: 'md 7/14/2005 12:01'!replaceNode: aNode withNodes: aCollection 	self addInstructions: aCollection before: aNode.	sequence remove: aNode ifAbsent: [self error].! !!IRSequence methodsFor: 'removing' stamp: 'dr 9/10/2005 21:03'!removeFirst	^sequence removeFirst.! !!IRSequence methodsFor: 'removing' stamp: 'md 7/14/2005 12:25'!removeLast	^sequence removeLast.! !!IRSequence methodsFor: 'manipulating' stamp: 'dr 9/10/2005 20:58'!setSuccessor: suc	"find the blockReturnTops, set successor "	self withAllSuccessorsDo: [:succ | succ notEmpty ifTrue: [		| last |		last := succ last.		last isBlockReturnTop ifTrue: [ 			last successor: suc.		]	]].! !!IRSequence methodsFor: 'manipulating' stamp: 'md 7/14/2005 13:22'!splitAfter: instruction	| newSeq index next |	next := self nextSequence.	next := next		ifNil: [self orderNumber + 1]		ifNotNil: [(next orderNumber + self orderNumber) / 2].	newSeq := self class new orderNumber: next.	newSeq method: self method.	"Split after instruction"	index := sequence indexOf: instruction.	(sequence last: sequence size - index) do: [:instr | newSeq add: instr].	sequence := sequence first: index.	sequence add: (IRJump new destination: newSeq).	^ newSeq! !!IRSequence methodsFor: 'manipulating' stamp: 'md 7/14/2005 13:22'!splitAfterNoJump: instruction	| newSeq next index |	next := self nextSequence.	next := next		ifNil: [self orderNumber + 1]		ifNotNil: [(next orderNumber + self orderNumber) / 2].	newSeq := self class new orderNumber: next.	newSeq method: self method.		"Split after instruction"	index := sequence indexOf: instruction.	(sequence last: sequence size - index) do: [:instr | newSeq add: instr].	sequence := sequence first: index.	^ newSeq! !!IRSequence methodsFor: 'manipulating' stamp: 'md 9/23/2005 14:42'!tranformToBlockSequence	| last |	" fix: if last jump --> follow jumps, remove returns and add blockReturnTop on leafs."	self withAllSuccessorsDo: [:succ | 		succ notEmpty ifTrue: [			last := succ last.			last isJump ifFalse: [ 				last isReturn ifTrue: [succ removeLast].				succ addLast: IRInstruction blockReturnTop.			]		].		succ ifEmpty: [succ addLast: IRInstruction blockReturnTop].	].! !!IRTempAccess methodsFor: 'testing' stamp: 'md 2/26/2005 16:22'!isSelf	^self number = 0.! !!IRTempAccess methodsFor: 'testing' stamp: 'md 2/22/2005 11:28'!isTemp	^true.! !!IRTempAccess methodsFor: 'testing' stamp: 'md 6/12/2005 18:42'!isTempAccess	^true.! !!IRTempAccess methodsFor: 'testing' stamp: 'md 6/13/2005 11:08'!isTempRead	^self isTempAccess and: [self isRead].! !!IRTempAccess methodsFor: 'testing' stamp: 'md 6/13/2005 12:01'!isTempStore	^self isTempAccess and: [self isStore].! !!IRTempRead methodsFor: 'interpret' stamp: 'md 6/12/2005 18:19'!executeOn: interpreter	interpreter pushTemp: number.! !!IRTempRead methodsFor: 'testing' stamp: 'md 6/12/2005 18:21'!isRead	^true! !!IRTempRead methodsFor: 'testing' stamp: 'md 6/13/2005 12:03'!isStore	^false! !!IRTempStore methodsFor: 'interpret' stamp: 'md 6/12/2005 18:20'!executeOn: interpreter	interpreter storeTemp: number.		! !!IRTempStore methodsFor: 'testing' stamp: 'md 6/12/2005 18:22'!isRead	^false! !!IRTempStore methodsFor: 'testing' stamp: 'md 6/13/2005 12:03'!isStore	^true! !!IRTransformTest methodsFor: 'testing' stamp: 'md 10/13/2004 14:09'!testAdd		| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushLiteral: 1;						returnTop;		ir.	(iRMethod allSequences last) last delete.	(iRMethod allSequences last) last delete.	(iRMethod allSequences last)			add: (IRInstruction pushLiteral: 2).	(iRMethod allSequences last)			add: (IRInstruction returnTop).	aCompiledMethod := iRMethod compiledMethod.	self should: [(aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2].! !!IRTransformTest methodsFor: 'testing' stamp: 'md 10/13/2004 14:09'!testAddBefore		| iRMethod aCompiledMethod ret |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushLiteral: 1;						returnTop;		ir.	(iRMethod allSequences last) last delete.	(iRMethod allSequences last) last delete.	ret :=  (IRInstruction returnTop).	(iRMethod allSequences last)			add: ret.	(iRMethod allSequences last)			add: (IRInstruction pushLiteral: 2) before: ret.	aCompiledMethod := iRMethod compiledMethod.	self should: [(aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2].! !!IRTransformTest methodsFor: 'testing' stamp: 'md 10/13/2004 14:09'!testAddIntructions		| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushLiteral: 1;						returnTop;		ir.	(iRMethod allSequences last) last delete.	(iRMethod allSequences last) last delete.	(iRMethod allSequences last)			addInstructions: {(IRInstruction pushLiteral: 2). (IRInstruction returnTop)}.	aCompiledMethod := iRMethod compiledMethod.	self should: [(aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2].! !!IRTransformTest methodsFor: 'testing' stamp: 'md 10/12/2004 16:31'!testAddIntructionsBefore		| iRMethod aCompiledMethod push |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushLiteral: 1;						returnTop;		ir.	push := (iRMethod allSequences last) at: (iRMethod allSequences size - 1) .	(iRMethod allSequences last)			addInstructions: {(IRInstruction pushLiteral: 2). (IRInstruction returnTop)} before: push.	aCompiledMethod := iRMethod compiledMethod.	self should: [(aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2].! !!IRTransformTest methodsFor: 'testing' stamp: 'md 10/13/2004 11:08'!testAddIntructionsBeforeFromLList		| iRMethod aCompiledMethod push llist col |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushLiteral: 1;						returnTop;		ir.	push := (iRMethod allSequences last) at: (iRMethod allSequences size - 1) .	llist := LinkedList new.	llist add: (IRInstruction pushLiteral: 2).	llist add: (IRInstruction returnTop).	col := llist asOrderedCollection.	(iRMethod allSequences last)			addInstructions:  col before: push.	aCompiledMethod := iRMethod compiledMethod.	self should: [(aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2].! !!IRTransformTest methodsFor: 'testing' stamp: 'md 10/13/2004 14:09'!testDelete		| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushLiteral: 1;						pushLiteral: 2;			returnTop;		ir.	((iRMethod allSequences last) 		detect: [:each | each isConstant: [:c | c == 2]]) delete.				aCompiledMethod := iRMethod compiledMethod.	self should: [(aCompiledMethod valueWithReceiver: nil arguments: #() ) = 1].! !!IRTransformTest methodsFor: 'testing' stamp: 'ms 7/13/2006 10:13'!testReplace	| iRMethod aCompiledMethod |		iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushLiteral: 1;						returnTop;		ir.		(iRMethod allSequences last at: 1) 			replaceWith: (IRInstruction pushLiteral: 2).	aCompiledMethod := iRMethod compiledMethod.	self should: [(aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2].! !!IRTransformTest methodsFor: 'testing' stamp: 'md 2/22/2005 11:58'!testReplaceInstr		| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushLiteral: 1;						returnTop;		ir.		(iRMethod allSequences last at: 1) 			replaceWithInstructions: {(IRInstruction pushLiteral: 2)}.	aCompiledMethod := iRMethod compiledMethod.	self should: [(aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2].! !!IRTranslator methodsFor: 'instructions' stamp: 'md 4/23/2005 17:15'!addLiteral: literal	gen addLiteral: literal.! !!IRTranslator methodsFor: 'instructions' stamp: 'md 10/8/2004 16:07'!blockReturnTop	self doPending.	gen blockReturnTop.! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 3/9/2003 22:09'!goto: seqNum	self doPending.	gen goto: seqNum.! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 3/9/2003 22:09'!if: bool goto: seqNum1 otherwise: seqNum2	self doPending.	gen if: bool goto: seqNum1 otherwise: seqNum2.! !!IRTranslator methodsFor: 'instructions' stamp: 'md 10/27/2004 17:00'!jumpOverBlock:  blockNum to: seqNum	self doPending.	gen jumpOverBlock: seqNum.! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 3/9/2003 22:10'!label: seqNum	pending _ OrderedCollection new.	gen label: seqNum.! !!IRTranslator methodsFor: 'instructions' stamp: 'ms 12/3/2006 18:18'!popTop	"if last was storeTemp,  storeInstVar storeIntoLiteralVariable then convert to storePopTemp, storePopInstVar storePopIntoLiteralVariable"	#storeTemp: == self pendingSelector ifTrue: [		^ self pendingSelector: #storePopTemp:].	#storeInstVar: == self pendingSelector ifTrue: [		^ self pendingSelector: #storePopInstVar:].	#storeIntoLiteralVariable: == self pendingSelector ifTrue:[		^self pendingSelector: #storePopIntoLiteralVariable:].	"otherwise do normal pop"	self doPending.	gen popTop.! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 6/28/2004 11:20'!pushBlock: irMethod	| meth block |	meth _ irMethod compiledMethodWith: trailerBytes.	meth isBlockMethod: true.	block _ meth createBlock: nil.	self addPending: (Message selector: #pushLiteral: argument: block)! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 6/28/2004 11:20'!pushBlockMethod: irMethod	| meth |	meth _ irMethod compiledMethodWith: trailerBytes.	meth isBlockMethod: true.	self addPending: (Message selector: #pushLiteral: argument: meth)! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 3/9/2003 22:10'!pushDup	self doPending.	gen pushDup.! !!IRTranslator methodsFor: 'instructions' stamp: 'md 7/19/2005 23:21'!pushInstVar: index	"self doPending.	gen pushInstVar: index."	self addPending: (Message selector: #pushInstVar: argument: index)! !!IRTranslator methodsFor: 'instructions' stamp: 'md 7/5/2005 16:10'!pushLiteral: object	self addPending: (Message selector: #pushLiteral: argument: object)! !!IRTranslator methodsFor: 'instructions' stamp: 'md 7/5/2005 16:10'!pushLiteralVariable: object	self addPending: (Message selector: #pushLiteralVariable: argument: object)! !!IRTranslator methodsFor: 'instructions' stamp: 'md 6/14/2005 15:02'!pushTemp: index	index = 0 ifTrue: [^ self addPending: (Message selector: #pushReceiver)].	(self pendingMatches: {		[:m | m selector == #storePopTemp: and: [m argument = index]]}		) ifTrue: [^ self pendingSelector: #storeTemp:].	self doPending.	index = -2 ifTrue: [^ gen pushThisContext].	index = -1 ifTrue: [		^ gen pushThisContext;			pushLiteral: MethodContext myEnvFieldIndex;			send: #privGetInstVar:].	gen pushTemp: index.! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 3/9/2003 22:12'!remoteReturn	self doPending.	gen remoteReturn.! !!IRTranslator methodsFor: 'instructions' stamp: 'md 7/19/2005 23:30'!returnTop	#pushReceiver == self pendingSelector ifTrue: [		self pendingSelector: #returnReceiver.		^ self doPending	].	#pushLiteral: == self pendingSelector ifTrue: [		self pendingSelector: #returnConstant:.		^ self doPending	].	#pushInstVar: == self pendingSelector ifTrue: [		self pendingSelector: #returnInstVar:.		^ self doPending	].	self doPending.	gen returnTop.! !!IRTranslator methodsFor: 'instructions' stamp: 'md 6/14/2005 15:04'!send: selector	"If get/set inst var, access it directly"	| index |		((#(privGetInstVar: #privStoreIn:instVar:) identityIncludes: selector) and:	 [self pendingMatches: {		[:m | m selector == #pushReceiver].		[:m | m selector == #pushLiteral: and: [m argument isInteger]]}]	) ifTrue: [		index _ self popPending argument.		self popPending.  "pop pushReceiver"		self addPending: (Message			selector: (selector == #privGetInstVar:				ifTrue: [#pushInstVar:] ifFalse: [#storeInstVar:])			argument: index).		(self pendingMatches: {			[:m | m selector == #storePopInstVar: and: [m argument = index]].			[:m | m selector == #pushInstVar: and: [m argument = index]]}		) ifTrue: [			self popPending.			self pendingSelector: #storeInstVar:.		].		^ self	].	"otherwise do normal send"	self doPending.	gen send: selector.! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 3/9/2003 22:14'!send: selector toSuperOf: behavior	self doPending.	gen send: selector toSuperOf: behavior.! !!IRTranslator methodsFor: 'instructions' stamp: 'ms 12/2/2006 23:01'!storeInstVar: index 	"self doPending.	gen storeInstVar: index"	self addPending: (Message selector: #storeInstVar: argument: index)! !!IRTranslator methodsFor: 'instructions' stamp: 'ms 12/3/2006 18:18'!storeIntoLiteralVariable: assoc	"self doPending.	gen storeIntoLiteralVariable: assoc."		self addPending: (Message selector: #storeIntoLiteralVariable: argument: assoc)! !!IRTranslator methodsFor: 'instructions' stamp: 'md 6/14/2005 15:04'!storeTemp: index	index = -1 "thisEnv" ifTrue: [		self doPending.		^ gen pushThisContext;			pushLiteral: MethodContext myEnvFieldIndex;			send: #privStoreIn:instVar:].	self addPending: (Message selector: #storeTemp: argument: index)! !!IRTranslator methodsFor: 'priv pending' stamp: 'ajh 6/22/2003 14:54'!addPending: message	pending addLast: currentInstr -> message! !!IRTranslator methodsFor: 'priv pending' stamp: 'ajh 3/13/2003 04:49'!doPending	"execute pending instructions"	| assoc |	[pending isEmpty] whileFalse: [		assoc _ pending removeFirst.		gen mapBytesTo: assoc key "instr".		assoc value "message" sendTo: gen.	].	gen mapBytesTo: currentInstr.! !!IRTranslator methodsFor: 'priv pending' stamp: 'ajh 6/5/2003 12:41'!pendingMatches: blocks	"Return true if each message at end of pending list satisfies its corresponding block.  The number of elements tested equals the number of blocks.  If not enough elements return false"	| messages i |	messages _ pending collect: [:assoc | assoc value].	blocks size > messages size ifTrue: [^ false].	i _ messages size - blocks size.	blocks do: [:b |		(b value: (messages at: (i _ i + 1))) ifFalse: [^ false].	].	^ true! !!IRTranslator methodsFor: 'priv pending' stamp: 'ajh 6/22/2003 21:06'!pendingSelector	pending isEmpty ifTrue: [^ nil].	^ pending last value "message" selector! !!IRTranslator methodsFor: 'priv pending' stamp: 'ajh 6/22/2003 21:06'!pendingSelector: selector	pending last value "message" setSelector: selector! !!IRTranslator methodsFor: 'priv pending' stamp: 'ajh 6/22/2003 14:27'!popPending	^ pending removeLast value "message"! !!IRTranslator methodsFor: 'results' stamp: 'ajh 6/28/2004 11:23'!compiledMethod	^ gen compiledMethodWith: trailerBytes! !!IRTranslator methodsFor: 'results' stamp: 'pmm 8/16/2006 20:55'!compiledMethodUsing: aCompiledMethodClass	^ gen compiledMethodWith: trailerBytes using: aCompiledMethodClass! !!IRTranslator methodsFor: 'results' stamp: 'ajh 3/13/2003 18:28'!compiledMethodWith: trailer	^ gen compiledMethodWith: trailer! !!IRTranslator methodsFor: 'results' stamp: 'pmm 8/16/2006 20:52'!compiledMethodWith: trailer using: aCompiledMethodClass	^ gen compiledMethodWith: trailer using: aCompiledMethodClass! !!IRTranslator methodsFor: 'initialize' stamp: 'ajh 6/28/2004 11:27'!initialize	gen _ BytecodeGenerator new.	trailerBytes _ #(0).! !!IRTranslator methodsFor: 'initialize' stamp: 'ajh 6/28/2004 11:23'!trailer: bytes	trailerBytes _ bytes! !!IRTranslator methodsFor: 'interpret' stamp: 'md 7/11/2005 22:23'!interpret: ir	ir optimize.	gen primitiveNode: ir primitiveNode.	gen numArgs: ir numArgs.	gen properties: ir properties.	ir additionalLiterals do: [:lit | gen addLiteral: lit].	super interpret: ir.! !!IRTranslator methodsFor: 'interpret' stamp: 'ajh 3/13/2003 18:07'!interpretAll: irSequences	irSequences withIndexDo: [:seq :i | seq orderNumber: i].	super interpretAll: irSequences.! !!IRTranslator methodsFor: 'interpret' stamp: 'ajh 3/13/2003 04:50'!interpretInstruction: irInstruction	currentInstr _ irInstruction.	super interpretInstruction: irInstruction.! !!IRTranslator commentStamp: 'ajh 3/25/2003 00:26' prior: 0!I interpret IRMethod instructions, sending the appropriate bytecode messages to my BytecodeGenerator (gen).  I hold some messages back in pending awaiting certain sequences of them that can be consolidated into single bytecode instructions, otherwise the pending messages are executed in order as if they were executed when they first appeared.!!ISO8601TimestampFormatter methodsFor: 'converting'!formatTimestamp: aTimestamp on: stream	self		print: aTimestamp year			on: stream			followedBy: $-			width: 4;		print: aTimestamp month			on: stream			followedBy: $-			width: 2;		print: aTimestamp day			on: stream			followedBy: Character space			width: 2;		print: aTimestamp hour			on: stream			followedBy: $:			width: 2;		print: aTimestamp minute			on: stream			followedBy: $:			width: 2;		print: aTimestamp second			on: stream			followedBy: $,			width: 2;		print: aTimestamp millisecond			on: stream			followedBy: nil			width: 3.	^stream contents			! !!ISO8601TimestampFormatter class methodsFor: '*Toothpick-Configuration'!mappingKey	^'iso'			! !!InlineAllMethodTest methodsFor: 'tests'!testInlineMethodWithMultipleSendersInMethod	| refactoring |	refactoring := InlineAllSendersRefactoring sendersOf: #caller2				in: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineLast) = (RBParser 							parseMethod: 'inlineLast	5 = 3 ifTrue: [^self caller] ifFalse: [^(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)]] ').	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #multipleCalls) = (RBParser 							parseMethod: 'multipleCalls	(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)].	(1 to: 10) inject: 1 into: [:sum1 :each1 | sum1 * (self foo: each1)]')! !!InlineAllMethodTest methodsFor: 'tests'!testRecursiveMethod	| class |	model := RBNamespace new.	class := model classNamed: self class name.	class		compile: 'foo ^self foo' classified: #(#accessing);		compile: 'bar ^self foo' classified: #(#accessing).	self executeRefactoring: (InlineAllSendersRefactoring 				model: model				sendersOf: #foo				in: class).	self assert: (class parseTreeFor: #foo) 				= (RBParser parseMethod: 'foo ^self foo').	self assert: (class parseTreeFor: #bar) 				= (RBParser parseMethod: 'bar ^self foo')! !!InlineAllSendersRefactoring methodsFor: 'transforming'!checkInlinedMethods	numberReplaced = 0 		ifTrue: [self refactoringError: 'Could not inline any senders']! !!InlineAllSendersRefactoring methodsFor: 'transforming'!inlineMessagesInClass: aClass andSelector: aSelector 	| messagesToInline previousCountOfMessages |	previousCountOfMessages := 4294967295.	"Some really large number > # of initial self sends."		[messagesToInline := self 				numberOfSelfSendsIn: (aClass parseTreeFor: aSelector).	messagesToInline > 0 and: [previousCountOfMessages > messagesToInline]] 			whileTrue: 				[| node |				previousCountOfMessages := messagesToInline.				node := self selfSendIn: (aClass parseTreeFor: aSelector).				self onError: 						[self performComponentRefactoring: (InlineMethodRefactoring 									model: self model									inline: node sourceInterval									inMethod: aSelector									forClass: aClass).						numberReplaced := numberReplaced + 1]					do: []].	numberNotReplaced := numberNotReplaced + messagesToInline! !!InlineAllSendersRefactoring methodsFor: 'transforming'!inlineSelfSends	class withAllSubclasses do: 			[:each | 			| selectors |			selectors := each selectors.			selectors remove: selector ifAbsent: [].			selectors do: [:sel | self inlineMessagesInClass: each andSelector: sel]]! !!InlineAllSendersRefactoring methodsFor: 'transforming'!messagePattern	^'self ' , (self buildSelectorString: selector)! !!InlineAllSendersRefactoring methodsFor: 'transforming'!numberOfSelfSendsIn: aParseTree 	| search |	search := ParseTreeSearcher new.	search matches: self messagePattern do: [:aNode :answer | answer + 1].	^search executeTree: aParseTree initialAnswer: 0! !!InlineAllSendersRefactoring methodsFor: 'transforming'!removeMethod	self onError: 			[self performComponentRefactoring: (RemoveMethodRefactoring 						model: self model						removeMethods: (Array with: selector)						from: class)]		do: []! !!InlineAllSendersRefactoring methodsFor: 'transforming'!selfSendIn: aTree 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: self messagePattern do: [:aNode :answer | ^aNode].	^searcher executeTree: aTree initialAnswer: nil! !!InlineAllSendersRefactoring methodsFor: 'transforming'!transform	self		inlineSelfSends;		removeMethod;		checkInlinedMethods! !!InlineAllSendersRefactoring methodsFor: 'accessing'!messagesNotReplaced	^numberNotReplaced! !!InlineAllSendersRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition canUnderstand: selector in: class! !!InlineAllSendersRefactoring methodsFor: 'initialize-release'!sendersOf: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	numberReplaced := numberNotReplaced := 0! !!InlineAllSendersRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' sendersOf: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!InlineAllSendersRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk sendersOf: aSelector in: aClass 	^(self new)		model: aRBSmalltalk;		sendersOf: aSelector in: aClass;		yourself! !!InlineAllSendersRefactoring class methodsFor: 'instance creation'!sendersOf: aSelector in: aClass 	^self new sendersOf: aSelector in: aClass! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!abstractVariableReferences	| refactoring |	refactoring := AbstractVariablesRefactoring 				model: self model				abstractVariablesIn: inlineParseTree				from: inlineClass				toAll: (Array with: class).	self performComponentRefactoring: refactoring.	inlineParseTree := refactoring parseTree! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!addArgumentToSelector: aSymbol 	^aSymbol isInfix 		ifTrue: [#value:value:]		ifFalse: [(aSymbol , 'value:') asSymbol]! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!addSelfReferenceToInlineParseTree	| variableName rewriter newArguments |	variableName := self newNameForSelf.	rewriter := ParseTreeRewriter rename: 'self' to: variableName.	(rewriter executeTree: inlineParseTree) 		ifTrue: [inlineParseTree := rewriter tree].	newArguments := inlineParseTree arguments asOrderedCollection.	newArguments addFirst: (RBVariableNode named: variableName).	inlineParseTree		arguments: newArguments;		selector: (self addArgumentToSelector: inlineParseTree selector).	sourceMessage receiver replaceWith: (RBVariableNode named: variableName)! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!addSelfReferenceToSourceMessage	| newArguments |	newArguments := sourceMessage arguments asOrderedCollection.	newArguments addFirst: sourceMessage receiver copy.	sourceMessage		arguments: newArguments;		selector: (self addArgumentToSelector: sourceMessage selector)! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!checkSuperMessages	inlineParseTree superMessages isEmpty 		ifFalse: 			[self 				refactoringError: 'Cannot inline method since it sends a super message']! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!findSelectedMessage	sourceParseTree := class parseTreeFor: sourceSelector.	sourceParseTree isNil 		ifTrue: [self refactoringError: 'Could not parse sources'].	sourceMessage := sourceParseTree whichNodeIsContainedBy: sourceInterval.	sourceMessage isNil 		ifTrue: 			[self 				refactoringError: 'The selection doesn''t appear to be a message send'].	sourceMessage isCascade 		ifTrue: [sourceMessage := sourceMessage messages last].	sourceMessage isMessage 		ifFalse: 			[self 				refactoringError: 'The selection doesn''t appear to be a message send']! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!inlineClass	| imps |	inlineClass notNil ifTrue: [^inlineClass].	imps := (self model allImplementorsOf: self inlineSelector) 				asOrderedCollection.	imps size = 1 ifTrue: [^inlineClass := imps first].	imps isEmpty 		ifTrue: 			[self 				refactoringError: 'Nobody defines a method named ' , self inlineSelector].	inlineClass := self requestImplementorToInline: imps.	inlineClass isNil 		ifTrue: [self refactoringError: 'No implementor selected'].	^inlineClass! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!newNameForSelf	| variableName index originalName nonMetaClass |	nonMetaClass := inlineClass nonMetaclass.	variableName := originalName := (nonMetaClass name first isVowel 						ifTrue: ['an']						ifFalse: ['a']) , nonMetaClass name.	index := 1.		[variableName := self safeVariableNameBasedOn: variableName.	inlineParseTree allDefinedVariables includes: variableName] 			whileTrue: 				[variableName := originalName , index printString.				index := index + 1].	^variableName! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!renameSelfReferences	self addSelfReferenceToSourceMessage.	self addSelfReferenceToInlineParseTree.! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!safeVariableNameBasedOn: aString 	"Creates an unused variable name containing aString"	| baseString newString i allTempVars |	allTempVars := inlineParseTree allTemporaryVariables.	baseString := aString copy.	baseString at: 1 put: baseString first asLowercase.	newString := baseString.	i := 0.		[(allTempVars includes: newString) 		or: [class definesInstanceVariable: newString]] 			whileTrue: 				[i := i + 1.				newString := baseString , i printString].	^newString! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!transform	self abstractVariableReferences.	self renameSelfReferences.	super transform! !!InlineMethodFromComponentRefactoring methodsFor: 'testing'!isOverridden	^(self inlineClass allSubclasses 		detect: [:each | each directlyDefinesMethod: self inlineSelector]		ifNone: [nil]) notNil! !!InlineMethodFromComponentTest methodsFor: 'tests'!testInlineComponentIntoCascadedMessage	| refactoring |	self proceedThroughWarning: 			[refactoring := InlineMethodFromComponentRefactoring 						inline: (self convertInterval: (35 to: 79)								for: (RefactoryTestDataApp sourceCodeAt: #inlineComponent))						inMethod: #inlineComponent						forClass: RefactoryTestDataApp.			(refactoring model classNamed: #Behavior) 				compile: 'hasImmediateInstances ^self format = 0'				classified: #(#accessing).			self setupInlineExpressionFor: refactoring toReturn: false.			self executeRefactoring: refactoring].	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineComponent) = (RBParser 							parseMethod: 'inlineComponent	| a aBehavior |	a := 5.	aBehavior := a class.	aBehavior superclass.	aBehavior format = 0.	^aBehavior yourself')! !!InlineMethodFromComponentTest methodsFor: 'tests'!testInlineComponentMethodMax	| refactoring |	self proceedThroughWarning: 			[| class |			refactoring := InlineMethodFromComponentRefactoring 						inline: (self convertInterval: (47 to: 58)								for: (RefactoryTestDataApp sourceCodeAt: #inlineMax))						inMethod: #inlineMax						forClass: RefactoryTestDataApp.			self setupInlineExpressionFor: refactoring toReturn: true.			class := refactoring model classNamed: #Magnitude.			class 				compile: 'max: aMagnitude 					"Answer the receiver or the argument, whichever has the greater magnitude."					self > aMagnitude						ifTrue: [^self]						ifFalse: [^aMagnitude]'				classified: #(#accessing).			self setupImplementorToInlineFor: refactoring toReturn: class.			self executeRefactoring: refactoring].	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineMax) = (RBParser 							parseMethod: 'inlineMax								| x y q |								x := 5.								y := 10.								q := x + 1 > y									ifTrue: [x + 1]									ifFalse: [y].								^q')! !!InlineMethodFromComponentTest methodsFor: 'tests'!testInlineEmptyComponentMethod	| refactoring |	self proceedThroughWarning: 			[refactoring := InlineMethodFromComponentRefactoring 						inline: (self convertInterval: (35 to: 91)								for: (RefactoryTestDataApp sourceCodeAt: #inlineComponent))						inMethod: #inlineComponent						forClass: RefactoryTestDataApp.			self setupInlineExpressionFor: refactoring toReturn: false.			self executeRefactoring: refactoring].	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineComponent) = (RBParser 							parseMethod: 'inlineComponent	| a anObject |	a := 5.	anObject := a class.	anObject superclass.	anObject hasImmediateInstances.	^anObject')! !!InlineMethodFromComponentTest methodsFor: 'tests'!testModelInlineMethodWithSameVariableNames	| class refactoring |	model := RBNamespace new.	class := model classNamed: self class name.	class compile: 'a9: a b9: b ^self + a + b' classified: #(#accessing).	(model classNamed: #Object) 		compile: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^a a9: b b9: c'		classified: #(#accessing).	self proceedThroughWarning: 			[refactoring := InlineMethodFromComponentRefactoring 						model: model						inline: (72 to: 84)						inMethod: #foo						forClass: (model classNamed: #Object).			self setupInlineExpressionFor: refactoring toReturn: false.			self executeRefactoring: refactoring].	self assert: ((refactoring model classNamed: #Object) parseTreeFor: #foo) 				= (RBParser 						parseMethod: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^a + b + c')! !!InlineMethodFromComponentTest methodsFor: 'tests'!testModelInlineMethodWithSameVariableNames1	| class refactoring |	model := RBNamespace new.	class := model classNamed: #Rectangle.	class 		compile: 'rectangleRelativeTo: aRectangle ^self origin extent: aRectangle extent'		classified: #(#accessing).	(model classNamed: #Object) 		compile: 'foo | aRectangle temp | aRectangle := 0@0 corner: 1@1. temp := aRectangle. ^aRectangle rectangleRelativeTo: temp'		classified: #(#accessing).	self proceedThroughWarning: 			[refactoring := InlineMethodFromComponentRefactoring 						model: model						inline: (77 to: 112)						inMethod: #foo						forClass: (model classNamed: #Object).			self setupInlineExpressionFor: refactoring toReturn: false.			self setupImplementorToInlineFor: refactoring toReturn: class.			self executeRefactoring: refactoring].	self assert: ((refactoring model classNamed: #Object) parseTreeFor: #foo) 				= (RBParser 						parseMethod: 'foo | aRectangle temp | aRectangle := 0@0 corner: 1@1. temp := aRectangle. ^aRectangle origin extent: temp extent')! !!InlineMethodFromComponentTest methodsFor: 'tests'!testModelInlineMethodWithSameVariableNames2	| class refactoring |	model := RBNamespace new.	class := model classNamed: self class name.	class compile: 'a9: a b9: b ^self + a + b' classified: #(#accessing).	(model classNamed: #Object) 		compile: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^c a9: b b9: a'		classified: #(#accessing).	self proceedThroughWarning: 			[refactoring := InlineMethodFromComponentRefactoring 						model: model						inline: (72 to: 84)						inMethod: #foo						forClass: (model classNamed: #Object).			self setupInlineExpressionFor: refactoring toReturn: false.			self executeRefactoring: refactoring].	self assert: ((refactoring model classNamed: #Object) parseTreeFor: #foo) 				= (RBParser 						parseMethod: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^c + b + a')! !!InlineMethodFromComponentTest methodsFor: 'failure tests'!testInlineMethodFromComponentFailure	self shouldFail: (InlineMethodFromComponentRefactoring 				inline: (self convertInterval: (50 to: 64)						for: (RefactoryTestDataApp sourceCodeAt: #inlineFailed))				inMethod: #inlineFailed				forClass: RefactoryTestDataApp)! !!InlineMethodRefactoring methodsFor: 'transforming'!addSelfReturn	inlineParseTree addSelfReturn! !!InlineMethodRefactoring methodsFor: 'transforming'!addTemporary: sourceNode assignedTo: replacementNode 	| newName |	newName := self renameConflictingTemporary: sourceNode name.	(inlineParseTree body)		addTemporaryNamed: newName;		addNodeFirst: (RBAssignmentNode variable: (RBVariableNode named: newName)					value: replacementNode)! !!InlineMethodRefactoring methodsFor: 'transforming'!checkSuperMessages	self inlineClass = class ifTrue: [^self].	self inlineClass superclass isNil ifTrue: [^self].	inlineParseTree superMessages do: 			[:each | 			(self inlineClass superclass whoDefinesMethod: each) 				= (class superclass whoDefinesMethod: each) 					ifFalse: 						[self 							refactoringError: ('Cannot inline method since it sends a super message <1s> that is overriden' 									expandMacrosWith: each)]]! !!InlineMethodRefactoring methodsFor: 'transforming'!compileMethod	class compileTree: sourceParseTree! !!InlineMethodRefactoring methodsFor: 'transforming'!findSelectedMessage	sourceParseTree := class parseTreeFor: sourceSelector.	sourceParseTree isNil 		ifTrue: [self refactoringError: 'Could not parse sources'].	sourceMessage := sourceParseTree whichNodeIsContainedBy: sourceInterval.	sourceMessage isNil 		ifTrue: 			[self 				refactoringError: 'The selection doesn''t appear to be a message send'].	sourceMessage isCascade 		ifTrue: [sourceMessage := sourceMessage messages last].	sourceMessage isMessage 		ifFalse: 			[self 				refactoringError: 'The selection doesn''t appear to be a message send'].	(sourceMessage receiver isVariable 		and: [#('self' 'super') includes: sourceMessage receiver name]) 			ifFalse: [self refactoringError: 'Cannot inline non-self messages']! !!InlineMethodRefactoring methodsFor: 'transforming'!inlineClass	^inlineClass isNil 		ifTrue: 			[inlineClass := (sourceMessage receiver name = 'super' 						ifTrue: [class superclass]						ifFalse: [class]) whoDefinesMethod: self inlineSelector]		ifFalse: [inlineClass]! !!InlineMethodRefactoring methodsFor: 'transforming'!inlineSelector	sourceMessage isNil ifTrue: [self findSelectedMessage].	^sourceMessage selector! !!InlineMethodRefactoring methodsFor: 'transforming'!inlineSourceReplacing: aParseTree 	| statements nodeUnderSequence |	statements := inlineParseTree body statements.	(statements size > 1 and: [aParseTree isEvaluatedFirst not]) 		ifTrue: 			[self 				refactoringWarning: 'To inline this method, we need to move some of its statements before the original message send.<n>This could change the order of execution, which can change the behavior.<n>Do you want to proceed?' 						expandMacros].	nodeUnderSequence := aParseTree.	[nodeUnderSequence parent isSequence] 		whileFalse: [nodeUnderSequence := nodeUnderSequence parent].	(nodeUnderSequence parent)		addNodes: (statements copyFrom: 1 to: (statements size - 1 max: 0))			before: nodeUnderSequence;		addTemporariesNamed: inlineParseTree body temporaryNames.	aParseTree parent replaceNode: aParseTree		withNode: (statements isEmpty 				ifTrue: [RBVariableNode named: 'self']				ifFalse: [statements last])! !!InlineMethodRefactoring methodsFor: 'transforming'!insertInlinedMethod	| node |	node := sourceMessage.	self moveComments.	node parent isCascade 		ifTrue: 			[self rewriteCascadedMessage.			node := node parent].	node parent isReturn 		ifTrue: [node := node parent]		ifFalse: [self removeReturns].	self replaceArguments.	self inlineSourceReplacing: node.	sourceParseTree removeDeadCode.	self removeEmptyIfTrues.	self removeImmediateBlocks! !!InlineMethodRefactoring methodsFor: 'transforming'!moveComments	inlineParseTree nodesDo: 			[:each | 			each 				comments: (each comments collect: 							[:anInterval | 							| start stop source |							source := sourceParseTree source.							start := source size + 1.							source := source 										, (inlineParseTree source copyFrom: anInterval first to: anInterval last).							stop := source size.							sourceParseTree source: source.							start to: stop])]! !!InlineMethodRefactoring methodsFor: 'transforming'!normalizeIfTrues	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: '| `@temps | ``@.s1. ``@boolean ifTrue: [| `@t1 | ``@.Stmts1. ^`@r1]. ``@.s2. ^``@r2'			with: '| `@temps | ``@.s1. ``@boolean ifTrue: [| `@t1 | ``@.Stmts1. ^`@r1] ifFalse: [``@.s2. ^``@r2]';		replace: '| `@temps | ``@.s1. ``@boolean ifFalse: [| `@t1 | ``@.Stmts1. ^`@r1]. ``@.s2. ^``@r2'			with: '| `@temps | ``@.s1. ``@boolean ifTrue: [``@.s2. ^``@r2] ifFalse: [| `@t1 | ``@.Stmts1. ^`@r1]'.	[rewriter executeTree: inlineParseTree] 		whileTrue: [inlineParseTree := rewriter tree]! !!InlineMethodRefactoring methodsFor: 'transforming'!normalizeReturns	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]'			with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]'			with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]'.	[rewriter executeTree: inlineParseTree] 		whileTrue: [inlineParseTree := rewriter tree]! !!InlineMethodRefactoring methodsFor: 'transforming'!parseInlineMethod	self inlineClass isNil 		ifTrue: 			[self 				refactoringError: ('<1p> or its superclasses don''t contain method <2s>' 						expandMacrosWith: class						with: self inlineSelector)].	inlineParseTree := self inlineClass parseTreeFor: self inlineSelector.	inlineParseTree isNil 		ifTrue: [self refactoringError: 'Could not parse sources'].	inlineParseTree lastIsReturn ifFalse: [inlineParseTree addSelfReturn]! !!InlineMethodRefactoring methodsFor: 'transforming'!removeEmptyIfTrues	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: '``@boolean ifTrue: [] ifFalse: [| `@temps | ``@.Stmts]'			with: '``@boolean ifFalse: [|`@temps | ``@.Stmts]';		replace: '``@boolean ifFalse: [] ifTrue: [| `@temps | ``@.Stmts]'			with: '``@boolean ifTrue: [|`@temps | ``@.Stmts]';		replace: '``@boolean ifTrue: [| `@temps | ``@.Stmts] ifFalse: []'			with: '``@boolean ifTrue: [|`@temps | ``@.Stmts]';		replace: '``@boolean ifFalse: [| `@temps | ``@.Stmts] ifTrue: []'			with: '``@boolean ifFalse: [|`@temps | ``@.Stmts]'.	(rewriter executeTree: sourceParseTree) 		ifTrue: [sourceParseTree := rewriter tree]! !!InlineMethodRefactoring methodsFor: 'transforming'!removeImmediateBlocks	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter 		replace: '[``.object] value'		with: '``.object'		when: [:aNode | aNode parent isCascade not].	rewriter 		replace: '| `@temps | ``@.Stmts1. [| `@bTemps | ``@.bStmts] value. ``@.Stmts2'		with: '| `@temps `@bTemps | ``@.Stmts1. ``@.bStmts. ``@.Stmts2'.	(rewriter executeTree: sourceParseTree) 		ifTrue: [sourceParseTree := rewriter tree]! !!InlineMethodRefactoring methodsFor: 'transforming'!removeReturns	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter replace: '^``@object' with: '``@object'.	(rewriter executeTree: inlineParseTree) 		ifTrue: [inlineParseTree := rewriter tree]! !!InlineMethodRefactoring methodsFor: 'transforming'!renameConflictingTemporaries	inlineParseTree allDefinedVariables 		do: [:each | self renameConflictingTemporary: each]! !!InlineMethodRefactoring methodsFor: 'transforming'!renameConflictingTemporary: aName 	| allNames newName index seqNode |	allNames := (Set new)				addAll: inlineParseTree allDefinedVariables;				yourself.	allNames remove: aName ifAbsent: [].	seqNode := sourceMessage.	[seqNode isSequence] whileFalse: [seqNode := seqNode parent].	allNames addAll: seqNode allDefinedVariables.	"Add those variables defined in blocks. This might cause a few 													variables to be renamed that don't need to be, but this should be safe."	newName := aName.	index := 0.		[(sourceMessage whoDefines: newName) notNil or: 			[(class hierarchyDefinesVariable: newName) or: [allNames includes: newName]]] 			whileTrue: 				[index := index + 1.				newName := aName , index printString].	newName = aName ifFalse: [self renameTemporary: aName to: newName].	^newName! !!InlineMethodRefactoring methodsFor: 'transforming'!renameTemporary: oldName to: newName 	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: oldName with: newName;		replaceArgument: oldName with: newName.	(rewriter executeTree: inlineParseTree) 		ifTrue: [inlineParseTree := rewriter tree]! !!InlineMethodRefactoring methodsFor: 'transforming'!replaceArgument: sourceNode with: replacementNode 	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter replaceTree: sourceNode withTree: replacementNode.	(rewriter executeTree: inlineParseTree body) 		ifTrue: [inlineParseTree body: rewriter tree]! !!InlineMethodRefactoring methodsFor: 'transforming'!replaceArguments	sourceMessage arguments reverse with: inlineParseTree arguments reverse		do: 			[:replacement :source | 			(replacement isImmediate 				or: [self shouldInlineExpression: replacement formattedCode]) 					ifTrue: [self replaceArgument: source with: replacement]					ifFalse: [self addTemporary: source assignedTo: replacement]]! !!InlineMethodRefactoring methodsFor: 'transforming'!rewriteCascadedMessage	| index messages |	messages := sourceMessage parent messages.	index := (1 to: messages size) 				detect: [:i | sourceMessage == (messages at: i)]				ifNone: [0].	inlineParseTree body addNodesFirst: (messages copyFrom: 1 to: index - 1).	self removeReturns.	inlineParseTree body 		addNodes: (messages copyFrom: index + 1 to: messages size).	inlineParseTree addReturn! !!InlineMethodRefactoring methodsFor: 'transforming'!rewriteInlinedTree	sourceMessage parent isReturn 		ifTrue: 			[(sourceParseTree isLast: sourceMessage parent) 				ifFalse: [self addSelfReturn]]		ifFalse: 			[self				writeGuardClauses;				normalizeIfTrues;				normalizeReturns;				addSelfReturn]! !!InlineMethodRefactoring methodsFor: 'transforming'!transform	self		renameConflictingTemporaries;		insertInlinedMethod;		compileMethod! !!InlineMethodRefactoring methodsFor: 'transforming'!writeGuardClauses	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2. ^`@r2'			with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1] ifFalse: [`@.s2. ^`@r2]';		replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2. ^`@r2'			with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [`@.s2. ^`@r2] ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]';		replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2'			with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1] ifFalse: [`@.s2. ^self]';		replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2'			with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [`@.s2. ^self] ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]'.	[rewriter executeTree: inlineParseTree] 		whileTrue: [inlineParseTree := rewriter tree]! !!InlineMethodRefactoring methodsFor: 'testing'!hasMultipleReturns	"Do we have multiple returns? If the last statement isn't a return, then we have an implicit return of self."	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '^``@object'		do: 			[:aNode :hasAReturn | 			hasAReturn ifTrue: [^true].			true].	searcher executeTree: inlineParseTree		initialAnswer: inlineParseTree lastIsReturn not.	^false! !!InlineMethodRefactoring methodsFor: 'testing'!isOverridden	^(class allSubclasses detect: [:each | each directlyDefinesMethod: self inlineSelector]		ifNone: [nil]) notNil! !!InlineMethodRefactoring methodsFor: 'testing'!isPrimitive	^inlineParseTree isPrimitive! !!InlineMethodRefactoring methodsFor: 'initialize-release'!inline: anInterval inMethod: aSelector forClass: aClass 	sourceSelector := aSelector.	class := self classObjectFor: aClass.	sourceInterval := anInterval! !!InlineMethodRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: sourceSelector in: class) 		& (RBCondition withBlock: 					[self findSelectedMessage.					self isOverridden 						ifTrue: 							[self 								refactoringWarning: ('<1p>>><2s> is overriden. Do you want to inline it anyway?' 										expandMacrosWith: self inlineClass										with: self inlineSelector)].					self parseInlineMethod.					self isPrimitive 						ifTrue: [self refactoringError: 'Cannot inline primitives'].					self checkSuperMessages.					self rewriteInlinedTree.					(sourceMessage parent isReturn or: [self hasMultipleReturns not]) 						ifFalse: 							[self 								refactoringError: 'Cannot inline method since it contains multiple returns that cannot be rewritten'].					true])! !!InlineMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' inline: '.	sourceInterval storeOn: aStream.	aStream		nextPutAll: ' inMethod: #';		nextPutAll: sourceSelector;		nextPutAll: ' forClass: '.	class storeOn: aStream.	aStream nextPut: $)! !!InlineMethodRefactoring class methodsFor: 'instance creation'!inline: anInterval inMethod: aSelector forClass: aClass 	^self new 		inline: anInterval		inMethod: aSelector		forClass: aClass! !!InlineMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk inline: anInterval inMethod: aSelector forClass: aClass 	^(self new)		model: aRBSmalltalk;		inline: anInterval			inMethod: aSelector			forClass: aClass;		yourself! !!InlineMethodTest methodsFor: 'failure tests'!testBadInterval	self		shouldFail: (InlineMethodRefactoring 					inline: (self convertInterval: (13 to: 23)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					inMethod: #testMethod					forClass: RefactoryTestDataApp);		shouldFail: (InlineMethodRefactoring 					inline: (self convertInterval: (14 to: 17)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					inMethod: #testMethod					forClass: RefactoryTestDataApp);		shouldFail: (InlineMethodRefactoring 					inline: (self convertInterval: (24 to: 30)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					inMethod: #testMethod					forClass: RefactoryTestDataApp);		shouldFail: (InlineMethodRefactoring 					inline: (self convertInterval: (1 to: 30)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					inMethod: #testMethod					forClass: RefactoryTestDataApp)! !!InlineMethodTest methodsFor: 'failure tests' stamp: 'md 7/25/2005 18:14'!testInlineMethodForSuperSendThatAlsoSendsSuper	| refactoring |	model := Compiler evaluate: self inlineMethodTestData.	refactoring := InlineMethodRefactoring 				inline: (102 to: 131)				inMethod: #executeNotifying:				forClass: (model classNamed: #RenameInstanceVariableChange).	self shouldFail: refactoring! !!InlineMethodTest methodsFor: 'failure tests'!testNonExistantSelector	self shouldFail: (InlineMethodRefactoring 				inline: (14 to: 17)				inMethod: #checkClass1:				forClass: RefactoryTestDataApp)! !!InlineMethodTest methodsFor: 'failure tests'!testOverriden	self shouldWarn: (InlineMethodRefactoring 				inline: (self convertInterval: (15 to: 26)						for: (LintRuleTest sourceCodeAt: #failedRules))				inMethod: #failedRules				forClass: LintRuleTest)! !!InlineMethodTest methodsFor: 'failure tests'!testPrimitive	self shouldFail: (InlineMethodRefactoring 				inline: (self convertInterval: (14 to: 23)						for: (RefactoryTestDataApp sourceCodeAt: #testMethod))				inMethod: #testMethod				forClass: RefactoryTestDataApp)! !!InlineMethodTest methodsFor: 'failure tests'!testReturn	self shouldFail: (InlineMethodRefactoring 				inline: (self convertInterval: (418 to: 485)						for: (BasicLintRuleTest class sourceCodeAt: #utilityMethods))				inMethod: #utilityMethods				forClass: BasicLintRuleTest class)! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (455 to: 504)						for: (BasicLintRuleTest class 								sourceCodeAt: #sentNotImplementedInApplication))				inMethod: #sentNotImplementedInApplication				forClass: BasicLintRuleTest class.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model metaclassNamed: #BasicLintRuleTest) 				parseTreeFor: #sentNotImplementedInApplication) = (RBParser 							parseMethod: 'sentNotImplementedInApplication									| detector |									detector := self new.									detector name: ''Messages sent but not implemented in application''.									detector methodBlock: 											[:context :result | 											| message class block |											message := context messages 														detect: [:each | (context isItem: each in: context application) not]														ifNone: [nil].											class := context selectedClass.											block := 													[:each | 													| app methodApp root |													app := context application.													((class canUnderstand: each) 														ifTrue: 															[root := app rootApplication.															methodApp := ((class whichClassIncludesSelector: each) 																		compiledMethodAt: each) application 																		rootApplication.															methodApp == root or: [root isBasedOn: methodApp]]														ifFalse: [false]) not].											message isNil 												ifTrue: [message := context selfMessages detect: block ifNone: [nil]].											message isNil 												ifTrue: 													[class := class superclass.													class isNil 														ifTrue: 															[context superMessages isEmpty 																ifFalse: [message := context superMessages asArray first]]														ifFalse: [message := context superMessages detect: block ifNone: [nil]]].											message notNil 												ifTrue: 													[result addSearchString: message.													result addClass: context selectedClass selector: context selector]].									^detector')! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod1	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (39 to: 84)						for: (RefactoryTestDataApp sourceCodeAt: #caller))				inMethod: #caller				forClass: RefactoryTestDataApp.	self setupInlineExpressionFor: refactoring toReturn: false.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #caller) = (RBParser 							parseMethod: 'caller 									| anObject anObject1 | 									anObject := 5.									anObject1 := anObject + 1.									Transcript										show: anObject1 printString;										cr.									^anObject')! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod2	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (40 to: 120)						for: (RefactoryTestDataApp sourceCodeAt: #caller1))				inMethod: #caller1				forClass: RefactoryTestDataApp.	self setupInlineExpressionFor: refactoring toReturn: false.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #caller1) = (RBParser 							parseMethod: 'caller1 								| anObject each1 anObject1 | 								anObject := 5.								anObject1 := anObject + 1.								each1 := anObject1 printString.								Transcript									show: each1;									cr.								[:each | each printString. ^anObject] value: each1')! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod3	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (58 to: 73)						for: (RefactoryTestDataApp sourceCodeAt: #caller2))				inMethod: #caller2				forClass: RefactoryTestDataApp.	self setupInlineExpressionFor: refactoring toReturn: false.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #caller2) = (RBParser 							parseMethod: 'caller2								^(1 to: 10) inject: 1 into: [:sum :each | sum * ((1 to: 10) inject: each into: [:sum1 :each1 | sum1 + each1])]	')! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod4	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (31 to: 112)						for: (RefactoryTestDataApp sourceCodeAt: #inlineJunk))				inMethod: #inlineJunk				forClass: RefactoryTestDataApp.	self setupInlineExpressionFor: refactoring toReturn: false.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineJunk) = (RBParser 							parseMethod: 'inlineJunk										| asdf bar1 baz1 asdf1 |										bar1 := 												[:each | 												| temp |												temp := each.												temp , temp] value: self.										baz1 := bar1 + bar1.										asdf1 := baz1 + bar1.										asdf := asdf1.										^asdf foo: 												[:bar | 												| baz |												baz := bar.												baz * baz]')! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod5	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (53 to: 64)						for: (RefactoryTestDataApp sourceCodeAt: #inlineLast))				inMethod: #inlineLast				forClass: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineLast) = (RBParser 							parseMethod: 'inlineLast									5 = 3 ifTrue: [^self caller] ifFalse: [^	(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)]]')! !!InlineMethodTest methodsFor: 'tests' stamp: 'md 7/25/2005 18:14'!testInlineMethodForSuperSend	| refactoring |	model := Compiler evaluate: self inlineMethodTestData.	(model classNamed: #RenameVariableChange) removeMethod: #executeNotifying:.	refactoring := InlineMethodRefactoring 				model: model				inline: (self convertInterval: (102 to: 131)						for: ((model classNamed: #RenameInstanceVariableChange) 								sourceCodeFor: #executeNotifying:))				inMethod: #executeNotifying:				forClass: (model classNamed: #RenameInstanceVariableChange).	self executeRefactoring: refactoring.	self 		assert: ((model classNamed: #RenameInstanceVariableChange) 				parseTreeFor: #executeNotifying:) = (RBParser 							parseMethod: 'executeNotifying: aBlock 									| undo undos undo1 |									self addNewVariable.									self copyOldValuesToNewVariable.									undos := changes collect: [:each | each executeNotifying: aBlock].									undo1 := self copy.									undo1 changes: undos reverse.									undo := undo1.									self removeOldVariable.									^undo')! !!InlineMethodTest methodsFor: 'tests'!testInlineRecursiveCascadedMethod	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (33 to: 62)						for: (RefactoryTestDataApp sourceCodeAt: #inlineMethod))				inMethod: #inlineMethod				forClass: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineMethod) = (RBParser 							parseMethod: 'inlineMethod									| temp temp1 |									self foo.									temp1 := self foo; inlineMethod; bar.									temp := self bar.									^temp')! !!InlineMethodTest methodsFor: 'tests'!testModelInlineRecursiveMethod	| refactoring class |	class := model classNamed: #Object.	class compile: 'foo self bar. self foo. self bar' classified: #(#accessing).	refactoring := InlineMethodRefactoring 				model: model				inline: (15 to: 23)				inMethod: #foo				forClass: class.	self executeRefactoring: refactoring.	self 		assert: (class parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo self bar. self bar. self foo. self bar. self bar')! !!InlineParameterRefactoring methodsFor: 'private'!allExpressionsToInline	| coll |	coll := Set new.	self model allReferencesTo: oldSelector		do: 			[:each | 			| tree |			tree := each parseTree.			tree notNil ifTrue: [coll addAll: (self expressionsToInlineFrom: tree)]].	^coll asOrderedCollection! !!InlineParameterRefactoring methodsFor: 'private'!expressionsToInlineFrom: aTree 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '``@obj ' , (self buildSelectorString: oldSelector)		do: 			[:aNode :answer | 			answer				add: (aNode arguments at: parameterIndex);				yourself].	^searcher executeTree: aTree initialAnswer: OrderedCollection new! !!InlineParameterRefactoring methodsFor: 'initialize-release'!inlineParameter: aString in: aClass selector: aSelector	oldSelector := aSelector.	class := self classObjectFor: aClass.	argument := aString! !!InlineParameterRefactoring methodsFor: 'transforming'!modifyImplementorParseTree: parseTree in: aClass 	| node assignment |	node := (parseTree arguments at: parameterIndex) copy.	parseTree body addTemporaryNamed: node name.	assignment := RBAssignmentNode variable: node copy value: expressions first.	parseTree body addNodeFirst: assignment.	super modifyImplementorParseTree: parseTree in: aClass! !!InlineParameterRefactoring methodsFor: 'preconditions'!myConditions	self getNewSelector.	expressions := self allExpressionsToInline.	^(RBCondition definesSelector: oldSelector in: class) 		& ((RBCondition withBlock: [expressions isEmpty not]) 				errorMacro: 'No callers. Use Remove Method instead.') 			& ((RBCondition withBlock: [expressions size = 1]) 					errorMacro: 'All values passed as this argument must be identical.') 			& ((RBCondition withBlock: [expressions first isLiteral]) 					errorMacro: 'All values passed must be literal.')! !!InlineParameterRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' inlineParameter: ''';		nextPutAll: argument;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: oldSelector;		nextPut: $)! !!InlineParameterRefactoring class methodsFor: 'instance creation'!inlineParameter: aString in: aClass selector: aSelector 	^self new 		inlineParameter: aString		in: aClass		selector: aSelector! !!InlineParameterRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk inlineParameter: aString in: aClass selector: aSelector 	^(self new)		model: aRBSmalltalk;		inlineParameter: aString			in: aClass			selector: aSelector;		yourself! !!InlineParameterTest methodsFor: 'failure tests'!testInlineBlockFailure	self shouldFail: (InlineParameterRefactoring 				inlineParameter: 'aBlock'				in: RefactoryTestDataApp				selector: ('inline' , 'Foo:') asSymbol)! !!InlineParameterTest methodsFor: 'tests'!testInlineLiteralArray	| refactoring class |	refactoring := InlineParameterRefactoring 				inlineParameter: 'aSymbol'				in: RefactoryTestDataApp				selector: ('inline' , 'ParameterMethod:') asSymbol.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: #inlineParameterMethod) = (RBParser 						parseMethod: 'inlineParameterMethod | aSymbol | aSymbol := #(asdf). ^aSymbol isSymbol').	self 		assert: (class parseTreeFor: #sendInlineParameterMethod) = (RBParser 						parseMethod: 'sendInlineParameterMethod ^self inlineParameterMethod').	self deny: (class 				directlyDefinesMethod: ('inline' , 'ParameterMethod:') asSymbol)! !!InlineTemporaryRefactoring methodsFor: 'transforming'!compileMethod	class compileTree: sourceTree! !!InlineTemporaryRefactoring methodsFor: 'transforming'!replaceAssignment	assignmentNode parent isSequence 		ifTrue: [assignmentNode parent removeNode: assignmentNode]		ifFalse: [assignmentNode replaceWith: assignmentNode value]! !!InlineTemporaryRefactoring methodsFor: 'transforming'!replaceReferences	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter replaceTree: assignmentNode variable		withTree: assignmentNode value.	definingNode removeTemporaryNamed: assignmentNode variable name.	rewriter executeTree: definingNode! !!InlineTemporaryRefactoring methodsFor: 'transforming'!transform	self		replaceAssignment;		replaceReferences;		compileMethod! !!InlineTemporaryRefactoring methodsFor: 'testing'!hasOnlyOneAssignment	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: assignmentNode variable name , ' := ``@object'		do: [:aNode :answer | answer + 1].	^(searcher executeTree: definingNode initialAnswer: 0) == 1! !!InlineTemporaryRefactoring methodsFor: 'initialize-release'!inline: anInterval from: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	sourceInterval := anInterval! !!InlineTemporaryRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition withBlock: 					[self verifySelectedInterval.					true])! !!InlineTemporaryRefactoring methodsFor: 'preconditions'!verifySelectedInterval	sourceTree := class parseTreeFor: selector.	sourceTree isNil ifTrue: [self refactoringError: 'Could not parse source'].	assignmentNode := sourceTree whichNodeIsContainedBy: sourceInterval.	assignmentNode isAssignment 		ifFalse: 			[self refactoringError: 'The selected node is not an assignment statement'].	definingNode := assignmentNode whoDefines: assignmentNode variable name.	self hasOnlyOneAssignment 		ifFalse: 			[self refactoringError: 'There are multiple assignments to the variable'].	(RBReadBeforeWrittenTester isVariable: assignmentNode variable name		writtenBeforeReadIn: definingNode) 			ifFalse: 				[self 					refactoringError: 'The variable is possible read before it is assigned']! !!InlineTemporaryRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' inline: '.	sourceInterval storeOn: aStream.	aStream		nextPutAll: ' from: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!InlineTemporaryRefactoring class methodsFor: 'instance creation'!inline: anInterval from: aSelector in: aClass 	^self new 		inline: anInterval		from: aSelector		in: aClass! !!InlineTemporaryRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk inline: anInterval from: aSelector in: aClass 	^(self new)		model: aRBSmalltalk;		inline: anInterval			from: aSelector			in: aClass;		yourself! !!InlineTemporaryTest methodsFor: 'tests'!testInlineTemporary	| refactoring |	refactoring := InlineTemporaryRefactoring 				inline: (self convertInterval: (24 to: 72)						for: (RefactoryTestDataApp sourceCodeAt: #inlineMethod))				from: #inlineMethod				in: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineMethod) = (RBParser 							parseMethod: 'inlineMethod										^self													foo;													inlineMethod;													bar')! !!InlineTemporaryTest methodsFor: 'tests'!testInlineTemporaryBadInterval	self shouldFail: (InlineTemporaryRefactoring 				inline: (self convertInterval: (29 to: 100)						for: (RefactoryTestDataApp sourceCodeAt: #moveDefinition))				from: #moveDefinition				in: RefactoryTestDataApp)! !!InlineTemporaryTest methodsFor: 'tests'!testInlineTemporaryMutlipleAssignment	self shouldFail: (InlineTemporaryRefactoring 				inline: (self convertInterval: (60 to: 83)						for: (RefactoryTestDataApp sourceCodeAt: #moveDefinition))				from: #moveDefinition				in: RefactoryTestDataApp)! !!InlineTemporaryTest methodsFor: 'tests'!testInlineTemporaryReadBeforeWritten	self shouldFail: (InlineTemporaryRefactoring 				inline: (self convertInterval: (48 to: 56)						for: (RefactoryTestDataApp sourceCodeAt: #inlineTemporary))				from: #inlineTemporary				in: RefactoryTestDataApp)! !!InstanceScope methodsFor: 'lookup' stamp: 'ajh 7/8/2004 14:55'!closestEnvScope	"If self has its own env return self, otherwise return first outer scope with its own env"	^ self! !!InstanceScope methodsFor: 'lookup' stamp: 'ajh 6/28/2004 16:36'!hasEscapingEnv	^ true! !!InstanceScope methodsFor: 'lookup' stamp: 'ms 7/3/2007 16:01'!instVar: index	^vars detect:[:each | each index == index]! !!InstanceScope methodsFor: 'lookup' stamp: 'ajh 6/24/2004 03:02'!lookupVar: name	"Return a SemVar for my pool var with this name.  Return nil if none found"	^ vars at: name ifAbsent: [self outerScope lookupVar: name]! !!InstanceScope methodsFor: 'lookup' stamp: 'ajh 6/24/2004 03:03'!possibleVarsFor: name continued: listOrNil	"Return my var names that are close in spelling to name"	| list |	list _ name first isLowercase		ifTrue: [name correctAgainstDictionary: vars continuedFrom: listOrNil]		ifFalse: [listOrNil].	^ self outerScope possibleVarsFor: name continued: list! !!InstanceScope methodsFor: 'lookup' stamp: 'ajh 6/24/2004 03:04'!rawVar: name	"Return a ScopeVar for my inst var with this name.  Return nil if none found"	^ vars at: name ifAbsent: [self outerScope rawVar: name]! !!InstanceScope methodsFor: 'accessing' stamp: 'md 3/10/2006 12:17'!emitEnvParentEnv: anIRBuilder 	^self.! !!InstanceScope methodsFor: 'decompile' stamp: 'ms 8/8/2007 13:14'!instVarForAssignment: instVarIndex 	^ self instVar: instVarIndex! !!InstanceScope methodsFor: 'decompile' stamp: 'ms 7/10/2007 17:58'!instanceScope	^self! !!InstanceScope methodsFor: 'decompile' stamp: 'ms 7/27/2007 17:21'!receiverVarAt: instVarIndex	^self instVar: instVarIndex! !!InstanceScope methodsFor: 'decompile' stamp: 'ms 8/8/2007 13:06'!receiverVarForAssignmentAt: instVarIndex 	^ self instVar: instVarIndex! !!InstanceScope methodsFor: 'initializing' stamp: 'ajh 7/8/2004 20:26'!isInstanceScope	^ true! !!InstanceScope methodsFor: 'initializing' stamp: 'ajh 7/8/2004 18:16'!tempsAreNoLongerAvailable	"done"! !!InstanceScope methodsFor: 'initializing' stamp: 'ajh 6/24/2004 04:10'!vars: names	self vars: names offset: 0! !!InstanceScope methodsFor: 'initializing' stamp: 'ajh 7/8/2004 16:22'!vars: names offset: k	vars _ Dictionary new.	names withIndexDo: [:name :index |		vars at: name put:			(CapturedVar new				name: name;				index: k + index;				scope: self)				markGiven].! !!InstructionCompaire methodsFor: 'as yet unclassified' stamp: 'ms 9/8/2007 02:07'!bytceodeOffset1At: key	^ (bytecodeToInstruction1 at: key) value! !!InstructionCompaire methodsFor: 'as yet unclassified' stamp: 'ms 9/8/2007 01:59'!bytecode1At: key1 	^ (bytecodeToInstruction1 at: key1) key! !!InstructionCompaire methodsFor: 'as yet unclassified' stamp: 'ms 9/8/2007 02:02'!bytecode2At: key2 	^ (bytecodeToInstruction2 at: key2) key! !!InstructionCompaire methodsFor: 'as yet unclassified' stamp: 'ms 9/8/2007 02:07'!bytecodeOffset2At: key	^ (bytecodeToInstruction2 at: key) value! !!InstructionCompaire methodsFor: 'as yet unclassified' stamp: 'ms 9/8/2007 02:08'!checkJump	mapJump keysAndValuesDo: 			[:key1 :key2 | 			((self bytecode1At: key1) = (self bytecode2At: key2) 				or: 					[self checkTempFor: (self bytecode1At: key1) and: (self bytecode2At: key2)]				or: 					[self 						checkPopOptimizationNext1: [self bytecode1At: (self bytceodeOffset1At: key1)]						next2: [self bytecode2At: (self bytecodeOffset2At: key2)]]				or: 					[(self bytecode1At: key1) isJump 						and: [(self bytecode2At: key2) isJump]						and: [(self bytecode1At: key1) sends: (self bytecode2At: key2) selector]						and: 							[(mapJump 								at: (self bytecode1At: key1) argument + (self bytceodeOffset1At: key1)) 									= ((self bytecode2At: key2) argument + (self bytecodeOffset2At: key2))]]) 					ifFalse: [^ false]].	^ true! !!InstructionCompaire methodsFor: 'as yet unclassified' stamp: 'ms 11/7/2007 15:04'!checkLiteral	^(inst1 sends: inst2 selector) and: [(inst1 arguments 		with: inst2 arguments 		collect:[:arg1 :arg2 | arg1 literalEqual: arg2]) allSatisfy: [:each | each]]! !!InstructionCompaire methodsFor: 'as yet unclassified' stamp: 'ms 9/8/2007 01:50'!checkPopOptimization	^self checkPopOptimizationNext1: [self nextInstruction1 ] next2: [self nextInstruction2] ! !!InstructionCompaire methodsFor: 'as yet unclassified' stamp: 'ms 9/8/2007 01:50'!checkPopOptimizationNext1: aBlock1 next2: aBlock2	| popInst storeInst pushInst insts |	((popInst := inst1) isPopInto and:[(storeInst := inst2) isStoreInto])		ifTrue:[self atEnd ifTrue:[^false].			pushInst := aBlock1 value.			pushInst argument = popInst argument ifFalse:[^false].			(insts := {pushInst. popInst. storeInst} allSatisfy: [:each | each isTemp])				ifTrue:[^self temp: pushInst argument map: storeInst argument]]		ifFalse:[((popInst := inst2) isPopInto and:[(storeInst := inst1) isStoreInto])			ifTrue:[otherStream atEnd ifTrue:[^false].				pushInst := aBlock2 value.				pushInst argument = popInst argument ifFalse:[^false].				(insts := {pushInst. popInst. storeInst} allSatisfy: [:each | each isTempVar])					ifTrue:[^self temp: storeInst argument  map: pushInst argument]]		  ifFalse:[^false]].			(popInst argument = pushInst argument and: [popInst argument = storeInst argument]) ifFalse:[^false].		(insts allSatisfy: [:each | each isInstVar]) ifTrue:[^true].		(insts allSatisfy: [:each | each isLiteralVar]) ifTrue:[^true].		^false	! !!InstructionCompaire methodsFor: 'as yet unclassified' stamp: 'ms 9/8/2007 01:03'!checkTemp	^ self checkTempFor: inst1 and: inst2! !!InstructionCompaire methodsFor: 'as yet unclassified' stamp: 'ms 9/8/2007 00:00'!checkTempFor: instruction1 and: instruction2	(instruction1 isAccessTemp and: [instruction2 isAccessTemp]		and: [instruction2 sends: instruction1 selector]) 			ifFalse: [^ false]			ifTrue: [(self temp: instruction1 argument map: instruction2 argument) ifFalse: [^ false]].	^ true! !!InstructionCompaire methodsFor: 'as yet unclassified' stamp: 'ms 11/7/2007 15:01'!compaireWith: anOtherMethod 	otherStream := InstructionStream on: anOtherMethod.		[self atEnd ~= otherStream atEnd ifTrue: [^ false].	self atEnd] 		whileFalse: [			self nextInstruction1 = self nextInstruction2 ifFalse: [				"check if the literal is equal (e.g. for Float nan)"				self checkLiteral ifFalse:[					"recodrde jump so we can post check the destination maping"					self recordJump ifFalse: [						"Check temp maping. Temp offset can be different"						self checkTemp ifFalse: [							"Some optimization from the compiler are missed"							self checkPopOptimization ifFalse: [^ false]]]]]].	^ self checkJump! !!InstructionCompaire methodsFor: 'as yet unclassified' stamp: 'ms 9/8/2007 01:23'!nextInstruction1	^inst1 := (bytecodeToInstruction1 at: self pc							put: self nextInstruction -> self pc) key! !!InstructionCompaire methodsFor: 'as yet unclassified' stamp: 'ms 9/8/2007 01:22'!nextInstruction2	^inst2 := (bytecodeToInstruction2 at: otherStream pc				 put: otherStream nextInstruction -> otherStream pc) key ! !!InstructionCompaire methodsFor: 'as yet unclassified' stamp: 'ms 9/8/2007 01:16'!recordJump	(inst1 isJump and: [inst2 isJump] and: [inst1 sends: inst2 selector]) 		ifTrue: 			[mapJump at: inst1 argument + self pc put: inst2 argument + otherStream pc.			^ true].	^ false! !!InstructionCompaire methodsFor: 'as yet unclassified' stamp: 'ms 9/7/2007 23:29'!temp: temp1 map: temp2 	^ (mapTemp at: temp1 ifAbsentPut: [temp2]) = temp2! !!InstructionCompaire methodsFor: 'initialize-release' stamp: 'ms 9/8/2007 01:25'!initialize	mapTemp := IdentityDictionary new.	mapJump := IdentityDictionary new.	bytecodeToInstruction1 := IdentityDictionary new.	bytecodeToInstruction2 := IdentityDictionary new! !!InstructionCompaire class methodsFor: 'as yet unclassified' stamp: 'ms 9/6/2007 05:08'!compaire: aMethod with: anOtherMethod 	^ (self on: aMethod) compaireWith: anOtherMethod! !!InteractiveAddClassChange methodsFor: 'private'!controller	^controller! !!InteractiveAddClassChange methodsFor: 'private'!controller: aController 	controller := aController! !!InteractiveAddClassChange methodsFor: 'private'!primitiveExecute	definedClass := super primitiveExecute! !!InteractiveAddClassChange methodsFor: 'accessing'!definedClass	^definedClass! !!InteractiveAddClassChange class methodsFor: 'instance creation'!definition: aString for: aController 	^(self definition: aString)		controller: aController;		yourself! !!InteractiveAddMethodChange methodsFor: 'private'!controller	^controller! !!InteractiveAddMethodChange methodsFor: 'private'!controller: aController 	controller := aController! !!InteractiveAddMethodChange methodsFor: 'private'!primitiveExecute	^definedSelector := super primitiveExecute! !!InteractiveAddMethodChange methodsFor: 'accessing'!definedSelector	^definedSelector! !!InteractiveAddMethodChange class methodsFor: 'instance creation'!compile: aString in: aBehavior classified: aProtocol for: aController 	^(self 		compile: aString		in: aBehavior		classified: aProtocol)		controller: aController;		yourself! !!InteractiveAddMethodChange class methodsFor: 'instance creation'!compile: aString in: aClass for: aController 	^(self compile: aString in: aClass)		controller: aController;		yourself! !!InterpretedReflectiveMethod methodsFor: 'interpretation' stamp: 'md 4/18/2007 12:37'!beInterpreted	"ignore"! !!InterpretedReflectiveMethod methodsFor: 'interpretation' stamp: 'md 4/18/2007 12:37'!beNative	self primitiveChangeClassTo: ReflectiveMethod new.! !!InterpretedReflectiveMethod methodsFor: 'interpretation' stamp: 'md 4/18/2007 12:30'!isInterpreted	^true! !!InterpretedReflectiveMethod methodsFor: 'running' stamp: 'md 4/18/2007 12:30'!run: oldSelector with: arguments in: aReceiver     ^self interpret: oldSelector with: arguments in: aReceiver.! !!Interval methodsFor: '*network-irc-model' stamp: 'sbw 3/1/2002 13:03'!end	^stop! !!JObject class methodsFor: 'accessing' stamp: 'md 3/31/2007 19:13'!compilerClass	^PECompiler! !!JObject class methodsFor: 'accessing' stamp: 'md 3/20/2007 17:24'!parseTreeFor: aSymbol	^(self compiledMethodAt: aSymbol) reflectiveMethod methodNode! !!JObject class methodsFor: 'compiling' stamp: 'md 3/20/2007 17:28'!recompile: selector from: oldClass	| jMethod |	jMethod := (oldClass >> selector) reflectiveMethodOrNil.	(jMethod notNil and: [ jMethod hasMethodClass not ]) ifTrue: [ jMethod methodClass: oldClass ].	super recompile: selector from: oldClass.	! !!LazyIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/23/2004 11:58'!display: item atRow: row on: canvas 	"display the given item at row row"	| drawBounds |	drawBounds := self drawBoundsForRow: row.	drawBounds := drawBounds intersect: self bounds.	item isText		ifTrue: [canvas				drawString: item				in: drawBounds				font: (font						emphasized: (item emphasisAt: 1))				color: (self colorForRow: row)]		ifFalse: [item isStringMorph				ifTrue: [item position: drawBounds origin.					item drawOn: canvas]				ifFalse: [canvas						drawString: item						in: drawBounds						font: font						color: (self colorForRow: row)]]! !!LazyIRCListMorph methodsFor: 'as yet unclassified' stamp: 'fc 8/7/2004 15:15'!drawSelectionOn: aCanvas" This is copied almost as is from our Super LazylistMorph. The only change is to the collor used for the highlighting. On Macs with display depth set to 16 the original highlighting was invisible."	| selectionDrawBounds |	selectedRow ifNil: [ ^self ].	selectedRow = 0 ifTrue: [ ^self ].	selectionDrawBounds := self drawBoundsForRow: selectedRow.	selectionDrawBounds := selectionDrawBounds intersect: self bounds.	aCanvas fillRectangle: selectionDrawBounds color: (TranslucentColor r:0 g:0 b:0 alpha: 0.15)! !!LazyListMorph methodsFor: '*network-irc-gui' stamp: 'sbw 3/12/2005 13:43'!colorForRow: row 	^ (selectedRow notNil			and: [row = selectedRow])		ifTrue: [self rowHighlightColor]		ifFalse: [self color]! !!LazyListMorph methodsFor: '*network-irc-gui' stamp: 'sbw 3/12/2005 13:43'!rowHighlightColor	^Color red! !!LexicalScope methodsFor: 'adding' stamp: 'ajh 2/25/2003 22:44'!addSelector: string	^ string asSymbol! !!LexicalScope methodsFor: 'lookup' stamp: 'ajh 6/25/2004 22:00'!captureVar: name	^ self lookupVar: name! !!LexicalScope methodsFor: 'lookup' stamp: 'ajh 2/27/2003 00:40'!classEncoding	^ self outerScope classEncoding! !!LexicalScope methodsFor: 'lookup' stamp: 'ajh 2/25/2003 22:41'!lookupSelector: name	Symbol hasInterned: name ifTrue: [ :sym | ^ sym].	^ nil! !!LexicalScope methodsFor: 'lookup' stamp: 'ajh 3/11/2003 20:19'!lookupVar: name	"subclass responsibility"	^ self outerScope lookupVar: name! !!LexicalScope methodsFor: 'lookup' stamp: 'ajh 2/25/2003 22:40'!possibleSelectorsFor: string	^ Symbol possibleSelectorsFor: string! !!LexicalScope methodsFor: 'lookup' stamp: 'ajh 2/25/2003 22:39'!possibleVarsFor: string	| list |	list _ self possibleVarsFor: string continued: nil.	^ string correctAgainst: nil continuedFrom: list! !!LexicalScope methodsFor: 'lookup' stamp: 'ajh 3/11/2003 20:17'!possibleVarsFor: name continued: listOrNil	"subclass responsibility"	^ self outerScope possibleVarsFor: name continued: listOrNil! !!LexicalScope methodsFor: 'lookup' stamp: 'ajh 3/25/2003 23:38'!rawVar: name	"subclass responsibility"	^ self outerScope rawVar: name! !!LexicalScope methodsFor: 'levels' stamp: 'ajh 7/8/2004 20:02'!hasOuter: scope	outerScope ifNil: [^ false].	^ outerScope = scope or: [outerScope hasOuter: scope]! !!LexicalScope methodsFor: 'levels' stamp: 'ajh 6/25/2004 17:27'!newBlockScope	^ self newFunctionScope! !!LexicalScope methodsFor: 'levels' stamp: 'ajh 6/25/2004 17:26'!newFunctionScope	^ FunctionScope new outerScope: self! !!LexicalScope methodsFor: 'levels' stamp: 'ajh 6/29/2004 16:37'!newMethodScope	^ self newFunctionScope isHome: true! !!LexicalScope methodsFor: 'levels' stamp: 'ajh 2/26/2003 13:44'!outerScope	^ outerScope! !!LexicalScope methodsFor: 'levels' stamp: 'ajh 3/20/2003 11:27'!scopeLevel	outerScope ifNil: [^ 0].	^ outerScope scopeLevel + 1! !!LexicalScope methodsFor: 'decompiling' stamp: 'ms 7/11/2007 11:16'!instanceScope	^self outerScope instanceScope! !!LexicalScope methodsFor: 'decompiling' stamp: 'ms 6/26/2007 14:11'!isChildrenOf: aScope	self outerScope == nil ifTrue: [^false].	self outerScope = aScope ifTrue:[^true].	^self outerScope isChildrenOf: aScope! !!LexicalScope methodsFor: 'scope' stamp: 'ajh 7/8/2004 18:39'!isDoItScope	^ false! !!LexicalScope methodsFor: 'scope' stamp: 'ajh 6/25/2004 15:20'!isFunctionScope	^ false! !!LexicalScope methodsFor: 'scope' stamp: 'ajh 7/8/2004 20:26'!isInstanceScope	^ false! !!LexicalScope methodsFor: 'initializing' stamp: 'ajh 2/26/2003 13:43'!outerScope: aSemScope	outerScope _ aSemScope! !!LexicalScope methodsFor: 'initializing' stamp: 'ajh 2/26/2003 20:01'!parseScope	^ self! !!LexicalScope methodsFor: 'old protocol' stamp: 'ajh 2/25/2003 20:09'!requestor: editor	"Old protocol, do nothing"! !!LexicalScope commentStamp: 'ajh 3/24/2003 21:53' prior: 0!I am a symbol table where variable names are associated with SemVars.  Each context (method/closure) get a fresh scope that inherits from its outer scope.!!LintDialog methodsFor: 'actions' stamp: 'nk 3/4/2005 11:06'!canRun	^tests anySelected 		and: [self environment notNil and: [self environment isEmpty not]]! !!LintDialog methodsFor: 'actions' stamp: 'nk 2/27/2005 13:14'!resultsForEnvironment: anEnvironment 	| allResults progress addAmount |	progress := ProgressMorph label: 'SLint progress'.	progress openInWorld.	addAmount := 1.0 / tests selectedItems size.	allResults := tests selectedItems				collect: [:each | 					progress subLabel: each name.					progress incrDone: addAmount.					SmalllintChecker runRule: each onEnvironment: anEnvironment].	progress delete.	^ allResults		select: [:each | each result problemCount > 0]! !!LintDialog methodsFor: 'actions' stamp: 'nk 3/4/2005 11:06'!run	self canRun ifFalse: [^self].	Cursor wait 		showWhile: [results := self resultsForEnvironment: self environment].	self resultsDialog! !!LintDialog methodsFor: 'actions' stamp: 'nk 3/4/2005 11:07'!runOnEnvironment: anEnvironment	self environment: anEnvironment.	results := #().	tests anySelected		ifFalse: [^ self].	anEnvironment isEmpty		ifTrue: [^ self].	Cursor wait		showWhile: [results := self resultsForEnvironment: anEnvironment].	self resultsDialog! !!LintDialog methodsFor: 'actions' stamp: 'nk 3/4/2005 11:06'!selectClasses	selector ifNil: [selector := CategoryAndClassSelector new].	self environment: selector getClassEnvironmentFromUser.	self changed: #canRun! !!LintDialog methodsFor: 'displaying' stamp: 'nk 2/27/2005 15:44'!canSelectClasses	^true! !!LintDialog methodsFor: 'displaying' stamp: 'nk 3/4/2005 12:10'!labelString	| theLabel |	theLabel := self environment printStringLimitedTo: 60.	^theLabel isEmpty ifFalse: [ 'SmallLint on ', theLabel ] ifTrue: ['SmallLint'].! !!LintDialog methodsFor: 'displaying' stamp: 'nk 3/4/2005 12:09'!lintWindow	^(SystemWindow labelled: self labelString)		model: self;		addMorph: testCategories listMorph frame: (0.0 @ 0.0 extent: 1 @ 0.3);		addMorph: tests listMorph			fullFrame: (LayoutFrame fractions: (0.0 @ 0.3 extent: 1 @ 0.7)					offsets: (0 @ 0 corner: 0 @ -40));		addMorph: self selectClassesButton			fullFrame: (LayoutFrame fractions: (0 @ 1 corner: 0.5 @ 1)					offsets: (10 @ -35 corner: -10 @ -5));		addMorph: self runButton			fullFrame: (LayoutFrame fractions: (0.5 @ 1 corner: 1 @ 1)					offsets: (10 @ -35 corner: -10 @ -5));		yourself! !!LintDialog methodsFor: 'displaying' stamp: 'nk 3/4/2005 11:09'!makeResultDialogOn: aNumber	| env |	aNumber = 0 ifTrue: [^self].	env := (results at: aNumber) result.	env openEditor.! !!LintDialog methodsFor: 'displaying' stamp: 'nk 2/27/2005 15:45'!open	| w |	w := self lintWindow openInWorld; yourself.	self changed: #canRun.	self changed: #canSelectClasses.	^w! !!LintDialog methodsFor: 'displaying' stamp: 'nk 3/4/2005 14:38'!resultsDialog	| theLabel |	theLabel := self labelString copyReplaceAll: 'SmallLint on' with: 'SmallLint Results for'.	^(SystemWindow labelled: theLabel)		model: self;		addMorph: (self resultsListMorph) frame:(0@0 extent: 1@1);		openInWorld;		yourself! !!LintDialog methodsFor: 'displaying' stamp: 'nk 2/27/2005 14:24'!resultsListMorph	| list |	list := PluggableListMorph 				on: self				list: #resultsAsText				selected: #returnZero				changeSelected: #makeResultDialogOn:.	^list! !!LintDialog methodsFor: 'displaying' stamp: 'nk 2/27/2005 15:45'!runButton	| button |	button := PluggableButtonMorph 				on: self				getState: #canRun				action: #run.	button		label: 'Run';		onColor: self defaultBackgroundColor lighter		offColor: self defaultBackgroundColor muchDarker;		hResizing: #shrinkWrap.	self addDependent: button.	^button! !!LintDialog methodsFor: 'displaying' stamp: 'nk 2/27/2005 15:45'!selectClassesButton	| button |	button := PluggableButtonMorph 				on: self				getState: #canSelectClasses				action: #selectClasses.	button		label: 'Select Classes';		onColor: self defaultBackgroundColor lighter		offColor: self defaultBackgroundColor muchDarker;		hResizing: #shrinkWrap.	^button! !!LintDialog methodsFor: 'initialize-release' stamp: 'nk 2/27/2005 15:32'!defaultTestsCategoriesModel	^ MultipleSelectionModel withModel: self withList: self determineTestCategories! !!LintDialog methodsFor: 'initialize-release' stamp: 'nk 2/27/2005 15:23'!defaultTestsModel	^(MultipleSelectionModel 		withModel: self 		withList: #()		withMessage: #testsFromCategories)		menuGetter: #listMenuFor:in:;		yourself! !!LintDialog methodsFor: 'initialize-release' stamp: 'nk 3/4/2005 13:38'!determineTestCategories	| taskCategories |	taskCategories := (self determineTestCategoriesForClass: BlockLintRule),		(self determineTestCategoriesForClass: ParseTreeLintRule).	taskCategories removeAllFoundIn: #(#'instance creation' #private #accessing).		^taskCategories asArray! !!LintDialog methodsFor: 'initialize-release' stamp: 'nk 2/25/2005 08:46'!determineTestCategoriesForClass: aClass 	^ aClass withAllSubclasses		inject: Set new		into: [:sum :each | sum addAll: each class organization categories;				 yourself]! !!LintDialog methodsFor: 'initialize-release' stamp: 'nk 2/27/2005 15:32'!initialize	super initialize.	tests := self defaultTestsModel.	tests addDependent: self.	testCategories := self defaultTestsCategoriesModel.	testCategories addDependent: self.	testCategories addDependent: tests.! !!LintDialog methodsFor: 'accessing' stamp: 'nk 3/4/2005 11:05'!environment	^environment! !!LintDialog methodsFor: 'accessing' stamp: 'nk 3/4/2005 11:10'!environment: anObject	environment := anObject.	results := #().	self changed: #canRun.! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:46'!resultsAsText	^results collect:[:each| each asString , ' [' , each result problemCount asString , ']']! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:47'!returnZero	^0! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:45'!testsFromCategories	^testCategories selectedItems inject: Array new into:		[:partialList :each | (self testsFromCategory: each) , partialList].! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:47'!testsFromCategory: aCategory 	^ (self testsFromCategory: aCategory inClassAndSubclasses: BlockLintRule)		, (self testsFromCategory: aCategory inClassAndSubclasses: ParseTreeLintRule)! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:47'!testsFromCategory: aSymbol inClass: aClass	| classTests |	classTests := aClass class organization listAtCategoryNamed: aSymbol.	^classTests collect:[: each | aClass perform: each].! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:47'!testsFromCategory: aSymbol inClassAndSubclasses: aClass 	| classAndSubclassesTests |	classAndSubclassesTests := (self testsFromCategory: aSymbol inClass: aClass) asOrderedCollection.	aClass allSubclasses		do: [:each | classAndSubclassesTests				addAll: (self testsFromCategory: aSymbol inClass: each)].	^ classAndSubclassesTests! !!LintDialog methodsFor: 'menus' stamp: 'nk 2/25/2005 12:02'!listMenuFor: aMenu in: aMultipleSelectionModel 	aMenu add: 'View rationale for selected rules'		target: self		selector: #viewRationaleForSelectionsIn:		argument: aMultipleSelectionModel.! !!LintDialog methodsFor: 'menus' stamp: 'nk 2/25/2005 12:02'!viewRationaleForSelectionsIn: aMultipleSelectionModel	| rationale |	rationale := String streamContents: [ :strm |		aMultipleSelectionModel selectedItems do: [ :rule | | str |			str := rule rationale.			str isEmpty ifFalse: [ strm nextPutAll: rule name; cr; nextPutAll: str; cr; cr ]]].	(StringHolder new contents: rationale)		openLabel: 'Rationale for selected rules'! !!LintDialog methodsFor: 'updating' stamp: 'nk 2/27/2005 15:29'!update: aSymbol	aSymbol == #allSelections ifTrue: [		self changed: #canRun.	]! !!LintDialog class methodsFor: 'class initialization' stamp: 'nk 2/26/2005 10:13'!initialize	"self initialize"	TheWorldMenu registerOpenCommand: {'Lint'. {self. #open}}.	self registerInFlapsRegistry.! !!LintDialog class methodsFor: 'class initialization' stamp: 'nk 2/26/2005 10:10'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(#LintDialog #prototypicalToolWindow 'SmallLint' 'A tool to check for bugs in code' ) 						forFlapNamed: 'Tools']! !!LintDialog class methodsFor: 'class initialization' stamp: 'nk 2/26/2005 10:13'!unload	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self].	TheWorldMenu unregisterOpenCommandWithReceiver: self.! !!LintDialog class methodsFor: 'instance creation' stamp: 'nk 3/4/2005 11:10'!onEnvironment: anEnvironment	self new environment: anEnvironment; open! !!LintDialog class methodsFor: 'instance creation' stamp: 'nk 2/26/2005 10:14'!open	^self new open! !!LintDialog class methodsFor: 'instance creation' stamp: 'nk 2/26/2005 10:14'!prototypicalToolWindow	"Answer an example of myself seen in a tool window, for the benefit of parts-launching tools"	^self new lintWindow! !!LintDialog class methodsFor: 'instance creation' stamp: 'nk 2/27/2005 13:19'!runOnEnvironment: anEnvironment	self new open; runOnEnvironment: anEnvironment! !!LintDialog class methodsFor: 'window color' stamp: 'nk 2/27/2005 15:00'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference"	^ WindowColorSpec classSymbol: self name  wording: 'Lint' brightColor: #lightGreen pastelColor: #paleGreen helpMessage: 'A tool for finding bugs in your code'! !!LintRule methodsFor: 'accessing' stamp: 'nk 3/5/2005 15:16'!changes	^#()! !!LintRule methodsFor: 'accessing'!checkClass: aSmalllintContext! !!LintRule methodsFor: 'accessing'!checkMethod: aSmalllintContext! !!LintRule methodsFor: 'accessing'!name	^name! !!LintRule methodsFor: 'accessing'!name: aString 	name := aString! !!LintRule methodsFor: 'accessing'!problemCount	^self subclassResponsibility! !!LintRule methodsFor: 'accessing' stamp: 'nk 2/25/2005 11:35'!rationale	"Answer the rationale for this rule."	^rationale ifNil: [ ^'' ]! !!LintRule methodsFor: 'accessing' stamp: 'nk 2/25/2005 11:35'!rationale: anObject	rationale := anObject! !!LintRule methodsFor: 'accessing' stamp: 'nk 11/12/2002 13:11'!run	^SmalllintChecker runRule: self! !!LintRule methodsFor: 'accessing' stamp: 'nk 11/12/2002 13:11'!runOnEnvironment: anEnvironment 	^SmalllintChecker runRule: self onEnvironment: anEnvironment! !!LintRule methodsFor: 'printing'!displayName	| nameStream |	nameStream := WriteStream on: (String new: 64).	nameStream nextPutAll: self name;		nextPutAll: ' ['.	self problemCount printOn: nameStream.	nameStream nextPut: $].	^nameStream contents! !!LintRule methodsFor: 'printing'!printOn: aStream 	name isNil		ifTrue: [super printOn: aStream]		ifFalse: [aStream nextPutAll: name]! !!LintRule methodsFor: 'private'!failedRules	^self isEmpty		ifTrue: [#()]		ifFalse: [Array with: self]! !!LintRule methodsFor: 'private' stamp: 'bh 5/9/2000 00:17'!viewResults	self subclassResponsibility! !!LintRule methodsFor: 'testing'!hasConflicts	^false! !!LintRule methodsFor: 'testing'!isComposite	^false! !!LintRule methodsFor: 'testing'!isEmpty	self subclassResponsibility! !!LintRule methodsFor: 'initialize-release'!initialize! !!LintRule methodsFor: 'initialize-release'!resetResult! !!LintRuleTest methodsFor: 'accessing'!checkClass: aSmalllintContext! !!LintRuleTest methodsFor: 'accessing'!checkMethod: aSmalllintContext! !!LintRuleTest methodsFor: 'accessing'!displayName	| nameStream |	nameStream := WriteStream on: (String new: 64).	nameStream nextPutAll: self name;		nextPutAll: ' ('.	self problemCount printOn: nameStream.	nameStream nextPut: $).	^nameStream contents! !!LintRuleTest methodsFor: 'accessing'!name	^name! !!LintRuleTest methodsFor: 'accessing'!name: aString 	name := aString! !!LintRuleTest methodsFor: 'accessing' stamp: 'bh 3/25/2000 02:00'!openEditor	| rules |	rules := self failedRules.	rules isEmpty ifTrue: [^self].	rules size == 1 ifTrue: [^rules first viewResults].	SmalllintResultEditor openOn: self label: name! !!LintRuleTest methodsFor: 'accessing'!problemCount	^self subclassResponsibility! !!LintRuleTest methodsFor: 'accessing'!run	^Object printOn: self! !!LintRuleTest methodsFor: 'accessing'!runOnEnvironment: anEnvironment 	^Object printOn: self onEnvironment: anEnvironment! !!LintRuleTest methodsFor: 'private'!failedRules	^self isEmpty		ifTrue: [#()]		ifFalse: [Array with: self]! !!LintRuleTest methodsFor: 'private'!viewResults	self subclassResponsibility! !!LintRuleTest methodsFor: 'testing'!hasConflicts	^false! !!LintRuleTest methodsFor: 'testing'!isComposite	^false! !!LintRuleTest methodsFor: 'testing'!isEmpty	self subclassResponsibility! !!LintRuleTest methodsFor: 'testing' stamp: 'bh 4/3/2000 22:39'!junk	^RefactoryTestDataApp printString copyFrom: 1 to: CR! !!LintRuleTest methodsFor: 'initialize-release'!initialize	name := ''! !!LintRuleTest methodsFor: 'initialize-release'!resetResult! !!LintRuleTest methodsFor: 'printing'!printOn: aStream 	name isNil		ifTrue: [super printOn: aStream]		ifFalse: [aStream nextPutAll: name]! !!LiteralList methodsFor: 'adding' stamp: 'ajh 3/6/2003 18:00'!addLast: object	"Only add if not already in list"	(equalitySet includes: object) ifTrue: [^ object].	equalitySet add: object.	super addLast: object.	^ object! !!LiteralList methodsFor: 'accessing' stamp: 'ajh 1/21/2003 12:21'!indexOf: anElement startingAt: start ifAbsent: exceptionBlock	start to: self size do:		[:index | ((self at: index) literalEqual: anElement) ifTrue: [^ index]].	^ exceptionBlock value! !!LiteralList methodsFor: 'private' stamp: 'ajh 1/21/2003 12:21'!setCollection: anArray	super setCollection: anArray.	equalitySet _ LiteralSet new: anArray size.! !!LiteralList commentStamp: 'ajh 3/25/2003 00:31' prior: 0!Holds a unique ordered collection of literals!!LiteralSet methodsFor: 'adding' stamp: 'ajh 12/9/2001 16:03'!add: newObject	"Include newObject as one of the receiver's elements.  If equivalent is already present don't add and return equivalent object"	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index _ self findElementOrNil: newObject.	^ (array at: index) 		ifNil: [self atNewIndex: index put: newObject. newObject]		ifNotNil: [array at: index]! !!LiteralSet methodsFor: 'private' stamp: 'ajh 2/2/2002 19:16'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil					or: [element literalEqual: anObject])					ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil					or: [element literalEqual: anObject])					ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!LiteralSet commentStamp: 'ajh 3/25/2003 00:33' prior: 0!Holds a unique set of literals.  Literal objects are equal if they are #= plus they are the same class.  This set uses this rule for finding elements.Example:	Set new add: 'anthony'; add: #anthony; size  "= 1"	LiteralSet new add: 'anthony'; add: #anthony; size  "= 2"!!LocalVar methodsFor: 'emitting' stamp: 'md 8/24/2006 12:11'!emitEnvStore: methodBuilder from: refScope	| nextParent |	refScope = self scope ifTrue: [^ self emitEnvStore: methodBuilder].	refScope isInstanceScope ifTrue: [^ self emitEnvStore: methodBuilder].	"self is being referenced from an inner scope (refScope), emit its parent env and recurse"	nextParent _ refScope emitEnvParentEnv: methodBuilder.	self emitEnvStore: methodBuilder from: nextParent.! !!LocalVar methodsFor: 'emitting' stamp: 'ms 7/1/2007 23:06'!emitEnvValue: methodBuilder from: refScope	| nextParent |	(refScope = self scope or: [refScope isInstanceScope]) 		ifTrue: [^ self emitEnvValue: methodBuilder].	"self is being referenced from an inner scope (refScope), emit its parent env and recurse"	nextParent := refScope emitEnvParentEnv: methodBuilder.	self emitEnvValue: methodBuilder from: nextParent.! !!LocalVar methodsFor: 'emitting' stamp: 'ms 6/16/2007 20:20'!emitStore: methodBuilder from: refScope	| nextParent |		refScope = self scope ifTrue: [^ self emitLocalStore: methodBuilder].		"self is being referenced from an inner scope (refScope), emit its parent env and recurse"	nextParent := refScope emitLocalParentEnv: methodBuilder.	self emitEnvStore: methodBuilder from: nextParent.! !!LocalVar methodsFor: 'emitting' stamp: 'ms 6/17/2007 22:20'!emitValue: methodBuilder from: refScope	| nextParent |	refScope = self scope ifTrue: [^ self emitLocalValue: methodBuilder].	"self is being referenced from an inner scope (refScope), emit its parent env and recurse"	nextParent := refScope emitLocalParentEnv: methodBuilder.	self emitEnvValue: methodBuilder from: nextParent. 	! !!LocalVar methodsFor: 'accessing' stamp: 'ajh 3/18/2003 11:30'!index	^ index! !!LocalVar methodsFor: 'accessing' stamp: 'ajh 6/23/2004 22:51'!name	^ name! !!LocalVar methodsFor: 'initializing' stamp: 'ajh 6/23/2004 22:43'!index: n	index _ n! !!LocalVar methodsFor: 'initializing' stamp: 'ajh 6/23/2004 22:47'!name: string	name _ string! !!LocalVar methodsFor: 'testing' stamp: 'ms 7/31/2007 00:42'!isLocal	^true! !!LocalVar methodsFor: 'read/write usage' stamp: 'ajh 7/8/2004 16:21'!isUndefined	^ usage isNil! !!LocalVar methodsFor: 'read/write usage' stamp: 'ajh 6/28/2004 10:10'!markArg	"mark given"	usage _ #arg! !!LocalVar commentStamp: 'ajh 3/24/2003 21:54' prior: 0!I am an argument or temporary variable of a method or block.!!Logger methodsFor: 'adding'!addEvent: anEvent 	self isLogging ifFalse: [^self].	(self policy isInteresting: anEvent) ifFalse: [^self].	[self format 		addEvent: anEvent		on: self stream		from: self] 			ensure: [self closeStream]			! !!Logger methodsFor: 'adding'!closeStream	(self stream)		cr;		flush			! !!Logger methodsFor: 'accessing'!format	^format			! !!Logger methodsFor: 'accessing'!format: anObject	format := anObject			! !!Logger methodsFor: 'accessing'!isLogging	isLogging isNil ifTrue: [isLogging := false].	^isLogging			! !!Logger methodsFor: 'accessing'!name	^name			! !!Logger methodsFor: 'accessing'!name: anObject	name := anObject			! !!Logger methodsFor: 'accessing'!policy	^policy			! !!Logger methodsFor: 'accessing'!policy: anObject	policy := anObject			! !!Logger methodsFor: 'accessing'!startLogging	self isLogging ifTrue: [^self].	isLogging := true.	self outputHeader			! !!Logger methodsFor: 'accessing'!stopLogging	self isLogging ifFalse: [^self].	self outputFooter.	isLogging := false.			! !!Logger methodsFor: 'accessing'!stream	^stream			! !!Logger methodsFor: 'accessing'!stream: anObject	stream := anObject			! !!Logger methodsFor: 'printing'!outputFooter			! !!Logger methodsFor: 'printing'!outputHeader			! !!Logger commentStamp: '<historical>' prior: 0!LoggingOutputter outputs logging events onto its stream. Instance Variables:	format	<LoggingFormat>	The formatter for outputting log events	name	<String>			The name of the outputter	stream	<Stream>			The output stream	isLogging	<Boolean>		Am I currently logging?	policy	<LoggingPolicy>	The policy for outputting log events!!Logger class methodsFor: '*Toothpick-Configuration'!configureFromDictionary: aDictionary 	" OrderedCollection ('format' 'name' 'stream' 'isLogging' 'fileName')"	^ ( self new )		name: ( aDictionary at: 'name' ifAbsent: [ self defaultLogName ]);		policy: (aDictionary at: 'policy' ifAbsent: [ nil ]);		format: (aDictionary at: 'formatter'  ifAbsent: [ nil ]);		yourself			! !!Logger class methodsFor: '*Toothpick-Configuration'!iniFileFields"The following fields may be defined in a toothpick.ini chunk. Check my subclasses for additional fields which they support		name - a String giving the name of the logger		policy - the logging policy to use. 		format - the logging format to use. "	^#('name' 'policy' 'format') asSet			! !!Logger class methodsFor: '*Toothpick-Configuration'!mappingKey	^self subclassResponsibility			! !!Logger class methodsFor: '*Toothpick-Configuration'!mappings	^self allSubclasses inject: Dictionary new into: [ :dict :subClass |		dict at: subClass mappingKey put: subClass. dict]			! !!Logger class methodsFor: 'configuring'!defaultLogName	^ 'an unnamed logger'			! !!LoggingEvent methodsFor: 'querying'!allLevels	^self class allLevels			! !!LoggingEvent methodsFor: 'querying'!allLevelsStrings	"	^#(#all #debug #info #notice #warn #error #crit #alert #emerg #panic #fatal #off #none)"	^#('ALL' 'DEBUG' 'INFO' 'NOTICE' 'WARN' 'ERROR' 'CRIT' 'ALERT' 'EMERG' 'PANIC' 'FATAL' 'OFF' 'NULL')			! !!LoggingEvent methodsFor: 'querying'!isLevelHigherThan: aSymbolOrInteger	^self level >= (aSymbolOrInteger isSymbol		ifTrue: [self allLevels indexOf: aSymbolOrInteger]		ifFalse: [aSymbolOrInteger])			! !!LoggingEvent methodsFor: 'accessing'!category	^category			! !!LoggingEvent methodsFor: 'accessing'!category: anObject	category := anObject			! !!LoggingEvent methodsFor: 'accessing'!context	^context			! !!LoggingEvent methodsFor: 'accessing'!context: anObject	context := anObject			! !!LoggingEvent methodsFor: 'accessing'!exception	^exception			! !!LoggingEvent methodsFor: 'accessing'!exception: anObject	exception := anObject			! !!LoggingEvent methodsFor: 'accessing'!level	^level			! !!LoggingEvent methodsFor: 'accessing'!level: aSymbolOrInteger		level := aSymbolOrInteger isSymbol		ifTrue: [self allLevels indexOf: aSymbolOrInteger ifAbsent: [0]]		ifFalse: [aSymbolOrInteger]			! !!LoggingEvent methodsFor: 'accessing'!message	^message			! !!LoggingEvent methodsFor: 'accessing'!message: anObject	message := anObject			! !!LoggingEvent methodsFor: 'accessing'!timeStamp	^timeStamp			! !!LoggingEvent methodsFor: 'accessing'!timeStamp: anObject	timeStamp := anObject			! !!LoggingEvent methodsFor: 'printing'!categoryString	^self category			! !!LoggingEvent methodsFor: 'printing'!levelString	^self allLevelsStrings at: self level			! !!LoggingEvent methodsFor: 'printing'!messageString	^self message			! !!LoggingEvent methodsFor: 'printing'!printBasicsOn: aStream 	aStream		nextPutAll: self levelString;		nextPutAll: ' - ';		nextPutAll: self messageString			! !!LoggingEvent commentStamp: '<historical>' prior: 0!LoggingEvent is what is says it is, namely, an object that captures information on an event so that it can be logged.Instance Variables:	category	<Symbol>			A freely chooseable Symbol describing the type of event, such as #debug or #performance	context		<String | Symbol>	A String or Symbol describing the logging context.	exception	<Exception>		placeholder, currently unused	level		<Symbol>			one of {#all | #debug | #info | #warn | #error | #fatal | #off | #null}	message	<String>			a text describing the event	timeStamp	<Timestamp>		a TimeStamp, what else!!LoggingEvent class methodsFor: 'querying'!allLevels	^#(#all #debug #info #notice #warn #error #crit #alert #emerg #panic #fatal #off #none)			! !!LoggingEvent class methodsFor: 'instance creation'!category: category level: level message: message 	| event |	event := (self new)				category: category;				timeStamp: self timestampClass now;				level: level;				message: message;				yourself.	^LoggingMultiplexer current addEvent: event			! !!LoggingEvent class methodsFor: 'instance creation'!category: category level: level message: message exception: exception 	| event |	event := (self new)				category: category;				timeStamp: self timestampClass now;				level: level;				message: message;				exception: exception;				yourself.	^LoggingMultiplexer current addEvent: event			! !!LoggingEvent class methodsFor: 'instance creation'!category: category timeStamp: timeStamp level: level message: message context: context exception: exception 	| event |	event := (self new)				category: category;				timeStamp: timeStamp;				level: level;				message: message;				context: context;				exception: exception;				yourself.	^LoggingMultiplexer current addEvent:event			! !!LoggingEvent class methodsFor: 'instance creation'!category: category timeStamp: timeStamp level: level message: message exception: exception 	| event |	event := (self new)				category: category;				timeStamp: timeStamp;				level: level;				message: message;				exception: exception;				yourself.	^LoggingMultiplexer current addEvent:event			! !!LoggingEvent class methodsFor: '*Toothpick-Tests'!debugDebug	^self logMessage: 'foo'			! !!LoggingEvent class methodsFor: '*Toothpick-Tests'!debugInfo	^self logInfo: 'foo'			! !!LoggingEvent class methodsFor: '*Toothpick-Tests'!performanceWarning	^self category: #perf level: #warn message: 'performance is bad'			! !!LoggingEvent class methodsFor: '*Toothpick-Tests'!uiFatal	^self category: #ui level: #fatal message: 'screen display'			! !!LoggingEvent class methodsFor: '*Toothpick-Tests'!uiWarning	^self category: #ui level: #warn message: 'screen display'			! !!LoggingEvent class methodsFor: 'convenience'!logError: message 	^LoggingMultiplexer current addEvent: (self newDebugEventLevel: #error message: message)			! !!LoggingEvent class methodsFor: 'convenience'!logFatal: message 	^LoggingMultiplexer current addEvent: (self newDebugEventLevel: #fatal message: message)			! !!LoggingEvent class methodsFor: 'convenience'!logInfo: message 	^LoggingMultiplexer current addEvent: (self newDebugEventLevel: #info message: message)			! !!LoggingEvent class methodsFor: 'convenience'!logMessage: message 	^LoggingMultiplexer current addEvent: (self newDebugEventLevel: #debug message: message)			! !!LoggingEvent class methodsFor: 'convenience'!logWarn: message 	^LoggingMultiplexer current addEvent: (self newDebugEventLevel: #warn message: message)			! !!LoggingEvent class methodsFor: 'convenience'!newDebugEventLevel: lvl message: message 	^(self new)		category: #debug;		timeStamp: self timestampClass now;		level: lvl;		message: message;		yourself			! !!LoggingEvent class methodsFor: 'convenience' stamp: 'jp 10/13/2006 12:04'!timestampClass	"dialect-specific"	^DateAndTime			! !!LoggingEventPattern methodsFor: 'accessing'!categories	^categories			! !!LoggingEventPattern methodsFor: 'accessing'!comparator	^comparator			! !!LoggingEventPattern methodsFor: 'accessing'!level	^level			! !!LoggingEventPattern methodsFor: 'accessing'!patternString	^patternString			! !!LoggingEventPattern methodsFor: 'accessing'!patternString: anObject	patternString := anObject			! !!LoggingEventPattern methodsFor: 'querying'!doesCategoryMatch: anEvent 	(self categories includes: #*) ifTrue: [^true].	^self categories includes: anEvent category			! !!LoggingEventPattern methodsFor: 'querying' stamp: 'jp 10/12/2006 16:58'!isInteresting: anEvent 	^(self doesCategoryMatch: anEvent) and: 			[self comparator isNil 				ifTrue: [anEvent level >= self level]				ifFalse: 					[self comparator = #= 						ifTrue: [anEvent level = self level]						ifFalse: [							self comparator = #!! 								ifTrue: [anEvent level < self level]								ifFalse: [anEvent level ~= self level]]]]! !!LoggingEventPattern methodsFor: 'initialize-release'!setCategories: cats comparator: comp level: lvl patternString: aString 	categories := cats.	comparator := comp.	level := LoggingEvent allLevels indexOf: lvl asSymbol ifAbsent: [0].	patternString := aString			! !!LoggingEventPattern class methodsFor: 'instance creation' stamp: 'jp 10/12/2006 16:57'!fromString: aString 	| stream cats catStream char level comparator |	stream := aString readStream.	cats := Set new.	catStream := String new writeStream.	[stream atEnd or: [(char := stream next) = $.]] whileFalse: 			[char = $, 				ifTrue: 					[catStream position = 0 						ifFalse: 							[cats add: catStream contents asSymbol.							catStream reset]]				ifFalse: [catStream nextPut: char]].	catStream position = 0 ifFalse: [cats add: catStream contents asSymbol].	char := stream peek.	comparator := ('!!=' includes: char) 		ifTrue: [			(char = $=)				ifTrue: [					stream next.					#=]				ifFalse: [					stream next.					(stream peek = $=)						ifTrue: [							stream next.							#!!=]						ifFalse: [#!!]]]		ifFalse: [nil].	level := stream upToEnd.	^self new 		setCategories: cats		comparator: comparator		level: level		patternString: aString! !!LoggingEventTestCase methodsFor: 'setup'!setUp	LoggingMultiplexer reset			! !!LoggingEventTestCase methodsFor: 'testing'!testLoggingEvent	| policy |	event := LoggingEvent category: #debug level: #info message: 'Test message '.	self assert: event messageString = 'Test message ';		assert: event levelString = 'INFO';		assert: (event isLevelHigherThan: #debug);		assert: (event isLevelHigherThan: 2);		deny: (event isLevelHigherThan: #fatal);		deny: (event isLevelHigherThan: 5).	policy := LoggingPolicy debugPolicy.	self assert: (policy isInteresting: event)			! !!LoggingFormatTestCase methodsFor: 'testing' stamp: 'jp 10/13/2006 12:39'!assert: expected equals: actual	expected = actual ifFalse: [		| size stream |		size := expected size min: actual size.		stream := WriteStream on: String new.		1 to: size do: [ :index | | char |			((char := expected at: index) = (actual at: index)) 				ifTrue: [stream nextPut: char]				ifFalse: [^stream contents inspect]]]			! !!LoggingFormatTestCase methodsFor: 'testing'!testSimpleLoggingFormat	| stream |	format := SimpleLoggingFormatter defaultFormat.	event := LoggingEvent logMessage: 'Test message'.	stream := '' copy writeStream.	format formatEvent: event on: stream from: nil.	self assert: stream contents = 'DEBUG - Test message'			! !!LoggingFormatTestCase methodsFor: 'testing' stamp: 'jp 10/13/2006 12:40'!testXMLLoggingFormat	| stream ts resultString tsString |	ts := LoggingEvent timestampClass now.	format := XMLLoggingFormatter timeFormat.	tsString := TimeTimestampFormatter new formatTimestamp: ts.	event := LoggingEvent logMessage: 'Test message'.	event timeStamp: ts.	stream := WriteStream on: String new.	format formatEvent: event on: stream from: TranscriptLogger new.	resultString := '<LoggingEvent loggerName=''Transcript'' category=''debug'' level=''DEBUG'' timestamp=''', tsString, '''>		<Message>Test message</Message></LoggingEvent>'.	self assert: stream contents withBlanksTrimmed equals: resultString			! !!LoggingFormatter methodsFor: 'adding-removing' stamp: 'jp 10/19/2006 13:08'!addEvent: aLoggingEvent on: aStream from: aLogger 	self formatEvent: aLoggingEvent on: aStream from: aLogger.	aStream cr			! !!LoggingFormatter methodsFor: '*Toothpick-Configuration'!configureFromDictionary: aDictionary	^self			! !!LoggingFormatter methodsFor: 'printing'!formatEvent: anEvent on: aStream from: anObject			! !!LoggingFormatter methodsFor: 'printing'!outputFooterOn: aStream			! !!LoggingFormatter methodsFor: 'printing'!outputHeaderOn: aStream			! !!LoggingFormatter class methodsFor: '*Toothpick-Configuration'!configureFromDictionary: aDictionary	| formatClass |	formatClass := ( aDictionary includesKey: 'format' ) 			ifTrue: [ self mappings at: ( aDictionary at: 'format' ) ifAbsent: [self mappings at: 'simple']]			ifFalse: [ self mappings at: 'simple' ].	^formatClass new configureFromDictionary: aDictionary			! !!LoggingFormatter class methodsFor: '*Toothpick-Configuration'!mappingKey	^self subclassResponsibility			! !!LoggingFormatter class methodsFor: '*Toothpick-Configuration'!mappings	^self allSubclasses inject: Dictionary new into: [ :dict :subClass |		dict at: subClass mappingKey put: subClass. dict]			! !!LoggingFormatter class methodsFor: 'instance creation'!defaultFormat	^self new			! !!LoggingMultiplexer methodsFor: 'adding' stamp: 'jp 10/19/2006 13:09'!addEvent: aLoggingEvent	"dialect-specific"	mutex critical: [self loggers do: [ :logger | logger addEvent: aLoggingEvent]].	^aLoggingEvent! !!LoggingMultiplexer methodsFor: 'adding'!addLogger: aLogger	self loggers add: aLogger			! !!LoggingMultiplexer methodsFor: '*Toothpick-Configuration'!configureFromIniFile	| loggerList configurator |	configurator := ToothpickConfigurator for: self.	loggerList := configurator configureFromIniFile.	loggerList do: [:logger | self addLogger: logger].	^loggers			! !!LoggingMultiplexer methodsFor: 'initialize' stamp: 'jp 10/19/2006 13:08'!initialize	loggers := Set new.	mutex := self newMutex! !!LoggingMultiplexer methodsFor: 'initialize' stamp: 'jp 10/19/2006 13:08'!newMutex	^Semaphore forMutualExclusion! !!LoggingMultiplexer methodsFor: 'accessing'!loggerNamed: aString	^loggers detect: [ :logger | logger name = aString] ifNone: []			! !!LoggingMultiplexer methodsFor: 'accessing'!loggers	^loggers			! !!LoggingMultiplexer methodsFor: 'logging' stamp: 'jp 10/19/2006 13:10'!startAllLoggers	mutex critical: [self loggers do: [ :logger | logger startLogging]]! !!LoggingMultiplexer methodsFor: 'logging' stamp: 'jp 10/19/2006 13:10'!stopAllLoggers	mutex critical: [self loggers do: [ :logger | logger stopLogging]]! !!LoggingMultiplexer class methodsFor: 'accessing'!current	current isNil ifTrue: [current := self new initialize].	^current			! !!LoggingMultiplexer class methodsFor: 'accessing'!initialize			! !!LoggingMultiplexer class methodsFor: 'accessing'!initializeAfterLoad			! !!LoggingMultiplexer class methodsFor: 'accessing'!reset	current := nil			! !!LoggingPolicy methodsFor: 'accessing'!category	category isNil ifTrue: [category := #debug].	^category			! !!LoggingPolicy methodsFor: 'accessing'!defaultIsInterestingBlock	^ [: event | event category == self category and: [ event isLevelHigherThan: self level ]]			! !!LoggingPolicy methodsFor: 'accessing'!isInterestingBlock	isInterestingBlock isNil 		ifTrue: [isInterestingBlock := self defaultIsInterestingBlock].	^isInterestingBlock			! !!LoggingPolicy methodsFor: 'accessing'!isInterestingBlock: anObject	isInterestingBlock := anObject			! !!LoggingPolicy methodsFor: 'accessing'!level	level isNil ifTrue: [level := #all].	^level			! !!LoggingPolicy methodsFor: 'accessing'!setCategory: aSymbol level: aSymbolOrInteger 	category := aSymbol asSymbol.	level := aSymbolOrInteger asSymbol			! !!LoggingPolicy methodsFor: '*Toothpick-Configuration'!configureFromDictionary: aDictionary 	^self setCategory: ( aDictionary at: 'category' ifAbsent: [ 'debug' ])			level: ( aDictionary at: 'threshold' ifAbsent: [ 'all' ])			! !!LoggingPolicy methodsFor: 'querying'!isInteresting: anEvent	^self isInterestingBlock value: anEvent			! !!LoggingPolicy commentStamp: '<historical>' prior: 0!LoggingPolicy defines which events will be logged. This is most often based on the criteria of category and level.!!LoggingPolicy class methodsFor: 'instance creation'!category: aSymbol level: aSymbolOrInteger 	^ ( self new )		setCategory: aSymbol level: aSymbolOrInteger;		yourself			! !!LoggingPolicy class methodsFor: 'instance creation'!debugPolicy	^self new		isInterestingBlock: [ :event | event isLevelHigherThan: #debug ];		yourself			! !!LoggingPolicy class methodsFor: 'instance creation'!defaultPolicy	^self new			! !!LoggingPolicy class methodsFor: '*Toothpick-Configuration'!configureFromDictionary: aDictionary	| policyClass |	policyClass := ( aDictionary includesKey: 'policy' ) 			ifTrue: [ self mappings at: ( aDictionary at: 'policy' ) ifAbsent: [self mappings at: 'simple']]			ifFalse: [ self mappings at: 'simple' ].	^policyClass new configureFromDictionary: aDictionary			! !!LoggingPolicy class methodsFor: '*Toothpick-Configuration'!mappingKey	^'simple'			! !!LoggingPolicy class methodsFor: '*Toothpick-Configuration'!mappings	^self withAllSubclasses inject: Dictionary new into: [ :dict :subClass |		dict at: subClass mappingKey put: subClass. dict]			! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:22'!testAddAction	"MVCToolBuilder does not implement #buildPluggableMenu:"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:22'!testAddTargetSelectorArgumentList	"MVCToolBuilder does not implement #buildPluggableMenu:"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:23'!testButtonFiresBlock	"MVC buttons only support action Symbols"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:23'!testButtonFiresMessage	"MVC buttons only support action Symbols, not MessageSends"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testButtonInitiallyDisabled	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testButtonInitiallyDisabledSelector	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testGetButtonColor	"MVC buttons do not have color"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testGetButtonEnabled	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:18'!testGetButtonSideEffectFree	"MVC button ask for their state on any change notification"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:19'!testGetInputFieldColor	"MVC input fields do not have color"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:20'!testGetPanelChildren	"MVC panels do not allow changing children"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetTextColor	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetWindowChildren	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetWindowLabel	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeExpandPath	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeExpandPathFirst	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeGetSelectionPath	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeRoots	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeWidgetID	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:25'!testWindowCloseAction	"This can only work if we're actually run in MVC"	World isNil ifTrue: [super testWindowCloseAction]! !!Message methodsFor: '*newcompiler' stamp: 'ms 9/8/2007 01:35'!= anOtherMessage	self class = anOtherMessage class ifFalse:[^false].	self arguments = anOtherMessage arguments ifFalse:[^false].	self selector = anOtherMessage selector ifFalse:[^false].	self lookupClass = anOtherMessage lookupClass ifFalse:[^false].	^true! !!Message methodsFor: '*newcompiler' stamp: 'ms 9/6/2007 03:09'!isAccessTemp	^#(#popIntoTemporaryVariable: #pushTemporaryVariable: #storeIntoTemporaryVariable:) includes: selector! !!Message methodsFor: '*newcompiler' stamp: 'ms 9/6/2007 05:34'!isConditionalJump	^#jump:if: = selector! !!Message methodsFor: '*newcompiler' stamp: 'ms 9/7/2007 23:25'!isInstVar	^#(	#pushReceiverVariable: 	#storeIntoReceiverVariable: 	#popIntoReceiverVariable:) 		includes: selector! !!Message methodsFor: '*newcompiler' stamp: 'ms 9/6/2007 05:12'!isJump	^#(#jump: #jump:if:) includes: selector! !!Message methodsFor: '*newcompiler' stamp: 'ms 9/7/2007 23:26'!isLiteralVar	^#(	#popIntoLiteralVariable: 	#pushLiteralVariable: 	#storeIntoLiteralVariable:) 		includes: selector! !!Message methodsFor: '*newcompiler' stamp: 'ms 9/7/2007 23:14'!isPopInto	^#(#popIntoLiteralVariable: #popIntoReceiverVariable: popIntoTemporaryVariable:) 		includes: selector! !!Message methodsFor: '*newcompiler' stamp: 'ms 9/7/2007 23:23'!isPush	^#(#pushTemporaryVariable: 	#pushReceiverVariable: 	#pushReceiver 	#pushLiteralVariable: 	#pushConstant:	#pushActiveContext) 		includes: selector! !!Message methodsFor: '*newcompiler' stamp: 'ms 9/7/2007 23:15'!isStoreInto	^#(#storeIntoLiteralVariable: #storeIntoReceiverVariable: storeIntoTemporaryVariable:) 		includes: selector! !!Message methodsFor: '*newcompiler' stamp: 'ms 9/7/2007 23:27'!isTempVar	^#(	#popIntoTemporaryVariable: 	#pushTemporaryVariable: 	#storeIntoTemporaryVariable:) 		includes: selector! !!MetaGeppettoTest methodsFor: 'setup' stamp: 'md 12/12/2007 21:07'!setup	gplink := nil.! !!MetaGeppettoTest methodsFor: 'setup' stamp: 'md 12/12/2007 21:07'!tearDown	gplink ifNotNil: [gplink uninstall].		GPExamples methodDict values do: [:method |		self removeLinks: method.		self assertNoLinks: method. 	].! !!MetaGeppettoTest methodsFor: 'tools' stamp: 'md 12/12/2007 21:06'!assertNoLinks: aMethod	aMethod  nodes do: [:node | self assert: node hasAnyLink not].! !!MetaGeppettoTest methodsFor: 'tools' stamp: 'md 12/12/2007 21:07'!removeLinks: aMethod	aMethod reflectiveMethod methodNode nodesDo: [:node |		node hasAnyLink ifTrue: [node removeAllLinks]].! !!MetaGeppettoTest methodsFor: 'tests' stamp: 'md 12/13/2007 09:23'!testBlockContext		gplink := GPLink metaObject: [:sender | sender log: 'Befor a send'].	gplink before.	gplink addOnActiveContext: TestRunnerContext.	(GPExamples>>#exampleLog) sends do: [:node | node link: gplink].		[GPCounter reset.	self assert: (GPExamples new exampleLog) = 7.	self assert: GPCounter counter = 1.] valueWithContext: TestRunnerContext.	[GPCounter reset.	self assert:  (GPExamples new exampleLog) = 7.	self assert: GPCounter counter = 0.] valueWithoutContext: TestRunnerContext.	[GPCounter reset.	self assert: (GPExamples new exampleLog) = 7.	self assert: GPCounter counter = 1.] valueWithContext: TestRunnerContext.	! !!MetaGeppettoTest methodsFor: 'tests' stamp: 'md 12/12/2007 21:12'!testCheckMetaActive	"simple test to check if the meta is inactive here, but then active when calling #assertMeta	 via a link. Seems to work"	gplink := GPLink new metaObject: self class;						selector: #assertMeta.						(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self deny: MetaContext current isActive.	self assert: (GPExamples new example = 11).	self deny: MetaContext current isActive.	self assert: (GPCounter counter = 1).	! !!MetaGeppettoTest methodsFor: 'tests' stamp: 'md 12/13/2007 09:06'!testCheckMetaActiveContextualLink	"simple test to check if the meta is inactive here, that we can turn it on and that the	 link then is skiped"	gplink := GPLink new metaObject: self class;						selector: #assertMeta;					addOnInactiveContext: MetaContext.						(GPExamples>>#example) sends do: [:node | node link: gplink].		GPCounter reset.	self deny: MetaContext current isActive.		"now lets call the meta with Meta already active, this should skip the call"	[self assert: (GPExamples new example = 11)] valueWithContext: MetaContext.		self deny: MetaContext current isActive.	self assert: (GPCounter counter = 0).	! !!MetaGeppettoTest methodsFor: 'tests' stamp: 'md 12/13/2007 09:23'!testLinkContext		gplink := GPLink metaObject: [:sender | sender log: 'Befor a send'].	gplink before.	gplink addOnActiveContext: DeploymentContext.			(GPExamples>>#exampleLog) sends do: [:node | node link: gplink].		GPCounter reset.	Preferences enable: #deploymentContext.	self assert: (GPExamples new exampleLog) = 7.	self assert: GPCounter counter = 1.	Preferences disable: #deploymentContext.		GPCounter reset.	self assert:  (GPExamples new exampleLog) = 7.	self assert: GPCounter counter = 0.	! !!MetaGeppettoTest methodsFor: 'tests' stamp: 'md 12/13/2007 09:23'!testMultipleContext		gplink := GPLink metaObject: [:sender | sender log: 'Befor a send'].	gplink before.	gplink addOnActiveContext: TestRunnerContext.	gplink addOnActiveContext: DeploymentContext.			(GPExamples>>#exampleLog) sends do: [:node | node link: gplink].		GPCounter reset.	TestRunnerContext current activate.	Preferences enable: #deploymentContext.	self assert: (GPExamples new exampleLog) = 7.	self assert: GPCounter counter = 1.	[GPCounter reset.	self assert:  (GPExamples new exampleLog) = 7.	self assert: GPCounter counter = 0.	] fork.	Preferences disable: #deploymentContext.	GPCounter reset.	self assert:  (GPExamples new exampleLog) = 7.	self assert: GPCounter counter = 0.	! !!MetaGeppettoTest methodsFor: 'tests' stamp: 'md 12/13/2007 09:23'!testOnInactiveContext		gplink := GPLink metaObject: [:sender | sender log: 'Befor a send'].	gplink before.	gplink addOnInactiveContext: DeploymentContext.			(GPExamples>>#exampleLog) sends do: [:node | node link: gplink].		GPCounter reset.	Preferences enable: #deploymentContext.	self assert: (GPExamples new exampleLog) = 7.	self assert: GPCounter counter = 0.	Preferences disable: #deploymentContext.		GPCounter reset.	self assert:  (GPExamples new exampleLog) = 7.	self assert: GPCounter counter = 1.	! !!MetaGeppettoTest methodsFor: 'tests' stamp: 'md 12/13/2007 09:23'!testProcessContext		gplink := GPLink metaObject: [:sender | sender log: 'Befor a send'].	gplink before.	gplink addOnActiveContext: TestRunnerContext.			(GPExamples>>#exampleLog) sends do: [:node | node link: gplink].		GPCounter reset.	TestRunnerContext current activate.	self assert: (GPExamples new exampleLog) = 7.	self assert: GPCounter counter = 1.	[GPCounter reset.	self assert:  (GPExamples new exampleLog) = 7.	self assert: GPCounter counter = 0.	] fork.	GPCounter reset.	self assert:  (GPExamples new exampleLog) = 7.	self assert: GPCounter counter = 1.	! !!MetaGeppettoTest class methodsFor: 'as yet unclassified' stamp: 'md 12/12/2007 21:10'!assertMeta	GPCounter inc.	self assert: MetaContext current isActive! !!Metaclass methodsFor: '*persephone' stamp: 'pmm 2/14/2007 21:25'!compilerClass       ^ self instanceSide compilerClass! !!MethodContext methodsFor: 'accessing' stamp: 'md 2/9/2007 19:06'!tempNamed: aName	^self tempAt: (self tempNames indexOf: aName)! !!MethodContext methodsFor: 'accessing' stamp: 'md 2/9/2007 19:07'!tempNamed: aName put: anObject	^self tempAt: (self tempNames indexOf: aName) put: anObject! !!MethodContext methodsFor: '*context' stamp: 'ms 11/1/2007 16:59'!ctxtTempAt: index put: value 	"Refer to the comment in ContextPart|tempAt:put:."	^self ctxtAt: index put: value! !!MethodContextTest methodsFor: 'tests' stamp: 'md 2/9/2007 19:06'!testTempNamed	| oneTemp |		oneTemp := 1.	self assert: (thisContext tempNamed: 'oneTemp') = oneTemp.	! !!MethodContextTest methodsFor: 'tests' stamp: 'md 2/9/2007 19:08'!testTempNamedPut	| oneTemp |		oneTemp := 1.	self assert: (thisContext tempNamed: 'oneTemp') = oneTemp.	thisContext tempNamed: 'oneTemp' put: 2.	self assert: (thisContext tempNamed: 'oneTemp') = 2.! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/1/2001 20:44'!accepted	^accepted! !!MethodNameEditor methodsFor: 'accessing' stamp: 'vd 5/19/2004 18:08'!accepted: anObject	bodyPane accept.		accepted := anObject! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/1/2001 02:34'!arguments	^methodName arguments! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/1/2001 20:46'!methodPreview	| stream |	stream := String new writeStream.	self selector numArgs > 0 		ifTrue: 			[self selector keywords with: self argumentList				do: 					[:keyword :arg | 					stream						nextPutAll: keyword;						nextPut: $ ;						nextPutAll: arg;						nextPut: $ ]]		ifFalse: [stream nextPutAll: self selector].	^stream contents! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/29/2001 14:52'!modalView	^modalView! !!MethodNameEditor methodsFor: 'accessing' stamp: 'mga 8/27/2001 15:20'!modalView: aSystemWindow	modalView := aSystemWindow	! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/1/2001 02:36'!selector	^methodName selector! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/1/2001 14:14'!selector: aString 	methodName selector: aString asString.	self changed: #selector.	self changed: #methodPreview.	^true.! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:51'!addArgumentListTo: window 	| anArgumentListMorph |	(anArgumentListMorph := PluggableListMorph new) 		on: self		list: #argumentList		selected: #argumentListIndex		changeSelected: #argumentListIndex:		menu: nil		keystroke: nil.	window addMorph: anArgumentListMorph frame: (0 @ 0.1 corner: 0.9 @ 0.7)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:53'!addCancelButtonTo: window 	window addMorph: ((PluggableButtonMorph 				on: self				getState: nil				action: #cancel)				label: 'cancel';				onColor: Color white offColor: Color white)		frame: (0.5 @ 0.8 corner: 1 @ 1)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:52'!addDownButtonTo: window 	window addMorph: ((PluggableButtonMorph 				on: self				getState: #downActivated				action: #down)				label: 'down';				setBalloonText: 'move argument down';				onColor: Color white offColor: Color lightGray)		frame: (0.9 @ 0.4 corner: 1 @ 0.7)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:52'!addOkButtonTo: window 	window addMorph: ((PluggableButtonMorph 				on: self				getState: #okEnabled				action: #ok)				label: 'ok';				setBalloonText: 'accept selector as shown in the preview';				onColor: Color white offColor: Color lightGray)		frame: (0 @ 0.8 corner: 0.5 @ 1)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:52'!addPreviewPaneTo: window 	| methodPreview |	methodPreview := PluggableTextMorph 				on: self				text: #methodPreview				accept: nil				readSelection: nil				menu: nil.	window addMorph: methodPreview frame: (0 @ 0.7 corner: 1.0 @ 0.8)! !!MethodNameEditor methodsFor: 'action' stamp: 'vd 5/19/2004 18:07'!addSelectorPaneTo: window 		bodyPane := PluggableTextMorph 				on: self				text: #selector				accept: #selector:				readSelection: nil				menu: nil.	bodyPane acceptOnCR: true.	window addMorph: bodyPane frame: (0 @ 0 corner: 1.0 @ 0.1)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:52'!addUpButtonTo: window 	window addMorph: ((PluggableButtonMorph 				on: self				getState: #upActivated				action: #up)				label: 'up';				setBalloonText: 'move argument up';				onColor: Color white offColor: Color lightGray)		frame: (0.9 @ 0.1 corner: 1 @ 0.4)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/1/2001 20:44'!cancel	self modalView delete.! !!MethodNameEditor methodsFor: 'action' stamp: 'vd 5/19/2004 18:07'!ok	self okEnabled 		ifFalse: 			[self modalView flash.			^self].	self accepted: true.	self modalView delete! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/1/2001 20:04'!okEnabled	^self selector isEmpty not and: [self methodName isValid]! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:53'!openAsMorph	"self new openAsMorph"	| window |	window := (SystemWindow labelled: 'Selector editor') model: self.	self addSelectorPaneTo: window.	self addArgumentListTo: window.	self addUpButtonTo: window.	self addDownButtonTo: window.	self addPreviewPaneTo: window.	self addOkButtonTo: window.	self addCancelButtonTo: window.	window		center: Display center;		extent: 100 @ 100.	self selectionChanged.	window openInWorld.	window setProperty: #methodNameEditorModel toValue: self.	^window! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 02:40'!argumentList	^ methodName arguments! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 02:35'!argumentList: aCollection	methodName argumentList: aCollection! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'mga 8/27/2001 00:57'!argumentListIndex	^argumentListIndex! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 13:21'!argumentListIndex: anInteger	argumentListIndex := anInteger.	self selectionChanged.! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 20:02'!down	self downActivated ifFalse: [^self].	self argumentList swap: argumentListIndex with: argumentListIndex + 1.	self argumentListIndex: self argumentListIndex + 1.	self selectionChanged! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 02:32'!for: aMethodName 	self methodName: aMethodName! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 20:41'!initialize	argumentListIndex := 1.	accepted := false! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'mga 8/27/2001 01:12'!methodName	^methodName! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'mga 8/27/2001 01:12'!methodName: aSelector	methodName := aSelector! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'mga 8/27/2001 11:08'!selectionChanged	self 		changed: #argumentListIndex;		changed: #argumentList;		changed: #upActivated;		changed: #downActivated;		changed: #methodPreview	! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 20:00'!up	self upActivated ifFalse: [^self].	self argumentList swap: argumentListIndex with: argumentListIndex - 1.	self argumentListIndex: self argumentListIndex - 1.	self selectionChanged! !!MethodNameEditor methodsFor: 'testing' stamp: 'dvf 9/1/2001 20:10'!downActivated	| newIndex |	newIndex := argumentListIndex + 1.	^newIndex between: 1 and: self arguments size! !!MethodNameEditor methodsFor: 'testing' stamp: 'dvf 9/1/2001 20:09'!upActivated	| newIndex |	newIndex := argumentListIndex - 1.	^newIndex between: 1 and: self arguments size! !!MethodNameEditor class methodsFor: 'examples' stamp: 'mga 8/27/2001 01:36'!example	self new		argumentList: #('1' '2');		argumentListIndex: 1;		openAsMorph! !!MethodNameEditor class methodsFor: 'instance creation' stamp: 'dvf 9/1/2001 18:51'!for: aMethodName 	| editor newMethodName |	newMethodName := aMethodName deepCopy.	newMethodName arguments 		ifNil: [newMethodName arguments: OrderedCollection new].	newMethodName selector		ifNil: [newMethodName selector: String new].	editor := self new.	editor for: newMethodName.	^editor! !!MethodNameEditor class methodsFor: 'instance creation' stamp: 'mga 8/27/2001 17:23'!forMethodName: aMethodName	^self modalEditorForMethodName: aMethodName ! !!MethodNameEditor class methodsFor: '-- all --' stamp: 'dvf 9/1/2001 20:43'!modalEditorForMethodName: aMethodName 	| editor window |	editor := self for: aMethodName.	window := editor openAsMorph.	editor modalView: window.	[window world notNil] 		whileTrue: [window outermostWorldMorph doOneCycleNow].	^editor accepted ifFalse: [nil] ifTrue: [(window valueOfProperty: #methodNameEditorModel) methodName]! !!MethodNode methodsFor: 'initialize-release' stamp: 'md 2/5/2007 15:40'!selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim 		self 		selector: selOrFalse		arguments: args		precedence: p		temporaries: temps		block: blk encoder:		anEncoder 		primitive: prim 		properties: MethodProperties new.! !!MethodNode methodsFor: 'printing' stamp: 'md 2/3/2007 11:53'!printOn: aStream 	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream nextPutAll: kwd; space.				aStream withStyleFor: #methodArgument					do: [aStream nextPutAll: arg key].				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '|'.			aStream withStyleFor: #temporaryVariable				do: [temporaries do: 						[:temp | aStream space; nextPutAll: temp key]].				aStream nextPutAll: ' |'].	properties ifNotNil: [ 		properties pragmas do: [ :each |			"Don't decompile basic primitives that return self, i-vars, etc."			each keyword = #primitive:				ifFalse: [ aStream crtab: 1. each printOn: aStream ]				ifTrue: [					( (each argumentAt: 1) isNumber and: [(each argumentAt: 1) between: 255 and: 519])						ifFalse: [ aStream crtab: 1. self printPrimitiveOn: aStream ] ] ] ].	aStream crtab: 1.	^ block printStatementsOn: aStream indent: 0! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 8/19/2006 20:44'!testCompileBinary	self assertPragma: ' = 1' givesKeyword: #= arguments: #( 1 ).	self assertPragma: ' , 3' givesKeyword: #, arguments: #( 3 ).	self assertPragma: ' > 4' givesKeyword: #> arguments: #( 4 ).	self assertPragma: ' < 5' givesKeyword: #< arguments: #( 5 ).	self assertPragma: ' == 1' givesKeyword: #== arguments: #( 1 ).	self assertPragma: ' <> 3' givesKeyword: #<> arguments: #( 3 ).	self assertPragma: ' >< 4' givesKeyword: #>< arguments: #( 4 ).	self assertPragma: ' ** 5' givesKeyword: #** arguments: #( 5 )! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 10/5/2006 09:49'!testCompileValue	self assertPragma: 'foo: true' givesKeyword: #foo: arguments: #( true ).	self assertPragma: 'foo: false' givesKeyword: #foo: arguments: #( false ).	self assertPragma: 'foo: nil' givesKeyword: #foo: arguments: #( nil )! !!MethodPragmaTest methodsFor: 'testing-printing-reformating' stamp: 'md 2/3/2007 11:55'!testReformat	self assert: (DisplayScreen class compiledMethodAt: #actualScreenDepth) getSource string = 'actualScreenDepth	<primitive: ''primitiveScreenDepth''>	^ Display depth'.		self shouldnt: [ DisplayScreen class reformatMethodAt: #actualScreenDepth] raise: Error.	self assert: (DisplayScreen class compiledMethodAt: #actualScreenDepth) getSource string = 'actualScreenDepth	<primitive: ''primitiveScreenDepth''>	^ Display depth'.	! !!MethodPragmaTest methodsFor: '*newcompiler-override' stamp: 'lr 10/5/2006 10:15' prior: 24466852!testCompileInvalid	"Invalid pragmas should properly raise an error."	self should: [ self compile: '<>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<1>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<#123>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo bar>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo 1>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo bar zork>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo bar 1>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo: bar:>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo: #bar: zork:>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<<1>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<=2>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '< =1 = >' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '< =1 =2 >' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo: String>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo: Pragma>' selector: #zork ] raise: SyntaxErrorNotification! !!MethodPragmaTest methodsFor: '*newcompiler-override' stamp: 'md 7/26/2006 14:59' prior: 34814226!testCompileInvalid	"Invalid pragmas should properly raise an error."	self should: [ self compile: '<>' selector: #zork ] raise: SmaCCParserError .	self should: [ self compile: '<1>' selector: #zork ] raise: SmaCCParserError.		self should: [ self compile: '<#123>' selector: #zork ] raise: SmaCCParserError.		self should: [ self compile: '<foo bar>' selector: #zork ] raise: SmaCCParserError.	self should: [ self compile: '<foo 1>' selector: #zork ] raise: SmaCCParserError.	self should: [ self compile: '<foo bar zork>' selector: #zork ] raise: SmaCCParserError.	self should: [ self compile: '<foo bar 1>' selector: #zork ] raise: SmaCCParserError.	self should: [ self compile: '<foo: bar:>' selector: #zork ] raise: SmaCCParserError.	self should: [ self compile: '<foo: #bar: zork:>' selector: #zork ] raise: SmaCCParserError.! !!MethodProperties methodsFor: '*newcompiler' stamp: 'md 8/20/2007 13:36'!= other	self class == other class ifFalse: [^false].	self pragmas = other pragmas ifFalse:[^false].	self selector = other  selector ifFalse:[^false].	self properties = other  properties ifFalse:[^false].	^true! !!MethodProperties methodsFor: '*newcompiler' stamp: 'ms 8/8/2007 01:50'!properties	^properties ! !!MethodRefactoring methodsFor: 'private'!buildSelectorString: aSelector 	aSelector numArgs = 0 ifTrue: [^aSelector].	^self buildSelectorString: aSelector		withPermuteMap: (1 to: aSelector numArgs)! !!MethodRefactoring methodsFor: 'private'!buildSelectorString: aSelector withPermuteMap: anIntegerCollection 	| stream keywords |	aSelector numArgs == 0 ifTrue: [^aSelector asString].	stream := WriteStream on: String new.	keywords := aSelector keywords.	keywords with: anIntegerCollection		do: 			[:each :i | 			stream				nextPutAll: each;				nextPutAll: ' ``@arg';				nextPutAll: i printString;				nextPut: $ ].	^stream contents! !!MethodReference methodsFor: '*persephone' stamp: 'md 3/27/2007 11:10'!methodClass	^Smalltalk at: classSymbol ifAbsent: [nil].! !!Morph methodsFor: 'halos and balloon help' stamp: 'zz 9/28/2006 18:53'!balloonHelpTextForHandle: aHandle 	"Answer a string providing balloon help for the	given halo handle"	| itsSelector |	itsSelector := aHandle eventHandler firstMouseSelector.	itsSelector == #doRecolor:with:		ifTrue: [^ Preferences propertySheetFromHalo				ifTrue: ['Open a property sheet.']				ifFalse: ['Change color']].	itsSelector == #mouseDownInDimissHandle:with:		ifTrue: [^ Preferences preserveTrash				ifTrue: ['Move to trash']				ifFalse: ['Remove from screen']].	#(#(#addFullHandles 'More halo handles') #(#addSimpleHandles 'Fewer halo handles') #(#chooseEmphasisOrAlignment 'Emphasis & alignment') #(#chooseFont 'Change font') #(#chooseNewGraphicFromHalo 'Choose a new graphic') #(#chooseStyle 'Change style') #(#dismiss 'Remove') #(#doDebug:with: 'Debug') #(#doDirection:with: 'Choose forward direction') #(#doDup:with: 'Duplicate') #(#doMakeSibling:with: 'Make a sibling') #(#doMenu:with: 'Menu') #(#doGrab:with: 'Pick up') #(#editButtonsScript 'See the script for this button') #(#editDrawing 'Repaint') #(#doDupOrMakeSibling:with: 'Duplicate (press shift to make a sibling)') #(#doMakeSiblingOrDup:with: 'Make a sibling (press shift to make simple duplicate)') #(#makeNascentScript 'Make a scratch script') #(#makeNewDrawingWithin 'Paint new object') #(#mouseDownInCollapseHandle:with: 'Collapse') #(#mouseDownOnHelpHandle: 'Help') #(#openViewerForArgument 'Open a Viewer for me. Press shift for a snapshot.') #(#openViewerForTarget:with: 'Open a Viewer for me. Press shift for a snapshot.') #(#paintBackground 'Paint background') #(#prepareToTrackCenterOfRotation:with: 'Move object or set center of rotation') #(#presentViewMenu 'Present the Viewing menu') #(#startDrag:with: 'Move') #(#startGrow:with: 'Change size') #(#startRot:with: 'Rotate') #(#startScale:with: 'Change scale') #(#tearOffTile 'Make a tile representing this object') #(#tearOffTileForTarget:with: 'Make a tile representing this object') #(#trackCenterOfRotation:with: 'Set center of rotation') )		do: [:pair | itsSelector == pair first				ifTrue: [^ pair last]].	^ 'unknown halo handle'translated! !!Morph methodsFor: '*network-irc-gui' stamp: 'sbw 2/21/2002 23:52'!decrementIndexPositionOfSubmorph: morph 	| indexOfMorph indexOfPartner temp |	submorphs isSequenceable		ifFalse: [^ nil].	indexOfMorph _ submorphs indexOf: morph.	indexOfMorph = 1 ifTrue: [^nil].	indexOfPartner _ indexOfMorph - 1.	temp _ submorphs at: indexOfPartner.	self invalidRect: self fullBounds.	submorphs at: indexOfPartner put: morph.	submorphs at: indexOfMorph put: temp.	self layoutChanged! !!Morph methodsFor: '*network-irc-gui' stamp: 'sbw 2/21/2002 23:52'!incrementIndexPositionOfSubmorph: morph 	| indexOfMorph indexOfPartner temp |	submorphs isSequenceable		ifFalse: [^ nil].	indexOfMorph _ submorphs indexOf: morph.	indexOfMorph = submorphs size		ifTrue: [^ nil].	indexOfPartner _ indexOfMorph + 1.	temp _ submorphs at: indexOfPartner.	self invalidRect: self fullBounds.	submorphs at: indexOfPartner put: morph.	submorphs at: indexOfMorph put: temp.	self layoutChanged! !!MoveMethodRefactoring methodsFor: 'transforming'!abstractVariables	self performComponentRefactoring: self abstractVariablesRefactoring.	parseTree := self abstractVariablesRefactoring parseTree! !!MoveMethodRefactoring methodsFor: 'transforming'!abstractVariablesRefactoring	^AbstractVariablesRefactoring 		model: self model		abstractVariablesIn: parseTree		from: class		toAll: moveToClasses		ignoring: variable! !!MoveMethodRefactoring methodsFor: 'transforming'!addSelfReturn	self hasOnlySelfReturns ifTrue: [^self].	parseTree addSelfReturn! !!MoveMethodRefactoring methodsFor: 'transforming'!compileDelagatorMethod	| statementNode delegatorNode tree |	delegatorNode := RBMessageNode 				receiver: (RBVariableNode named: variable)				selectorParts: parseTree selectorParts				arguments: (parseTree argumentNames collect: 							[:each | 							RBVariableNode 								named: (each = selfVariableName ifTrue: ['self'] ifFalse: [each])]).	self hasOnlySelfReturns 		ifFalse: [delegatorNode := RBReturnNode value: delegatorNode].	statementNode := RBSequenceNode temporaries: #()				statements: (Array with: delegatorNode).	(tree := class parseTreeFor: selector) body: statementNode.	class compileTree: tree! !!MoveMethodRefactoring methodsFor: 'transforming'!compileNewMethods	moveToClasses 		do: [:each | each compileTree: parseTree classified: (class protocolsFor: selector)]! !!MoveMethodRefactoring methodsFor: 'transforming'!getArgumentNameForSelf	self needsToReplaceSelfReferences ifFalse: [^self].		[selfVariableName := self requestSelfArgumentName.	(self checkInstanceVariableName: selfVariableName in: class) 		ifTrue: 			[self verifyTemporaryVariableDoesNotOverride 				ifFalse: 					[self 						refactoringWarning: 'The variable is already defined in one of the classes you''re moving the method to.<n>Try another?' 								expandMacros.					selfVariableName := nil]]		ifFalse: 			[self 				refactoringWarning: 'The variable name is not a valid Smalltalk temporary variable name<n>Try again?' 						expandMacros.			selfVariableName := nil].	selfVariableName isNil] 			whileTrue: []! !!MoveMethodRefactoring methodsFor: 'transforming'!hasOnlySelfReturns	^hasOnlySelfReturns isNil 		ifTrue: 			[| searcher |			searcher := ParseTreeSearcher new.			searcher				matches: '^self' do: [:aNode :answer | answer];				matches: '^`@object' do: [:aNode :answer | false].			hasOnlySelfReturns := searcher executeTree: parseTree initialAnswer: true]		ifFalse: [hasOnlySelfReturns]! !!MoveMethodRefactoring methodsFor: 'transforming' stamp: 'rr 3/16/2004 15:15'!removeArgument	"Removes the excess argument if any.	This argument is the variable which is	referenced by self in the classes the	method is moved to. "	| removeIndex |	removeIndex := parseTree argumentNames indexOf: variable.	removeIndex = 0 ifFalse: 		[parseTree arguments: ((parseTree arguments asOrderedCollection)  									removeAt: removeIndex; yourself) asArray.		parseTree selectorParts: ((parseTree selectorParts asOrderedCollection) 									removeAt: removeIndex; yourself) asArray].! !!MoveMethodRefactoring methodsFor: 'transforming' stamp: 'dvf 10/13/2001 23:19'!replaceSelfReferences	| replacer |	self needsToReplaceSelfReferences ifTrue: [		replacer := ParseTreeRewriter new.		replacer replace: 'self' with: selfVariableName.		self hasOnlySelfReturns ifTrue: 			[replacer replace: '^self' with: '^self'].		replacer executeTree: parseTree.		parseTree := replacer tree].! !!MoveMethodRefactoring methodsFor: 'transforming'!replaceVariableReferences	| replacer |	replacer := ParseTreeRewriter new.	replacer replace: variable with: 'self'.	replacer executeTree: parseTree.	parseTree := replacer tree! !!MoveMethodRefactoring methodsFor: 'transforming'!transform	self		abstractVariables;		addSelfReturn;		replaceSelfReferences;		replaceVariableReferences;		compileNewMethods;		compileDelagatorMethod! !!MoveMethodRefactoring methodsFor: 'transforming'!verifyTemporaryVariableDoesNotOverride	(parseTree allDefinedVariables includes: selfVariableName) 		ifTrue: [^false].	moveToClasses 		do: [:each | (each definesVariable: selfVariableName) ifTrue: [^false]].	^true! !!MoveMethodRefactoring methodsFor: 'private'!buildParseTree	parseTree := (class parseTreeFor: selector) copy.	parseTree isNil ifTrue: [self refactoringError: 'Could not parse method']! !!MoveMethodRefactoring methodsFor: 'preconditions'!checkAssignmentsToVariable	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: variable , ' := `@object' do: [:aNode :answer | true].	(searcher executeTree: parseTree initialAnswer: false) 		ifTrue: 			[self refactoringError: ('Cannot move the method into <1s> since it is assigned' 						expandMacrosWith: variable)]! !!MoveMethodRefactoring methodsFor: 'preconditions'!checkForPrimitiveMethod	parseTree isPrimitive 		ifTrue: [self refactoringError: 'Cannot move primitive methods']! !!MoveMethodRefactoring methodsFor: 'preconditions'!checkForSuperReferences	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'super `@message: `@args' do: [:aNode :answer | true].	(searcher executeTree: parseTree initialAnswer: false) 		ifTrue: 			[self refactoringError: 'Cannot move the method since it has a super message send.']! !!MoveMethodRefactoring methodsFor: 'preconditions'!checkTemporaryVariableNames	| varNames |	varNames := parseTree allDefinedVariables.	selfVariableName notNil ifTrue: [varNames add: selfVariableName].	varNames do: 			[:name | 			moveToClasses do: 					[:each | 					(self canReferenceVariable: name in: each) 						ifTrue: 							[self refactoringError: ('<1p> already defines a variable called <2s>' 										expandMacrosWith: each										with: name)]]]! !!MoveMethodRefactoring methodsFor: 'preconditions' stamp: 'rr 3/16/2004 15:14'!getNewMethodName	"rr 3/16/2004 15:12 : changed the code	to really remove the variable which	the extracted selector is moved to,	as in the new location it is now the	self pseudo-argument.		The previous version was only removing	it from the arguments, which was causing	a bug."	| newSelector parameters alreadyDefined methodName newMethodName |	self removeArgument.	parameters := parseTree argumentNames asOrderedCollection.	"parameters remove: variable ifAbsent: []."	self needsToReplaceSelfReferences 		ifTrue: [parameters add: selfVariableName].	methodName := RBMethodName selector: (self uniqueMethodNameFor: parameters size) arguments: parameters.		[newMethodName := self requestMethodNameFor: methodName.	newMethodName isNil ifTrue: [self refactoringError: 'Did not move method'].	newMethodName isValid 		ifTrue: [newSelector := newMethodName selector]		ifFalse: [self refactoringWarning: 'Invalid method name'].	parameters := newMethodName arguments.	(self checkMethodName: newSelector in: class) 		ifFalse: 			[self refactoringWarning: newSelector , ' is not a valid selector name.'.			newSelector := nil].	alreadyDefined := moveToClasses 				detect: [:each | each hierarchyDefinesMethod: newSelector]				ifNone: [nil].	alreadyDefined notNil 		ifTrue: 			[self 				refactoringWarning: ('<1s> is already defined by <2p> or a super/subclass<n>Try another?' 						expandMacrosWith: newSelector						with: alreadyDefined).			newSelector := nil].	newSelector isNil] 			whileTrue: [].	parseTree		arguments: (parameters collect: [:each | RBVariableNode named: each]) 					asArray;		selector: newSelector! !!MoveMethodRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition withBlock: 					[self buildParseTree.					self checkForPrimitiveMethod.					self checkForSuperReferences.					self checkAssignmentsToVariable.					self getClassesToMoveTo.					self getArgumentNameForSelf.					self checkTemporaryVariableNames.					self getNewMethodName.					true])! !!MoveMethodRefactoring methodsFor: 'private-accessing'!getClassForGlobalOrClassVariable	| definingClass type |	definingClass := class whoDefinesClassVariable: variable.	definingClass isNil 		ifTrue: 			[type := self model classNamed: variable.			type isNil ifTrue: [type := self model classNamed: #Object]]		ifFalse: [type := definingClass typeOfClassVariable: variable].	moveToClasses := self selectVariableTypesFrom: (Array with: type)				selected: (Array with: type).	moveToClasses isNil ifTrue: [self refactoringError: 'Method not moved']! !!MoveMethodRefactoring methodsFor: 'private-accessing'!getClassesForInstanceVariable	| definingClass typer types |	definingClass := class whoDefinesInstanceVariable: variable.	typer := RefactoryTyper newFor: self model.	typer runOn: definingClass.	types := typer typesFor: variable.	types isEmpty 		ifTrue: [types := OrderedCollection with: (self model classNamed: #Object)].	moveToClasses := self selectVariableTypesFrom: types				selected: (typer guessTypesFor: variable).	moveToClasses isNil ifTrue: [self refactoringError: 'Method not moved']! !!MoveMethodRefactoring methodsFor: 'private-accessing'!getClassesForTemporaryVariable	| types |	types := RefactoryTyper 				typesFor: variable				in: parseTree				model: self model.	types isEmpty 		ifTrue: [types := OrderedCollection with: (self model classNamed: #Object)].	moveToClasses := self selectVariableTypesFrom: types selected: types.	moveToClasses isNil ifTrue: [self refactoringError: 'Method not moved']! !!MoveMethodRefactoring methodsFor: 'private-accessing'!getClassesToMoveTo	self isMovingToArgument 		ifTrue: [self getClassesForTemporaryVariable]		ifFalse: 			[self isMovingToInstVar 				ifTrue: [self getClassesForInstanceVariable]				ifFalse: [self getClassForGlobalOrClassVariable]].	moveToClasses isEmpty 		ifTrue: [self refactoringError: 'No classes selected, method not moved.']! !!MoveMethodRefactoring methodsFor: 'testing'!hasSelfReferences	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'self' do: [:aNode :answer | true].	self hasOnlySelfReturns 		ifTrue: [searcher matches: '^self' do: [:aNode :answer | answer]].	^searcher executeTree: parseTree initialAnswer: false! !!MoveMethodRefactoring methodsFor: 'testing'!isMovingToArgument	^(parseTree arguments collect: [:each | each name]) includes: variable! !!MoveMethodRefactoring methodsFor: 'testing'!isMovingToInstVar	^self isMovingToArgument not 		and: [(class whoDefinesInstanceVariable: variable) notNil]! !!MoveMethodRefactoring methodsFor: 'testing'!needsToReplaceSelfReferences	^self hasSelfReferences 		or: [self abstractVariablesRefactoring hasVariablesToAbstract]! !!MoveMethodRefactoring methodsFor: 'initialize-release'!selector: aSymbol class: aClass variable: aVariableName 	selector := aSymbol.	class := self classObjectFor: aClass.	variable := aVariableName! !!MoveMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: selector;		nextPutAll: ' class: '.	class storeOn: aStream.	aStream		nextPutAll: ' variable: ''';		nextPutAll: variable;		nextPutAll: ''')'! !!MoveMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk selector: aSymbol class: aClass variable: aVariableName 	^(self new)		model: aRBSmalltalk;		selector: aSymbol			class: aClass			variable: aVariableName;		yourself! !!MoveMethodRefactoring class methodsFor: 'instance creation'!selector: aSymbol class: aClass variable: aVariableName 	^(self new)		selector: aSymbol			class: aClass			variable: aVariableName;		yourself! !!MoveMethodTest methodsFor: 'tests'!testMoveMethodIntoArgument	| refactoring class |	self proceedThroughWarning: 			[refactoring := MoveMethodRefactoring 						selector: #checkMethod:						class: TransformationRuleTest						variable: 'aSmalllintContext'.			self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.			self setupVariableTypesFor: refactoring				toReturn: (Array with: (refactoring model classNamed: #SmalllintContext)).			self setupMethodNameFor: refactoring toReturn: #foo:.			self executeRefactoring: refactoring].	class := refactoring model classNamed: #TransformationRuleTest.	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext aSmalllintContext foo: self').	self 		assert: ((refactoring model classNamed: #SmalllintContext) 				parseTreeFor: #foo:) = (RBParser 							parseMethod: 'foo: transformationRule	transformationRule class: self selectedClass.	(transformationRule rewriteRule executeTree: self parseTree) ifTrue: 			[(transformationRule class recursiveSelfRule executeTree: transformationRule rewriteRule tree initialAnswer: false)				ifFalse: 					[transformationRule builder compile: transformationRule rewriteRule tree printString						in: transformationRule class1						classified: self protocols]]').	self assert: (class parseTreeFor: #class1) 				= (RBParser parseMethod: 'class1 ^class').	self assert: (class parseTreeFor: #class:) 				= (RBParser parseMethod: 'class: anObject class := anObject').	self 		assert: (class metaclass parseTreeFor: #recursiveSelfRule:) = (RBParser 						parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').	self assert: (class metaclass parseTreeFor: #recursiveSelfRule) 				= (RBParser parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').	self assert: (class parseTreeFor: #builder) 				= (RBParser parseMethod: 'builder ^builder').	self assert: (class parseTreeFor: #builder:) 				= (RBParser parseMethod: 'builder: anObject builder := anObject').	self assert: (class parseTreeFor: #rewriteRule) 				= (RBParser parseMethod: 'rewriteRule ^rewriteRule').	self assert: (class parseTreeFor: #rewriteRule:) 				= (RBParser parseMethod: 'rewriteRule: anObject rewriteRule := anObject')! !!MoveMethodTest methodsFor: 'tests'!testMoveMethodIntoClassVariable	| refactoring class |	self proceedThroughWarning: 			[refactoring := MoveMethodRefactoring 						selector: #checkMethod:						class: TransformationRuleTest						variable: 'RecursiveSelfRule'.			self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.			self setupVariableTypesFor: refactoring				toReturn: (Array with: (refactoring model classNamed: #ParseTreeSearcher)).			self 				setupMethodNameFor: refactoring				toReturn: #foo:foo:				withArguments: #('transformationRule' 'aSmalllintContext').			self executeRefactoring: refactoring].	class := refactoring model classNamed: #TransformationRuleTest.	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext RecursiveSelfRule foo: self foo: aSmalllintContext').	self 		assert: ((refactoring model classNamed: #ParseTreeSearcher) 				parseTreeFor: #foo:foo:) = (RBParser 							parseMethod: 'foo: transformationRule foo: aSmalllintContext	transformationRule class: aSmalllintContext selectedClass.	(transformationRule rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[(self executeTree: transformationRule rewriteRule tree initialAnswer: false)				ifFalse: 					[transformationRule builder compile: transformationRule rewriteRule tree printString						in: transformationRule class1						classified: aSmalllintContext protocols]]').	self assert: (class parseTreeFor: #class1) 				= (RBParser parseMethod: 'class1 ^class').	self assert: (class parseTreeFor: #class:) 				= (RBParser parseMethod: 'class: anObject class := anObject').	self assert: (class parseTreeFor: #builder) 				= (RBParser parseMethod: 'builder ^builder').	self assert: (class parseTreeFor: #builder:) 				= (RBParser parseMethod: 'builder: anObject builder := anObject').	self assert: (class parseTreeFor: #rewriteRule) 				= (RBParser parseMethod: 'rewriteRule ^rewriteRule').	self assert: (class parseTreeFor: #rewriteRule:) 				= (RBParser parseMethod: 'rewriteRule: anObject rewriteRule := anObject')! !!MoveMethodTest methodsFor: 'tests'!testMoveMethodIntoInstanceVariable	| refactoring class |	self proceedThroughWarning: 			[refactoring := MoveMethodRefactoring 						selector: #checkMethod:						class: TransformationRuleTest						variable: 'rewriteRule'.			self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.			self setupVariableTypesFor: refactoring				toReturn: (Array with: (refactoring model classNamed: #ParseTreeRewriter)).			self 				setupMethodNameFor: refactoring				toReturn: #foo:foo:				withArguments: #('transformationRule' 'aSmalllintContext').			self executeRefactoring: refactoring].	class := refactoring model classNamed: #TransformationRuleTest.	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext rewriteRule foo: self foo: aSmalllintContext').	self 		assert: ((refactoring model classNamed: #ParseTreeRewriter) 				parseTreeFor: #foo:foo:) = (RBParser 							parseMethod: 'foo: transformationRule foo: aSmalllintContext	transformationRule class: aSmalllintContext selectedClass.	(self executeTree: aSmalllintContext parseTree) ifTrue: 			[(transformationRule class recursiveSelfRule executeTree: self tree initialAnswer: false)				ifFalse: 					[transformationRule builder compile: self tree printString						in: transformationRule class1						classified: aSmalllintContext protocols]]').	self assert: (class parseTreeFor: #class1) 				= (RBParser parseMethod: 'class1 ^class').	self assert: (class parseTreeFor: #class:) 				= (RBParser parseMethod: 'class: anObject class := anObject').	self 		assert: (class metaclass parseTreeFor: #recursiveSelfRule:) = (RBParser 						parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').	self assert: (class metaclass parseTreeFor: #recursiveSelfRule) 				= (RBParser parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').	self assert: (class parseTreeFor: #builder) 				= (RBParser parseMethod: 'builder ^builder').	self assert: (class parseTreeFor: #builder:) 				= (RBParser parseMethod: 'builder: anObject builder := anObject')! !!MoveMethodTest methodsFor: 'tests' stamp: 'bh 5/1/2000 00:09'!testMoveMethodThatReferencesPoolDictionary	| refactoring class |	self		proceedThroughWarning: 			[refactoring := MoveMethodRefactoring						selector: #junk						class: LintRuleTest						variable: 'RefactoryTestDataApp'.			self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.			self setupVariableTypesFor: refactoring toReturn: (Array with: (refactoring model classNamed: 'RefactoryTestDataApp class' asSymbol)).			self setupMethodNameFor: refactoring toReturn: #junk1.			self executeRefactoring: refactoring].	class := refactoring model classNamed: #LintRuleTest.	self assert: (class parseTreeFor: #junk)			= (RBParser parseMethod: 'junk ^RefactoryTestDataApp junk1').	self assert: ((refactoring model metaclassNamed: #RefactoryTestDataApp)			parseTreeFor: #junk1)			= (RBParser parseMethod: 'junk1	^self printString copyFrom: 1 to: CR').	self assert: (class directlyDefinesPoolDictionary: 'TextConstants' asSymbol)! !!MoveMethodTest methodsFor: 'failure tests'!testMovePrimitiveMethod	| refactoring |	(model classNamed: #Object) 		compile: 'foo <primitive: 100> ^#() primitiveFailed'		classified: #(#accessing).	refactoring := MoveMethodRefactoring 				model: model				selector: #foo				class: Object				variable: 'OrderedCollection'.	self shouldFail: refactoring! !!MoveVariableDefinitionRefactoring methodsFor: 'transforming'!checkNodes: sequenceNodes 	(sequenceNodes 		detect: [:each | RBReadBeforeWrittenTester isVariable: name readBeforeWrittenIn: each]		ifNone: [nil]) notNil 		ifTrue: [^false].	sequenceNodes do: 			[:each | 			(self usesDirectly: each body) 				ifTrue: [blockNodes add: each]				ifFalse: 					[(self checkNodes: (self subblocksIn: each body)) 						ifFalse: [blockNodes add: each]]].	^true! !!MoveVariableDefinitionRefactoring methodsFor: 'transforming'!checkParseTree	| node |	blockNodes := OrderedCollection new.	node := self whichVariableNode: parseTree				inInterval: interval				name: name.	node isNil		ifTrue: [self refactoringError: 'Unable to locate node in parse tree'].	definingNode := node whoDefines: name.	definingNode isNil		ifTrue: [self refactoringError: 'Cannot locate variable definition'].	definingNode isSequence		ifFalse: [self refactoringError: 'Variable is an argument'].	(self usesDirectly: definingNode)		ifTrue: [self refactoringError: 'Variable already bound tightly as possible'].	(self checkNodes: (self subblocksIn: definingNode))		ifFalse: [self refactoringError: 'Variable is possibly read before written']! !!MoveVariableDefinitionRefactoring methodsFor: 'transforming'!subblocksIn: aParseTree 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '[:`@blockTemps | | `@temps | `@.Statements]'		do: 			[:aNode :answer | 			(aNode references: name)				ifTrue: [answer add: aNode].			answer].	^searcher executeTree: aParseTree initialAnswer: OrderedCollection new! !!MoveVariableDefinitionRefactoring methodsFor: 'transforming'!transform	definingNode removeTemporaryNamed: name.	blockNodes do: [:each | each body addTemporaryNamed: name].	class compileTree: parseTree! !!MoveVariableDefinitionRefactoring methodsFor: 'transforming'!usesDirectly: aParseTree 	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: '[:`@args | | `@temps | `@.Statements]'			do: [:aNode :answer | answer];		matches: name do: [:aNode :answer | true].	^searcher executeTree: aParseTree initialAnswer: false! !!MoveVariableDefinitionRefactoring methodsFor: 'initialize-release'!class: aClass selector: aSelector interval: anInterval 	interval := anInterval.	class := self classObjectFor: aClass.	selector := aSelector! !!MoveVariableDefinitionRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition withBlock: 					[| methodSource |					interval first <= interval last 						ifFalse: [self refactoringError: 'Invalid variable name'].					methodSource := class sourceCodeFor: selector.					methodSource size >= interval last 						ifFalse: [self refactoringError: 'Invalid range for variable'].					name := methodSource copyFrom: interval first to: interval last.					(self checkInstanceVariableName: name in: class) 						ifFalse: 							[self 								refactoringError: name , ' does not seem to be a valid variable name.'].					parseTree := class parseTreeFor: selector.					self checkParseTree.					true])! !!MoveVariableDefinitionRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' bindTight: '.	interval storeOn: aStream.	aStream nextPutAll: ' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: selector.	aStream nextPut: $)! !!MoveVariableDefinitionRefactoring class methodsFor: 'instance creation'!bindTight: anInterval in: aClass selector: aSelector 	^self new		class: aClass		selector: aSelector		interval: anInterval! !!MoveVariableDefinitionRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk bindTight: anInterval in: aClass selector: aSelector 	^(self new)		model: aRBSmalltalk;		class: aClass			selector: aSelector			interval: anInterval;		yourself! !!MoveVariableDefinitionTest methodsFor: 'tests'!testMoveDefinition	| refactoring |	refactoring := MoveVariableDefinitionRefactoring 				bindTight: (self convertInterval: (19 to: 22)						for: (RefactoryTestDataApp sourceCodeAt: #moveDefinition))				in: RefactoryTestDataApp				selector: #moveDefinition.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #moveDefinition) = (RBParser 							parseMethod: 'moveDefinition								^(self collect: 										[:each | 										| temp |										temp := each printString.										temp , temp]) 									select: 										[:each | 										| temp |										temp := each size.										temp odd]')! !!MoveVariableDefinitionTest methodsFor: 'tests'!testMoveDefinitionIntoBlockThatIsAReceiverOfACascadedMessage	| refactoring |	refactoring := MoveVariableDefinitionRefactoring 				bindTight: (self convertInterval: (48 to: 58)						for: (RefactoryTestDataApp sourceCodeAt: #referencesConditionFor:))				in: RefactoryTestDataApp				selector: #referencesConditionFor:.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #referencesConditionFor:) = (RBParser 							parseMethod: 'referencesConditionFor: aClass 								| environment  |								^(RBCondition withBlock: 										[| association |association := Smalltalk associationAt: aClass name													ifAbsent: [self refactoringError: ''Could not find class''].										environment := (self environment referencesTo: association) 													| (self environment referencesTo: aClass name).										environment isEmpty])									errorMacro: aClass , '' is referenced.<n>Browse references?'';									errorBlock: [environment openEditor];									yourself')! !!MoveVariableDefinitionTest methodsFor: 'tests'!testNoMoveDefinition	self shouldFail: (MoveVariableDefinitionRefactoring 				bindTight: (self convertInterval: (21 to: 24)						for: (RefactoryTestDataApp sourceCodeAt: #moveDefinition))				in: RefactoryTestDataApp				selector: #noMoveDefinition)! !!MoveVariableDefinitionTest methodsFor: 'tests'!testNonExistantName	self		shouldFail: (MoveVariableDefinitionRefactoring 					bindTight: (1 to: 10)					in: LintRuleTest					selector: #name1);		shouldFail: (MoveVariableDefinitionRefactoring 					bindTight: (self convertInterval: (44 to: 54)							for: (LintRuleTest sourceCodeAt: #displayName))					in: LintRuleTest					selector: #displayName);		shouldFail: (MoveVariableDefinitionRefactoring 					bindTight: (self convertInterval: (16 to: 25)							for: (LintRuleTest sourceCodeAt: #displayName))					in: LintRuleTest					selector: #displayName)! !!MultiEnvironment methodsFor: 'adding'!addClass: aClass into: aValue 	(environmentDictionaries at: aValue ifAbsentPut: [SelectorEnvironment new]) 		addClass: aClass! !!MultiEnvironment methodsFor: 'adding'!addClass: aClass selector: aSymbol into: aValue 	(environmentDictionaries at: aValue ifAbsentPut: [SelectorEnvironment new]) 		addClass: aClass		selector: aSymbol! !!MultiEnvironment methodsFor: 'accessing' stamp: 'rr 4/19/2004 16:04'!asSelectorEnvironment	| s |	s := SelectorEnvironment new.	s label: self label.	environmentDictionaries do: [:each | | env |			env := each asSelectorEnvironment. 			env classesDo: [:cls | env selectorsForClass: cls do:  [:sel | s addClass: cls selector: sel]]].	^ s	  ! !!MultiEnvironment methodsFor: 'accessing'!environments	^environmentDictionaries keys! !!MultiEnvironment methodsFor: 'accessing'!problemCount	^environmentDictionaries size! !!MultiEnvironment methodsFor: 'accessing'!selectEnvironment: aValue 	environment := environmentDictionaries at: aValue				ifAbsent: [SelectorEnvironment new]! !!MultiEnvironment methodsFor: 'initialize-release'!initialize	super initialize.	environmentDictionaries := Dictionary new.	environment := SelectorEnvironment new! !!MultiEnvironment methodsFor: 'testing'!isEmpty	^environmentDictionaries isEmpty! !!MultiEnvironment methodsFor: 'GUI' stamp: 'lr 12/13/2005 15:00'!openEditor	self explore.! !!MultiEnvironment methodsFor: 'removing'!removeClass: aClass into: aValue 	(environmentDictionaries at: aValue ifAbsent: [SelectorEnvironment new]) 		removeClass: aClass! !!MultiEnvironment methodsFor: 'removing'!removeClass: aClass selector: aSelector into: aValue 	(environmentDictionaries at: aValue ifAbsentPut: [SelectorEnvironment new]) 		removeClass: aClass		selector: aSelector! !!MultiValuedAnnotation methodsFor: 'adding' stamp: 'pmm 10/9/2005 20:18'!addValue: anObject	^self values add: anObject! !!MultiValuedAnnotation methodsFor: 'enumerating' stamp: 'pmm 7/9/2006 12:09'!collect: aOneArgumentBlock	| newCollection |	newCollection := OrderedCollection new.	self do: [:each | newCollection add: (aOneArgumentBlock value: each)].	^ newCollection! !!MultiValuedAnnotation methodsFor: 'enumerating' stamp: 'pmm 10/9/2005 23:11'!do: aBlock	self values do: aBlock! !!MultiValuedAnnotation methodsFor: 'testing' stamp: 'pmm 10/9/2005 22:44'!hasValue	^true! !!MultiValuedAnnotation methodsFor: 'testing' stamp: 'pmm 6/5/2006 10:20'!isMultivalued	^true! !!MultiValuedAnnotation methodsFor: 'initialize-release' stamp: 'pmm 10/9/2005 20:18'!initialize	super initialize.	self values: OrderedCollection new! !!MultiValuedAnnotation methodsFor: 'accessing' stamp: 'pmm 6/11/2006 15:09'!mergeValueOf: anAnnotation	self addValues: anAnnotation values! !!MultiValuedAnnotation methodsFor: 'accessing' stamp: 'pmm 10/9/2005 20:17'!size	^self values size! !!MultiValuedAnnotation methodsFor: 'accessing' stamp: 'pmm 10/9/2005 20:17'!values	^values! !!MultiValuedAnnotation methodsFor: 'accessing' stamp: 'pmm 6/11/2006 21:51'!values: aCollection 	values := aCollection! !!MulticolumnLazyIRCListMorph methodsFor: 'drawing' stamp: 'sbw 5/23/2004 08:32'!columnPadding	^4! !!MulticolumnLazyIRCListMorph methodsFor: 'drawing' stamp: 'sbw 5/21/2004 20:21'!display: items atRow: row on: canvas 	"display the specified item, which is on the specified row; for  	Multicolumn  	lists, items will be a list of strings"	| drawBounds |	drawBounds := self drawBoundsForRow: row.	drawBounds := drawBounds intersect: self bounds.	items		with: (1 to: items size)		do: [:item :index | 			"move the bounds to the right at each step"			index > 1				ifTrue: [drawBounds := drawBounds left: drawBounds left + 1									+ (columnWidths at: index - 1)].			item isText				ifTrue: [canvas						drawString: item						in: drawBounds						font: (font								emphasized: (item emphasisAt: 1))						color: (self colorForRow: row)]				ifFalse: [canvas						drawString: item						in: drawBounds						font: font						color: (self colorForRow: row)]]! !!MulticolumnLazyIRCListMorph methodsFor: 'drawing' stamp: 'sbw 5/23/2004 08:32'!setColumnWidthsFor: aCanvas 	"set columnWidths for drawing on the specified canvas"	| row topRow bottomRow |	columnWidths		ifNil: [columnWidths := (self item: 1)						collect: [:ignored | 0]].	topRow := (self topVisibleRowForCanvas: aCanvas)				max: 1.	bottomRow := (self bottomVisibleRowForCanvas: aCanvas)				max: 1.	topRow > bottomRow		ifTrue: [^ self].	topRow		to: bottomRow		do: [:rowIndex | 			row := self item: rowIndex.			columnWidths := columnWidths						with: row						collect: [:currentWidth :item | 							| widthOfItem | 							widthOfItem := (font widthOfStringOrText: item)										+ self columnPadding.							widthOfItem > currentWidth								ifTrue: [self changed.									widthOfItem]								ifFalse: [currentWidth]]]! !!MulticolumnLazyIRCListMorph methodsFor: 'accessing' stamp: 'sbw 5/23/2004 07:54'!columnWidths	^ columnWidths! !!MulticolumnLazyIRCListMorph methodsFor: 'as yet unclassified' stamp: 'fc 8/7/2004 15:20'!drawSelectionOn: aCanvas" This is copied almost as is from our Super LazylistMorph. The only change is to the collor used for the highlighting. On Macs with display depth set to 16 the original highlighting was invisible."	| selectionDrawBounds |	selectedRow ifNil: [ ^self ].	selectedRow = 0 ifTrue: [ ^self ].	selectionDrawBounds := self drawBoundsForRow: selectedRow.	selectionDrawBounds := selectionDrawBounds intersect: self bounds.	aCanvas fillRectangle: selectionDrawBounds color: (TranslucentColor r:0 g:0 b:0 alpha: 0.15)! !!MulticolumnLazyIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 3/12/2005 13:54'!rowHighlightColor	listSource model isNil		ifFalse: [^ listSource model rowHighlightColor].	^ super rowHighlightColor! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'MPH 10/18/2000 18:34'!anySelected	^selection includes:true.! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'MPH 10/22/2000 22:31'!selectAll	1 to: list size do:[:each | selection at: each put: true].	self changed: #allSelections.! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'MPH 10/22/2000 22:30'!selectNone	selection := Dictionary new.	self changed: #allSelections.! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'nk 3/1/2005 09:21'!selectedItem	primary isZero ifTrue: [ ^nil ].	^list at: primary.! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'MPH 10/19/2000 11:43'!selectedItems	| index |	index := 0.	^list select:		[:each | index := index + 1.		 self listSelectionAt: index]! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'ls 11/8/2003 16:20'!selectionsChanged	self changed: #allSelections.! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'MPH 10/18/2000 17:03'!list	^list collect:[:each| each asString]! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'MPH 10/18/2000 16:12'!listSelectionAt: anIndex	^selection at: anIndex ifAbsent:[^false]! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'ls 11/8/2003 16:20'!listSelectionAt: anIndex put: aValue 	selection at: anIndex put: aValue.	self selectionsChanged! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'nk 3/1/2005 09:13'!primarySelection	^primary! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'nk 3/1/2005 09:13'!primarySelection: aNumber	primary := aNumber! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'MPH 10/18/2000 16:57'!trueIndexes	| indexList |	indexList := Set new.	selection keysAndValuesDo:[:eachKey :eachValue | eachValue ifTrue: [indexList add: eachKey]].	^indexList! !!MultipleSelectionModel methodsFor: 'user interface' stamp: 'nk 3/1/2005 09:13'!listMorph	| m |	m := PluggableListMorphOfMany				on: self				list: #list				primarySelection: #primarySelection				changePrimarySelection: #primarySelection:				listSelection: #listSelectionAt:				changeListSelection: #listSelectionAt:put:				menu: #menu:.	m color: Color transparent; borderWidth: 0.	^ m! !!MultipleSelectionModel methodsFor: 'menus' stamp: 'nk 2/27/2005 14:05'!menu: aMenu 	aMenu		add: 'Select All' action: #selectAll;		add: 'Select None' action: #selectNone.	getMenu ifNotNil: 			[model perform: getMenu				withArguments: { 						aMenu.						self}].	^aMenu! !!MultipleSelectionModel methodsFor: 'menus' stamp: 'nk 2/27/2005 14:05'!menuGetter: aSelector	getMenu := aSelector! !!MultipleSelectionModel methodsFor: 'menus' stamp: 'nk 2/27/2005 14:06'!perform: selector orSendTo: otherTarget	^(self respondsTo: selector)		ifTrue: [ self perform: selector]		ifFalse: [ otherTarget perform: selector]! !!MultipleSelectionModel methodsFor: 'initialization' stamp: 'nk 3/1/2005 09:14'!model: aModel list: aList message: aSelector selection: anArray 	model := aModel.	list := aList.	getList := aSelector.	selection := anArray.	primary := 0! !!MultipleSelectionModel methodsFor: 'updating' stamp: 'nk 2/27/2005 14:15'!refreshList	| newList oldSelection newSelection index |	newSelection := Dictionary new.	(model notNil and: [getList notNil]) 		ifTrue: 			[newList := model perform: getList.			oldSelection := self selectedItems collect: [:each | each asString].			index := 0.			(newList collect: [:each | each asString]) do: 					[:each | 					index := index + 1.					(oldSelection includes: each) ifTrue: [newSelection at: index put: true]].			list := newList.			self changed: #list].	selection := newSelection.	self selectionsChanged! !!MultipleSelectionModel methodsFor: 'updating' stamp: 'nk 2/27/2005 15:31'!update: aSelector 	self refreshList! !!MultipleSelectionModel class methodsFor: '*RefactoringEngine' stamp: 'nk 2/27/2005 14:03'!withModel: aModel withList: aList	^self withModel: aModel withList: aList withMessage: nil! !!MultipleSelectionModel class methodsFor: '*RefactoringEngine' stamp: 'nk 2/27/2005 14:02'!withModel: aModel  withList: aList  withMessage: aSelector 	^super new 		model: aModel		list: aList		message: aSelector		selection: Dictionary new! !!NewCompilerDocumentation methodsFor: 'as yet unclassified' stamp: 'md 6/8/2006 15:57'!compiler'Comment for class Compiler:Closure Compilerby Anthony Hannan 3/13/2003The Compiler class (like before) serves as the interface to the compiler.  If Preferences compileUseNewCompiler is true it will run the new closure compiler.  The closure compiler classes reside in their own system category called "Compiler", which is broken down into four minor categories: "Compiler-Syntax", "Compiler-Semantics", "Compiler-IR", and "Compiler-Bytecodes".  The closure compiler also uses classes in "SmaCC-Runtime".Like most compilers, the closure compiler translates source text into bytecodes in a sequence of phases or transformations.Phase 1 - Scan and parse text into abstract syntax tree (AST)SqueakScanner and SqueakParser in "Compiler-Syntax" transform a method or do-it text into a Refactory abstract syntax tree.  SqueakScanner and SqueakParser classes were automatically generated using the SmaCC parser generator from a token and grammar specification derived from the StScanner and StParser specifications that comes with SmaCC.Phase 2 - Verify and annotate AST (semantic analysis)SemanticChecker in "Compiler-Semantics" binds RBVariableNodes in the AST to temp, instance, or pool (class, pool, or global) SemVars, raising a notifier if no match is found.  The lookup is performed on a chain of SemScopes, one for the class, method and each nested closure.  Var usage (read/write/capture-in-closure) is tracked using a FiniteAutomaton.  The final usage state is used to determine unused temps and escaping temps (temps whose storage need to reside independent of the context since a block may assign to it after the context is gone).Phase 3 - Translate AST to intermediate representation (IR)SemanticTranslator in "Compiler-Semantics" visits each node in the AST and invokes the appropriate instruction message on IRBuilder in "Compiler-IR" resulting in an IRMethod.  An IRMethod consists of IRInstructions grouped by IRSequence (basic block).  Each IRInstruction represents a simple stack instruction like pushTemp: or send:.Phase 4 - Optimize IRTwo simple optimization are applied to the IRMethod: absorbJumpsToSingleInstrs and absorbConstantConditionalJumps. The first eliminates jumps to returns and returns directly.  The second converts chained constant jumps created by and:/or: to single jumps directly to the target code.Phase 5 - Translate IR to bytecodes (CompiledMethod)IRTranslator in "Compiler-IR" visits each IR instruction and invokes the appropriate bytecode message on BytecodeGenerator in "Compiler-Bytecodes".  Certain combinations of IR instructions (like storeTemp: and popTop) are mapped to a single bytecode instructions.'! !!NewCompilerDocumentation commentStamp: 'md 7/23/2005 09:21' prior: 0!This class is used for collection documentation... e.g. for classes outside of NewCompiler(e.g. Compiler). This will go away at some point.!!NoInlineAnnotation methodsFor: 'testing' stamp: 'pmm 10/9/2005 20:29'!isSourceVisible	^true! !!NoInlineAnnotation class methodsFor: 'accessing' stamp: 'pmm 6/11/2006 09:56'!key	^#noInline! !!NoInlineAnnotation class methodsFor: 'accessing' stamp: 'pmm 6/11/2006 09:57'!keys	^Array with: self key! !!NoValueAnnotation methodsFor: 'adding' stamp: 'pmm 10/9/2005 22:44'!addValue: anObject	"do nothing"! !!NoValueAnnotation methodsFor: 'adding' stamp: 'pmm 6/11/2006 15:07'!mergeValueOf: anAnnotation	"ignore"! !!NoValueAnnotation methodsFor: 'enumerating' stamp: 'pmm 10/9/2005 22:58'!do: aBlock	aBlock value: nil! !!NoValueAnnotation methodsFor: 'testing' stamp: 'pmm 10/9/2005 22:44'!hasValue	^false! !!NoValueAnnotation methodsFor: 'testing' stamp: 'pmm 6/5/2006 10:20'!isMultivalued	^false! !!NoValueAnnotation methodsFor: 'accessing' stamp: 'pmm 6/5/2006 10:20'!size	^0! !!NoValueAnnotation class methodsFor: 'instance creation' stamp: 'pmm 7/28/2006 11:13'!newWithKey	^self new		key: self keys anyOne;		yourself! !!NonClosureScopeFixer methodsFor: 'visitor-double dispatching' stamp: 'md 3/16/2006 17:52'!acceptDoItNode: aDoItNode	methodScope := aDoItNode scope.	self visitNode: aDoItNode body.! !!NonClosureScopeFixer methodsFor: 'visitor-double dispatching' stamp: 'md 3/16/2006 17:52'!acceptMethodNode: aMethodNode	methodScope := aMethodNode scope.	self visitNode: aMethodNode body.! !!NonClosureScopeFixer methodsFor: 'visitor-double dispatching' stamp: 'md 10/5/2007 14:40'!acceptVariableNode: aVariableNode	| temp |	aVariableNode name = 'thisContext' ifTrue: [^self].	aVariableNode binding isTemp ifFalse: [^self].	aVariableNode binding scope isHome ifTrue: [^self].		temp := methodScope rawVar: aVariableNode name.	temp ifNil: [temp := methodScope addTemp: aVariableNode name].	temp markArg.	aVariableNode binding: temp.		super acceptVariableNode: aVariableNode.! !!NonClosureScopeFixer commentStamp: 'md 3/16/2006 17:49' prior: 0!Standard Squeak has only one scope for temporaries: the method. All temps and args,even those of the blocks, are just temps of the method.But when compiling, we for sure want to do a correct scope analysis to make surethat we do not access temps from outside their static scope... even if that's notpart of the semantic model of non-Closure Squeak.The idea now is to use the scoping of the ClosureCompiler to work normally, makingscopes for variables... checking for errors. And then, afterwards, we go overthe AST and rewrite all temp-bindings... ugly.!!NonClosureScopeFixerTest methodsFor: 'example' stamp: 'md 3/16/2006 18:00'!exampleSimple	| a |	a := 1.	^[:b | a + b] value: 1.! !!NonClosureScopeFixerTest methodsFor: 'tests' stamp: 'md 3/17/2006 11:38'!testSimple	| text ast |		text := self class sourceCodeAt: #exampleSimple.	self assert: text isText.	ast := Parser2 new parse: text class: self class.	self assert: (ast isKindOf: RBMethodNode).		self assert: ast scope isMethodScope.	NonClosureScopeFixer new visitNode: ast.! !!NotEnvironment methodsFor: 'testing'!includesCategory: aCategory 	^(self classNamesFor: aCategory) isEmpty not! !!NotEnvironment methodsFor: 'testing'!includesClass: aClass 	(environment includesClass: aClass) ifFalse: [^true].	aClass selectorsAndMethodsDo: 			[:each :meth | 			(environment includesSelector: each in: aClass) ifFalse: [^true]].	^false! !!NotEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass 	^(self selectorsFor: aProtocol in: aClass) isEmpty not! !!NotEnvironment methodsFor: 'testing'!includesSelector: aSelector in: aClass	^(environment includesSelector: aSelector in: aClass) not! !!NotEnvironment methodsFor: 'environments'!not	^environment! !!NotEnvironment methodsFor: 'printing'!storeOn: aStream	environment storeOn: aStream.	aStream nextPutAll: ' not'! !!Object methodsFor: '*newcompiler' stamp: 'ajh 6/29/2004 14:40'!doItScope	^ self class parseScope instanceScope! !!Object methodsFor: '*newcompiler' stamp: 'ms 7/31/2007 00:25'!isBlockClosure	^false! !!Object methodsFor: '*newcompiler-override' stamp: 'md 4/21/2007 16:55' prior: 25784010!executeMethod: compiledMethod	"Execute compiledMethod against the receiver with no args"	<primitive: 189> "uncomment once prim 189 is in VM"	^ self withArgs: #() executeMethod: compiledMethod! !!Object methodsFor: '*newcompiler-override' stamp: 'md 4/21/2007 16:55' prior: 25788469!with: arg1 executeMethod: compiledMethod	"Execute compiledMethod against the receiver and arg1"	<primitive: 189> "uncomment once prim 189 is in VM"	^ self withArgs: {arg1} executeMethod: compiledMethod! !!Object methodsFor: '*newcompiler-override' stamp: 'md 4/21/2007 16:55' prior: 25788749!with: arg1 with: arg2 executeMethod: compiledMethod	"Execute compiledMethod against the receiver and arg1 & arg2"	<primitive: 189> "uncomment once prim 189 is in VM"	^ self withArgs: {arg1. arg2} executeMethod: compiledMethod! !!Object methodsFor: '*newcompiler-override' stamp: 'md 4/21/2007 16:55' prior: 25789053!with: arg1 with: arg2 with: arg3 executeMethod: compiledMethod	"Execute compiledMethod against the receiver and arg1, arg2, & arg3"	<primitive: 189> "uncomment once prim 189 is in VM"	^ self withArgs: {arg1. arg2. arg3} executeMethod: compiledMethod! !!Object methodsFor: '*newcompiler-override' stamp: 'md 4/21/2007 16:55' prior: 25789381!with: arg1 with: arg2 with: arg3 with: arg4 executeMethod: compiledMethod	"Execute compiledMethod against the receiver and arg1, arg2, arg3, & arg4"	<primitive: 189> "uncomment once prim 189 is in VM"	^ self withArgs: {arg1. arg2. arg3. arg4} executeMethod: compiledMethod! !!Object methodsFor: '*persephone' stamp: 'pmm 7/18/2005 10:24'!allInstVars	^self class allInstVarNames collect: [ :each |		self instVarNamed: each ]! !!Object methodsFor: '*persephone' stamp: 'md 3/31/2007 19:18'!asLiteralNode	^self isLiteral		ifTrue: [ RBLiteralNode value: self ]		ifFalse: [ PEObjectLiteralNode value: self ]! !!Object methodsFor: '*context' stamp: 'ms 11/1/2007 13:07'!ctxtAt: index put: value 	"Only for context awar link of geppetto.		Primitive. Assumes receiver is indexable. Store the argument value in 	the indexable element of the receiver indicated by index. Fail if the 	index is not an Integer or is out of bounds. Or fail if the value is not of 	the right type for this kind of collection. Answer the value that was 	stored. Essential. See Object documentation whatIsAPrimitive."	<primitive: 61>	index isInteger ifTrue:		[self class isVariable			ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]]			ifFalse: [self errorNotIndexable]].	index isNumber		ifTrue: [^self ctxtAt: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: '*geppetto2' stamp: 'md 2/12/2007 11:00'!isBoolean	^false! !!Object methodsFor: '*network-irc-gui' stamp: 'sbw 3/1/2002 11:44'!isStringMorph	^false! !!ObjectTracer methodsFor: 'intialization' stamp: 'Y.-G.G. 4/4/2014 12:44'!initialize	self shouldBeImplemented! !!PEASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'md 3/28/2007 15:21'!acceptMethodNode: aJMethodNode	super acceptMethodNode: aJMethodNode! !!PEASTTranslator methodsFor: 'initialize-release' stamp: 'md 3/31/2007 19:15'!initialize	methodBuilder := IRBuilder new.	effectTranslator := self as: PEASTTranslatorForEffect.	valueTranslator := self as: PEASTTranslatorForValue.	effectTranslator instVarNamed: #effectTranslator put: effectTranslator.	effectTranslator instVarNamed: #valueTranslator put: valueTranslator.	valueTranslator instVarNamed: #valueTranslator put: valueTranslator.! !!PEASTTranslator methodsFor: 'accessing' stamp: 'pmm 9/19/2005 17:36'!noInlineAnnotationKey	^#noInline! !!PEASTTranslatorForEffect methodsFor: 'as yet unclassified' stamp: 'md 10/22/2007 15:30'!acceptInstrumentedVariableNode: aVariableNode	"ignore"! !!PEASTTranslatorForEffect methodsFor: 'visitor-double dispatching' stamp: 'md 3/28/2007 16:30'!acceptMessageNode: aMessageNode 	| noInline |	noInline := aMessageNode hasAnnotation: NoInlineAnnotation key.	noInline ifFalse: [		aMessageNode isInlineIf ifTrue: [^ self emitIfNode: aMessageNode].		aMessageNode isInlineIfNil ifTrue: [^ self emitIfNilNode: aMessageNode].		aMessageNode isInlineAndOr ifTrue: [^ self emitAndOrNode: aMessageNode].		aMessageNode isInlineWhile ifTrue: [^ self emitWhileNode: aMessageNode].		aMessageNode isInlineToDo ifTrue: [^ self emitToDoNode: aMessageNode].		aMessageNode isInlineCase ifTrue: [^ self emitCaseNode: aMessageNode]. ].	^ self emitMessageNode: aMessageNode! !!PEASTTranslatorForValue methodsFor: 'as yet unclassified' stamp: 'md 8/23/2007 22:08'!acceptInstrumentedLiteralNode: aLiteralNode	self emitBefore: aLiteralNode.	self acceptLiteralNode: aLiteralNode.		self emitAfter: aLiteralNode.! !!PEASTTranslatorForValue methodsFor: 'as yet unclassified' stamp: 'md 8/23/2007 22:08'!acceptInstrumentedObjectLiteralNode: aLiteralNode	self acceptInstrumentedLiteralNode: aLiteralNode! !!PEASTTranslatorForValue methodsFor: 'as yet unclassified' stamp: 'md 10/22/2007 15:29'!acceptInstrumentedVariableNode: aVariableNode		self emitBefore: aVariableNode.		self acceptVariableNode: aVariableNode.		self emitAfter: aVariableNode.! !!PEASTTranslatorForValue methodsFor: 'as yet unclassified' stamp: 'md 8/25/2007 15:59'!popAfterIntrsumentatation! !!PEASTTranslatorForValue methodsFor: 'visitor-double dispatching' stamp: 'md 4/15/2007 14:36'!acceptMessageNode: aMessageNode 	| noInline |		noInline := aMessageNode hasAnnotation: NoInlineAnnotation key.	noInline ifFalse: [		aMessageNode isInlineIf ifTrue: [^ self emitIfNode: aMessageNode].		aMessageNode isInlineIfNil ifTrue: [^ self emitIfNilNode: aMessageNode].		aMessageNode isInlineAndOr ifTrue: [^ self emitAndOrNode: aMessageNode].		aMessageNode isInlineWhile ifTrue: [^ self emitWhileNode: aMessageNode].		aMessageNode isInlineToDo ifTrue: [^ self emitToDoNode: aMessageNode].		aMessageNode isInlineCase ifTrue: [^ self emitCaseNode: aMessageNode]. ].	^ self emitMessageNode: aMessageNode! !!PEAggressiveLiteralEvaluator methodsFor: 'testing' stamp: 'pmm 9/24/2006 12:16'!isAcceptable: aResult	^true! !!PEAggressiveLiteralEvaluator commentStamp: 'pmm 9/24/2006 10:58' prior: 0!This inliner will stop inlining once the value is no longer a literal.!!PEAssertDisabler methodsFor: 'visitor-double dispatching' stamp: 'md 4/15/2007 15:27'!acceptMessageNode: aNode	(aNode selector == #assert:) ifTrue: [		"we do not want to remove assertions in tests..."		(aNode methodNode methodClass inheritsFrom: TestCase) ifFalse: [			aNode replaceWith: (RBVariableNode named: 'self')]].		super acceptMessageNode: aNode.! !!PEAssertDisabler class methodsFor: 'class initialization' stamp: 'md 12/13/2007 09:51'!initialize	Preferences		addBooleanPreference: #disableAssert		categories: #(reflectivitydemo)		default: false		balloonHelp:  'If true, we do not compile any code for assert: outside of the TestCase hierarchy.'		projectLocal: false		changeInformee: self		changeSelector: #invalidateSenderOfAssert.! !!PEAssertDisabler class methodsFor: 'invalidation' stamp: 'md 4/15/2007 15:19'!invalidateSenderOfAssert	((SystemNavigation new allCallsOn: #assert:) select: [:each | 		(each methodClass inheritsFrom: TestCase) not]) do: [:ref |			ref compiledMethod invalidate].! !!PEAssertDisabler class methodsFor: 'plugin interface' stamp: 'md 7/5/2007 16:54'!isActive	^Preferences disableAssert! !!PEAssertDisablerTest methodsFor: 'tests' stamp: 'md 4/15/2007 15:33'!testDisableAssert	self assert: PersephoneExample new exampleAssert.	Preferences enable: #disableAssert.	self deny: PersephoneExample new exampleAssert.	Preferences disable: #disableAssert.	self assert: PersephoneExample new exampleAssert.! !!PEBlockInterpreter methodsFor: 'private' stamp: 'pmm 5/1/2006 12:36'!copyForSaving	"obsolete"! !!PEBlockInterpreter methodsFor: 'private' stamp: 'pmm 5/1/2006 12:36'!fixTemps	"obsolete"! !!PEBlockInterpreter methodsFor: 'private' stamp: 'pmm 5/1/2006 12:36'!valueError	self error: 'Incompatible number of args'! !!PEBlockInterpreter methodsFor: 'scheduling' stamp: 'pmm 5/1/2006 12:37'!fork	"Create and schedule a Process running the code in the receiver."	^ self newProcess resume! !!PEBlockInterpreter methodsFor: 'scheduling' stamp: 'pmm 5/1/2006 12:37'!forkAndWait	"Suspend current process while self runs"	| semaphore |	semaphore := Semaphore new.	[self ensure: [semaphore signal]] fork.	semaphore wait.! !!PEBlockInterpreter methodsFor: 'scheduling' stamp: 'pmm 5/1/2006 12:38'!forkAt: priority 	"Create and schedule a Process running the code in the receiver at the given priority. Answer the newly created process."	^ self newProcess		priority: priority;		resume! !!PEBlockInterpreter methodsFor: 'scheduling' stamp: 'pmm 5/1/2006 12:38'!forkAt: priority named: name	"Create and schedule a Process running the code in the receiver at the	given priority and having the given name. Answer the newly created 	process."	| forkedProcess |	forkedProcess := self newProcess.	forkedProcess priority: priority.	forkedProcess name: name.	^ forkedProcess resume! !!PEBlockInterpreter methodsFor: 'scheduling' stamp: 'pmm 5/1/2006 12:38'!forkNamed: aString	"Create and schedule a Process running the code in the receiver and	having the given name."	^ self newProcess name: aString; resume! !!PEBlockInterpreter methodsFor: 'scheduling' stamp: 'pmm 5/1/2006 12:38'!newProcess	"Answer a Process running the code in the receiver. The process is not 	scheduled."	<primitive: 19> "Simulation guard"	^ Process		forContext: 			[self value.			Processor terminateActive] asContext		priority: Processor activePriority! !!PEBlockInterpreter methodsFor: 'scheduling' stamp: 'pmm 5/1/2006 12:39'!simulate	"Like run except interpret self using Smalltalk instead of VM.  It is much slower."	^ self newProcess simulate! !!PEBlockInterpreter methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:20'!bench	"See how many times I can value in 5 seconds.  I'll answer a meaningful description."	| startTime endTime count |	count := 0.	endTime := Time millisecondClockValue + 5000.	startTime := Time millisecondClockValue.	[ Time millisecondClockValue > endTime ] whileFalse: [ self value.  count := count + 1 ].	endTime := Time millisecondClockValue.	^count = 1		ifTrue: [ ((endTime - startTime) // 1000) printString, ' seconds.' ]		ifFalse:			[ ((count * 1000) / (endTime - startTime)) asFloat printString, ' per second.' ]! !!PEBlockInterpreter methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:21'!durationToRun	"Answer the duration taken to execute this block."	^ Duration milliSeconds: self timeToRun! !!PEBlockInterpreter methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:21'!ifError: errorHandlerBlock	"Evaluate the block represented by the receiver, and normally return it's value.  If an error occurs, the errorHandlerBlock is evaluated, and it's value is instead returned.  The errorHandlerBlock must accept zero, one, or two parameters (the error message and the receiver)."	"Examples:		[1 whatsUpDoc] ifError: [:err :rcvr | 'huh?'].		[1 / 0] ifError: [:err :rcvr |			'ZeroDivide' = err				ifTrue: [Float infinity]				ifFalse: [self error: err]]"	^ self on: Error do: [:ex |		errorHandlerBlock valueWithPossibleArgs: {ex description. ex receiver}]! !!PEBlockInterpreter methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:22'!timeToRun	"Answer the number of milliseconds taken to execute this block."	^ Time millisecondsToRun: self! !!PEBlockInterpreter methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:23'!value	"Evaluate the block represented by the receiver."	^self valueWithArguments: #()! !!PEBlockInterpreter methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:24'!value: arg	"Evaluate the block with the given argument. Fail if the block expects other than 1 arguments."	^self valueWithArguments: (Array with: arg)! !!PEBlockInterpreter methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:25'!value: arg1 value: arg2 	"Evaluate the block with the given arguments. Fail if the block expects other than 2 arguments."	^self valueWithArguments: (Array with: arg1 with: arg2)! !!PEBlockInterpreter methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:25'!value: arg1 value: arg2 value: arg3 	"Evaluate the block with the given arguments. Fail if the block expects other than 3 arguments."	^self valueWithArguments: 		(Array			with: arg1			with: arg2			with: arg3)! !!PEBlockInterpreter methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:26'!value: arg1 value: arg2 value: arg3 value: arg4	"Evaluate the block with the given arguments. Fail if the block expects other than 4 arguments."	^self valueWithArguments: 		(Array			with: arg1			with: arg2			with: arg3			with: arg4)! !!PEBlockInterpreter methodsFor: 'evaluating' stamp: 'pmm 4/27/2006 21:45'!valueWithArguments: anArray	self initializeArgumentsWith: anArray.	^self visitNode: blockNode body! !!PEBlockInterpreter methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:32'!valueWithPossibleArgs: anArray	 "Evaluate the block represented by the receiver.      If the block requires arguments, take them from anArray. If anArray is too     large, the rest is ignored, if it is too small, use nil for the other arguments"	| numArgs |	numArgs := self numArgs.	numArgs = 0 ifTrue: [^ self value].	numArgs = anArray size ifTrue: [^ self valueWithArguments: anArray].	^ self valueWithArguments: (numArgs > anArray size		ifTrue: [anArray, (Array new: numArgs - anArray size)]		ifFalse: [anArray copyFrom: 1 to: numArgs])! !!PEBlockInterpreter methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:31'!valueWithPossibleArgument: anArg      "Evaluate the block represented by the receiver.      If the block requires one argument, use anArg, if it requires more than one,     fill up the rest with nils."	| numArgs |	numArgs := self numArgs.	numArgs = 0 ifTrue: [^self value].	numArgs = 1 ifTrue: [^self value: anArg].	numArgs  > 1 ifTrue: [^self valueWithArguments: {anArg}, (Array new: numArgs  - 1)]! !!PEBlockInterpreter methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:32'!valueWithin: aDuration onTimeout: timeoutBlock	"Evaluate the receiver.	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"	| theProcess delay watchdog done result |	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := aDuration asDelay.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		done ifFalse: [ theProcess signalException: TimedOut ] 	] newProcess.	"watchdog needs to run at high priority to do its job"	watchdog priority: Processor timingPriority.	"catch the timeout signal"	^ [	done := false.		watchdog resume.				"start up the watchdog"		result := self value.				"evaluate the receiver"		done := true.						"it has completed, so ..."		delay delaySemaphore signal.	"arrange for the watchdog to exit"		result ]			on: TimedOut do: [ :e | timeoutBlock value ].! !!PEBlockInterpreter methodsFor: 'exceptions' stamp: 'pmm 5/1/2006 12:33'!assert	self assert: self! !!PEBlockInterpreter methodsFor: 'exceptions' stamp: 'pmm 5/1/2006 12:33'!ensure: aBlock	"Evaluate a termination block after evaluating the receiver, regardless of whether the receiver's evaluation completes."	| returnValue b |	<primitive: 198>	returnValue := self value.	"aBlock wasn't nil when execution of this method began; it is nil'd out by the unwind machinery, and that's how we know it's already been evaluated ... otherwise, obviously, it needs to be evaluated"	aBlock == nil ifFalse: [		"nil out aBlock temp before evaluating aBlock so it is not executed again if aBlock remote returns"		b := aBlock.		thisContext tempAt: 1 put: nil.  "aBlock := nil"		b value.	].	^ returnValue! !!PEBlockInterpreter methodsFor: 'exceptions' stamp: 'pmm 5/1/2006 15:57'!ifCurtailed: aBlock	"Evaluate the receiver with an abnormal termination action."	^ [ self value ] ifCurtailed: aBlock! !!PEBlockInterpreter methodsFor: 'exceptions' stamp: 'pmm 5/1/2006 15:56'!on: exception do: handlerAction	"Evaluate the receiver in the scope of an exception handler."	^[ self value ] on: exception do: handlerAction! !!PEBlockInterpreter methodsFor: 'exceptions' stamp: 'pmm 5/1/2006 12:35'!onDNU: selector do: handleBlock	"Catch MessageNotUnderstood exceptions but only those of the given selector (DNU stands for doesNotUnderstand:)"	^ self on: MessageNotUnderstood do: [:exception |		exception message selector = selector			ifTrue: [handleBlock valueWithPossibleArgs: {exception}]			ifFalse: [exception pass]	  ]! !!PEBlockInterpreter methodsFor: 'exceptions' stamp: 'pmm 5/1/2006 12:35'!valueUninterruptably	"Prevent remote returns from escaping the sender.  Even attempts to terminate (unwind) this process will be halted and the process will resume here.  A terminate message is needed for every one of these in the sender chain to get the entire process unwound."	^ self ifCurtailed: [^ self]! !!PEBlockInterpreter methodsFor: 'accessing' stamp: 'pmm 4/24/2006 20:13'!blockNode	^blockNode! !!PEBlockInterpreter methodsFor: 'accessing' stamp: 'pmm 4/24/2006 20:13'!blockNode: aBlockNode 	blockNode := aBlockNode! !!PEBlockInterpreter methodsFor: 'accessing' stamp: 'pmm 4/27/2006 21:44'!codeNode	^blockNode! !!PEBlockInterpreter methodsFor: 'accessing' stamp: 'pmm 5/1/2006 12:14'!isBlock	^ true! !!PEBlockInterpreter methodsFor: 'accessing' stamp: 'pmm 4/24/2006 20:54'!methodClass	^methodInterpreter methodClass! !!PEBlockInterpreter methodsFor: 'accessing' stamp: 'pmm 4/24/2006 19:55'!methodInterpreter	^methodInterpreter! !!PEBlockInterpreter methodsFor: 'accessing' stamp: 'pmm 4/24/2006 20:14'!methodInterpreter: aMethodInterpreter 	methodInterpreter := aMethodInterpreter! !!PEBlockInterpreter methodsFor: 'accessing' stamp: 'pmm 8/23/2006 13:54'!nodesForInstrumentation	^Array with: self blockNode copy! !!PEBlockInterpreter methodsFor: 'accessing' stamp: 'pmm 4/28/2006 10:53'!numArgs	^blockNode numArgs! !!PEBlockInterpreter methodsFor: 'accessing' stamp: 'pmm 4/28/2006 10:42'!outerInterpreter	^outerInterpreter! !!PEBlockInterpreter methodsFor: 'accessing' stamp: 'pmm 4/28/2006 10:43'!outerInterpreter: aCodeInterpreter 	outerInterpreter := aCodeInterpreter! !!PEBlockInterpreter methodsFor: 'accessing' stamp: 'pmm 4/24/2006 20:51'!receiver	^methodInterpreter receiver! !!PEBlockInterpreter methodsFor: 'controlling' stamp: 'pmm 5/1/2006 12:16'!doWhileFalse: conditionBlock	"Evaluate the receiver once, then again as long the value of conditionBlock is false." 	| result |	[result := self value.	conditionBlock value] whileFalse.	^ result! !!PEBlockInterpreter methodsFor: 'controlling' stamp: 'pmm 5/1/2006 12:17'!doWhileTrue: conditionBlock	"Evaluate the receiver once, then again as long the value of conditionBlock is true." 	| result |	[result := self value.	conditionBlock value] whileTrue.	^ result! !!PEBlockInterpreter methodsFor: 'controlling' stamp: 'pmm 5/1/2006 12:17'!repeat	"Evaluate the receiver repeatedly, ending only if the block explicitly returns."	[self value. true] whileTrue! !!PEBlockInterpreter methodsFor: 'controlling' stamp: 'pmm 5/1/2006 12:18'!repeatWithGCIf: testBlock	| ans |	"run the receiver, and if testBlock returns true, garbage collect and run the receiver again"	ans := self value.	(testBlock value: ans) ifTrue: [ Smalltalk garbageCollect. ans := self value ].	^ans! !!PEBlockInterpreter methodsFor: 'controlling' stamp: 'pmm 5/1/2006 12:18'!whileFalse	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the receiver, as long as its value is false." 	^ [self value] whileFalse: []! !!PEBlockInterpreter methodsFor: 'controlling' stamp: 'pmm 5/1/2006 12:18'!whileFalse: aBlock 	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the argument, aBlock, as long as the value of the receiver is false."	^ [self value] whileFalse: [aBlock value]! !!PEBlockInterpreter methodsFor: 'controlling' stamp: 'pmm 5/1/2006 12:19'!whileTrue	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the receiver, as long as its value is true." 	^ [self value] whileTrue: []! !!PEBlockInterpreter methodsFor: 'controlling' stamp: 'pmm 5/1/2006 12:19'!whileTrue: aBlock 	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the argument, aBlock, as long as the value of the receiver is true."	^ [self value] whileTrue: [aBlock value]! !!PEBlockInterpreter methodsFor: 'visitor-double dispatching' stamp: 'pmm 4/28/2006 19:01'!acceptBlockNode: aBlockNode	^self blockInterpreterClass		block: aBlockNode		methodInterpreter: methodInterpreter		outerInterpreter: self! !!PEBlockInterpreter methodsFor: 'accessing-variables' stamp: 'pmm 4/28/2006 10:28'!instanceVariableAt: aString	^methodInterpreter instanceVariableAt: aString! !!PEBlockInterpreter methodsFor: 'accessing-variables' stamp: 'pmm 4/28/2006 10:28'!instanceVariableAt: aString put: anObject	^methodInterpreter instanceVariableAt: aString put: anObject! !!PEBlockInterpreter methodsFor: 'accessing-variables' stamp: 'pmm 4/28/2006 10:52'!temporaryVariableAt: aString	^temps		at: aString		ifAbsent: [			outerInterpreter temporaryVariableAt: aString ]! !!PEBlockInterpreter methodsFor: 'accessing-variables' stamp: 'pmm 4/28/2006 10:46'!temporaryVariableAt: aString put: anObject	^(temps includesKey: aString)		ifTrue: [ temps at: aString put: anObject ]		ifFalse: [ outerInterpreter temporaryVariableAt: aString put: anObject ]! !!PEBlockInterpreter methodsFor: 'returning' stamp: 'pmm 4/26/2006 17:45'!return: anObject	self methodInterpreter return: anObject! !!PEBlockInterpreter class methodsFor: 'instance creation' stamp: 'pmm 4/28/2006 10:43'!block: aBlockNode interpreter: aMethodInterpreter	^self new		blockNode: aBlockNode;		methodInterpreter: aMethodInterpreter;		outerInterpreter: aMethodInterpreter;		yourself! !!PEBlockInterpreter class methodsFor: 'instance creation' stamp: 'pmm 4/28/2006 10:44'!block: aBlockNode methodDnterpreter: aMethodInterpreter outerInterpreter: aCodeInterpreter	^self new		blockNode: aBlockNode;		methodInterpreter: aMethodInterpreter;		outerInterpreter: aCodeInterpreter;		yourself! !!PEBlockInterpreter class methodsFor: 'instance creation' stamp: 'pmm 4/28/2006 10:45'!block: aBlockNode methodInterpreter: aMethodInterpreter outerInterpreter: aCodeInterpreter	^self new		blockNode: aBlockNode;		methodInterpreter: aMethodInterpreter;		outerInterpreter: aCodeInterpreter;		yourself! !!PECodeInterpreter methodsFor: 'visitor-double dispatching' stamp: 'pmm 4/24/2006 20:12'!acceptArrayNode: anArrayNode 	^anArrayNode children collect: [ :each |		self visitNode: each ]! !!PECodeInterpreter methodsFor: 'visitor-double dispatching' stamp: 'pmm 4/26/2006 17:06'!acceptAssignmentNode: anAssignmentNode 	self		set: anAssignmentNode variable		toValue: (self visitNode: anAssignmentNode value)! !!PECodeInterpreter methodsFor: 'visitor-double dispatching' stamp: 'pmm 4/28/2006 10:45'!acceptBlockNode: aBlockNode	self subclassResponsibility! !!PECodeInterpreter methodsFor: 'visitor-double dispatching' stamp: 'pmm 4/24/2006 20:31'!acceptCascadeNode: aCascadeNode	| receiver last |	receiver := self visitNode: aCascadeNode receiver.	aCascadeNode messages do: [ :each |		last := receiver			perform: each selector			withArguments: (each arguments collect: [ :argument |				self visitNode: argument] ) ].	^last! !!PECodeInterpreter methodsFor: 'visitor-double dispatching' stamp: 'pmm 4/29/2006 11:58'!acceptDoItNode: aDoItNode	| localTempNames |	localTempNames := aDoItNode tempNames.	temps := Dictionary new: (localTempNames size).	localTempNames do: [ :each |		temps at: each put: nil ].	self visitNode: aDoItNode body	! !!PECodeInterpreter methodsFor: 'visitor-double dispatching' stamp: 'pmm 4/24/2006 20:08'!acceptLiteralNode: aLiteralNode	^aLiteralNode value! !!PECodeInterpreter methodsFor: 'visitor-double dispatching' stamp: 'md 4/16/2007 21:25'!acceptMessageNode: aMessageNode	| isSuperSend messageReceiver messageArguments |	isSuperSend := aMessageNode isSuperSend.	messageReceiver := isSuperSend		ifTrue: [ self receiver ]		ifFalse: [ self visitNode: aMessageNode receiver ].	messageArguments := aMessageNode arguments collect: [ :each |		self visitNode: each ].	^isSuperSend		ifTrue: [			messageReceiver				perform: aMessageNode selector				withArguments: messageArguments				inSuperclass: self methodClass superclass ]		ifFalse: [			messageReceiver				perform: aMessageNode selector				withArguments: messageArguments ]! !!PECodeInterpreter methodsFor: 'visitor-double dispatching' stamp: 'pmm 4/27/2006 23:37'!acceptReturnNode: aReturnNode 	self return: (self visitNode: aReturnNode value)! !!PECodeInterpreter methodsFor: 'visitor-double dispatching' stamp: 'pmm 4/24/2006 20:22'!acceptSequenceNode: aSequenceNode 	| last |	last := nil.	aSequenceNode statements do: [:each |		last := self visitNode: each ].	^last! !!PECodeInterpreter methodsFor: 'visitor-double dispatching' stamp: 'md 3/31/2007 19:01'!acceptVariableNode: aVariableNode	| name |	name := aVariableNode name.	(#('self' 'super') includes: name)		ifTrue: [ ^self receiver ].	name = 'true' ifTrue: [ ^true ].	name = 'false' ifTrue: [ ^false ].	name = 'nil' ifTrue: [ ^nil ].	name = 'thisContext' ifTrue: [ ^ PEInterpreterContext codeInterpreter: self ].		^aVariableNode		ifTemp: [ self temporaryVariableAt: name ]		ifInstance: [ self instanceVariableAt: name ]		ifGlobal: [ (self receiver class bindingOf: name) value ]! !!PECodeInterpreter methodsFor: 'private' stamp: 'md 3/31/2007 19:17'!blockInterpreterClass	^PEBlockInterpreter! !!PECodeInterpreter methodsFor: 'accessing' stamp: 'pmm 4/27/2006 21:44'!codeNode	self subclassResponsibility ! !!PECodeInterpreter methodsFor: 'accessing' stamp: 'pmm 4/24/2006 20:52'!methodClass	self subclassResponsibility ! !!PECodeInterpreter methodsFor: 'accessing' stamp: 'pmm 4/24/2006 20:16'!methodInterpreter	self subclassResponsibility ! !!PECodeInterpreter methodsFor: 'accessing' stamp: 'pmm 4/24/2006 20:51'!receiver	self subclassResponsibility ! !!PECodeInterpreter methodsFor: 'accessing' stamp: 'pmm 4/24/2006 16:29'!temps	^temps! !!PECodeInterpreter methodsFor: 'accessing' stamp: 'pmm 4/24/2006 16:30'!temps: aDictionary 	temps := aDictionary! !!PECodeInterpreter methodsFor: 'initialize-release' stamp: 'pmm 4/29/2006 12:45'!initializeArgumentsWith: anArray	| localTempNames |	localTempNames := self codeNode tempNames.	temps := Dictionary new: (localTempNames size).	localTempNames do: [ :each |		temps at: each put: nil ].	self codeNode arguments withIndexDo: [ :each :index | 		temps at: each name put: (anArray at: index) ].! !!PECodeInterpreter methodsFor: 'accessing-variables' stamp: 'pmm 4/26/2006 10:52'!instanceVariableAt: aString	self subclassResponsibility ! !!PECodeInterpreter methodsFor: 'accessing-variables' stamp: 'pmm 4/26/2006 17:03'!instanceVariableAt: aString put: anObject	self subclassResponsibility ! !!PECodeInterpreter methodsFor: 'accessing-variables' stamp: 'pmm 7/1/2006 15:21'!set: aVariable toValue: anObject	aVariable		ifTemp: [ self temporaryVariableAt: aVariable name put: anObject ]		ifInstance: [ self instanceVariableAt: aVariable name put: anObject ]		ifGlobal: [ (self receiver class bindingOf: aVariable name) value: anObject ].	^anObject! !!PECodeInterpreter methodsFor: 'accessing-variables' stamp: 'pmm 4/26/2006 10:53'!temporaryVariableAt: aString	self subclassResponsibility ! !!PECodeInterpreter methodsFor: 'accessing-variables' stamp: 'pmm 4/26/2006 17:02'!temporaryVariableAt: aString put: anObject	self subclassResponsibility ! !!PECodeInterpreter methodsFor: 'returning' stamp: 'pmm 4/24/2006 19:55'!return: anObject	self subclassResponsibility ! !!PECommonCompilationStrategy methodsFor: 'compiling' stamp: 'md 11/4/2007 20:05'!compile: aJMethod	| methodNode |		[aJMethod methodNode verifyIn: aJMethod methodClass parseScope]		on: SemanticWarning do: [:ex | ex correctIn: aJMethod methodNode].		"This uses the old style non-copying transformer. FIX" self flag: #FIXME.	methodNode := self transform: aJMethod methodNode. 		"This calls the new copying transformers. For now none"		"methodNode := self transform2: methodNode".	[methodNode verifyIn: aJMethod methodClass parseScope]		on: SemanticWarning do: [:ex | ex correctIn: aJMethod methodNode].		^(methodNode hasBeforeOrAfterCode)		ifTrue: [ self compileTransformed: methodNode ]		ifFalse: [ self compileDefault: methodNode ]! !!PECommonCompilationStrategy methodsFor: 'private' stamp: 'md 4/2/2007 17:28'!compileDefault: aMethodNode	^self		compileNode: aMethodNode		trailer: aMethodNode defaultTrailer! !!PECommonCompilationStrategy methodsFor: 'private' stamp: 'md 10/21/2007 20:56'!compileNode: aMethodNode trailer: aByteArray	^(ir := PEASTTranslator new		visitNode: aMethodNode;		ir) compiledMethodWith: aByteArray! !!PECommonCompilationStrategy methodsFor: 'private' stamp: 'pmm 7/21/2006 15:17'!compileTransformed: aJMethod	self subclassResponsibility! !!PECommonCompilationStrategy methodsFor: 'private' stamp: 'md 11/4/2007 19:59'!transform2: aNode	| transfromedNode |		transfromedNode := aNode.	self transformers2 do: [ :each |		transfromedNode := each visitNode: transfromedNode ].	^transfromedNode! !!PECommonCompilationStrategy methodsFor: 'private' stamp: 'md 7/25/2007 22:13'!transform: aNode	| transfromedNode |	transfromedNode := aNode copy.	transfromedNode isDoIt ifFalse: [ transfromedNode scope:nil].	self transformers do: [ :each |		each visitNode: transfromedNode ].	^transfromedNode! !!PECommonCompilationStrategy methodsFor: 'private' stamp: 'md 7/5/2007 16:55'!transformers	^(PECompilerPlugin allSubclasses		select: [ :each | each isActive ]) asSortedCollection		collect: [ :each | each new ]! !!PECommonCompilationStrategy methodsFor: 'private' stamp: 'md 11/4/2007 19:57'!transformers2	^(PECompilerPlugin2 allSubclasses		select: [ :each | each isActive ]) asSortedCollection		collect: [ :each | each new ]! !!PECommonCompilationStrategy methodsFor: 'private' stamp: 'pmm 8/11/2006 10:25'!wrap: aNode withEnsure: anStatementsNode	^RBMessageNode		receiver: (RBBlockNode body: aNode asSequenceNode)		selector: #ensure:		argument: (RBBlockNode body: anStatementsNode)	! !!PECommonCompilationStrategy methodsFor: 'accessing' stamp: 'md 4/4/2007 18:53'!ir	^ir! !!PECompiler methodsFor: 'public access' stamp: 'md 10/25/2007 15:46'!compileDoIt: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock log: log	"Compiles the sourceStream into a parse tree, then generates code into a method.  This method is then wrapped in a block with the receiver or context as the sole free variable which the method refers to.  If requestor is not nil, then it will receive a notify:at: message if there is a compile error, followed by the failBlock being executed."	| scope parser blockNode method source |	source _ textOrStream readStream.	scope _ aContext		ifNotNil: [aContext doItScope]		ifNil: [receiver class parseScope instanceScope].	parser _ Preferences compileDoitWithPersephone 					ifTrue: [PEParser new]					ifFalse: [Parser2 new].	blockNode _ parser			parse: source			class: scope			noPattern: true			notifying: aRequestor			ifFail: [^ failBlock value].	method _ blockNode generate.	method selector: #DoIt.	Preferences compileDoitWithPersephone 					ifTrue: [method methodClass: UndefinedObject.							method reflectiveMethod: (ReflectiveMethod 										blockNode: blockNode compiledMethod: method)].	log ifTrue: [		method putSource: source contents			fromParseNode: blockNode			inFile: 2 			withPreamble: [:file | file cr]].	^ BlockClosure new		env: (aContext ifNil: [receiver]);		method: method;		yourself! !!PECompiler methodsFor: 'assessing' stamp: 'md 3/31/2007 18:56'!parserClass	^PEParser! !!PECompiler commentStamp: 'md 3/31/2007 19:11' prior: 0!This is a subclass of ClosureCompiler that creates ReflectiveMethods!!PECompiler class methodsFor: 'class init' stamp: 'md 12/13/2007 09:50'!initialize	Preferences		addPreference: #compileReflectiveMethods		category: #reflectivity		default: false		balloonHelp: 'If true, we generate ReflectiveMethods when compiling. The newCompiler preference needs to be turned ON, too.'.	Preferences		addPreference: #compileDoitWithPersephone		category: #reflectivity		default: false		balloonHelp: 'If true, we use Persephone for #doit. Broken right now'! !!PECompiler class methodsFor: 'accessing' stamp: 'md 3/31/2007 18:56'!parserClass	"Return a parser class to use for parsing method headers."	^PEParser! !!PECompilerPlugin class methodsFor: 'plugin interface' stamp: 'md 7/5/2007 16:53'!<= other	^self priority <= other priority! !!PECompilerPlugin class methodsFor: 'plugin interface' stamp: 'md 7/5/2007 16:54'!isActive	^true! !!PECompilerPlugin class methodsFor: 'plugin interface' stamp: 'md 3/16/2007 11:24'!priority	^16rFFFF! !!PECompilerPlugin2 methodsFor: 'visitor-double dispatching' stamp: 'md 11/4/2007 20:07'!acceptAssignmentNode: anAssignmentNode 	anAssignmentNode variable: (self visitNode: anAssignmentNode variable).	anAssignmentNode value: (self visitNode: anAssignmentNode value).	^anAssignmentNode! !!PECompilerPlugin2 methodsFor: 'visitor-double dispatching' stamp: 'md 11/4/2007 20:07'!acceptBlockNode: aBlockNode 	aBlockNode arguments: (self visitBlockArguments: aBlockNode arguments).	aBlockNode body: (self visitNode: aBlockNode body).	^aBlockNode! !!PECompilerPlugin2 methodsFor: 'visitor-double dispatching' stamp: 'md 11/4/2007 20:07'!acceptCascadeNode: aCascadeNode 	aCascadeNode messages: (aCascadeNode messages collect: [:each | self visitNode: each]).	^aCascadeNode.! !!PECompilerPlugin2 methodsFor: 'visitor-double dispatching' stamp: 'md 11/4/2007 20:08'!acceptLiteralNode: aLiteralNode	^aLiteralNode! !!PECompilerPlugin2 methodsFor: 'visitor-double dispatching' stamp: 'md 11/4/2007 20:08'!acceptMessageNode: aMessageNode 	aMessageNode receiver: (self visitNode: aMessageNode receiver).	aMessageNode 		arguments: (aMessageNode arguments collect: [:each | self visitNode: each]).	^aMessageNode.! !!PECompilerPlugin2 methodsFor: 'visitor-double dispatching' stamp: 'md 11/4/2007 20:08'!acceptMethodNode: aMethodNode 	aMethodNode arguments: (self visitMethodArguments: aMethodNode arguments).	aMethodNode body: (self visitNode: aMethodNode body).	^aMethodNode ! !!PECompilerPlugin2 methodsFor: 'visitor-double dispatching' stamp: 'md 11/4/2007 20:08'!acceptPragmaNode: aPragmaNode	^aPragmaNode! !!PECompilerPlugin2 methodsFor: 'visitor-double dispatching' stamp: 'md 11/4/2007 20:08'!acceptReturnNode: aReturnNode 	aReturnNode value: (self visitNode: aReturnNode value).	^aReturnNode! !!PECompilerPlugin2 methodsFor: 'visitor-double dispatching' stamp: 'md 11/4/2007 20:08'!acceptSequenceNode: aSequenceNode 	aSequenceNode temporaries: (self visitTemporaryVariables: aSequenceNode temporaries).	aSequenceNode statements: (aSequenceNode statements collect: [:each | self visitNode: each]).	^aSequenceNode! !!PECompilerPlugin2 methodsFor: 'visitor-double dispatching' stamp: 'md 11/4/2007 20:09'!acceptVariableNode: aVariableNode	^aVariableNode! !!PECompilerPlugin2 methodsFor: 'as yet unclassified' stamp: 'md 11/4/2007 20:12'!acceptInstrumentedAssignmentNode: anAssignmentNode	^self acceptAssignmentNode: anAssignmentNode.		! !!PECompilerPlugin2 methodsFor: 'as yet unclassified' stamp: 'md 11/4/2007 20:12'!acceptInstrumentedVariableNode: aVariableNode	^self acceptVariableNode: aVariableNode! !!PECompilerPlugin2 methodsFor: 'visiting' stamp: 'md 11/4/2007 20:09'!visitMethodArguments: aNodeCollection 	^aNodeCollection collect: [:each | self visitMethodArgument: each]! !!PECompilerPlugin2 methodsFor: 'visiting' stamp: 'md 11/4/2007 20:09'!visitNode: aNode	^aNode copy acceptVisitor: self.! !!PECompilerPlugin2 methodsFor: 'visiting' stamp: 'md 11/4/2007 20:09'!visitTemporaryVariables: aNodeCollection 	^aNodeCollection collect: [:each | self visitTemporaryVariable: each]! !!PECompilerPlugin2 class methodsFor: 'plugin interface' stamp: 'md 11/4/2007 19:57'!<= other	^self priority <= other priority! !!PECompilerPlugin2 class methodsFor: 'plugin interface' stamp: 'md 11/4/2007 19:57'!isActive	^true! !!PECompilerPlugin2 class methodsFor: 'plugin interface' stamp: 'md 11/4/2007 19:57'!priority	^16rFFFF! !!PEConvervativeLiteralEvaluator methodsFor: 'testing' stamp: 'pmm 9/24/2006 10:56'!isAcceptable: aResult	^aResult isLiteral! !!PEConvervativeLiteralEvaluator commentStamp: 'pmm 9/24/2006 10:56' prior: 0!This inliner will inline only as long as the result is a literal.!!PEDoItNode methodsFor: 'beforeafter' stamp: 'md 7/24/2007 15:10'!after	^self propertyAt: #after ifAbsentPut: [OrderedCollection new].! !!PEDoItNode methodsFor: 'beforeafter' stamp: 'md 7/24/2007 15:10'!before	^self propertyAt: #before ifAbsentPut: [OrderedCollection new]. ! !!PEDoItNode methodsFor: 'beforeafter' stamp: 'md 7/24/2007 15:10'!hasAfterCode	^(self hasProperty: #after) and: [(self propertyAt: #after) notEmpty].! !!PEDoItNode methodsFor: 'beforeafter' stamp: 'md 7/24/2007 15:10'!hasBeforeCode	^(self hasProperty: #before) and: [(self propertyAt: #before) notEmpty].! !!PEDoItNode methodsFor: 'beforeafter' stamp: 'md 7/24/2007 15:10'!hasBeforeOrAfterCode	^self hasBeforeCode		or: [ self hasAfterCode ]! !!PEDoItNode methodsFor: 'as yet unclassified' stamp: 'md 7/25/2007 22:46'!callSemanticPlugins	PESemCheckPlugin allPlugins do: [ :each |		each visitNode: self]. ! !!PEDoItNode methodsFor: 'as yet unclassified' stamp: 'md 7/24/2007 15:10'!defaultTrailer	"this is needed for the source pointer	the default #(0) will result in the VM setfaulting	because #setSourcePointer: writes into the CompiledMethod	*we think*"	^ #(0 0 0 0).! !!PEDoItNode methodsFor: 'as yet unclassified' stamp: 'md 7/24/2007 15:06'!restoreScope	self scope! !!PEDoItNode methodsFor: 'newcompiler' stamp: 'md 7/24/2007 15:05'!generateIR	^ ir  := PECommonCompilationStrategy new compile: self; ir! !!PEDoItNode methodsFor: 'hack' stamp: 'md 9/27/2007 11:22'!methodClass	^nil parseScope.! !!PEDoItNode methodsFor: 'hack' stamp: 'md 7/24/2007 15:04'!methodClass: ignored	! !!PEFormatter methodsFor: 'testing' stamp: 'md 4/13/2007 15:31'!needsAnnotaionParenthesisFor: aNode	aNode isVariable ifTrue: [ ^false ].	aNode isLiteral ifTrue: [ ^false ].	aNode isMethod ifTrue: [ ^false ].	aNode hasVisibleAnnotations ifFalse: [ ^false ].	^aNode isMessage		or: [ aNode isSequence ]		or: [ aNode isAssignment ]! !!PEFormatter methodsFor: 'testing' stamp: 'pmm 6/7/2006 09:32'!needsParenthesisFor: aNode	^(super needsParenthesisFor: aNode)		or: [ self needsAnnotaionParenthesisFor: aNode ]! !!PEFormatter methodsFor: 'private' stamp: 'pmm 10/10/2005 10:53'!numberOfClosingParenthesisFor: aNode	^(self needsParenthesisFor: aNode)		ifTrue: [ 1 ]		ifFalse: [ 0 ]! !!PEFormatter methodsFor: 'private' stamp: 'pmm 6/7/2006 09:33'!numberOfOpeningParenthesisFor: aNode	^(self needsParenthesisFor: aNode)		ifFalse: [ 0 ]		ifTrue: [ 			(self needsAnnotaionParenthesisFor: aNode)				ifTrue: [ 2 ]				ifFalse: [ 1 ] ]! !!PEFormatter methodsFor: 'private' stamp: 'pmm 6/7/2006 09:35'!printAnnotation: anAnnotaion value: anObject	| key |	key := anAnnotaion key.	codeStream nextPutAll: '<:'.			anAnnotaion		ifUnary:  [ self printUnaryAnnotationNamed: key ]		ifBinary: [ self printBinaryAnnotationNamed: key value: anObject ]		ifKeyword: [ self printKeywordAnnotationNamed: key value: anObject ].	codeStream nextPutAll: ' :>'.! !!PEFormatter methodsFor: 'private' stamp: 'pmm 9/22/2005 11:33'!printBinaryAnnotationNamed: aString value: aNode	| parenthesis |	codeStream		nextPutAll: aString;		nextPut: Character space.		self flag: #todo. "better check if parantessis are needed"	parenthesis := true.	parenthesis ifTrue: [codeStream nextPut: $(].	self visitNode: aNode.	parenthesis ifTrue: [codeStream nextPut: $) ]! !!PEFormatter methodsFor: 'private' stamp: 'pmm 9/22/2005 11:32'!printKeywordAnnotationNamed: aString value: aCollection	| words node parenthesis |	words := aString subStrings: #($:).	words withIndexDo: [ :each :index |		codeStream			nextPutAll: each;			nextPut: $:;			nextPut: Character space.		node := aCollection at: index.				self flag: #todo. "better check if parantessis are needed"		parenthesis := true.		parenthesis ifTrue: [codeStream nextPut: $(].		self visitNode: node.		parenthesis ifTrue: [codeStream nextPut: $) ] ]! !!PEFormatter methodsFor: 'private' stamp: 'pmm 8/27/2005 17:10'!printUnaryAnnotationNamed: aString	codeStream nextPutAll: aString.! !!PEFormatter methodsFor: 'private' stamp: 'pmm 6/7/2006 17:57'!processAnnotaionsOf: aNode	aNode sourceVisibleAnnotationsDo: [ :each |			each do: [ :value |				self printAnnotation: each value: value  ] ].	(self needsAnnotaionParenthesisFor: aNode) 		ifTrue: [ codeStream nextPut: $) ].! !!PEFormatter methodsFor: 'private' stamp: 'pmm 10/9/2005 22:42'!visitNode: aNode 	(self numberOfOpeningParenthesisFor: aNode)		timesRepeat: [codeStream nextPut: $(].	aNode acceptVisitor: self.	(self numberOfClosingParenthesisFor: aNode)		timesRepeat: [codeStream nextPut: $)].	 self processAnnotaionsOf: aNode.	! !!PEInlineCompilationStrategy methodsFor: 'private' stamp: 'md 6/13/2007 11:42'!addNoChangeAfter: aJMethod to: aSequenceNode	| original |	original := aJMethod methodNode.	^aSequenceNode		addNode: (self			wrap: original body copy			withEnsure: aJMethod)		yourself! !!PEInlineCompilationStrategy methodsFor: 'private' stamp: 'md 6/13/2007 11:56'!addOutlineReturnAfter: original to: aSequenceNode	| body last |	body := original body copy.	last := body statements last.	last isReturn ifTrue: [		body replaceNode: last withNode: last value ].	aSequenceNode addNode: (self		wrap: body		withEnsure: original after asSequenceNode).	^last isReturn		ifTrue: [ (RBReturnNode value: aSequenceNode) asSequenceNode ]		ifFalse: [ aSequenceNode ]! !!PEInlineCompilationStrategy methodsFor: 'private' stamp: 'md 10/21/2007 20:50'!compileTransformed: original 	| aJMethod methodNode sequence |	aJMethod := original parent.	sequence := RBSequenceNode 				temporaries: original body temporaries				statements: OrderedCollection new.		original before addToSequence: sequence.		original hasAfterCode 		ifTrue: 			[sequence := original hasReturnAtMostAtEnd 						ifTrue: [self addOutlineReturnAfter: original to: sequence]						ifFalse: [self addNoChangeAfter: original to: sequence]]		ifFalse: [sequence addNodes: original body statements].		methodNode := PEReflectiveMethodNode 				selector: original selector				arguments: original arguments				body: sequence.	methodNode methodClass: aJMethod methodClass.	methodNode parent: original parent.	original hasAnnotations ifTrue: [methodNode annotations:  original annotations].	^ self compileNode: methodNode trailer: aJMethod defaultTrailer! !!PEInstrumentationVisitor methodsFor: 'accessing' stamp: 'pmm 9/24/2005 10:07'!block	^block! !!PEInstrumentationVisitor methodsFor: 'accessing' stamp: 'pmm 6/11/2006 21:51'!block: aBlock 	block := aBlock! !!PEInstrumentationVisitor class methodsFor: 'instance creation' stamp: 'pmm 9/24/2005 10:08'!block: aBlock	^self new		block: aBlock;		yourself! !!PEInstrumentedAssignmentNode methodsFor: 'visitor' stamp: 'md 8/24/2007 11:09'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptInstrumentedAssignmentNode: self! !!PEInstrumentedAssignmentNode methodsFor: 'accessing' stamp: 'md 8/24/2007 11:07'!after	^after! !!PEInstrumentedAssignmentNode methodsFor: 'accessing' stamp: 'md 8/24/2007 11:07'!after: aCollection	self basicAfter: (aCollection do: [ :each | each parent: self ]; yourself)! !!PEInstrumentedAssignmentNode methodsFor: 'accessing' stamp: 'md 8/24/2007 11:08'!basicAfter: anObject	after := anObject! !!PEInstrumentedAssignmentNode methodsFor: 'accessing' stamp: 'md 8/24/2007 11:08'!basicBefore: anObject	before := anObject! !!PEInstrumentedAssignmentNode methodsFor: 'accessing' stamp: 'md 8/24/2007 11:08'!before	^before! !!PEInstrumentedAssignmentNode methodsFor: 'accessing' stamp: 'md 8/25/2007 14:53'!before: aCollection	self before addAll: (aCollection do: [ :each | each parent: self ]; yourself)! !!PEInstrumentedAssignmentNode methodsFor: 'converting' stamp: 'md 8/24/2007 11:08'!asInstrumentedNode	^self! !!PEInstrumentedAssignmentNode methodsFor: 'initialize-release' stamp: 'md 8/25/2007 14:54'!initialize	super initialize.	before := OrderedCollection new.	after := OrderedCollection new! !!PEInstrumentedAssignmentNode methodsFor: 'as yet unclassified' stamp: 'md 10/22/2007 15:36'!isInstrumented	^true! !!PEInstrumentedAssignmentNode class methodsFor: 'instance creation' stamp: 'md 8/24/2007 11:09'!fromUninstrumented: aNode	^self		variable: aNode variable		value: aNode value		position: aNode position! !!PEInstrumentedGlobalVariableNode methodsFor: 'as yet unclassified' stamp: 'md 10/5/2007 12:20'!isGlobal	^true! !!PEInstrumentedGlobalVariableNode methodsFor: 'as yet unclassified' stamp: 'md 10/5/2007 12:21'!isInstance	^false! !!PEInstrumentedGlobalVariableNode methodsFor: 'as yet unclassified' stamp: 'md 10/22/2007 15:36'!isInstrumented	^true! !!PEInstrumentedGlobalVariableNode methodsFor: 'as yet unclassified' stamp: 'md 10/5/2007 12:21'!isTemp	^false! !!PEInstrumentedInstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'md 10/5/2007 12:21'!isGlobal	^false! !!PEInstrumentedInstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'md 10/5/2007 12:22'!isInstance	^true! !!PEInstrumentedInstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'md 10/22/2007 15:36'!isInstrumented	^true! !!PEInstrumentedInstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'md 10/5/2007 12:22'!isTemp	^false! !!PEInstrumentedLiteralNode methodsFor: 'visitor' stamp: 'md 8/24/2007 15:45'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptInstrumentedLiteralNode: self! !!PEInstrumentedLiteralNode methodsFor: 'accessing' stamp: 'md 8/24/2007 15:43'!after	^after! !!PEInstrumentedLiteralNode methodsFor: 'accessing' stamp: 'md 8/24/2007 15:43'!after: aCollection	self basicAfter: (aCollection do: [ :each | each parent: self ]; yourself)! !!PEInstrumentedLiteralNode methodsFor: 'accessing' stamp: 'md 8/24/2007 15:44'!basicAfter: anObject	after := anObject! !!PEInstrumentedLiteralNode methodsFor: 'accessing' stamp: 'md 8/24/2007 15:44'!basicBefore: anObject	before := anObject! !!PEInstrumentedLiteralNode methodsFor: 'accessing' stamp: 'md 8/24/2007 15:44'!before	^before! !!PEInstrumentedLiteralNode methodsFor: 'accessing' stamp: 'md 8/24/2007 15:44'!before: aCollection	self basicBefore: (aCollection do: [ :each | each parent: self ]; yourself)! !!PEInstrumentedLiteralNode methodsFor: 'converting' stamp: 'md 8/24/2007 15:44'!asInstrumentedNode	^self! !!PEInstrumentedLiteralNode methodsFor: 'initialize-release' stamp: 'md 8/24/2007 15:43'!initialize	super initialize.	self before: OrderedCollection new.	self after: OrderedCollection new! !!PEInstrumentedLiteralNode methodsFor: 'as yet unclassified' stamp: 'md 10/22/2007 15:36'!isInstrumented	^true! !!PEInstrumentedLiteralNode class methodsFor: 'instance creation' stamp: 'md 8/24/2007 15:45'!fromUninstrumented: aLiteralNode	| token |	token := aLiteralNode token.	token isRBToken ifFalse: [		token := RBLiteralToken value: aLiteralNode value start: token start stop: token stop ].	^self		literalToken: token		value: aLiteralNode value! !!PEInstrumentedMessageNode methodsFor: 'visitor' stamp: 'md 8/24/2007 17:19'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptInstrumentedMessageNode: self! !!PEInstrumentedMessageNode methodsFor: 'accessing' stamp: 'md 8/24/2007 17:17'!after	^after! !!PEInstrumentedMessageNode methodsFor: 'accessing' stamp: 'md 8/24/2007 17:18'!after: aCollection	self basicAfter: (aCollection do: [ :each | each parent: self ]; yourself)! !!PEInstrumentedMessageNode methodsFor: 'accessing' stamp: 'md 8/24/2007 17:18'!basicAfter: anObject	after := anObject! !!PEInstrumentedMessageNode methodsFor: 'accessing' stamp: 'md 8/24/2007 17:18'!basicBefore: anObject	before := anObject! !!PEInstrumentedMessageNode methodsFor: 'accessing' stamp: 'md 8/24/2007 17:18'!before	^before! !!PEInstrumentedMessageNode methodsFor: 'accessing' stamp: 'md 8/25/2007 15:04'!before: aCollection	self before addAll: (aCollection do: [ :each | each parent: self ]; yourself)! !!PEInstrumentedMessageNode methodsFor: 'converting' stamp: 'md 8/24/2007 17:19'!asInstrumentedNode	^self! !!PEInstrumentedMessageNode methodsFor: 'initialize-release' stamp: 'md 8/25/2007 14:55'!initialize	super initialize.	before := OrderedCollection new.	after := OrderedCollection new! !!PEInstrumentedMessageNode methodsFor: 'as yet unclassified' stamp: 'md 10/22/2007 15:36'!isInstrumented	^true! !!PEInstrumentedMessageNode class methodsFor: 'instance creation' stamp: 'md 8/25/2007 12:05'!fromUninstrumented: aNode	^self		receiver: aNode receiver		selector: aNode selector		arguments: aNode arguments! !!PEInstrumentedObjectLiteralNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:27'!after	^after! !!PEInstrumentedObjectLiteralNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:27'!after: aCollection	self basicAfter: (aCollection do: [ :each | each parent: self ]; yourself)! !!PEInstrumentedObjectLiteralNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:27'!basicAfter: aCollection	after := aCollection! !!PEInstrumentedObjectLiteralNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:27'!basicBefore: aCollection	before := aCollection! !!PEInstrumentedObjectLiteralNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:28'!before	^before! !!PEInstrumentedObjectLiteralNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:28'!before: aCollection	self basicBefore: (aCollection do: [ :each | each parent: self ]; yourself)! !!PEInstrumentedObjectLiteralNode methodsFor: 'converting' stamp: 'md 8/25/2007 12:28'!asInstrumentedNode	^self! !!PEInstrumentedObjectLiteralNode methodsFor: 'initialize-release' stamp: 'md 8/25/2007 12:27'!initialize	super initialize.	self before: OrderedCollection new.	self after: OrderedCollection new! !!PEInstrumentedObjectLiteralNode class methodsFor: 'instance creation' stamp: 'md 8/25/2007 12:29'!fromUninstrumented: aNode	^self value: aNode value! !!PEInstrumentedReturnNode methodsFor: 'visitor' stamp: 'md 8/25/2007 12:02'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptInstrumentedReturnNode: self! !!PEInstrumentedReturnNode methodsFor: 'converting' stamp: 'md 8/25/2007 12:03'!asInstrumentedNode	^self! !!PEInstrumentedReturnNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:04'!before	^before! !!PEInstrumentedReturnNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:04'!before: aCollection	before := aCollection do: [ :each | each parent: self ]; yourself! !!PEInstrumentedReturnNode methodsFor: 'initialize-release' stamp: 'md 8/25/2007 12:04'!initialize	super initialize.	self before: OrderedCollection new! !!PEInstrumentedReturnNode methodsFor: 'as yet unclassified' stamp: 'md 10/22/2007 15:37'!isInstrumented	^true! !!PEInstrumentedReturnNode class methodsFor: 'instance creation' stamp: 'md 8/25/2007 12:05'!fromUninstrumented: aReturnNode	^self		return: aReturnNode start		value: aReturnNode value ! !!PEInstrumentedSequenceNode methodsFor: 'visitor' stamp: 'md 8/25/2007 12:07'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptInstrumentedSequenceNode: self! !!PEInstrumentedSequenceNode methodsFor: 'converting' stamp: 'md 8/25/2007 12:08'!asInstrumentedNode	^self! !!PEInstrumentedSequenceNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:08'!before	^before! !!PEInstrumentedSequenceNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:08'!before: anObject	before := anObject! !!PEInstrumentedSequenceNode methodsFor: 'initialize-release' stamp: 'md 8/25/2007 12:08'!initialize	super initialize.	self before: OrderedCollection new! !!PEInstrumentedSequenceNode methodsFor: 'as yet unclassified' stamp: 'md 10/22/2007 15:37'!isInstrumented	^true! !!PEInstrumentedSequenceNode class methodsFor: 'instance creation' stamp: 'md 8/25/2007 12:09'!fromUninstrumented: aNode	^self		temporaries: aNode temporaries		statements: aNode statements ! !!PEInstrumentedTempVariableNode methodsFor: 'as yet unclassified' stamp: 'md 10/5/2007 12:22'!isArgument	"is this an argument variable?"	^self method arguments includes: self! !!PEInstrumentedTempVariableNode methodsFor: 'as yet unclassified' stamp: 'md 10/5/2007 12:22'!isGlobal	^false! !!PEInstrumentedTempVariableNode methodsFor: 'as yet unclassified' stamp: 'md 10/5/2007 12:22'!isInstance	^false! !!PEInstrumentedTempVariableNode methodsFor: 'as yet unclassified' stamp: 'md 10/22/2007 15:37'!isInstrumented	^true! !!PEInstrumentedTempVariableNode methodsFor: 'as yet unclassified' stamp: 'md 10/5/2007 12:22'!isTemp	^true! !!PEInstrumentedVariableNode methodsFor: 'visitor' stamp: 'md 8/25/2007 12:13'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptInstrumentedVariableNode: self! !!PEInstrumentedVariableNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:10'!after	^after! !!PEInstrumentedVariableNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:10'!after: aCollection	self basicAfter: (aCollection do: [ :each | each parent: self ]; yourself)! !!PEInstrumentedVariableNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:10'!basicAfter: anObject	after := anObject! !!PEInstrumentedVariableNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:10'!basicBefore: anObject	before := anObject! !!PEInstrumentedVariableNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:11'!before	^before! !!PEInstrumentedVariableNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:12'!before: aCollection	self basicBefore: (aCollection do: [ :each | each parent: self ]; yourself)! !!PEInstrumentedVariableNode methodsFor: 'converting' stamp: 'md 8/25/2007 12:13'!asInstrumentedNode	^self! !!PEInstrumentedVariableNode methodsFor: 'initialize-release' stamp: 'md 8/25/2007 12:09'!initialize	super initialize.	self before: OrderedCollection new.	self after: OrderedCollection new! !!PEInstrumentedVariableNode methodsFor: 'as yet unclassified' stamp: 'md 10/22/2007 15:37'!isInstrumented	^true! !!PEInstrumentedVariableNode class methodsFor: 'instance creation' stamp: 'md 8/25/2007 12:13'!fromUninstrumented: aNode	| token |	token := aNode token.	(token isRBToken and: [ token isIdentifier ]) ifFalse: [		token := RBIdentifierToken value: token value start: token start ].	^self new identifierToken: token! !!PEInterpretationExamples methodsFor: 'accessing' stamp: 'pmm 5/31/2006 10:55'!classVar	^ClassVar! !!PEInterpretationExamples methodsFor: 'accessing' stamp: 'pmm 5/31/2006 10:55'!classVar: anObject	ClassVar := anObject! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'pmm 4/26/2006 21:41'!exampleArgument: anObject	^anObject + 5! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'pmm 4/26/2006 21:49'!exampleArray	^{ 1 . 1 + 1 . 1 + 2 . 2 + 3  }! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'pmm 4/26/2006 21:40'!exampleArrayLiteral	^#(1 2 3 4)! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'pmm 4/26/2006 21:45'!exampleBlockReturn	#(1 2 3) do: [ :each |		each = 2 ifTrue: [ ^each ] ]! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'pmm 4/26/2006 21:44'!exampleBlockTemp	instVar := 0.	#(1 2 3) do: [ :each |		| x |		x := each.		x := x * x.		instVar := instVar + x ].	^instVar! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'pmm 4/28/2006 20:40'!exampleBranch	^1 > 2		ifTrue: [ 1000 + 337 ]		ifFalse: [ 30000 + 1000 + 337 ]! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'pmm 4/26/2006 21:48'!exampleCascade	^OrderedCollection new		add: 1;		add: 2;		add: 3;		yourself! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'pmm 4/26/2006 21:42'!exampleDo	| x |	x := 0.	#(1 2 3) do: [ :each |		x := x + each ].	^x! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'pmm 5/1/2006 16:21'!exampleEnsure	| x |	x := ValueHolder new		contents: 0		yourself.	[ 0 / 1 ]		ensure: [ x contents: 20 ].	^x contents! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'md 4/16/2007 21:26'!exampleGlobal	^PEInterpretationExamples name! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'pmm 4/26/2006 21:43'!exampleInstVar	instVar := 0.	#(1 2 3) do: [ :each |		instVar := instVar + each ].	^instVar! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'pmm 5/1/2006 16:08'!exampleOnDo	| x |	x := 0.	[ 1 / 0 ]		on: ZeroDivide		do: [ x:= 20 ].	^x! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'pmm 4/28/2006 18:59'!exampleOuterBlock	| x |	x := 0.	#(1 2 3) do: [ :each |		| blockTemp |		blockTemp := each.		blockTemp = 2 ifTrue: [			blockTemp := blockTemp + 10 ].		x := x + blockTemp ].	^x! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'pmm 4/26/2006 21:40'!exampleReturnSelf	1 + 2! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'pmm 4/26/2006 21:41'!exampleTemp	| temp |	temp := 1000.	temp := temp + 337.	^temp! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'pmm 4/26/2006 21:55'!exampleTrue	^true! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'pmm 5/1/2006 08:16'!exampleWhile	| x |	x := 40.	[ (x > 20) ]		whileTrue: [ x := x - 2 ].	^x! !!PEInterpretationExamples methodsFor: 'examples' stamp: 'md 4/16/2007 21:30'!printString	^super printString , ' RLY'! !!PEInterpretationExamples class methodsFor: 'compiling' stamp: 'md 3/31/2007 19:14'!compilerClass	^PECompiler! !!PEInterpretationExamples class methodsFor: 'compiling' stamp: 'md 3/31/2007 19:09'!parseTreeFor: aSymbol	^(self compiledMethodAt: aSymbol) reflectiveMethod methodNode! !!PEInterpretationExamples class methodsFor: 'compiling' stamp: 'md 3/31/2007 19:09'!recompile: selector from: oldClass	| jMethod |	jMethod := (oldClass >> selector) reflectiveMethodOrNil.	(jMethod notNil and: [ jMethod hasMethodClass not ]) ifTrue: [ jMethod methodClass: oldClass ].	super recompile: selector from: oldClass.	! !!PEInterpretationTest methodsFor: 'private' stamp: 'pmm 4/27/2006 23:14'!interpret: aSymbol	^self interpret: aSymbol withArguments: #()! !!PEInterpretationTest methodsFor: 'private' stamp: 'pmm 4/27/2006 23:14'!interpret: aSymbol with: anObject	^self interpret: aSymbol withArguments: (Array with: anObject)! !!PEInterpretationTest methodsFor: 'private' stamp: 'md 4/16/2007 21:17'!interpret: aSymbol withArguments: aCollection	^(self reflectiveMethod: aSymbol)		interpret: aSymbol		with: aCollection		in: example! !!PEInterpretationTest methodsFor: 'private' stamp: 'md 4/16/2007 21:17'!reflectiveMethod: aSymbol	^(example class >> aSymbol) reflectiveMethod! !!PEInterpretationTest methodsFor: 'running' stamp: 'md 4/16/2007 21:21'!setUp	super setUp.	example := PEInterpretationExamples new ! !!PEInterpretationTest methodsFor: 'testing' stamp: 'pmm 7/1/2006 15:25'!testClassVar	"self run: #testClassVar"	(self interpret: #classVar: with: 666).	self assert: (self interpret: #classVar) = 666.		(self interpret: #classVar: with: 'Nova Cat').	self assert: (self interpret: #classVar) = 'Nova Cat'.		! !!PEInterpretationTest methodsFor: 'testing' stamp: 'pmm 4/27/2006 22:53'!testExampleArgument	"self run: #testExampleArgument"	self assert: (self interpret: #exampleArgument: with: 10) = 15! !!PEInterpretationTest methodsFor: 'testing' stamp: 'pmm 4/26/2006 21:52'!testExampleArray	self assert: (self interpret: #exampleArray) = #(1 2 3 5)! !!PEInterpretationTest methodsFor: 'testing' stamp: 'pmm 4/26/2006 21:52'!testExampleArrayLiteral	self assert: (self interpret: #exampleArrayLiteral) = #(1 2 3 4)! !!PEInterpretationTest methodsFor: 'testing' stamp: 'pmm 4/26/2006 21:53'!testExampleBlockReturn	self assert: (self interpret: #exampleBlockReturn) = 2! !!PEInterpretationTest methodsFor: 'testing' stamp: 'pmm 4/26/2006 21:54'!testExampleBlockTemp	self assert: (self interpret: #exampleBlockTemp) = 14! !!PEInterpretationTest methodsFor: 'testing' stamp: 'pmm 4/28/2006 20:37'!testExampleBranch	self assert: (self interpret: #exampleBranch) = 31337! !!PEInterpretationTest methodsFor: 'testing' stamp: 'pmm 4/26/2006 21:54'!testExampleCascade	self assert: (self interpret: #exampleCascade) = #(1 2 3) asOrderedCollection! !!PEInterpretationTest methodsFor: 'testing' stamp: 'pmm 4/26/2006 21:55'!testExampleDo	self assert: (self interpret: #exampleDo) = 6! !!PEInterpretationTest methodsFor: 'testing' stamp: 'pmm 5/1/2006 16:06'!testExampleEnsure	self assert: (self interpret: #exampleEnsure) = 20! !!PEInterpretationTest methodsFor: 'testing' stamp: 'md 4/16/2007 21:26'!testExampleGlobal	self assert: (self interpret: #exampleGlobal) = 'PEInterpretationExamples'! !!PEInterpretationTest methodsFor: 'testing' stamp: 'pmm 4/26/2006 21:56'!testExampleInstVar	self assert: (self interpret: #exampleInstVar) = 6! !!PEInterpretationTest methodsFor: 'testing' stamp: 'pmm 5/1/2006 16:06'!testExampleOnDo	self assert: (self interpret: #exampleOnDo) = 20! !!PEInterpretationTest methodsFor: 'testing' stamp: 'pmm 4/28/2006 19:00'!testExampleOuterBlock	self assert: (self interpret: #exampleOuterBlock) = 16! !!PEInterpretationTest methodsFor: 'testing' stamp: 'pmm 4/26/2006 21:57'!testExampleReturnSelf	self assert: (self interpret: #exampleReturnSelf) == example! !!PEInterpretationTest methodsFor: 'testing' stamp: 'md 4/16/2007 21:27'!testExampleTemp	self assert: (self interpret: #printString) =  'a PEInterpretationExamples RLY'! !!PEInterpretationTest methodsFor: 'testing' stamp: 'pmm 4/26/2006 21:55'!testExampleTrue	self assert: (self interpret: #exampleTrue)! !!PEInterpretationTest methodsFor: 'testing' stamp: 'pmm 5/1/2006 08:16'!testExampleWhile	self assert: (self interpret: #exampleWhile) = 20! !!PEInterpretationTest methodsFor: 'testing' stamp: 'md 4/16/2007 21:11'!testPrimitive	| methodNode result method |	methodNode := PESqueakParser parseMethod: (SmalltalkImage >> #getSystemAttribute:) getSource.	methodNode methodClass: SmalltalkImage.	method := ReflectiveMethod new		methodNode: methodNode;		yourself.	method beInterpreted.	result := method run: #getSystemAttribute: with: #(1001) in: SmalltalkImage current.	self deny: result isNil.	self assert: result = (SmalltalkImage current getSystemAttribute: 1001)! !!PEInterpreterContext methodsFor: 'accessing' stamp: 'pmm 4/26/2006 09:02'!codeInterpreter	^codeInterpreter! !!PEInterpreterContext methodsFor: 'accessing' stamp: 'pmm 4/26/2006 09:02'!codeInterpreter: aCodeInterpreter 	codeInterpreter := aCodeInterpreter! !!PEInterpreterContext class methodsFor: 'instance creation' stamp: 'pmm 4/26/2006 09:03'!codeInterpreter: aCodeInterpreter	^self new		codeInterpreter: aCodeInterpreter;		yourself! !!PELiteralCollector methodsFor: 'as yet unclassified' stamp: 'md 4/15/2007 15:53'!acceptLiteralNode: aNode 	aNode value ifNotNil: [literals add: aNode value].	^super acceptLiteralNode: aNode.! !!PELiteralCollector methodsFor: 'as yet unclassified' stamp: 'md 4/15/2007 14:38'!acceptMessageNode: aMessageNode 	literals add: aMessageNode selector.	^super acceptMessageNode: aMessageNode.! !!PELiteralCollector methodsFor: 'as yet unclassified' stamp: 'md 4/15/2007 15:47'!initialize	literals := IdentitySet new.! !!PELiteralCollector methodsFor: 'as yet unclassified' stamp: 'md 4/15/2007 14:37'!literals	^literals asArray.! !!PELiteralEvaluator methodsFor: 'visitor-double dispatching' stamp: 'pmm 9/24/2006 11:03'!acceptMessageNode: aMessageNode	(self canInline: aMessageNode)		ifTrue: [ self inline: aMessageNode ]		ifFalse: [ super acceptMessageNode: aMessageNode ]! !!PELiteralEvaluator methodsFor: 'testing' stamp: 'pmm 9/24/2006 11:02'!canInline: aMessageNode	^aMessageNode receiver isLiteral		and: [ aMessageNode arguments allSatisfy: [ :each | each isLiteral ] ]		and: [ aMessageNode isCascaded not  ]! !!PELiteralEvaluator methodsFor: 'testing' stamp: 'pmm 9/24/2006 10:34'!isAcceptable: aResult	self subclassResponsibility ! !!PELiteralEvaluator methodsFor: 'private' stamp: 'pmm 9/24/2006 10:55'!inline: aMessageNode	| value |	value := aMessageNode evaluate.	(self isAcceptable: value) ifTrue: [		aMessageNode replaceWith: (RBLiteralNode value: value).		self visitNode: aMessageNode parent ]! !!PELiteralEvaluator class methodsFor: 'accessing' stamp: 'pmm 9/24/2006 10:27'!enabled	^enabled ifNil: [ false ]! !!PELiteralEvaluator class methodsFor: 'accessing' stamp: 'pmm 9/24/2006 10:28'!enabled: aBoolean	enabled := aBoolean! !!PELiteralEvaluator class methodsFor: 'accessing' stamp: 'pmm 9/24/2006 12:12'!priority	^16r1000! !!PELiteralEvaluator class methodsFor: 'testing' stamp: 'md 7/5/2007 16:54'!isActive	^self isEnabled ! !!PELiteralEvaluator class methodsFor: 'testing' stamp: 'pmm 9/24/2006 10:27'!isEnabled	^self enabled! !!PELiteralReducer methodsFor: 'visitor-double dispatching' stamp: 'pmm 8/11/2006 10:06'!acceptLiteralNode: aLiteralNode	normalLiterals		literalIndexOf: aLiteralNode		ifAbsent: [ normalLiterals add: aLiteralNode ]! !!PELiteralReducer methodsFor: 'visitor-double dispatching' stamp: 'pmm 8/11/2006 10:05'!acceptObjectLiteralNode: anObjectLiteralNode	objectLiterals		literalIndexOf: anObjectLiteralNode		ifAbsent: [ objectLiterals add: anObjectLiteralNode ]! !!PELiteralReducer methodsFor: 'testing' stamp: 'pmm 8/11/2006 10:08'!hasTooManyLiterals	^normalLiterals size + objectLiterals size > self maximumLiterals ! !!PELiteralReducer methodsFor: 'initialize-release' stamp: 'pmm 8/11/2006 09:58'!initialize	super initialize.	normalLiterals := OrderedCollection new.	objectLiterals := OrderedCollection new.! !!PELiteralReducer methodsFor: 'accessing' stamp: 'pmm 8/11/2006 10:03'!maximumLiterals	"256 is maximum	one is used for properties and	one is used for selector and method class"	^256 - 2 ! !!PELiteralReducer methodsFor: 'actions' stamp: 'pmm 8/11/2006 10:09'!reduceLiterals	self hasTooManyLiterals ifFalse: [ ^self ].! !!PELiteralReducer methodsFor: 'visiting' stamp: 'pmm 8/11/2006 10:09'!visitNode: aNode	super visitNode: aNode.	aNode isMethod ifTrue: [		self reduceLiterals ]! !!PELiteralReducer class methodsFor: 'accessing' stamp: 'md 8/25/2007 12:30'!isActive	^false! !!PELiteralReducer class methodsFor: 'accessing' stamp: 'pmm 8/11/2006 09:56'!priority	^16rFFFFFFFF! !!PEMessageSendSearcher methodsFor: 'visitor-double dispatching' stamp: 'pmm 7/8/2005 12:44'!acceptMessageNode: aMessageNode 	aMessageNode selector = self selector		ifTrue: [ self found: true ]		ifFalse: [ super acceptMessageNode: aMessageNode  ]! !!PEMessageSendSearcher methodsFor: 'accessing' stamp: 'pmm 7/8/2005 12:42'!found	^found! !!PEMessageSendSearcher methodsFor: 'accessing' stamp: 'pmm 7/8/2005 12:42'!found: aBoolean 	found _ aBoolean! !!PEMessageSendSearcher methodsFor: 'accessing' stamp: 'pmm 7/8/2005 12:42'!selector	^selector! !!PEMessageSendSearcher methodsFor: 'accessing' stamp: 'pmm 7/8/2005 12:43'!selector: aSymbol 	selector _ aSymbol! !!PEMessageSendSearcher methodsFor: 'initialize-release' stamp: 'pmm 7/8/2005 12:42'!initialize	super initialize.	self found: false.! !!PEMessageSendSearcher class methodsFor: 'instance creation' stamp: 'pmm 7/8/2005 12:47'!selector: aSymbol	^self new		selector: aSymbol;		yourself! !!PEMethodBodyInstrumentationVisitor methodsFor: 'visitor-double dispatching' stamp: 'pmm 9/25/2006 09:18'!acceptAssignmentNode: anAssignmentNode 	super acceptAssignmentNode: anAssignmentNode.	self block value: anAssignmentNode! !!PEMethodBodyInstrumentationVisitor methodsFor: 'visitor-double dispatching' stamp: 'pmm 11/11/2006 16:34'!acceptBlockNode: aBlockNode	self block value: aBlockNode.	"don't care about arguments"	self visitNode: aBlockNode body! !!PEMethodBodyInstrumentationVisitor methodsFor: 'visitor-double dispatching' stamp: 'pmm 9/25/2006 09:19'!acceptLiteralNode: aLiteralNode 	self block value: aLiteralNode! !!PEMethodBodyInstrumentationVisitor methodsFor: 'visitor-double dispatching' stamp: 'pmm 9/25/2006 09:19'!acceptMessageNode: aMessageNode 	super acceptMessageNode: aMessageNode.	self block value: aMessageNode! !!PEMethodBodyInstrumentationVisitor methodsFor: 'visitor-double dispatching' stamp: 'pmm 9/25/2006 09:19'!acceptReturnNode: aReturnNode 	super acceptReturnNode: aReturnNode.	self block value: aReturnNode! !!PEMethodBodyInstrumentationVisitor methodsFor: 'visitor-double dispatching' stamp: 'pmm 11/11/2006 16:34'!acceptSequenceNode: aSequenceNode	self block value: aSequenceNode.	"don't care about temps"	aSequenceNode statements do: [:each | self visitNode: each]! !!PEMethodBodyInstrumentationVisitor methodsFor: 'visitor-double dispatching' stamp: 'md 10/18/2007 11:07'!acceptVariableNode: aVariablNode 	self block value: aVariablNode.	super acceptVariableNode: aVariablNode.! !!PEMethodInterpreter methodsFor: 'visitor-double dispatching' stamp: 'pmm 4/28/2006 19:01'!acceptBlockNode: aBlockNode	^self blockInterpreterClass		block: aBlockNode		interpreter: self! !!PEMethodInterpreter methodsFor: 'visitor-double dispatching' stamp: 'pmm 7/3/2006 09:11'!acceptMethodNode: aMethodNode 	aMethodNode isPrimitive		ifTrue: [ self executePrimitve: aMethodNode ]		ifFalse: [ self interpret: aMethodNode ]! !!PEMethodInterpreter methodsFor: 'accessing' stamp: 'pmm 7/3/2006 08:36'!arguments	^self codeNode arguments		collect: [ :each | temps at: each name ]! !!PEMethodInterpreter methodsFor: 'accessing' stamp: 'pmm 4/27/2006 21:44'!codeNode	^methodNode! !!PEMethodInterpreter methodsFor: 'accessing' stamp: 'pmm 4/27/2006 23:05'!instanceVariableMap	instanceVariableMap isNil ifTrue: [		instanceVariableMap := Dictionary new.		receiver class allInstVarNames withIndexDo: [ :each :index |			instanceVariableMap at: each put: index ] ].	^instanceVariableMap! !!PEMethodInterpreter methodsFor: 'accessing' stamp: 'pmm 4/24/2006 20:54'!methodClass	^methodNode methodClass! !!PEMethodInterpreter methodsFor: 'accessing' stamp: 'pmm 4/24/2006 20:16'!methodInterpreter	^self! !!PEMethodInterpreter methodsFor: 'accessing' stamp: 'pmm 4/27/2006 22:04'!methodNode: aMethodNode 	methodNode := aMethodNode! !!PEMethodInterpreter methodsFor: 'accessing' stamp: 'pmm 4/24/2006 20:20'!receiver	^receiver! !!PEMethodInterpreter methodsFor: 'accessing' stamp: 'pmm 4/24/2006 20:20'!receiver: anObject	receiver := anObject! !!PEMethodInterpreter methodsFor: 'executing' stamp: 'md 3/31/2007 19:18'!executePrimitve: aMethodNode	| newMethodNode newBody newMethod |	newMethodNode := aMethodNode copy.	newBody := RBSequenceNode statement: (		RBMessageNode			receiver: (PEObjectLiteralNode value: self)			selector: #interpret:			argument: (PEObjectLiteralNode value: aMethodNode)).	newMethodNode body: newBody.	newMethod := (ASTTranslator new		visitNode: newMethodNode;		ir) compiledMethodWith: #(0 0 0 0).	self return: (newMethod valueWithReceiver: self receiver arguments: self arguments)! !!PEMethodInterpreter methodsFor: 'executing' stamp: 'pmm 7/3/2006 08:21'!interpret: aMethodNode	self visitNode: aMethodNode body.	self returnSelf! !!PEMethodInterpreter methodsFor: 'executing' stamp: 'pmm 4/27/2006 22:06'!run	^self withEscaper: [		self visitNode: methodNode ]! !!PEMethodInterpreter methodsFor: 'accessing-variables' stamp: 'pmm 4/26/2006 11:23'!instanceVariableAt: aString	^self receiver instVarAt: (self instanceVariableMap at: aString)! !!PEMethodInterpreter methodsFor: 'accessing-variables' stamp: 'pmm 4/26/2006 17:20'!instanceVariableAt: aString put: anObject	^self receiver		instVarAt: (self instanceVariableMap at: aString)		 put: anObject! !!PEMethodInterpreter methodsFor: 'accessing-variables' stamp: 'pmm 4/28/2006 10:53'!temporaryVariableAt: aString	^temps at: aString! !!PEMethodInterpreter methodsFor: 'accessing-variables' stamp: 'pmm 4/26/2006 17:22'!temporaryVariableAt: aString put: anObject	^temps		at: aString		put: anObject! !!PEMethodInterpreter methodsFor: 'returning' stamp: 'pmm 4/27/2006 23:43'!return: anObject	escaper value: anObject! !!PEMethodInterpreter methodsFor: 'returning' stamp: 'pmm 4/27/2006 23:43'!returnSelf	self return: receiver ! !!PEMethodInterpreter methodsFor: 'visiting' stamp: 'pmm 4/24/2006 16:39'!visitBlockArguments: aNodeCollection	self shouldNotImplement! !!PEMethodInterpreter methodsFor: 'escaping' stamp: 'pmm 4/26/2006 21:13'!withEscaper: aBlock	| old |	old := escaper.	escaper := [ :value | ^ value ].	^ aBlock ensure: [ escaper := old ]! !!PEMethodInterpreter class methodsFor: 'execution' stamp: 'pmm 4/29/2006 12:29'!evaluateDoIt: aDoItNode	| instance |	instance := self new.	^instance withEscaper: [		instance visitNode: aDoItNode ]! !!PEMethodInterpreter class methodsFor: 'execution' stamp: 'pmm 8/19/2006 22:14'!run: aMethodNode with: anArray in: anObject	^self new		methodNode: aMethodNode;		initializeArgumentsWith: anArray;		receiver: anObject;		run! !!PENodeReplacer methodsFor: 'accessing' stamp: 'pmm 11/7/2005 11:44'!original	^original! !!PENodeReplacer methodsFor: 'accessing' stamp: 'pmm 6/11/2006 21:52'!original: aNode 	original := aNode! !!PENodeReplacer methodsFor: 'accessing' stamp: 'pmm 11/7/2005 11:44'!replacement	^replacement! !!PENodeReplacer methodsFor: 'accessing' stamp: 'pmm 6/11/2006 21:52'!replacement: aNode 	replacement := aNode! !!PENodeReplacer methodsFor: 'visiting' stamp: 'pmm 9/24/2006 13:39'!visitNode: aNode	^(aNode = self original		and: [ (aNode hasAnnotation: #dontreplace) not ])			ifFalse: [ super visitNode: aNode ]			ifTrue: [ aNode parent				replaceNodeAndSetParent: aNode				withNode: (self replacement copy					addAnnotation: ((GenericNoValueAnnotation						key: #dontreplace)						sourceVisible: false;						yourself);					yourself) ]! !!PENodeReplacer class methodsFor: 'private' stamp: 'pmm 7/26/2006 10:42'!asDictionary: aCollectionOrAssociation	^aCollectionOrAssociation isDictionary		ifTrue: [ aCollectionOrAssociation ]		ifFalse: [			aCollectionOrAssociation isCollection				ifTrue: [ Dictionary withAll: aCollectionOrAssociation ]				ifFalse: [ Dictionary with: aCollectionOrAssociation ] ]! !!PENodeReplacer class methodsFor: 'private' stamp: 'md 4/13/2007 15:14'!replaceMetavariablesIn: aBlockNode with: aNode shared: aDictionary	| newBlock |	newBlock := aBlockNode copy.	^newBlock body! !!PENodeReplacer class methodsFor: 'private' stamp: 'pmm 7/26/2006 15:42'!replacementNodeFor: aNode of: anAnnotedNode	^self replacementNodeFor: aNode of: anAnnotedNode shared: Dictionary new! !!PENodeReplacer class methodsFor: 'private' stamp: 'pmm 7/26/2006 15:41'!replacementNodeFor: aNode of: anAnnotedNode shared: aDictionary	| replacement |	replacement := aNode isBlock		ifFalse: [ aNode ]		ifTrue: [ self replaceMetavariablesIn: aNode with: anAnnotedNode shared: aDictionary ].	^(replacement isSequence and: [ replacement statements size = 1 ])		ifTrue: [ replacement statements first ]		ifFalse: [ replacement ]! !!PENodeReplacer class methodsFor: 'instance creation' stamp: 'pmm 11/7/2005 12:43'!original: anOriginalNode replacement: aReplacementNode	^self new		original: anOriginalNode;		replacement: aReplacementNode;		yourself! !!PENodeReplacer class methodsFor: 'utilities' stamp: 'pmm 11/7/2005 12:57'!replace: anOriginalNode with: aReplacementNode in: aNode	(self original: anOriginalNode replacement: aReplacementNode)		visitNode: aNode! !!PENodeReplacer class methodsFor: 'utilities' stamp: 'pmm 11/27/2006 16:19'!replaceVariablesIn: aNode using: aCollectionOrAssociation	(self asDictionary: aCollectionOrAssociation) keysAndValuesDo: [ :variableName :newValue |		self			replace: variableName asVariableNode			with: newValue asLiteralNode			in: aNode ]! !!PEObjectLiteralNode methodsFor: 'comparing' stamp: 'md 3/31/2007 19:18'!= anObject 	^self == anObject		or: [			(anObject isKindOf: PEObjectLiteralNode)				and: [ self value == anObject value ] ]! !!PEObjectLiteralNode methodsFor: 'comparing' stamp: 'md 7/25/2007 15:33'!hash	^self identityHash ! !!PEObjectLiteralNode methodsFor: 'visitor' stamp: 'pmm 6/25/2006 15:29'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptObjectLiteralNode: self! !!PEObjectLiteralNode methodsFor: 'accessing' stamp: 'pmm 6/21/2006 15:41'!formattedCode	^self value printString! !!PEObjectLiteralNode methodsFor: 'accessing' stamp: 'md 8/25/2007 12:26'!instrumentedClassname	^'PEInstrumentedObjectLiteralNode'! !!PEObjectLiteralNode methodsFor: 'accessing' stamp: 'pmm 8/6/2006 15:27'!token	self shouldNotImplement! !!PEObjectLiteralNode methodsFor: 'accessing' stamp: 'pmm 1/16/2006 10:48'!value	^value! !!PEObjectLiteralNode class methodsFor: 'instance creation' stamp: 'pmm 1/16/2006 10:49'!value: anObject	^(super value: anObject)		value: anObject;		yourself! !!PEParser methodsFor: 'public access' stamp: 'md 7/25/2007 22:47'!parse: sourceStream class: parseScope noPattern: doitBool notifying: req ifFail: aBlock	"Parse sourceStream into a embedded BlockNode if doitFlag is true (no method header) or a MethodNode if doitFlag is false.  Parsing is done with respect to parseScope to find non-local variables.  Errors in parsing are reported to req if not nil followed by executing the fail block."	| parser |		source := sourceStream.	requestor := req.	doitFlag := doitBool.	scope := parseScope parseScope.	failBlock := [^ aBlock value].	parser := self realParserClass.	^ [	| tree |		tree := doitFlag 			ifTrue: [parser parseDoIt: source]			ifFalse: [parser parseMethod: source].		[		tree methodClass: parseScope.		tree verifyIn: scope.		tree callSemanticPlugins.] on: SemanticWarning do: [:ex | ex correctIn: self]	 ] on: UnhandledError do: [:uEx | | ex |		ex := uEx exception.		(SmaCCParserError handles: ex)			ifTrue: [self notify: ex description at: ex tag position]			ifFalse: [uEx pass]	 ]! !!PEParser methodsFor: 'accessing' stamp: 'md 3/31/2007 18:48'!realParserClass	^ PESqueakParser! !!PERecompiler methodsFor: 'recompile' stamp: 'md 7/24/2007 16:45'!recompile: selector in: class	"Recompile method in class. If method can't be recompiled (because of compile error) add it to problemMethods with general reason"	| source oldMethod trailer methodNode newMethod |		"do not recompile Traits methods here, they are recompiled 	and reinstalled when the trait is recompiled"		(class includesLocalSelector: selector) ifFalse: [^self].		oldMethod := class compiledMethodAt: selector.	source := class sourceCodeAt: selector.	source ifNil: [^ self problem: 'no source' sel: selector in: class].	trailer := oldMethod trailer.	methodNode := PECompiler new		compile: source in: class notifying: self		ifFail: [^ self problem: 'syntax error' sel: selector in: class].	selector == methodNode selector ifFalse: [		^ self problem: 'selector changed' sel: selector in: class].	newMethod := methodNode generate: trailer.	methodNode prepareForStorage.	methodNode reflectiveMethod classBinding: class binding.	methodNode properties: newMethod compiledMethod properties.	class addSelectorSilently: selector withMethod: newMethod compiledMethod.! !!PERecompiler methodsFor: 'recompile' stamp: 'md 7/24/2007 16:48'!recompile: selector inTrait: trait	"Recompile method in class. If method can't be recompiled (because of compile error) add it to problemMethods with general reason"	| source oldMethod trailer methodNode newMethod |		"do not recompile Traits methods here, they are recompiled 	and reinstalled when the trait is recompiled"		(trait includesLocalSelector: selector) ifFalse: [^self].			oldMethod _ trait compiledMethodAt: selector.	source _ trait sourceCodeAt: selector.	source ifNil: [^ self problem: 'no source' sel: selector in: trait].	trailer _ oldMethod trailer.	methodNode _ PECompiler new		compile: source in: trait notifying: self		ifFail: [^ self problem: 'syntax error' sel: selector in: trait].	selector == methodNode selector ifFalse: [		^ self problem: 'selector changed' sel: selector in: trait].	newMethod _ methodNode generate: trailer.		methodNode prepareForStorage.	methodNode reflectiveMethod classBinding: trait binding.	methodNode properties: newMethod compiledMethod properties.	trait addSelectorSilently: selector withMethod: newMethod compiledMethod.		"now update all the classes that have this trait imported"	trait updateMethodDictionarySelector: selector.! !!PERecompiler commentStamp: 'md 3/31/2007 19:11' prior: 0![PERecompiler new inspect; recompileImage] forkAt: 30!!PEReflectiveMethodNode methodsFor: 'beforeafter' stamp: 'md 3/29/2007 23:35'!after	^self propertyAt: #after ifAbsentPut: [OrderedCollection new].! !!PEReflectiveMethodNode methodsFor: 'beforeafter' stamp: 'md 6/13/2007 13:37'!before	^self propertyAt: #before ifAbsentPut: [OrderedCollection new].! !!PEReflectiveMethodNode methodsFor: 'beforeafter' stamp: 'md 6/13/2007 13:44'!hasAfterCode	^(self hasProperty: #after) and: [(self propertyAt: #after) notEmpty].! !!PEReflectiveMethodNode methodsFor: 'beforeafter' stamp: 'md 6/13/2007 13:45'!hasBeforeCode	^(self hasProperty: #before) and: [(self propertyAt: #before) notEmpty].! !!PEReflectiveMethodNode methodsFor: 'beforeafter' stamp: 'md 3/28/2007 10:33'!hasBeforeOrAfterCode	^self hasBeforeCode		or: [ self hasAfterCode ]! !!PEReflectiveMethodNode methodsFor: 'as yet unclassified' stamp: 'md 7/25/2007 22:47'!callSemanticPlugins	PESemCheckPlugin allPlugins do: [ :each |		each visitNode: self]. ! !!PEReflectiveMethodNode methodsFor: 'private' stamp: 'md 3/27/2007 17:18'!correctSelector: variableNode	^ self. ! !!PEReflectiveMethodNode methodsFor: 'private' stamp: 'md 4/13/2007 15:09'!correctVariable: variableNode	"Correct the variableNode to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps, and uppercase variables as Globals or ClassVars,	depending on whether the context is nil (class=UndefinedObject)."	| varName |	varName := variableNode name.	Transcript show: ' (' , varName , ' is Undeclared) '.	varName _ varName asSymbol.	Undeclared at: varName put: nil.	^ GlobalVar new assoc: (Undeclared associationAt: varName); scope: self scope! !!PEReflectiveMethodNode methodsFor: 'private' stamp: 'md 4/2/2007 17:30'!defaultTrailer	"this is needed for the source pointer	the default #(0) will result in the VM setfaulting	because #setSourcePointer: writes into the CompiledMethod	*we think*"	^ #(0 0 0 0). ! !!PEReflectiveMethodNode methodsFor: 'private' stamp: 'md 4/4/2007 18:53'!generateIR	^ PECommonCompilationStrategy new compile: self; ir! !!PEReflectiveMethodNode methodsFor: 'private' stamp: 'md 3/27/2007 17:18'!queryUninitializedTemp: variableNode	^ self. ! !!PEReflectiveMethodNode methodsFor: 'private' stamp: 'md 3/27/2007 17:17'!removeUnusedTemp: variableNode	"Removing unused temp, variableNode, if verified by the user"	^ self.  "don't remove and continue"! !!PEReflectiveMethodNode methodsFor: 'private' stamp: 'md 3/27/2007 17:19'!variable: varNode shadows: semVar		^ Transcript show: '(', varNode name, ' is shadowed)'.! !!PEReflectiveMethodNode methodsFor: 'accessing' stamp: 'md 3/31/2007 18:57'!encoder	^PEParser new! !!PEReflectiveMethodNode methodsFor: 'accessing' stamp: 'md 5/18/2007 15:18'!methodClass	^Smalltalk classNamed: (self propertyAt: #definitionClass).! !!PEReflectiveMethodNode methodsFor: 'accessing' stamp: 'md 5/18/2007 15:16'!methodClass: aClass	self propertyAt: #definitionClass put: aClass name asSymbol.! !!PEReflectiveMethodNode methodsFor: 'accessing' stamp: 'md 3/30/2007 16:47'!reflectiveMethod	^self parent! !!PEReflectiveMethodNode methodsFor: 'accessing' stamp: 'md 3/27/2007 17:16'!scope	"Object parseScope"	^ scope ifNil: [		[ self verifyIn: (self methodClass parseScope			outerScope: nil parseScope;			yourself) ] on: SemanticWarning do: [:ex | ex correctIn: self ].		scope	  ]! !!PEReflectiveMethodNode methodsFor: 'accessing' stamp: 'md 4/7/2007 11:31'!source	self flag: #FIXME.	^source isNil			ifTrue: [self reflectiveMethod getSource]			ifFalse: [source].! !!PEReflectiveMethodNode methodsFor: 'translate' stamp: 'md 3/29/2007 18:51'!generate: trailer 	"self verifyIn: (ClassScope new class: JExamples; yourself)"	^ReflectiveMethod 		methodNode: self		compiledMethod: (super generate: trailer)! !!PEReflectiveMethodNode methodsFor: 'testing' stamp: 'md 5/18/2007 15:17'!hasMethodClass	| className |	className _ self propertyAt: #definitionClass. 	^className notNil and: [ className ~= #unknown ]! !!PEReflectiveMethodNode methodsFor: 'actions' stamp: 'pmm 10/22/2005 13:35'!killIR	self privIR: nil! !!PEReflectiveMethodNode methodsFor: 'actions' stamp: 'md 3/5/2007 14:37'!killScope	PEScopeKiller new visitNode: self! !!PEReflectiveMethodNode methodsFor: 'actions' stamp: 'md 3/5/2007 17:20'!killSource	self source: nil! !!PEReflectiveMethodNode methodsFor: 'actions' stamp: 'md 4/13/2007 22:16'!prepareForStorage	self killScope.	self killIR.	self killSource.	PETokenKiller new visitNode: self! !!PEReflectiveMethodNode methodsFor: 'actions' stamp: 'pmm 10/22/2005 13:35'!restoreIR	self generateIR! !!PEReflectiveMethodNode methodsFor: 'actions' stamp: 'pmm 10/22/2005 11:07'!restoreScope	self scope! !!PEReflectiveMethodNode methodsFor: 'copying' stamp: 'md 6/13/2007 14:03'!postCopy	super postCopy.	properties := properties copy.	annotations := annotations copy.! !!PEReflectiveMethodNode methodsFor: '*geppetto2' stamp: 'md 8/20/2007 16:44'!addNode: aNode before: anotherNode	self body addNode: aNode before: anotherNode. ! !!PEReflectiveMethodNode methodsFor: '*geppetto2' stamp: 'md 5/18/2007 17:18'!gpAddAfter: aNode	self after add: aNode.! !!PEReflectiveMethodNode methodsFor: '*geppetto2' stamp: 'md 6/13/2007 13:41'!gpAddBefore: aNode	self before add: aNode.! !!PEReflectiveMethodNode methodsFor: '*geppetto2' stamp: 'md 10/21/2007 21:02'!gpreplaceWith: aNode 	self body: aNode copy asSequenceNode.	primitiveNode := nil.! !!PEReflectiveMethodNode methodsFor: '*geppetto2' stamp: 'md 3/1/2007 17:38'!link: aLink	aLink hookOn: self		! !!PEReflectiveMethodNode methodsFor: '*geppetto2' stamp: 'md 3/21/2007 15:11'!resetCache	self scope: nil.	self parent ifNotNil: [self parent invalidate].! !!PEReflectiveMethodNode class methodsFor: 'accessing' stamp: 'md 3/21/2007 13:40'!formatterClass	^FormatterClass isNil ifTrue: [PEFormatter] ifFalse: [FormatterClass]! !!PEReturnCounter methodsFor: 'visitor-double dispatching' stamp: 'pmm 8/28/2006 11:32'!acceptReturnNode: aReturnNode	returns := returns + 1.	super acceptReturnNode: aReturnNode ! !!PEReturnCounter methodsFor: 'initialize-release' stamp: 'pmm 8/28/2006 11:32'!initialize	super initialize.	returns := 0! !!PEReturnCounter methodsFor: 'accessing' stamp: 'pmm 8/28/2006 11:31'!returns	^returns! !!PEReturnCounter class methodsFor: 'convenience' stamp: 'pmm 8/28/2006 11:33'!returnsIn: aNode	^self new		visitNode: aNode;		returns! !!PEScopeKiller methodsFor: 'visitor-double dispatching' stamp: 'pmm 10/22/2005 14:10'!acceptBlockNode: aBlockNode 	aBlockNode scope: nil.	super acceptBlockNode: aBlockNode ! !!PEScopeKiller methodsFor: 'visitor-double dispatching' stamp: 'pmm 10/22/2005 11:27'!acceptMethodNode: aMethodNode 	aMethodNode scope: nil.	super acceptMethodNode: aMethodNode! !!PEScopeKiller methodsFor: 'visitor-double dispatching' stamp: 'md 3/30/2007 10:03'!acceptVariableNode: aVariableNode		aVariableNode binding ifNotNil: [		aVariableNode binding  isGlobal ifTrue: [aVariableNode primitiveChangeClassTo: RBGlobalVariableNode basicNew].		aVariableNode binding  isInstance ifTrue: [aVariableNode primitiveChangeClassTo: RBInstanceVariableNode basicNew].		aVariableNode binding  isTemp ifTrue: [aVariableNode primitiveChangeClassTo: RBTempVariableNode basicNew].	].		aVariableNode binding: nil.	super acceptVariableNode: aVariableNode	! !!PESemCheckPlugin commentStamp: 'md 7/25/2007 22:57' prior: 0!Sem Plugins are run *after the name analysis of the Parse*. They work on the AST, not a copy.!!PESemCheckPlugin class methodsFor: 'plugin interface' stamp: 'md 7/5/2007 17:01'!<= other	^self priority <= other priority! !!PESemCheckPlugin class methodsFor: 'plugin interface' stamp: 'md 7/5/2007 17:01'!isActive	^true! !!PESemCheckPlugin class methodsFor: 'plugin interface' stamp: 'md 7/5/2007 17:00'!priority	^16rFFFF! !!PESemCheckPlugin class methodsFor: 'as yet unclassified' stamp: 'md 7/25/2007 22:33'!allPlugins	^(self allSubclasses		select: [ :each | each isActive ]) asSortedCollection		collect: [ :each | each new ]! !!PESqueakParser methodsFor: 'reduction actions' stamp: 'pmm 6/9/2006 13:23'!annotation: nodes	| node annoations |	(nodes size = 1) ifTrue: [^ nodes first].	nodes second isNil ifTrue: [^ nodes first].	node := nodes first.	annoations := nodes second.	self flag: #todo. "think about mulivalued annotations"	annoations do: [ :each |		node addAnnotation: each ].	^node! !!PESqueakParser methodsFor: 'reduction actions' stamp: 'pmm 6/9/2006 13:23'!keywordAnnotation: nodes	| selector values |	selector := String streamContents: [ :stream |		nodes second first do: [ :each |			stream nextPutAll: each value ] ].	self flag: #todo. "think about annotations with two arguments"	values := nodes second second.	^Annotation		forKey: selector asSymbol		values: values! !!PESqueakParser methodsFor: 'reduction actions' stamp: 'md 3/31/2007 18:58'!method: nodes	^ PEReflectiveMethodNode new		selectorParts: nodes first first		arguments: nodes first last;		body: nodes second;		yourself! !!PESqueakParser methodsFor: 'reduction actions' stamp: 'md 3/31/2007 18:58'!methodPragma: nodes	^PEReflectiveMethodNode new		selectorParts: nodes first first		arguments: nodes first last;		body: nodes third;		pragmas: nodes second;		yourself! !!PESqueakParser methodsFor: 'reduction actions' stamp: 'md 3/31/2007 18:58'!methodPragmaTempsPragma: nodes	| sequence |	sequence := (RBSequenceNode		temporaries: nodes third first		statements: nodes fifth) 		firstToken: nodes third second; 		yourself.	nodes fifth isEmpty ifFalse: [		sequence lastToken: nodes third third ].	^ PEReflectiveMethodNode new 		selectorParts: nodes first first		arguments: nodes first last;		body: sequence;		pragmas: (nodes second addAll: nodes fourth; yourself)! !!PESqueakParser methodsFor: 'reduction actions' stamp: 'md 3/31/2007 18:58'!methodTempsPragma: nodes	| sequence |	sequence := (RBSequenceNode		temporaries: nodes second first		statements: nodes fourth)		firstToken: nodes second second; 		yourself.	nodes fourth isEmpty ifFalse: [			sequence lastToken: nodes second third ].	^ PEReflectiveMethodNode new		selectorParts: nodes first first		arguments: nodes first last;		body: sequence;		pragmas: nodes third! !!PESqueakParser methodsFor: 'reduction actions' stamp: 'pmm 6/9/2006 10:01'!unaryAnnotation: nodes	^Annotation forKey: (nodes second first first value) asSymbol! !!PESqueakParser methodsFor: 'examples' stamp: 'pmm 6/7/2006 08:37'!exampleCode	^'exampleUnknown: anArgument <: noInline :>	| unknown <: noInline :> |	1 to: 5 do: [ :each <: noInline :> |		Transcript show: each ].	unknown := Unknown basicNew.	(unknown ifTrue: [^ false] ifFalse: [^ false]) <: noInline :> .	^ true'! !!PESqueakParser methodsFor: 'generated-reduction actions' stamp: 'md 4/7/2007 11:33'!reduceActionForOptionalXXXperiodX1: nodes 	^ nil! !!PESqueakParser methodsFor: 'generated-reduction actions' stamp: 'md 4/7/2007 11:33'!reduceActionForOptionalXXXperiodX2: nodes 	^ nodes at: 1! !!PESqueakParser methodsFor: 'generated-reduction actions' stamp: 'md 4/7/2007 11:33'!reduceActionForRepeatXXAnnotation1: nodes 	^ OrderedCollection new! !!PESqueakParser methodsFor: 'generated-reduction actions' stamp: 'md 4/7/2007 11:33'!reduceActionForRepeatXXAnnotation2: nodes 	^ (nodes at: 1)		add: (nodes at: 2);		yourself! !!PESqueakParser methodsFor: 'generated-tables' stamp: 'md 4/7/2007 11:33'!reduceTable	^#(#(41 0 #array)#(41 2 #first:)#(41 5 #returnAdd:)#(41 3 #return:)#(42 2 #method:)#(42 3 #methodPragma:)#(42 5 #methodPragmaTempsPragma:)#(42 4 #methodTempsPragma:)#(43 1 #reduceFor:)#(44 2 #annotation:)#(45 3 #pragma:)#(45 3 #pragmaEndMissing:)#(45 2 #pragmaMissing:)#(45 4 #pragmas:)#(45 4 #pragmaEndMissing:)#(45 3 #pragmaMissing:)#(46 1 #messagePragma:)#(46 1 #messagePragma:)#(46 1 #messagePragma:)#(47 0 #array)#(47 2 #add:)#(48 1 #variable:)#(49 3 #keywordAnnotation:)#(49 3 #unaryAnnotation:)#(50 0 #reduceActionForRepeatXXAnnotation1:)#(50 2 #reduceActionForRepeatXXAnnotation2:)#(51 1 #firstIn:)#(51 3 #add3:)#(52 0 #reduceActionForOptionalXXXperiodX1:)#(52 1 #reduceActionForOptionalXXXperiodX2:)#(53 2 #secondIn:)#(53 2 #argumentNameMissing:)#(53 3 #add3:)#(53 3 #argumentNameMissing:)#(54 5 #blockWithArgs:)#(54 3 #blockNoArgs:)#(54 3 #blockArgs:)#(54 7 #blockWithTemps:)#(55 2 #messagePart:)#(55 2 #argumentMissing:)#(55 3 #addMessagePart:)#(55 3 #argumentMissing:)#(56 1 #unaryMessage:)#(57 3 #assignment:)#(57 3 #expressionMissing:)#(58 1 #first:)#(58 3 #cascade:)#(58 3 #cascadeMMissing:)#(59 3 #array:)#(60 1 #sequence:)#(60 2 #sequenceWithTemps:)#(61 1 #first:)#(61 1 #first:)#(61 2 #annotation:)#(62 1 #unaryMessage:)#(62 2 #messagePart:)#(62 2 #argumentNameMissing:)#(62 1 #first:)#(63 1 #first:)#(63 1 #first:)#(63 1 #first:)#(64 2 #messageSend:)#(64 2 #messageSend:)#(64 2 #messageSend:)#(65 2 #messageSend:)#(65 2 #messageSend:)#(65 2 #messageSend:)#(66 2 #messageSend:)#(66 2 #messageSend:)#(67 2 #messagePart:)#(67 2 #argumentMissing:)#(68 1 #first:)#(68 1 #first:)#(68 1 #first:)#(69 1 #first:)#(69 1 #first:)#(70 3 #secondPutToken:)#(70 1 #first:)#(70 1 #first:)#(70 1 #first:)#(70 1 #first:)#(71 0 #byteStream)#(71 2 #byteStreamPut:)#(72 0 #stream)#(72 2 #streamPut:)#(73 1 #value:)#(73 1 #valueSymbol:)#(73 1 #valueSymbol:)#(73 1 #valueSymbol:)#(73 1 #valueSymbol:)#(73 1 #valueSymbol:)#(73 3 #contents2:)#(73 3 #contents2:)#(73 1 #valueSymbol:)#(74 1 #arrayAddToken:)#(74 3 #secondAddToken:)#(74 3 #verticalBarMissing:)#(75 6 #externalCall:)#(75 8 #externalModuleCall:)#(76 2 #primitiveString:)#(76 2 #primitiveNumber:)#(76 2 #primitiveArgMissing:)#(76 4 #primitiveModule:)#(76 4 #moduleArgMissing:)#(77 1 #pragmaMessage:)#(77 1 #pragmaMessage:)#(77 1 #pragmaUnaryMessage:)#(78 2 #messagePart:)#(78 2 #literalMissing:)#(78 3 #addMessagePart:)#(78 3 #literalMissing:)#(79 2 #messagePart:)#(79 2 #argumentMissing:)#(80 1 #first:)#(80 1 #first:)#(80 1 #first:)#(80 1 #first:)#(81 1 #callConvention:)#(81 1 #callConvention:)#(82 1 #externalType:)#(82 2 #externalTypePointer:)#(83 1 #externalFunction:)#(83 1 #externalIndex:)#(84 1 #parameterExtCall:)#(84 2 #parametersExtCall:)#(87 1 #first:)#(87 1 #first:)#(87 1 #first:)#(88 1 #litTrue:)#(88 1 #litFalse:)#(88 1 #litNil:)#(88 1 #litNumber:)#(88 1 #litNumber:)#(88 1 #litChar:)#(88 1 #litString:)#(88 2 #litStringSymbol:)#(88 2 #litSymbol:)#(88 2 #litSymbol:)#(88 2 #litSymbol:)#(88 2 #litSymbol:)#(88 2 #litSymbol:)#(88 4 #litArray:)#(88 4 #litArray:)#(88 1 #litString:)#(89 2 #messagePart:)#(89 2 #argumentNameMissing:)#(89 3 #addMessagePart:)#(89 3 #argumentNameMissing:))! !!PESqueakParser methodsFor: 'generated-tables' stamp: 'md 4/7/2007 11:33'!transitionTable	^#(#(3 17 24 21 25 25 27 29 42 33 62 37 89)#(3 41 1 45 4 49 8 53 9 57 10 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 105 41 109 48 113 51 117 54 121 57 125 58 129 59 133 60 137 61 141 64 145 65 149 66 153 70 157 74 6 85 161 87 165 88)#(3 17 24 21 25 25 27 169 62 37 89)#(2 222 1 4 6 8 9 10 11 14 17 18 19 20 21 22 23 24 32 85)#(3 97 24 173 44 177 48 181 86)#(3 97 24 185 44 177 48 189 86)#(2 0 85)#(3 41 1 45 4 193 6 49 8 53 9 57 10 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 105 41 197 45 109 48 113 51 117 54 121 57 125 58 129 59 201 60 137 61 141 64 145 65 149 66 153 70 205 74 6 85 161 87 165 88)#(3 234 1 234 4 234 6 234 8 234 9 234 10 234 11 234 14 234 17 234 18 234 19 234 20 234 21 234 22 234 23 234 24 209 25 234 32 234 85)#(3 41 1 45 4 49 8 53 9 57 10 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 6 35 213 38 105 41 109 48 113 51 217 53 117 54 121 57 125 58 129 59 221 60 137 61 141 64 145 65 149 66 153 70 157 74 161 87 165 88)#(3 82 4 82 24 225 47 82 86)#(3 41 1 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 109 48 117 54 121 57 125 58 129 59 229 61 141 64 145 65 149 66 153 70 161 87 165 88)#(3 41 1 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 109 48 117 54 121 57 125 58 129 59 233 61 141 64 145 65 149 66 153 70 161 87 165 88)#(2 382 1 6 8 9 11 14 17 18 19 20 21 22 23 24 32 35 85)#(3 41 1 49 8 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 6 36 237 41 109 48 113 51 117 54 121 57 125 58 129 59 137 61 141 64 145 65 149 66 153 70 161 87 165 88)#(2 518 1 2 5 7 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 33 35 36 37 39 40 85 86)#(2 578 1 2 5 7 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 33 35 36 37 39 40 85 86)#(2 522 1 2 5 7 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 33 35 36 37 39 40 85 86)#(2 526 1 2 5 7 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 33 35 36 37 39 40 85 86)#(3 241 1 245 9 249 23 253 24 257 25 261 26 265 27 269 29)#(2 530 1 2 5 7 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 33 35 36 37 39 40 85 86)#(2 534 1 2 5 7 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 33 35 36 37 39 40 85 86)#(2 542 1 2 5 7 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 33 35 36 37 39 40 85 86)#(2 90 1 2 4 5 6 7 8 9 10 11 14 17 18 19 20 21 22 23 24 25 27 28 32 33 35 36 37 38 39 85 86)#(2 538 1 2 5 7 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 33 35 36 37 39 40 85 86)#(2 202 35 85)#(3 326 2 326 24 326 25 326 27 273 28 326 33 326 35 326 36 326 37 326 85)#(3 277 33 118 35 118 36 281 52 118 85)#(2 318 2 5 24 25 27 33 35 36 37 39 85)#(2 210 33 35 36 37 85)#(3 214 33 214 35 214 36 214 37 285 39 214 85)#(2 314 2 5 24 25 27 33 35 36 37 39 85)#(2 0 85)#(2 110 33 35 36 85)#(2 506 33 35 36 37 39 85)#(3 289 25 293 27 510 33 510 35 510 36 510 37 510 39 297 55 301 67 510 85)#(3 305 24 289 25 293 27 514 33 514 35 514 36 514 37 514 39 309 55 313 56 317 67 514 85)#(3 102 2 305 24 289 25 293 27 102 33 102 35 102 36 102 37 321 50 325 55 329 56 333 67 102 85)#(3 41 1 49 8 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 6 35 337 41 109 48 113 51 117 54 121 57 125 58 129 59 137 61 141 64 145 65 149 66 153 70 6 85 161 87 165 88)#(2 186 33 35 36 37 39 85)#(2 322 2 5 24 25 27 33 35 36 37 39 85)#(2 0 85)#(2 582 1 4 6 8 9 10 11 14 17 18 19 20 21 22 23 24 25 32 85)#(3 102 1 102 2 102 4 102 6 102 8 102 9 102 10 102 11 102 14 102 17 102 18 102 19 102 20 102 21 102 22 102 23 102 24 102 25 102 32 102 35 102 38 341 50 102 85 102 86)#(2 586 1 4 6 8 9 10 11 14 17 18 19 20 21 22 23 24 25 32 85)#(2 226 1 4 6 8 9 10 11 14 17 18 19 20 21 22 23 24 32 85)#(2 230 1 4 6 8 9 10 11 14 17 18 19 20 21 22 23 24 32 85)#(3 345 3 349 12 353 13 305 24 357 25 361 27 365 46 369 55 373 56 377 75 381 76 385 77 389 78 393 79 397 81 401 86)#(3 41 1 45 4 405 6 49 8 53 9 57 10 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 105 41 109 48 113 51 117 54 121 57 125 58 129 59 409 60 137 61 141 64 145 65 149 66 153 70 413 74 6 85 161 87 165 88)#(2 22 85)#(3 41 1 193 6 49 8 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 337 41 417 45 109 48 113 51 117 54 121 57 125 58 129 59 137 61 141 64 145 65 149 66 153 70 6 85 161 87 165 88)#(3 97 24 421 44 177 48 425 86)#(3 97 24 429 44 177 48 433 86)#(3 437 4 441 10 445 35 449 38)#(2 453 35)#(3 457 4 97 24 461 44 177 48 465 86)#(3 469 33 118 35 118 36 473 52 118 85)#(2 477 37)#(2 481 36)#(3 330 21 330 35 485 71)#(3 338 1 338 9 338 14 338 17 338 18 338 19 338 20 338 21 338 22 338 23 338 24 338 25 338 26 338 27 338 29 338 32 338 37 338 40 489 72)#(2 546 1 2 5 7 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 33 35 36 37 39 40 85 86)#(2 550 1 2 5 7 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 33 35 36 37 39 40 85 86)#(2 558 1 2 5 7 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 33 35 36 37 39 40 85 86)#(2 562 1 2 5 7 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 33 35 36 37 39 40 85 86)#(2 554 1 2 5 7 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 33 35 36 37 39 40 85 86)#(2 566 1 2 5 7 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 33 35 36 37 39 40 85 86)#(3 41 1 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 109 48 117 54 121 57 125 58 129 59 493 61 141 64 145 65 149 66 153 70 497 86 161 87 165 88)#(3 41 1 501 8 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 122 35 122 36 109 48 117 54 121 57 125 58 129 59 505 61 141 64 145 65 149 66 153 70 122 85 161 87 165 88)#(2 10 35 36 85)#(3 305 24 289 25 293 27 509 55 513 56 517 63 521 67 525 86)#(3 41 1 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 529 48 117 54 129 59 533 65 537 66 541 68 545 70 549 86 165 88)#(3 41 1 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 529 48 117 54 129 59 553 66 557 69 561 70 565 86 165 88)#(3 569 25 250 33 250 35 250 36 250 37 250 39 250 85)#(2 262 5 25 27 33 35 36 37 39 85)#(2 174 5 7 24 25 27 33 35 36 37 39 85 86)#(3 569 25 254 33 254 35 254 36 254 37 254 39 254 85)#(2 274 5 24 25 27 33 35 36 37 39 85)#(2 266 5 25 27 33 35 36 37 39 85)#(3 573 2 218 33 218 35 218 36 218 37 577 49 218 85)#(3 569 25 258 33 258 35 258 36 258 37 258 39 258 85)#(2 278 5 24 25 27 33 35 36 37 39 85)#(2 270 5 25 27 33 35 36 37 39 85)#(2 206 35 85)#(3 42 1 573 2 42 4 42 6 42 8 42 9 42 10 42 11 42 14 42 17 42 18 42 19 42 20 42 21 42 22 42 23 42 24 42 25 42 32 42 35 42 38 577 49 42 85 42 86)#(3 581 21 585 23 589 86)#(2 474 24)#(2 478 24)#(3 41 1 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 593 48 597 54 601 59 533 65 537 66 541 68 545 70 605 80 609 86 613 88)#(3 41 1 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 617 48 621 54 625 59 629 80 633 86 637 88)#(3 641 7 645 86)#(2 649 25)#(2 430 7 86)#(2 70 7 86)#(2 74 7 86)#(2 78 7 86)#(2 422 7 86)#(2 426 7 86)#(3 653 24 657 82)#(2 54 1 4 6 8 9 10 11 14 17 18 19 20 21 22 23 24 32 85)#(3 345 3 349 12 353 13 305 24 357 25 361 27 661 46 369 55 373 56 377 75 381 76 385 77 389 78 393 79 397 81 665 86)#(2 26 85)#(3 41 1 193 6 49 8 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 337 41 669 45 109 48 113 51 117 54 121 57 125 58 129 59 137 61 141 64 145 65 149 66 153 70 6 85 161 87 165 88)#(3 41 1 405 6 49 8 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 673 41 109 48 113 51 117 54 121 57 125 58 129 59 137 61 141 64 145 65 149 66 153 70 6 85 161 87 165 88)#(2 590 1 4 6 8 9 10 11 14 17 18 19 20 21 22 23 24 25 32 85)#(2 594 1 4 6 8 9 10 11 14 17 18 19 20 21 22 23 24 25 32 85)#(2 126 4 10 35 38)#(2 130 4 10 35 38)#(3 41 1 45 4 49 8 53 9 57 10 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 6 35 105 41 109 48 113 51 117 54 121 57 125 58 129 59 677 60 137 61 141 64 145 65 149 66 153 70 157 74 161 87 165 88)#(3 82 4 82 24 681 47)#(2 150 2 5 7 24 25 27 33 35 36 37 39 85 86)#(3 97 24 685 44 177 48 689 86)#(2 146 2 5 7 24 25 27 33 35 36 37 39 85 86)#(2 386 1 6 8 9 11 14 17 18 19 20 21 22 23 24 32 35 85)#(2 86 4 24 86)#(2 390 1 6 8 9 11 14 17 18 19 20 21 22 23 24 32 35 85)#(2 122 35 36 85)#(2 18 35 36 85)#(2 310 2 5 24 25 27 33 35 36 37 39 85)#(2 198 2 5 7 24 25 27 33 35 36 37 39 85 86)#(3 693 21 697 35)#(3 701 1 705 9 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 709 24 713 25 717 26 721 27 725 29 101 32 729 37 733 40 737 73 741 88)#(2 178 33 35 36 37 85)#(2 182 33 35 36 37 85)#(3 41 1 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 109 48 117 54 121 57 125 58 129 59 745 61 141 64 145 65 149 66 153 70 161 87 165 88)#(2 114 33 35 36 85)#(3 569 25 246 33 246 35 246 36 246 37 246 39 246 85)#(2 238 33 35 36 37 39 85)#(2 190 33 35 36 37 39 85)#(2 242 33 35 36 37 39 85)#(2 194 33 35 36 37 39 85)#(2 326 5 24 25 27 33 35 36 37 39 85)#(3 290 5 290 25 293 27 290 33 290 35 290 36 290 37 290 39 301 67 290 85)#(3 294 5 305 24 294 25 293 27 294 33 294 35 294 36 294 37 294 39 313 56 317 67 294 85)#(2 158 5 25 33 35 36 37 39 85)#(3 298 5 305 24 298 25 293 27 298 33 298 35 298 36 298 37 298 39 329 56 333 67 298 85)#(2 162 5 25 33 35 36 37 39 85)#(3 302 5 305 24 302 25 302 27 302 33 302 35 302 36 302 37 302 39 313 56 302 85)#(2 282 5 25 27 33 35 36 37 39 85)#(3 306 5 305 24 306 25 306 27 306 33 306 35 306 36 306 37 306 39 329 56 306 85)#(2 286 5 25 27 33 35 36 37 39 85)#(3 41 1 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 529 48 117 54 129 59 533 65 537 66 749 68 545 70 753 86 165 88)#(3 305 24 289 25 757 55 761 56)#(2 106 1 2 4 6 8 9 10 11 14 17 18 19 20 21 22 23 24 25 32 33 35 36 37 38 85 86)#(2 406 7 86)#(3 402 7 765 15 402 86)#(2 410 7 86)#(3 470 7 326 24 326 25 326 27 470 86)#(3 462 7 318 24 318 25 318 27 462 86)#(3 458 7 314 24 314 25 314 27 458 86)#(2 434 7 86)#(3 438 7 162 25 438 86)#(3 466 7 322 24 322 25 322 27 466 86)#(2 470 7 86)#(2 462 7 86)#(2 458 7 86)#(2 450 7 86)#(2 454 7 86)#(2 466 7 86)#(2 46 1 4 6 8 9 10 11 14 17 18 19 20 21 22 23 24 32 85)#(2 50 1 4 6 8 9 10 11 14 17 18 19 20 21 22 23 24 32 85)#(3 41 1 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 593 48 597 54 601 59 533 65 537 66 749 68 545 70 769 80 773 86 613 88)#(3 777 16 482 21 482 23 482 24 482 37)#(3 781 21 785 23 789 83)#(3 793 7 797 86)#(2 66 1 4 6 8 9 10 11 14 17 18 19 20 21 22 23 24 32 85)#(3 41 1 405 6 49 8 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 801 41 109 48 113 51 117 54 121 57 125 58 129 59 137 61 141 64 145 65 149 66 153 70 6 85 161 87 165 88)#(2 34 85)#(2 805 35)#(3 809 4 97 24 461 44 177 48)#(2 134 4 10 35 38)#(2 138 4 10 35 38)#(2 334 21 35)#(2 570 1 2 5 7 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 33 35 36 37 39 40 85 86)#(3 330 21 330 35 813 71)#(3 338 1 338 9 338 14 338 17 338 18 338 19 338 20 338 21 338 22 338 23 338 24 338 25 338 26 338 27 338 29 338 32 338 37 338 40 817 72)#(2 350 1 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 37 40)#(2 358 1 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 37 40)#(2 362 1 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 37 40)#(2 354 1 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 37 40)#(2 366 1 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 37 40)#(2 574 1 2 5 7 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 33 35 36 37 39 40 85 86)#(2 378 1 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 37 40)#(2 342 1 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 37 40)#(2 346 1 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 37 40)#(3 469 33 118 35 118 36 821 52 118 85)#(2 166 5 25 33 35 36 37 39 85)#(2 170 5 25 33 35 36 37 39 85)#(3 825 5 569 25)#(2 829 5)#(3 833 23 837 86)#(2 442 7 86)#(3 446 7 170 25 446 86)#(2 486 21 23 24 37)#(2 494 9)#(2 490 9)#(2 841 9)#(2 58 1 4 6 8 9 10 11 14 17 18 19 20 21 22 23 24 32 85)#(2 62 1 4 6 8 9 10 11 14 17 18 19 20 21 22 23 24 32 85)#(2 30 85)#(2 142 2 5 7 24 25 27 33 35 36 37 39 85 86)#(3 41 1 49 8 53 9 61 11 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 97 24 101 32 6 35 845 41 109 48 113 51 117 54 121 57 125 58 129 59 137 61 141 64 145 65 149 66 153 70 161 87 165 88)#(3 693 21 849 35)#(3 701 1 705 9 65 14 69 17 73 18 77 19 81 20 85 21 89 22 93 23 709 24 713 25 717 26 721 27 725 29 101 32 853 37 733 40 737 73 741 88)#(2 14 35 36 85)#(2 94 1 2 4 6 8 9 10 11 14 17 18 19 20 21 22 23 24 25 32 33 35 36 37 38 85 86)#(2 98 1 2 4 6 8 9 10 11 14 17 18 19 20 21 22 23 24 25 32 33 35 36 37 38 85 86)#(2 414 7 86)#(2 418 7 86)#(3 653 24 857 82 861 84)#(2 865 35)#(2 374 1 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 37 40)#(2 370 1 9 14 17 18 19 20 21 22 23 24 25 26 27 29 32 37 40)#(2 498 24 37)#(3 653 24 869 37 873 82)#(2 154 2 5 7 24 25 27 33 35 36 37 39 85 86)#(3 394 7 877 15 394 86)#(2 502 24 37)#(2 881 23)#(2 398 7 86))! !!PESqueakParser class methodsFor: 'as yet unclassified' stamp: 'md 7/24/2007 15:04'!parseDoIt: stringOrStream	| sequence |	sequence _ self		parseStream: stringOrStream readStream		startingAt: self startingStateForSequence.	^ (PEDoItNode body: sequence)		source: stringOrStream contents! !!PESqueakParser class methodsFor: 'generated-comments' stamp: 'md 4/7/2007 11:33'!parserDefinitionComment	"%id <name> <number> <negativeNumber> <binarySymbol> <period> <colon> <rightParentheses> <rightCurlyBrackets> <rightBoxBrackets> <string> <keyword> <multikeyword> <assignment> <character>;%start Sequence MethodPattern;%left Primary;%left Expression;Method:	MethodPattern Sequence						{#method:}|	MethodPattern Pragmas Sequence			{#methodPragma:}|	MethodPattern Pragmas Temporaries Pragmas Statements {#methodPragmaTempsPragma:}|	MethodPattern Temporaries Pragmas Statements {#methodTempsPragma:};MethodPattern:	<name>										{#unaryMessage:}|	<binarySymbol> AnnotatedVariable			{#messagePart:}|	<binarySymbol> error						{#argumentNameMissing:}|	KeywordMethodPattern						{#first:};KeywordMethodPattern:	<keyword> AnnotatedVariable					{#messagePart:}|	<keyword> error									{#argumentNameMissing:}|	KeywordMethodPattern <keyword> AnnotatedVariable	{#addMessagePart:}|	KeywordMethodPattern <keyword> error			{#argumentNameMissing:};Pragmas:	""<"" PragmaMessage "">""							{#pragma:}|	""<"" PragmaMessage error							{#pragmaEndMissing:}|	""<"" error											{#pragmaMissing:}|	Pragmas ""<"" PragmaMessage "">""					{#pragmas:}|	Pragmas ""<"" PragmaMessage error				{#pragmaEndMissing:}|	Pragmas ""<"" error								{#pragmaMissing:};Sequence:	Statements									{#sequence:}|	Temporaries Statements						{#sequenceWithTemps:};Temporaries:	""||""											{#arrayAddToken:}|	""|"" TemporaryVariables ""|""					{#secondAddToken:}| 	""|"" TemporaryVariables error					{#verticalBarMissing:};TemporaryVariables:												{#array}|	TemporaryVariables AnnotatedVariable		{#add:};AnnotatedVariable:	Variable Annotation*						{#annotation:};Statements:												{#array}|	StatementList <period>?						{#first:}|	StatementList <period> ""^"" Expression <period>?	{#returnAdd:}|	""^"" Expression <period>?						{#return:};StatementList:	Expression									{#firstIn:}|	StatementList <period> Expression				{#add3:};Block:	""["" BlockArgs ""|"" Sequence <rightBoxBrackets>	{#blockWithArgs:}|	""["" Sequence <rightBoxBrackets>				{#blockNoArgs:}|	""["" BlockArgs <rightBoxBrackets>				{#blockArgs:}|	""["" BlockArgs ""||"" TemporaryVariables ""|"" Statements <rightBoxBrackets> {#blockWithTemps:};				BlockArgs:	<colon> AnnotatedVariable						{#secondIn:}|	<colon>	error									{#argumentNameMissing:}|	BlockArgs <colon> AnnotatedVariable				{#add3:}|	BlockArgs <colon> error							{#argumentNameMissing:};Annotation:	""<:"" KeywordMessage "":>""		{#keywordAnnotation:}|	""<:"" UnaryMessage "":>""		{#unaryAnnotation:};Expression:	Assignment								{#first:}|	Cascade									{#first:}|	Primary	Annotation*					{#annotation:};Primary:	""("" Expression <rightParentheses>				{#secondPutToken:}|	Array										{#first:}|	Block										{#first:}|	Literal										{#first:}|	Variable									{#first:};Assignment:	Variable <assignment> Expression				{#assignment:}|	Variable <assignment> error					{#expressionMissing:};Cascade:	MessageSend								{#first:}|	Cascade <semicolon> Message					{#cascade:}|	Cascade <semicolon> error 					{#cascadeMMissing:};MessageSend:	KeywordMessageSend						{#first:}|	BinaryMessageSend							{#first:}|	UnaryMessageSend							{#first:};Message:	UnaryMessage								{#first:}|	BinaryMessage								{#first:}|	KeywordMessage							{#first:};KeywordMessageSend:	BinaryMessageSend KeywordMessage			{#messageSend:}|	UnaryMessageSend KeywordMessage			{#messageSend:}|	Primary KeywordMessage					{#messageSend:};KeywordMessage:	<keyword> KeywordArgument				{#messagePart:}|	<keyword> error 							{#argumentMissing:}|	KeywordMessage <keyword> KeywordArgument {#addMessagePart:}|	KeywordMessage <keyword> error 			{#argumentMissing:};KeywordArgument:	BinaryMessageSend							{#first:}|	UnaryMessageSend							{#first:}|	Primary									{#first:};BinaryMessageSend:	BinaryMessageSend BinaryMessage			{#messageSend:}|	UnaryMessageSend BinaryMessage			{#messageSend:}|	Primary BinaryMessage						{#messageSend:};BinaryMessage :	<binarySymbol> BinaryArgument				{#messagePart:}|	<binarySymbol> error 						{#argumentMissing:}; BinaryArgument:	UnaryMessageSend							{#first:}|	Primary									{#first:};UnaryMessageSend :	UnaryMessageSend UnaryMessage			{#messageSend:}|	Primary UnaryMessage						{#messageSend:};UnaryMessage :	<name>										{#unaryMessage:};Array:	""{"" Statements <rightCurlyBrackets>			{#array:};Variable:	<name>										{#variable:};Literal:	""true""										{#litTrue:}|	""false""										{#litFalse:}|	""nil""										{#litNil:}|	<number>									{#litNumber:}|	<negativeNumber>							{#litNumber:} |	<character>									{#litChar:}|	<string>										{#litString:}|	""#"" <string>									{#litStringSymbol:}|	""#"" <name>									{#litSymbol:}|	""#"" <binarySymbol>							{#litSymbol:}|	""#"" <keyword>								{#litSymbol:}|	""#"" <multikeyword>							{#litSymbol:}|	""#"" <alternateKeyword>						{#litSymbol:}|	""#"" ""["" ByteArray <rightBoxBrackets>			{#litArray:}|	""#"" ""("" LiteralArray <rightParentheses>		{#litArray:}|	""#:""											{#litString:};ByteArray:												{#byteStream}|	ByteArray <number>							{#byteStreamPut:};LiteralArray:												{#stream}|	LiteralArray ArrayLiteral					{#streamPut:};ArrayLiteral:	Literal										{#value:}|	<name>										{#valueSymbol:}|	<binarySymbol>								{#valueSymbol:}|	<keyword>									{#valueSymbol:}|	<multikeyword>								{#valueSymbol:}|	<alternateKeyword>							{#valueSymbol:}|	""("" LiteralArray <rightParentheses>			{#contents2:}|	""["" ByteArray <rightBoxBrackets>				{#contents2:}|	<anyChar>									{#valueSymbol:};PragmaMessage:	Apicall										{#messagePragma:}| 	Primitive 									{#messagePragma:} |	MessagePragma 								{#messagePragma:};MessagePragma:	KeyWordMessagePragma						{#pragmaMessage:}|	BinaryMessagePragma						{#pragmaMessage:}|	UnaryMessage 								{#pragmaUnaryMessage:};									BinaryMessagePragma:	<binarySymbol> PrimaryPragma				{#messagePart:}|	<binarySymbol> error 						{#argumentMissing:};										KeyWordMessagePragma:	<keyword> PrimaryPragma					{#messagePart:}|	<keyword> error 							{#literalMissing:}|	KeywordMessage <keyword> PrimaryPragma	{#addMessagePart:}|	KeywordMessage <keyword> error 			{#literalMissing:};PrimaryPragma:	Array										{#first:}|	Block										{#first:}|	Literal										{#first:}|	Variable									{#first:};Apicall:	TypeCall ExternalType IndexName ""("" ParameterApicall <rightParentheses>	{#externalCall:}|	TypeCall ExternalType IndexName ""("" ParameterApicall <rightParentheses> ""module:"" <string>	{#externalModuleCall:};IndexName:	<string>										{#externalFunction:}|	<number>									{#externalIndex:};TypeCall:	""apicall:""									{#callConvention:}|	""cdecl:""										{#callConvention:};ParameterApicall:	ExternalType 								{#parameterExtCall:}|	ParameterApicall ExternalType 				{#parametersExtCall:};ExternalType:	<name>										{#externalType:}	|	<name> ""*""									{#externalTypePointer:};Primitive:	""primitive:"" <string>							{#primitiveString:}|	""primitive:"" <number>						{#primitiveNumber:}|	""primitive:"" error 							{#primitiveArgMissing:}|	""primitive:"" <string> ""module:"" <string>		{#primitiveModule:}|	""primitive:"" <string> ""module:"" error 			{#moduleArgMissing:};"! !!PESqueakParser class methodsFor: 'generated-accessing' stamp: 'md 4/7/2007 11:33'!scannerClass	^PESqueakScanner! !!PESqueakParser class methodsFor: 'generated-starting states' stamp: 'md 4/7/2007 11:33'!startingStateForMethod	^1! !!PESqueakParser class methodsFor: 'generated-starting states' stamp: 'md 4/7/2007 11:33'!startingStateForMethodPattern	^3! !!PESqueakParser class methodsFor: 'generated-starting states' stamp: 'md 4/7/2007 11:33'!startingStateForSequence	^2! !!PESqueakScanner methodsFor: 'generated-tokens' stamp: 'md 4/7/2007 11:33'!assignmentId	^28! !!PESqueakScanner methodsFor: 'generated-tokens' stamp: 'md 4/7/2007 11:33'!binarySymbolId	^27! !!PESqueakScanner methodsFor: 'generated-tokens' stamp: 'md 4/7/2007 11:33'!characterId	^32! !!PESqueakScanner methodsFor: 'generated-tokens' stamp: 'md 4/7/2007 11:33'!colonId	^38! !!PESqueakScanner methodsFor: 'generated-tokens' stamp: 'md 4/7/2007 11:33'!emptySymbolTokenId	^85! !!PESqueakScanner methodsFor: 'generated-tokens' stamp: 'md 4/7/2007 11:33'!errorTokenId	^86! !!PESqueakScanner methodsFor: 'generated-tokens' stamp: 'md 4/7/2007 11:33'!keywordId	^25! !!PESqueakScanner methodsFor: 'generated-tokens' stamp: 'md 4/7/2007 11:33'!multikeywordId	^26! !!PESqueakScanner methodsFor: 'generated-tokens' stamp: 'md 4/7/2007 11:33'!nameId	^24! !!PESqueakScanner methodsFor: 'generated-tokens' stamp: 'md 4/7/2007 11:33'!negativeNumberId	^22! !!PESqueakScanner methodsFor: 'generated-tokens' stamp: 'md 4/7/2007 11:33'!numberId	^21! !!PESqueakScanner methodsFor: 'generated-tokens' stamp: 'md 4/7/2007 11:33'!periodId	^33! !!PESqueakScanner methodsFor: 'generated-tokens' stamp: 'md 4/7/2007 11:33'!rightBoxBracketsId	^35! !!PESqueakScanner methodsFor: 'generated-tokens' stamp: 'md 4/7/2007 11:33'!rightCurlyBracketsId	^36! !!PESqueakScanner methodsFor: 'generated-tokens' stamp: 'md 4/7/2007 11:33'!rightParenthesesId	^37! !!PESqueakScanner methodsFor: 'generated-tokens' stamp: 'md 4/7/2007 11:33'!stringId	^23! !!PESqueakScanner methodsFor: 'generated-scanner' stamp: 'md 4/7/2007 11:33'!scan1	self recordMatch: #(23 ).	self step.	currentCharacter = $' ifTrue: [^ self scan2].	^ self reportLastMatch! !!PESqueakScanner methodsFor: 'generated-scanner' stamp: 'md 4/7/2007 11:33'!scan10	self step.	(currentCharacter between: $0 and: $9) 		ifTrue: 			[			[self recordMatch: #(22 ).			self step.			currentCharacter between: $0 and: $9] 					whileTrue.			^ self reportLastMatch].	currentCharacter = $- ifTrue: [^ self scan11].	^ self reportLastMatch! !!PESqueakScanner methodsFor: 'generated-scanner' stamp: 'md 4/7/2007 11:33'!scan11	self step.	(currentCharacter between: $0 and: $9) 		ifTrue: 			[			[self recordMatch: #(22 ).			self step.			currentCharacter between: $0 and: $9] 					whileTrue.			^ self reportLastMatch].	^ self reportLastMatch! !!PESqueakScanner methodsFor: 'generated-scanner' stamp: 'md 4/7/2007 11:33'!scan2		[self step.	currentCharacter ~= $'] whileTrue.	currentCharacter = $' ifTrue: [^ self scan1].	^ self reportLastMatch! !!PESqueakScanner methodsFor: 'generated-scanner' stamp: 'md 4/7/2007 11:33'!scan3	self step.	(currentCharacter between: $0 and: $9) 		ifTrue: 			[			[self recordMatch: #(21 ).			self step.			currentCharacter between: $0 and: $9] 					whileTrue.			currentCharacter = $e ifTrue: [^ self scan4].			currentCharacter = $s ifTrue: [^ self scan5].			^ self reportLastMatch].	^ self reportLastMatch! !!PESqueakScanner methodsFor: 'generated-scanner' stamp: 'md 4/7/2007 11:33'!scan4	self step.	(currentCharacter between: $0 and: $9) 		ifTrue: 			[			[self recordMatch: #(21 ).			self step.			currentCharacter between: $0 and: $9] 					whileTrue.			^ self reportLastMatch].	currentCharacter = $- ifTrue: [^ self scan5].	^ self reportLastMatch! !!PESqueakScanner methodsFor: 'generated-scanner' stamp: 'md 4/7/2007 11:33'!scan5	self step.	(currentCharacter between: $0 and: $9) 		ifTrue: 			[			[self recordMatch: #(21 ).			self step.			currentCharacter between: $0 and: $9] 					whileTrue.			^ self reportLastMatch].	^ self reportLastMatch! !!PESqueakScanner methodsFor: 'generated-scanner' stamp: 'md 4/7/2007 11:33'!scan6	self step.	((currentCharacter between: $0 and: $9) 		or: [currentCharacter between: $A and: $Z]) 			ifTrue: 				[				[self recordMatch: #(21 ).				self step.				(currentCharacter between: $0 and: $9) 					or: [currentCharacter between: $A and: $Z]] 						whileTrue.				currentCharacter = $. 					ifTrue: 						[self step.						((currentCharacter between: $0 and: $9) 							or: [currentCharacter between: $A and: $Z]) 								ifTrue: 									[									[self recordMatch: #(21 ).									self step.									(currentCharacter between: $0 and: $9) 										or: [currentCharacter between: $A and: $Z]] 											whileTrue.									currentCharacter = $e ifTrue: [^ self scan4].									^ self reportLastMatch].						^ self reportLastMatch].				currentCharacter = $e ifTrue: [^ self scan4].				^ self reportLastMatch].	^ self reportLastMatch! !!PESqueakScanner methodsFor: 'generated-scanner' stamp: 'md 4/7/2007 11:33'!scan7		[self step.	(currentCharacter between: $0 and: $9) or: 			[(currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]]] 			whileTrue.	currentCharacter = $: 		ifTrue: 			[self recordMatch: #(29 ).			self step.			((currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan7].			^ self reportLastMatch].	^ self reportLastMatch! !!PESqueakScanner methodsFor: 'generated-scanner' stamp: 'md 4/7/2007 11:33'!scan8	self recordMatch: #(25 ).	self step.	((currentCharacter between: $A and: $Z) 		or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan9].	currentCharacter = $= 		ifTrue: [^ self recordAndReportMatch: #variableAssignment].	^ self reportLastMatch! !!PESqueakScanner methodsFor: 'generated-scanner' stamp: 'md 4/7/2007 11:33'!scan9		[self step.	(currentCharacter between: $0 and: $9) or: 			[(currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]]] 			whileTrue.	currentCharacter = $: 		ifTrue: 			[self recordMatch: #(26 ).			self step.			((currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan9].			^ self reportLastMatch].	^ self reportLastMatch! !!PESqueakScanner methodsFor: 'generated-scanner' stamp: 'md 4/7/2007 11:33'!scanForToken	self step.	(currentCharacter <= Character backspace or: 			[(currentCharacter between: (Character value: 14) and: (Character value: 31)) 				or: [currentCharacter = $` or: [currentCharacter >= $]]]) 		ifTrue: [^ self recordAndReportMatch: #(40 )].	((currentCharacter between: $A and: $Z) 		or: [currentCharacter between: $a and: $z]) 			ifTrue: 				[self recordMatch: #(24 40 ).				self step.				((currentCharacter between: $0 and: $9) or: 						[(currentCharacter between: $A and: $Z) 							or: [currentCharacter between: $a and: $z]]) 					ifTrue: 						[						[self recordMatch: #(24 ).						self step.						(currentCharacter between: $0 and: $9) or: 								[(currentCharacter between: $A and: $Z) 									or: [currentCharacter between: $a and: $z]]] 								whileTrue.						currentCharacter = $: ifTrue: [^ self scan8].						^ self reportLastMatch].				currentCharacter = $: ifTrue: [^ self scan8].				^ self reportLastMatch].	(currentCharacter = $!! or: 			[(currentCharacter between: $% and: $&) or: 					[(currentCharacter between: $+ and: $,) or: 							[currentCharacter = $/ or: 									[currentCharacter = $= or: 											[(currentCharacter between: $? and: $@) 												or: [currentCharacter = $\ or: [currentCharacter = $~]]]]]]]) 		ifTrue: 			[self recordMatch: #binarySymbol.			self step.			(currentCharacter = $!! or: 					[(currentCharacter between: $% and: $&) or: 							[(currentCharacter between: $* and: $-) or: 									[currentCharacter = $/ or: 											[(currentCharacter between: $< and: $@) or: 													[currentCharacter = $\ 														or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]) 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter = $!! or: 							[(currentCharacter between: $% and: $&) or: 									[(currentCharacter between: $* and: $-) or: 											[currentCharacter = $/ or: 													[(currentCharacter between: $< and: $@) or: 															[currentCharacter = $\ 																or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	(currentCharacter between: $0 and: $9) 		ifTrue: 			[self recordMatch: #(21 40 ).			self step.			(currentCharacter between: $0 and: $9) 				ifTrue: 					[					[self recordMatch: #(21 ).					self step.					currentCharacter between: $0 and: $9] 							whileTrue.					currentCharacter = $. ifTrue: [^ self scan3].					currentCharacter = $e ifTrue: [^ self scan4].					currentCharacter = $r ifTrue: [^ self scan6].					currentCharacter = $s ifTrue: [^ self scan5].					^ self reportLastMatch].			currentCharacter = $. ifTrue: [^ self scan3].			currentCharacter = $e ifTrue: [^ self scan4].			currentCharacter = $r ifTrue: [^ self scan6].			currentCharacter = $s ifTrue: [^ self scan5].			^ self reportLastMatch].	((currentCharacter between: Character tab and: Character cr) 		or: [currentCharacter = Character space]) 			ifTrue: 				[self recordMatch: #whitespace.				self step.				((currentCharacter between: Character tab and: Character cr) 					or: [currentCharacter = Character space]) 						ifTrue: 							[							[self recordMatch: #whitespace.							self step.							(currentCharacter between: Character tab and: Character cr) 								or: [currentCharacter = Character space]] 									whileTrue.							^ self reportLastMatch].				^ self reportLastMatch].	currentCharacter = $" 		ifTrue: 			[self recordMatch: #(40 ).			self step.			currentCharacter ~= $" 				ifTrue: 					[					[self step.					currentCharacter ~= $"] whileTrue.					currentCharacter = $" ifTrue: [^ self recordAndReportMatch: #comment].					^ self reportLastMatch].			currentCharacter = $" ifTrue: [^ self recordAndReportMatch: #comment].			^ self reportLastMatch].	currentCharacter = $# 		ifTrue: 			[self recordMatch: #(20 40 ).			self step.			currentCharacter = $: ifTrue: [^ self recordAndReportMatch: #(17 )].			^ self reportLastMatch].	currentCharacter = $$ 		ifTrue: 			[self recordMatch: #(40 ).			self step.			currentCharacter <= $ ifTrue: [^ self recordAndReportMatch: #(32 )].			^ self reportLastMatch].	currentCharacter = $' 		ifTrue: 			[self recordMatch: #(40 ).			self step.			currentCharacter ~= $' ifTrue: [^ self scan2].			currentCharacter = $' ifTrue: [^ self scan1].			^ self reportLastMatch].	currentCharacter = $( ifTrue: [^ self recordAndReportMatch: #(9 40 )].	currentCharacter = $) ifTrue: [^ self recordAndReportMatch: #(37 40 )].	currentCharacter = $* 		ifTrue: 			[self recordMatch: #(16 27 40 ).			self step.			(currentCharacter = $!! or: 					[(currentCharacter between: $% and: $&) or: 							[(currentCharacter between: $* and: $-) or: 									[currentCharacter = $/ or: 											[(currentCharacter between: $< and: $@) or: 													[currentCharacter = $\ 														or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]) 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter = $!! or: 							[(currentCharacter between: $% and: $&) or: 									[(currentCharacter between: $* and: $-) or: 											[currentCharacter = $/ or: 													[(currentCharacter between: $< and: $@) or: 															[currentCharacter = $\ 																or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $- 		ifTrue: 			[self recordMatch: #binarySymbol.			self step.			(currentCharacter = $!! or: 					[(currentCharacter between: $% and: $&) or: 							[(currentCharacter between: $* and: $-) or: 									[currentCharacter = $/ or: 											[(currentCharacter between: $< and: $@) or: 													[currentCharacter = $\ 														or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]) 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter = $!! or: 							[(currentCharacter between: $% and: $&) or: 									[(currentCharacter between: $* and: $-) or: 											[currentCharacter = $/ or: 													[(currentCharacter between: $< and: $@) or: 															[currentCharacter = $\ 																or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]] 							whileTrue.					^ self reportLastMatch].			(currentCharacter between: $0 and: $9) 				ifTrue: 					[					[self recordMatch: #(22 ).					self step.					currentCharacter between: $0 and: $9] 							whileTrue.					currentCharacter = $. 						ifTrue: 							[self step.							(currentCharacter between: $0 and: $9) 								ifTrue: 									[									[self recordMatch: #(22 ).									self step.									currentCharacter between: $0 and: $9] 											whileTrue.									currentCharacter = $e ifTrue: [^ self scan10].									currentCharacter = $s ifTrue: [^ self scan11].									^ self reportLastMatch].							^ self reportLastMatch].					currentCharacter = $e ifTrue: [^ self scan10].					currentCharacter = $r 						ifTrue: 							[self step.							((currentCharacter between: $0 and: $9) 								or: [currentCharacter between: $A and: $Z]) 									ifTrue: 										[										[self recordMatch: #(22 ).										self step.										(currentCharacter between: $0 and: $9) 											or: [currentCharacter between: $A and: $Z]] 												whileTrue.										currentCharacter = $. 											ifTrue: 												[self step.												((currentCharacter between: $0 and: $9) 													or: [currentCharacter between: $A and: $Z]) 														ifTrue: 															[															[self recordMatch: #(22 ).															self step.															(currentCharacter between: $0 and: $9) 																or: [currentCharacter between: $A and: $Z]] 																	whileTrue.															currentCharacter = $e ifTrue: [^ self scan10].															^ self reportLastMatch].												^ self reportLastMatch].										currentCharacter = $e ifTrue: [^ self scan10].										^ self reportLastMatch].							^ self reportLastMatch].					currentCharacter = $s ifTrue: [^ self scan11].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $. ifTrue: [^ self recordAndReportMatch: #(33 40 )].	currentCharacter = $: 		ifTrue: 			[self recordMatch: #(38 40 ).			self step.			((currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan7].			currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(28 )].			currentCharacter = $> ifTrue: [^ self recordAndReportMatch: #(5 )].			^ self reportLastMatch].	currentCharacter = $; ifTrue: [^ self recordAndReportMatch: #(39 40 )].	currentCharacter = $< 		ifTrue: 			[self recordMatch: #(6 27 40 ).			self step.			(currentCharacter = $!! or: 					[(currentCharacter between: $% and: $&) or: 							[(currentCharacter between: $* and: $-) or: 									[currentCharacter = $/ or: 											[(currentCharacter between: $< and: $@) or: 													[currentCharacter = $\ 														or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]) 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter = $!! or: 							[(currentCharacter between: $% and: $&) or: 									[(currentCharacter between: $* and: $-) or: 											[currentCharacter = $/ or: 													[(currentCharacter between: $< and: $@) or: 															[currentCharacter = $\ 																or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]] 							whileTrue.					^ self reportLastMatch].			currentCharacter = $: ifTrue: [^ self recordAndReportMatch: #(2 )].			^ self reportLastMatch].	currentCharacter = $> 		ifTrue: 			[self recordMatch: #(7 27 40 ).			self step.			(currentCharacter = $!! or: 					[(currentCharacter between: $% and: $&) or: 							[(currentCharacter between: $* and: $-) or: 									[currentCharacter = $/ or: 											[(currentCharacter between: $< and: $@) or: 													[currentCharacter = $\ 														or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]) 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter = $!! or: 							[(currentCharacter between: $% and: $&) or: 									[(currentCharacter between: $* and: $-) or: 											[currentCharacter = $/ or: 													[(currentCharacter between: $< and: $@) or: 															[currentCharacter = $\ 																or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $[ ifTrue: [^ self recordAndReportMatch: #(1 40 )].	currentCharacter = $] ifTrue: [^ self recordAndReportMatch: #(35 40 )].	currentCharacter = $^ ifTrue: [^ self recordAndReportMatch: #(8 40 )].	currentCharacter = $_ ifTrue: [^ self recordAndReportMatch: #(28 40 )].	currentCharacter = ${ ifTrue: [^ self recordAndReportMatch: #(11 40 )].	currentCharacter = $| 		ifTrue: 			[self recordMatch: #(4 27 40 ).			self step.			(currentCharacter = $!! or: 					[(currentCharacter between: $% and: $&) or: 							[(currentCharacter between: $* and: $-) or: 									[currentCharacter = $/ or: 											[(currentCharacter between: $< and: $@) or: 													[currentCharacter = $\ 														or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]) 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter = $!! or: 							[(currentCharacter between: $% and: $&) or: 									[(currentCharacter between: $* and: $-) or: 											[currentCharacter = $/ or: 													[(currentCharacter between: $< and: $@) or: 															[currentCharacter = $\ 																or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $} ifTrue: [^ self recordAndReportMatch: #(36 40 )].	^ self reportLastMatch! !!PESqueakScanner class methodsFor: 'generated-initialization' stamp: 'md 4/7/2007 11:33'!initializeKeywordMap	keywordMap := Dictionary new.	#(		#(25 'apicall:' 12 )		#(25 'cdecl:' 13 )		#(25 'module:' 15 )		#(25 'primitive:' 3 )		#(#binarySymbol '||' 10 )		#(24 'false' 18 )		#(24 'nil' 19 )		#(24 'true' 14 )	) do: 				[:each | 				(keywordMap at: each first ifAbsentPut: [Dictionary new]) at: (each at: 2)					put: each last].	^ keywordMap! !!PESqueakScanner class methodsFor: 'generated-comments' stamp: 'md 4/7/2007 11:33'!scannerDefinitionComment	"<decimalNumber>:	[0-9]+ (\. [0-9]+)? ;<radixNumber>:		[0-9]+ r [0-9A-Z]+ (\. [0-9A-Z]+)? ;<scaledNumber>:		<decimalNumber> s [0-9]+ ;<exponentNumber>:	(<decimalNumber> | <radixNumber>) e \-? [0-9]+ ;<number>:			<decimalNumber> | <radixNumber> | <exponentNumber> | <scaledNumber> ;<negativeNumber>:	\- <number> ;<string>:				\'  [^\']* \' (\' [^\']* \')* ;<name>:				[a-zA-Z] [a-zA-Z0-9]* ;<keyword>:			<name> \: ;<multikeyword>:		<name> \: (<name> \: )+ ;<binarySymbol>:		[\~\!!\@\%\&\*\-\+\=\\\|\?\/\>\<\,] [\~\!!\@\%\&\*\-\+\=\\\|\?\/\>\<\,]* ;<assignment>:		\: \= | \_ ;<alternateKeyword>:	\: <name> \: (<name> \:)* ;<whitespace>:		\s+ ;<comment>:			\"" [^\""]* \"" ;<character>:			\$ . ;<period>:				\. ;<variableAssignment>:	<name> \: \= ;<rightBoxBrackets>:	];<rightCurlyBrackets>:	};<rightParentheses>:	\);<colon>:				\:;<semicolon>:			\;;<anyChar>:			. ; # For VW literal arrays that handle #(;) -> #(#';');"! !!PETokenKiller methodsFor: 'as yet unclassified' stamp: 'md 7/6/2007 14:04'!acceptAssignmentNode: aVariableNode	self removePropertiesFromNode: aVariableNode.	super acceptAssignmentNode: aVariableNode.! !!PETokenKiller methodsFor: 'as yet unclassified' stamp: 'md 7/6/2007 14:04'!acceptLiteralNode: aVariableNode	self removePropertiesFromNode: aVariableNode.	aVariableNode token previous: nil.	aVariableNode token next: nil.	super acceptLiteralNode: aVariableNode.! !!PETokenKiller methodsFor: 'as yet unclassified' stamp: 'md 7/6/2007 14:03'!acceptMessageNode: aMethodNode	self removePropertiesFromNode: aMethodNode.	aMethodNode selectorParts do: [:token | 			token next: nil.			token previous: nil].	^super acceptMessageNode: aMethodNode! !!PETokenKiller methodsFor: 'as yet unclassified' stamp: 'md 7/6/2007 14:03'!acceptMethodNode: aMethodNode	self removePropertiesFromNode: aMethodNode.	aMethodNode selectorParts do: [:token | 			token next: nil.			token previous: nil].	^super acceptMethodNode: aMethodNode! !!PETokenKiller methodsFor: 'as yet unclassified' stamp: 'md 7/6/2007 14:04'!acceptReturnNode: aVariableNode	self removePropertiesFromNode: aVariableNode.	super acceptReturnNode: aVariableNode.! !!PETokenKiller methodsFor: 'as yet unclassified' stamp: 'md 7/6/2007 14:03'!acceptVariableNode: aVariableNode	self removePropertiesFromNode: aVariableNode.	aVariableNode token previous: nil.	aVariableNode token next: nil.	super acceptVariableNode: aVariableNode.! !!PETokenKiller methodsFor: 'as yet unclassified' stamp: 'md 7/6/2007 14:28'!removePropertiesFromNode: aNode	aNode removeProperty: #firstToken ifAbsent:[].	aNode removeProperty: #lastToken ifAbsent:[].	aNode removeProperty: #comments ifAbsent:[].	aNode removeProperty: #position ifAbsent:[].	aNode removeProperty: #return ifAbsent:[].	aNode removeProperty: #parenthesis ifAbsent:[].	aNode removeProperty: #leftBar ifAbsent:[].	aNode removeProperty: #rightBar ifAbsent:[].	aNode removeProperty: #periods ifAbsent:[].! !!PETokenKiller methodsFor: 'as yet unclassified' stamp: 'md 7/6/2007 14:03'!visitNode: aNode	self removePropertiesFromNode: aNode.		super visitNode: aNode.! !!PEWrapperCompilationStrategy methodsFor: 'private' stamp: 'md 10/21/2007 20:55'!compileTransformed: aMethodNode	| wrapped methodNode sequence executeSend |	wrapped := self compileDefault: aMethodNode.		sequence := RBSequenceNode		temporaries: #()		statements: OrderedCollection new.		aMethodNode before addToSequence: sequence.		executeSend := (RBMessageNode		receiver: 'self' asVariableNode		selector: #withArgs:executeMethod:		arguments: (Array			with: (RBArrayNode statements: aMethodNode arguments)			with: (PEObjectLiteralNode value: wrapped))).			 aMethodNode hasAfterCode ifTrue: [		executeSend := self			wrap: executeSend			withEnsure: (self afterWithReplacedMetaVariablesOf: aMethodNode) asSequenceNode ].		sequence addNode: (RBReturnNode value: executeSend).			methodNode := PEReflectiveMethodNode		selector:  aMethodNode selector 		arguments: aMethodNode  arguments		body: sequence.		methodNode parent:  aMethodNode parent.	aMethodNode hasAnnotations ifTrue: [methodNode annotations:   aMethodNode annotations].			methodNode methodClass: aMethodNode parent methodClass.	^self		compileNode: methodNode		trailer: aMethodNode parent defaultTrailer ! !!PEWrapperCompilationStrategy methodsFor: 'private' stamp: 'md 3/28/2007 15:53'!replacementNodeFor: aNode of: anAnnotedNode	^PENodeReplacer replacementNodeFor: aNode of: anAnnotedNode! !!PackageEnvironment methodsFor: 'accessing' stamp: 'lr 1/3/2006 12:05'!asSelectorEnvironment	| result |	result := SelectorEnvironment onEnvironment: self.	self classesAndSelectorsDo: [ :class :selector | 		result addClass: class selector: selector ].	^ result.! !!PackageEnvironment methodsFor: 'accessing' stamp: 'lr 1/3/2006 12:05'!classesAndSelectorsDo: aBlock	self package coreMethods do: [ :method |		(self includesSelector: method methodSymbol in: method actualClass)			ifTrue: [ aBlock value: method actualClass value: method methodSymbol ] ].	self package extensionMethods do: [ :method |		(self includesSelector: method methodSymbol in: method actualClass)			ifTrue: [ aBlock value: method actualClass value: method methodSymbol ] ].! !!PackageEnvironment methodsFor: 'accessing' stamp: 'lr 1/3/2006 12:05'!classesDo: aBlock	self package classesAndMetaClasses do: [ :each |		(self includesClass: each)			ifTrue: [ aBlock value: each ] ].	self package extensionClasses do: [ :each |		(self environment includesClass: each)			ifTrue: [ aBlock value: each ].		(self environment includesClass: each class)			ifTrue: [ aBlock value: each class ] ].! !!PackageEnvironment methodsFor: 'accessing' stamp: 'lr 1/3/2006 12:05'!package	^ package! !!PackageEnvironment methodsFor: 'testing' stamp: 'lr 1/3/2006 12:06'!includesCategory: aCategory	^ (super includesCategory: aCategory) 		and: [ self package includesSystemCategory: aCategory ].! !!PackageEnvironment methodsFor: 'testing' stamp: 'lr 1/3/2006 12:06'!includesClass: aClass	^ (super includesClass: aClass) 		and: [ self package includesClass: aClass ].! !!PackageEnvironment methodsFor: 'testing' stamp: 'lr 1/3/2006 12:12'!includesProtocol: aProtocol in: aClass	^ (self environment includesProtocol: aProtocol in: aClass) 		and: [ self package includesMethodCategory: aProtocol ofClass: aClass ].! !!PackageEnvironment methodsFor: 'testing' stamp: 'lr 1/3/2006 12:12'!includesSelector: aSelector in: aClass	^ (self environment includesSelector: aSelector in: aClass) 		and: [ self package includesMethod: aSelector ofClass: aClass ].! !!PackageEnvironment methodsFor: 'private' stamp: 'lr 1/3/2006 12:12'!package: aPackageInfo	package := aPackageInfo! !!PackageEnvironment methodsFor: 'printing' stamp: 'lr 1/3/2006 12:06'!storeOn: aStream 	aStream nextPut: $(; nextPutAll: self class name; nextPutAll: ' onEnvironment: '.	environment storeOn: aStream.	aStream nextPutAll: ' packageNamed: '; print: self package packageName; nextPut: $).! !!PackageEnvironment class methodsFor: 'instance creation' stamp: 'lr 1/3/2006 12:14'!onEnvironment: anEnvironment package: aPackageInfo	^ (self onEnvironment: anEnvironment)		package: aPackageInfo;		yourself.! !!PackageEnvironment class methodsFor: 'instance creation' stamp: 'lr 1/3/2006 12:14'!onEnvironment: anEnvironment packageNamed: aString	^ self onEnvironment: anEnvironment package: (PackageInfo named: aString).! !!ParseTreeEnvironment methodsFor: 'initialize-release'!matcher: aParseTreeSearcher	matcher := aParseTreeSearcher! !!ParseTreeEnvironment methodsFor: 'accessing' stamp: 'bh 5/9/2000 00:19'!selectionIntervalFor: aString 	| parseTree node |	matcher isNil ifTrue: [^super selectionIntervalFor: aString].	parseTree := RBParser parseMethod: aString				onError: [:error :position | ^super selectionIntervalFor: aString].	node := matcher executeTree: parseTree initialAnswer: nil.	^node isNil 		ifTrue: [super selectionIntervalFor: aString]		ifFalse: [node sourceInterval]! !!ParseTreeLintRule methodsFor: 'accessing'!checkMethod: aSmalllintContext 	(matcher canMatchMethod: aSmalllintContext compiledMethod) 		ifFalse: [^self].	(matcher executeTree: aSmalllintContext parseTree initialAnswer: nil) 		notNil 			ifTrue: 				[result addClass: aSmalllintContext selectedClass					selector: aSmalllintContext selector]! !!ParseTreeLintRule methodsFor: 'private'!defaultResultClass	^ParseTreeEnvironment! !!ParseTreeLintRule methodsFor: 'initialize-release'!matcher: aParseTreeMatcher	matcher := aParseTreeMatcher! !!ParseTreeLintRule methodsFor: 'initialize-release'!resetResult	result := ParseTreeEnvironment new.	result		label: self name;		matcher: matcher! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!asOrderedCollectionNotNeeded	^self 		createParseTreeRule: #('`@node addAll: `{:node | node isMessage and: [#(asOrderedCollection asArray) includes: node selector]}')		name: '#asOrderedCollection/#asArray not needed'! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!assignmentInBlock	^self createParseTreeRule: #(			'`@cursor showWhile: [| `@temps | `@.Statements1. `var := `@object]' 			'`@cursor showWhile: [| `@temps | `@.Statements1. ^`@object]' 			'[| `@temps | `@.Statements. `var := `@object] valueNowOrOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. ^`@object] valueNowOrOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. `var := `@object] valueOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. ^`@object] valueOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. `var := `@object] ensure: `@block' 			'[| `@temps | `@.Statements. ^`@object] ensure: `@block' 			'[| `@temps | `@.Statements. `var := `@object] ifCurtailed: `@block' 			'[| `@temps | `@.Statements. ^`@object] ifCurtailed: `@block' ) 		name: 'Unnecessary assignment or return in block'! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!ifTrueBlocks	^self 		createParseTreeRule: #(				'`@condition ifTrue: `{:node | node isBlock not} ifFalse: `@block' 				'`@condition ifTrue: `@block ifFalse: `{:node | node isBlock not}' 				'`@condition ifFalse: `{:node | node isBlock not} ifTrue: `@block' 				'`@condition ifFalse: `@block ifTrue: `{:node | node isBlock not}' 				'`@condition ifTrue: `{:node | node isBlock not}' 				'`@condition ifFalse: `{:node | node isBlock not}')		name: 'Non-blocks in ifTrue:/ifFalse: messages'! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!precedence	^self 		createParseTreeRule: #('`{:node | node isMessage and: [node hasParentheses not and: [#(#+ #-) includes: node selector]]} * `@C')		name: 'Inspect instances of "A + B * C" might be "A + (B * C)"'! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!stringConcatenation	| detector matcher concatenationMatcher |	detector := self new.	detector name: 'String concatenation instead of streams'.	matcher := ParseTreeSearcher new.	concatenationMatcher := ParseTreeSearcher new.	concatenationMatcher matches: '`@receiver , `@argument'		do: [:aNode :answer | true].	matcher 		matchesAnyOf: 			#('``@collection do: [:`each | | `@temps | ``@.Statements]' 			'``@collection do: [:`each | | `@temps | ``@.Statements] separatedBy: [| `@temps1 | ``@.Statements1]' 			'``@number to: ``@endNumber do: [:`i | | `@temps | ``@.Statements]' 			'``@collection detect: [:`each | | `@temps | ``@.Statements]' 			'``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [| `@temps1 | ``@.Statements1]' 			'``@collection select: [:`each | | `@temps | ``@.Statements]' 			'``@collection inject: ``@value into: [:`each | | `@temps | ``@.Statements]')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[(aNode arguments detect: 							[:each | 							each isBlock 								and: [concatenationMatcher executeTree: each initialAnswer: false]]						ifNone: [nil]) notNil 						ifTrue: [aNode]						ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!unoptimizedAndOr	^self 		createParseTreeRule: #('(`@a and: `@b) and: `@c' '(`@a or: `@b) or: `@c')		name: 'Uses "(a and: [b]) and: [c]" instead of "a and: [b and: [c]]"'! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!unoptimizedToDo	^self createParseTreeRule: #('(`@a to: `@b) do: `@c')		name: 'Uses (to:)do: instead of to:do:'! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!yourselfNotUsed	^self createParseTreeRule: #('`{:node | node parent isUsed not} yourself')		name: 'Doesn''t use the result of a yourself message'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!assignmentInIfTrue	^self createParseTreeRule: 			#('`@boolean 					ifTrue: [| `@temps1 | `@.Statements1. `var := `@object1] 					ifFalse: [| `@temps2 | `@.Statements2. `var := `@object2]' 			'`@boolean 					ifFalse: [| `@temps1 | `@.Statements1. `var := `@object1] 					ifTrue: [| `@temps2 | `@.Statements2. `var := `@object2]') 		name: 'Assignment to same variable and end of ifTrue:ifFalse: blocks'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!atIfAbsent	^self createParseTreeRule: 				#('`@object 						at: `@atArg 						ifAbsent: [| `@temps | `@.Statements. `@object at: `@atArg put: `@putArg]' 				'`@object 						at: `@atArg 						ifAbsent: [| `@temps | 								`@.Statements. 								`@object at: `@atArg put: `@putArg. 								`@.xStatements1. 								`@putArg]') 		name: 'Uses at:ifAbsent: instead of at:ifAbsentPut:'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!collectSelectNotUsed	^self 		createParseTreeRule: #('`{:node | node isMessage and: [(#(#select: #collect: #reject:) includes: node selector) and: [node isUsed not]]}')		name: 'Doesn''t use the result of a collect:/select:'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!collectionMessagesToExternalObject	| detector matcher |	detector := self new.	detector name: 'Sends add:/remove: to external collection'.	matcher := ParseTreeSearcher new.	matcher 		matchesAnyOf: (#(#add: #remove: #addAll: #removeAll:) collect: 					[:each | 					('(`@Object `@message: `@args) <1s> `@Arg' expandMacrosWith: each) 						asString])		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[((aNode receiver selector copyFrom: 1						to: (aNode receiver selector size min: 2)) ~= 'as' 						and: 							[| receiver |							receiver := aNode receiver receiver.							receiver isVariable not or: 									[((#('self' 'super') includes: receiver name) 										or: [Smalltalk includesKey: receiver name asSymbol]) not]]) 							ifTrue: [aNode]							ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'intention revealing'!collectionProtocol	^self createParseTreeRule: 			#('`@collection do: [:`each | | `@temps | `@.Statements1. `@object add: `@arg. `@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@blockTemps | 							`@.BlockStatements1. 							`@object add: `each. 							`@.BlockStatements2]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@blockTemps | 							`@.BlockStatements1. 							`@object add: `each. 							`@.BlockStatements2]. 					`@.Statements2]') 		name: 'Uses do: instead of collect: or select:''s'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!consistencyCheck	^self createParseTreeRule: 				#('`@object size == 0' 				'`@object size = 0' 				'`@object size > 0' 				'`@object size >= 1' 				'`@object == nil' 				'`@object = nil'				'`@collection at: 1'				'`@collection at: `@collection size') 		name: 'Uses "size = 0", "= nil",  or "at: 1" instead of "isEmpty",  "isNil", or "first"'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!contains	^self createParseTreeRule: 			#('(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) isNil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) notNil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) = nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) == nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) ~= nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) ~~ nil' 			'`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [| `@temps1 | `@.Statements2. ^`@anything]') 		name: 'Uses detect:ifNone: instead of contains:'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!detectContains	^self createParseTreeRule: 			#('`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^`each]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^`each]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^true]. 					`@.Statements2]' 			'`@Collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^true]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^false]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^false]. 					`@.Statements2]') 		name: 'Uses do: instead of contains: or detect:''s'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!guardingClause	| detector matcher |	detector := self new.	detector name: 'Guarding clauses'.	matcher := ParseTreeSearcher new.	matcher 		matchesAnyMethodOf: 				#('`@MethodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifTrue: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]' 			'`@MethodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifFalse: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[aNode body statements last]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'intention revealing' stamp: 'bh 4/2/2000 22:14'!ifTrueReturns	| detector matcher |	detector := self new.	detector name: 'ifTrue:/ifFalse: returns instead of and:/or:''s'.	matcher := ParseTreeSearcher new.	matcher 		matchesAnyOf: 			#('| `@temps | ``@.Statements. ``@object ifTrue: [^``@value1]. ^``@value2' 			'| `@temps | ``@.Statements. ``@object ifFalse: [^``@value1]. ^``@value2')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[| node |					node := (aNode statements at: aNode statements size - 1) arguments first 								body statements 								last value.	"``@value1"					((node isLiteral and: [{true. false} includes: node value]) or: 							[node := aNode statements last value.							node isLiteral and: [{true. false} includes: node value]]) 						ifTrue: [aNode]						ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'intention revealing'!literalArrayCharacters	| detector matcher |	detector := self new.	detector name: 'Literal array contains only characters'.	matcher := ParseTreeSearcher new.	matcher matches: '`#literal'		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[(aNode value class == Array and: [self isArrayOfCharacters: aNode value]) 						ifTrue: [aNode]						ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'intention revealing'!minMax	| detector matcher |	detector := self new.	detector name: 'Uses ifTrue:/ifFalse: instead of min: or max:'.	matcher := ParseTreeSearcher new.	matcher 		matchesAnyOf: #('(`x `message: `@y) `ifTrue: [`x := `@y]' '(`@x `message: `@y) `ifTrue: [`@x] `ifFalse: [`@y]' '(`@x `message: `@y) `ifTrue: [`v := `@x] `ifFalse: [`v := `@y]')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[((#(#ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue:) 						includes: aNode selector) 							and: [#(#< #<= #> #>=) includes: aNode receiver selector]) 							ifTrue: [aNode]							ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'intention revealing'!searchingLiteral	| detector matcher |	detector := self new.	detector name: 'Uses or''s instead of a searching literal'.	matcher := ParseTreeSearcher new.	matcher 		matchesAnyOf: #('``@object = `#literal or: [``@expression]' 						'``@object == `#literal or: [``@expression]' 						'`#literal = ``@object or: [``@expression]' 						'`#literal == ``@object or: [``@expression]' 						'``@expression | (``@object = `#literal)' 						'``@expression | (``@object == `#literal)' 						'``@expression | (`#literal = ``@object)' 						'``@expression | (`#literal == ``@object)')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[(self isSearchingLiteralExpression: aNode) ifTrue: [aNode] ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'intention revealing'!sizeCheck	^self createParseTreeRule: (#(#do: #collect: #reject: #select:) collect: 					[:each | 					'`@object size > 0 ifTrue: [`@object ' , each						, ' [:`each | | `@temps | `@.Statements1]. `@.Statements2]'])				, (#(#do: #collect: #reject: #select:) collect: 							[:each | 							'`@object isEmpty ifFalse: [`@object ' , each								, ' [:`each | | `@temps | `@.Statements1]. `@.Statements2]'])		name: 'Unnecessary size check'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!toDo	| detector matcher |	detector := self new.	detector name: 'Uses to:do: instead of do:, with:do: or timesRepeat:'.	matcher := ParseTreeSearcher new.	matcher 		matches: '1 to: ``@object size do: [:`each | | `@temps | `@.Statements]'		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[| varName variableMatcher |					varName := aNode arguments last arguments first.	"`each"					variableMatcher := ParseTreeSearcher new.					variableMatcher matchesTree: varName						do: [:node :ans | ans and: [node parent isMessage and: [node parent selector == #at:]]].					(variableMatcher executeTree: aNode arguments last body initialAnswer: true) 						ifTrue: [aNode]						ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'intention revealing'!toDoCollect	^self 		createParseTreeRule: #(			'| `@temps1 |			`@.Stmts1.			`collection := Array new: `@size.			`@.Stmts2.			1 to: `@size do: 					[:`i | 					| `@Btemps2 | 					`@.BStmts1. 					`collection at: `i put: `@obj.					`@.BStmt2].			`@.Stmts3'					"-------------"			 '| `@temps1 |			`@.Stmts1.			`collection := Array new: `@size.			`@.Stmts2.			1 to: `collection size do: 					[:`i | 					| `@Btemps2 | 					`@.BStmts1. 					`collection at: `i put: `@obj.					`@.BStmt2].			`@.Stmts3')		name: 'to:do: doesn''t use collect:'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!toDoWithIncrement	^self 		createParseTreeRule: #(				'`@i to: `@j do: [:`e | | `@temps | `@.Stmts. `x := `x + 1. `@.Stmts2]' 				'`@i to: `@j by: `@k do: [:`e | | `@temps | `@.Stmts. `x := `x + `@k. `@.Stmts2]')		name: 'to:do: loop also increments a counter'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!whileTrue	^self createParseTreeRule: 			#('| `@temps | 				`@.Statements1. 				[`index <= `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index + 1].				`@.Statements2' 			'| `@temps | 				`@.Statements1. 				[`index < `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index + 1].				`@.Statements2'			'| `@temps | 				`@.Statements1. 				[`index >= `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index - 1].				`@.Statements2' 			'| `@temps | 				`@.Statements1. 				[`index > `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index - 1].				`@.Statements2') 		name: 'Uses whileTrue: instead of to:do:'! !!ParseTreeLintRule class methodsFor: 'bugs'!booleanPrecedence	^self createParseTreeRule: 			#('`@object1 | `@object2 = `@object3'			'`@object1 | `@object2 == `@object3'			'`@object1 & `@object2 = `@object3'			'`@object1 & `@object2 == `@object3'			'`@object1 | `@object2 ~= `@object3'			'`@object1 | `@object2 ~~ `@object3'			'`@object1 & `@object2 ~= `@object3'			'`@object1 & `@object2 ~~ `@object3')		name: 'Uses A | B = C instead of A | (B = C)'! !!ParseTreeLintRule class methodsFor: 'bugs' stamp: 'nk 2/24/2005 15:04'!sendsUnknownMessageToGlobal	| detector matcher |	detector := self new.	detector name: 'Sends unknown message to global'.	matcher := ParseTreeSearcher new.	matcher 		matches: '`{:node :context | node isVariable and: [ Smalltalk includesKey: node name asSymbol ] } `@message: `@args'		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[| what |					what := Smalltalk at: aNode receiver name asSymbol.					(what notNil 						and: [what ~~ Preferences and: [(what respondsTo: aNode selector) not]]) 							ifTrue: [aNode]							ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'squeak bugs' stamp: 'nk 3/4/2005 17:20'!codeCruftLeftInMethods	^(self createParseTreeRule: {				'`@whatever doOnlyOnce: `@stuff'.				'Transcript `@msg: `@args'.				'`@any halt'.				'true ifTrue: `@stuff'.				'`@any flag: `#lit'.				'`@any needsWork'.			}		name: 'Debugging code left in methods')		rationale: 'Halts, Transcript writes, doOnlyOnce:, etc. should not be left in production code.';		yourself! !!ParseTreeLintRule class methodsFor: 'squeak bugs' stamp: 'nk 3/4/2005 17:46'!missingTranslationsInMenus	^(self createParseTreeRule: {				'`@menu add: `#label action: `#sym'.				'`@menu add: `#label selector: `#sym arguments: `@stuff'.				'`@menu add: `#label subMenu: `@stuff'.				'`@menu add: `#label subMenu: `@stuff target: `@targ selector: `#sel argumentList: `@args'.				'`@menu add: `#label target: `@targ action: `#sel'.				'`@menu add: `#label target: `@targ selector `#sel'.				'`@menu add: `#label target: `@targ selector `#sel argument: `@arg'.				'`@menu add: `#label target: `@targ selector `#sel arguments: `@arg'.				'`@menu addList: `{ :n | n isLiteral and: [ n token realValue anySatisfy: [ :row | (row isKindOf: Array) and: [ row first isLiteral ]]] }'.				'`@menu addTitle: `#label'.				'`@menu addTitle: `#label updatingSelector: `#sel updateTarget: `@targ'.				'`@menu addWithLabel: `#label enablement: `#esel action: `#sel'.				'`@menu addWithLabel: `#label enablementSelector: `#esel target: `@targ selector: `#sel argumentList: `@args'.				'`@menu balloonTextForLastItem: `#label'.				'`@menu labels: `#lit lines: `@lines selections: `@sels'.				'`@menu title: `#title'			}		name: 'Menus missing translations')		rationale: 'Literal strings shown to users in menus should be translated.';		yourself! !!ParseTreeLintRule class methodsFor: 'squeak bugs' stamp: 'nk 7/30/2004 19:09'!sendsDeprecatedMethodToGlobal	| nav patterns pattern wellKnownGlobals |	nav := SystemNavigation default.	patterns := OrderedCollection new.	wellKnownGlobals := IdentityDictionary new.	Smalltalk		keysAndValuesDo: [:k :v | v isBehavior				ifFalse: [(wellKnownGlobals						at: v class						ifAbsentPut: [Set new])						add: k]].	#(#deprecated: 'deprecated:explanation:' 'deprecated:block:' )		do: [:sym | (nav allCallsOn: sym)				do: [:mr | mr classIsMeta						ifTrue: [mr actualClass								withAllSubclassesDo: [:cls | patterns										add: (String												streamContents: [:s | s nextPutAll: cls theNonMetaClass name;																												nextPutAll: (self genericPatternForSelector: mr methodSymbol)])]]						ifFalse: [wellKnownGlobals								keysAndValuesDo: [:gcls :gnames | (gcls includesBehavior: mr actualClass)										ifTrue: [gnames												do: [:gname | pattern := String																streamContents: [:s | 																	s nextPutAll: gname.																	s																		nextPutAll: (self genericPatternForSelector: mr methodSymbol)]].											patterns add: pattern]]]]].	patterns add: 'self beep: `@object1';		 add: 'self beep'.	^ self createParseTreeRule: patterns name: 'Sends a deprecated message to a known global'! !!ParseTreeLintRule class methodsFor: 'private'!createMatcherFor: codeStrings method: aBoolean 	| matcher |	matcher := ParseTreeSearcher new.	aBoolean 		ifTrue: [matcher matchesAnyMethodOf: codeStrings do: [:aNode :answer | aNode]]		ifFalse: [matcher matchesAnyOf: codeStrings do: [:aNode :answer | aNode]].	^matcher! !!ParseTreeLintRule class methodsFor: 'private' stamp: 'nk 7/30/2004 09:55'!genericPatternForSelector: sel	"	ParseTreeLintRule genericPatternForSelector: #a	ParseTreeLintRule genericPatternForSelector: #a:b:c:	"	^String streamContents: [ :s |		sel keywords withIndexDo: [ :k :i | s space; nextPutAll: k.			(k last = $:) ifTrue: [ s space; nextPutAll: '`@object'; print: i  ]]]! !!ParseTreeLintRule class methodsFor: 'private'!isArrayOfCharacters: anArray 	anArray isEmpty ifTrue: [^false].	1 to: anArray size		do: [:each | (anArray at: each) class == Character ifFalse: [^false]].	^true! !!ParseTreeLintRule class methodsFor: 'private'!isSearchingLiteralExpression: aMessageNode 	| equalNode expressionNode |	equalNode := aMessageNode selector = #| 				ifTrue: [aMessageNode arguments first]				ifFalse: [aMessageNode receiver].	expressionNode := equalNode receiver isLiteral 				ifTrue: [equalNode arguments first]				ifFalse: [equalNode receiver].	^self isSearchingLiteralExpression: aMessageNode for: expressionNode! !!ParseTreeLintRule class methodsFor: 'private'!isSearchingLiteralExpression: aSearchingNode for: anObjectNode 	| argument arguments |	aSearchingNode isMessage ifFalse: [^false].	arguments := aSearchingNode arguments.	arguments size = 1 ifFalse: [^false].	argument := arguments first.	(#(#= #==) includes: aSearchingNode selector) 		ifTrue: 			[^(aSearchingNode receiver = anObjectNode 				and: [aSearchingNode arguments first isLiteral]) or: 						[aSearchingNode arguments first = anObjectNode 							and: [aSearchingNode receiver isLiteral]]].	aSearchingNode selector = #| 		ifTrue: 			[^(self isSearchingLiteralExpression: aSearchingNode receiver				for: anObjectNode) 					and: [self isSearchingLiteralExpression: argument for: anObjectNode]].	aSearchingNode selector = #or: ifFalse: [^false].	argument isBlock ifFalse: [^false].	argument body statements size = 1 ifFalse: [^false].	^(self isSearchingLiteralExpression: aSearchingNode receiver		for: anObjectNode) and: 				[self isSearchingLiteralExpression: argument body statements first					for: anObjectNode]! !!ParseTreeLintRule class methodsFor: 'private'!modifiesTree: aCollectionTree in: aParseTree 	| notifier args |	notifier := ParseTreeSearcher new.	args := Array with: (RBVariableNode named: '`@object').	notifier 		matchesAnyTreeOf: (#(#add: #addAll: #remove: #removeAll:) collect: 					[:each | 					RBMessageNode 						receiver: aCollectionTree						selector: each						arguments: args])		do: [:aNode :answer | true].	^notifier executeTree: aParseTree initialAnswer: false! !!ParseTreeLintRule class methodsFor: 'instance creation'!createParseTreeRule: codeStrings method: aBoolean name: aName 	^(self new)		name: aName;		matcher: (self createMatcherFor: codeStrings method: aBoolean);		yourself! !!ParseTreeLintRule class methodsFor: 'instance creation'!createParseTreeRule: codeStrings name: aName 	^self 		createParseTreeRule: codeStrings		method: false		name: aName! !!ParseTreeLintRule class methodsFor: 'unnecessary code'!endTrueFalse	| detector matcher |	detector := self new.	detector 		name: 'Check for same statements at end of ifTrue:ifFalse: blocks'.	matcher := (ParseTreeSearcher new)				matchesAnyOf: 						#('`@object 								ifTrue: [| `@temps1 | `@.Statements1. `.Statement] 								ifFalse: [| `@temps2 | `@.Statements2. `.Statement]' 						'`@object 								ifTrue: [| `@temps1 | `.Statement. `@.Statements1] 								ifFalse: [| `@temps2 | `.Statement. `@.Statements2]' 						'`@object 								ifFalse: [| `@temps1 | `@.Statements1. `.Statement] 								ifTrue: [| `@temps2 | `@.Statements2. `.Statement]' 						'`@object 								ifFalse: [| `@temps1 | `.Statement. `@.Statements1] 								ifTrue: [| `@temps2 | `.Statement. `@.Statement2]') 					do: 						[:aNode :answer | 						answer isNil 							ifTrue: 								[| node |								node := aNode arguments first body statements last.								(node isVariable and: [node = aNode arguments last body statements last]) 									ifTrue: [nil]									ifFalse: [aNode]]							ifFalse: [answer]];				yourself.	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'unnecessary code'!equalsTrue	| detector matcher |	detector := self new.	detector name: 'Unnecessary "= true"'.	matcher := (ParseTreeSearcher new)				matchesAnyOf: #('true' 'false')					do: 						[:aNode :answer | 						answer isNil 							ifTrue: 								[(aNode parent isMessage 									and: [#(#= #== #~= #~~) includes: aNode parent selector]) 										ifTrue: [aNode]										ifFalse: [nil]]							ifFalse: [answer]];				yourself.	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'unnecessary code'!extraBlock	^self 		createParseTreeRule: #('`{:node | node isMessage and: [node receiver isBlock and: [node parent isCascade not and: [#(#value #value: #value:value: #value:value:value: #valueWithArguments) includes: node selector]]]}')		name: 'Block immediately evaluated'! !!ParseTreeLintRule class methodsFor: 'unnecessary code'!unnecessaryAssignment	^self 		createParseTreeRule: #('^`{:aNode | aNode isAssignment and: [(aNode whoDefines: aNode variable name) notNil]}')		name: 'Unnecessary assignment to a temporary variable'! !!ParseTreeLintRule class methodsFor: 'possible bugs'!equalNotUsed	^self 		createParseTreeRule: #('`{:node | node isMessage and: [node isUsed not and: [#(#= #== #~= #~~ #< #> #<= #>=) includes: node selector]]}')		name: 'Doesn''t use the result of a =, ~=, etc.'! !!ParseTreeLintRule class methodsFor: 'possible bugs'!fileBlocks	^self createParseTreeRule: 				#('[| `@temps | 					`var := `@object.  					`@.statements] 							valueNowOrOnUnwindDo: 								[`var `@messages: `@args]' 				'[| `@temps | 					`var := `@object.  					`@.statements] 							valueOnUnwindDo: 								[`var `@messages: `@args]'				'[| `@temps | 					`var := `@object.  					`@.statements] 							ensure: 								[`var `@messages: `@args]' 				'[| `@temps | 					`var := `@object.  					`@.statements] 							ifCurtailed: 								[`var `@messages: `@args]') 		name: 'Assignment inside unwind blocks should be outside.'! !!ParseTreeLintRule class methodsFor: 'possible bugs' stamp: 'bh 4/2/2000 22:17'!missingYourself	^self 		createParseTreeRule: #('`{:node | node isMessage and: [node parent isCascade and: [node isDirectlyUsed and: [node selector ~~ #yourself]]]}')		name: 'Possible missing "; yourself"'! !!ParseTreeLintRule class methodsFor: 'possible bugs'!modifiesCollection	| detector matcher |	detector := self new.	detector name: 'Modifies collection while iterating over it'.	matcher := (ParseTreeSearcher new)				matchesAnyOf: 						#('`@object do: [:`each | | `@temps | ``@.Statements]' 						'`@object collect: [:`each | | `@temps | ``@.Statements]' 						'`@object select: [:`each | | `@temps | ``@.Statements]' 						'`@object reject: [:`each | | `@temps | ``@.Statements]' 						'`@object inject: `@value into: [:`sum :`each | | `@temps | ``@.Statements]')					do: 						[:aNode :answer | 						answer isNil 							ifTrue: 								[(self modifiesTree: aNode receiver in: aNode arguments last) 									ifTrue: [aNode]									ifFalse: [nil]]							ifFalse: [answer]];				yourself.	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'possible bugs'!returnInEnsure	| detector matcher returnMatcher |	detector := self new.	detector name: 'Contains a return in an ensure: block'.	returnMatcher := ParseTreeSearcher new.	returnMatcher matches: '^`@object' do: [:aNode :answer | true].	matcher := ParseTreeSearcher new.	matcher 		matchesAnyOf: #('``@rcv ensure: [| `@temps | ``@.Stmts]' 						'``@rcv valueNowOrOnUnwindDo: [| `@temps | ``@.Stmts]' 						'``@rcv ifCurtailed: [| `@temps | ``@.Stmts]' 						'``@rcv valueOnUnwindDo: [| `@temps | ``@.Stmts]')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[(returnMatcher executeTree: aNode arguments first initialAnswer: false) 						ifTrue: [aNode]						ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'possible bugs'!returnsIfTrue	^self createParseTreeRule: 				#('^`@condition ifTrue: [| `@temps | `@.statements]' 				'^`@condition ifFalse: [| `@temps | `@.statements]') 		name: 'Returns value of ifTrue:/ifFalse: without ifFalse:/ifTrue: block'! !!ParseTreeLintRule class methodsFor: 'possible bugs'!threeElementPoint	| detector matcher |	detector := self new.	detector name: 'Possible three element point (e.g., x @ y + q @ r)'.	matcher := (ParseTreeSearcher new)				matches: '``@x @ ``@y'					do: 						[:aNode :answer | 						answer isNil 							ifTrue: 								[| current |								current := aNode parent.																[current isNil or: 										[current isMessage 											and: [current selector == #@ or: [current selector isInfix not]]]] 										whileFalse: [current := current parent].								(current isNil or: [current isMessage and: [current selector isInfix not]]) 									ifTrue: [nil]									ifFalse: [aNode]]							ifFalse: [answer]];				yourself.	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'possible bugs'!usesAdd	^self 		createParseTreeRule: #('`{:node | node isMessage and: [(node selector == #add: or: [node selector == #addAll:]) and: [node isDirectlyUsed]]}')		name: 'Uses the result of an add: message'! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching'!acceptAssignmentNode: anAssignmentNode 	anAssignmentNode variable: (self visitNode: anAssignmentNode variable).	anAssignmentNode value: (self visitNode: anAssignmentNode value)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'nk 1/29/2005 11:10'!acceptBlockNode: aBlockNode 	aBlockNode arguments: (self visitBlockArguments: aBlockNode arguments).	aBlockNode body: (self visitNode: aBlockNode body)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching'!acceptCascadeNode: aCascadeNode 	| newMessages notFound |	newMessages := OrderedCollection new: aCascadeNode messages size.	notFound := OrderedCollection new: aCascadeNode messages size.	aCascadeNode messages do: 			[:each | 			| newNode |			newNode := self performSearches: searches on: each.			newNode isNil 				ifTrue: 					[newNode := each.					notFound add: newNode].			newNode isMessage 				ifTrue: [newMessages add: newNode]				ifFalse: 					[newNode isCascade 						ifTrue: [newMessages addAll: newNode messages]						ifFalse: 							[Transcript								show: 'Cannot replace message node inside of cascaded node with non-message node.';								cr.							newMessages add: each]]].	notFound size == aCascadeNode messages size 		ifTrue: 			[| receiver |			receiver := self visitNode: aCascadeNode messages first receiver.			newMessages do: [:each | each receiver: receiver]].	notFound 		do: [:each | each arguments: (each arguments collect: [:arg | self visitNode: arg])].	aCascadeNode messages: newMessages! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching'!acceptMessageNode: aMessageNode 	aMessageNode receiver: (self visitNode: aMessageNode receiver).	aMessageNode 		arguments: (aMessageNode arguments collect: [:each | self visitNode: each])! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'nk 1/29/2005 11:10'!acceptMethodNode: aMethodNode 	aMethodNode arguments: (self visitMethodArguments: aMethodNode arguments).	aMethodNode body: (self visitNode: aMethodNode body)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching'!acceptReturnNode: aReturnNode 	aReturnNode value: (self visitNode: aReturnNode value)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'nk 1/29/2005 11:10'!acceptSequenceNode: aSequenceNode 	aSequenceNode temporaries: (self visitTemporaryVariables: aSequenceNode temporaries).	aSequenceNode statements: (aSequenceNode statements collect: [:each | self visitNode: each])! !!ParseTreeRewriter methodsFor: 'accessing'!executeTree: aParseTree 	| oldContext |	oldContext := context.	context := RBSmallDictionary new.	answer := false.	tree := self visitNode: aParseTree.	context := oldContext.	^answer! !!ParseTreeRewriter methodsFor: 'accessing'!tree	^tree! !!ParseTreeRewriter methodsFor: 'private'!foundMatch	answer := true! !!ParseTreeRewriter methodsFor: 'private'!lookForMoreMatchesInContext: oldContext 	oldContext keysAndValuesDo: 			[:key :value | 			(key isString not and: [key recurseInto]) 				ifTrue: 					[oldContext at: key put: (value collect: [:each | self visitNode: each])]]! !!ParseTreeRewriter methodsFor: 'replacing'!replace: searchString with: replaceString 	self addRule: (RBStringReplaceRule searchFor: searchString				replaceWith: replaceString)! !!ParseTreeRewriter methodsFor: 'replacing'!replace: searchString with: replaceString when: aBlock 	self addRule: (RBStringReplaceRule 				searchFor: searchString				replaceWith: replaceString				when: aBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replace: searchString withValueFrom: replaceBlock 	self addRule: (RBBlockReplaceRule searchFor: searchString				replaceWith: replaceBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replace: searchString withValueFrom: replaceBlock when: conditionBlock 	self addRule: (RBBlockReplaceRule 				searchFor: searchString				replaceWith: replaceBlock				when: conditionBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString with: replaceString 	self addArgumentRule: (RBStringReplaceRule searchFor: searchString				replaceWith: replaceString)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString with: replaceString when: aBlock 	self addArgumentRule: (RBStringReplaceRule 				searchFor: searchString				replaceWith: replaceString				when: aBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString withValueFrom: replaceBlock 	self addArgumentRule: (RBBlockReplaceRule searchFor: searchString				replaceWith: replaceBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString withValueFrom: replaceBlock when: conditionBlock 	self addArgumentRule: (RBBlockReplaceRule 				searchFor: searchString				replaceWith: replaceBlock				when: conditionBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString with: replaceString 	self addRule: (RBStringReplaceRule searchForMethod: searchString				replaceWith: replaceString)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString with: replaceString when: aBlock 	self addRule: (RBStringReplaceRule 				searchForMethod: searchString				replaceWith: replaceString				when: aBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString withValueFrom: replaceBlock 	self addRule: (RBBlockReplaceRule searchForMethod: searchString				replaceWith: replaceBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString withValueFrom: replaceBlock when: conditionBlock 	self addRule: (RBBlockReplaceRule 				searchForMethod: searchString				replaceWith: replaceBlock				when: conditionBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceTree: searchTree withTree: replaceTree 	self addRule: (RBStringReplaceRule searchForTree: searchTree				replaceWith: replaceTree)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceTree: searchTree withTree: replaceTree when: aBlock 	self addRule: (RBStringReplaceRule 				searchForTree: searchTree				replaceWith: replaceTree				when: aBlock)! !!ParseTreeRewriter methodsFor: 'visiting'!visitArguments: aNodeCollection 	^aNodeCollection collect: [:each | self visitArgument: each]! !!ParseTreeRewriter methodsFor: 'visiting' stamp: 'nk 2/23/2005 15:20'!visitBlockArguments: aNodeCollection 	^aNodeCollection collect: [:each | self visitBlockArgument: each]! !!ParseTreeRewriter methodsFor: 'visiting' stamp: 'nk 2/23/2005 15:21'!visitMethodArguments: aNodeCollection 	^aNodeCollection collect: [:each | self visitMethodArgument: each]! !!ParseTreeRewriter methodsFor: 'visiting' stamp: 'nk 2/23/2005 15:22'!visitTemporaryVariables: aNodeCollection 	^aNodeCollection collect: [:each | self visitTemporaryVariable: each]! !!ParseTreeRewriter commentStamp: 'md 8/9/2005 14:55' prior: 0!ParseTreeRewriter walks over and transforms its RBProgramNode (tree). If the tree is modified, then answer is set to true, and the modified tree can be retrieved by the #tree method.Instance Variables:	tree	<RBProgramNode>	the parse tree we're transforming!!ParseTreeRewriter class methodsFor: 'instance creation'!classVariable: aVarName getter: getMethod setter: setMethod 	^self 		variable: aVarName		getter: getMethod		setter: setMethod		receiver: 'self class'! !!ParseTreeRewriter class methodsFor: 'instance creation'!removeTemporaryNamed: aName 	| rewriteRule |	rewriteRule := self new.	rewriteRule replace: '| `@temps1 ' , aName , ' `@temps2 | ``@.Statements'		with: '| `@temps1  `@temps2 | ``@.Statements'.	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!rename: varName to: newVarName 	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: varName with: newVarName;		replaceArgument: varName with: newVarName.	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!rename: varName to: newVarName handler: aBlock 	"Rename varName to newVarName, evaluating aBlock if there is a 	temporary variable with the same name as newVarName. This 	does not change temporary variables with varName."	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: varName with: newVarName;		replaceArgument: newVarName			withValueFrom: 				[:aNode | 				aBlock value.				aNode].	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!replace: code with: newCode method: aBoolean 	| rewriteRule |	rewriteRule := self new.	aBoolean 		ifTrue: [rewriteRule replaceMethod: code with: newCode]		ifFalse: [rewriteRule replace: code with: newCode].	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!replaceLiteral: literal with: newLiteral 	| rewriteRule |	rewriteRule := self new.	rewriteRule 		replace: '`#literal'		withValueFrom: [:aNode | aNode]		when: 			[:aNode | 			self 				replaceLiteral: literal				with: newLiteral				inToken: aNode token].	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!variable: aVarName getter: getMethod setter: setMethod 	^self 		variable: aVarName		getter: getMethod		setter: setMethod		receiver: 'self'! !!ParseTreeRewriter class methodsFor: 'instance creation'!variable: aVarName getter: getMethod setter: setMethod receiver: aString 	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: aVarName , ' := ``@object'			with: aString , ' ' , setMethod , ' ``@object';		replace: aVarName with: aString , ' ' , getMethod.	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'accessing'!replace: code with: newCode in: aParseTree 	^(self 		replace: code		with: newCode		method: false)		executeTree: aParseTree;		tree! !!ParseTreeRewriter class methodsFor: 'accessing'!replace: code with: newCode in: aParseTree onInterval: anInterval 	| rewriteRule |	rewriteRule := self new.	^rewriteRule		replace: code			with: newCode			when: [:aNode | aNode intersectsInterval: anInterval];		executeTree: aParseTree;		tree! !!ParseTreeRewriter class methodsFor: 'accessing'!replaceStatements: code with: newCode in: aParseTree onInterval: anInterval 	| tree searchStmt replaceStmt |	tree := self buildTree: code method: false.	tree lastIsReturn		ifTrue: 			[searchStmt := '| `@temps | `@.Statements. ' , code.			replaceStmt := '| `@temps | `@.Statements. ^' , newCode]		ifFalse: 			[searchStmt := '| `@temps | `@.Statements1. ' , code , '.  `@.Statements2'.			replaceStmt := '| `@temps | `@.Statements1. ' , newCode , '.  `@.Statements2'].	^self		replace: searchStmt		with: replaceStmt		in: aParseTree		onInterval: anInterval! !!ParseTreeRewriter class methodsFor: 'private'!replaceLiteral: literal with: newLiteral inToken: literalToken 	| value |	value := literalToken realValue.	(value class = literal class and: [value = literal]) 		ifTrue: 			[literalToken 				value: newLiteral				start: nil				stop: nil.			^true].	^value class == Array and: 			[literalToken value inject: false				into: 					[:bool :each | 					bool | (self 								replaceLiteral: literal								with: newLiteral								inToken: each)]]! !!ParseTreeSearcher methodsFor: 'accessing'!addArgumentRule: aParseTreeRule 	argumentSearches add: aParseTreeRule.	aParseTreeRule owner: self! !!ParseTreeSearcher methodsFor: 'accessing'!addArgumentRules: ruleCollection 	ruleCollection do: [:each | self addArgumentRule: each]! !!ParseTreeSearcher methodsFor: 'accessing'!addRule: aParseTreeRule 	searches add: aParseTreeRule.	aParseTreeRule owner: self! !!ParseTreeSearcher methodsFor: 'accessing'!addRules: ruleCollection 	ruleCollection do: [:each | self addRule: each]! !!ParseTreeSearcher methodsFor: 'accessing'!answer	^answer! !!ParseTreeSearcher methodsFor: 'accessing'!context	^context! !!ParseTreeSearcher methodsFor: 'accessing'!executeMethod: aParseTree initialAnswer: anObject 	answer := anObject.	searches detect: [:each | (each performOn: aParseTree) notNil] ifNone: [].	^answer! !!ParseTreeSearcher methodsFor: 'accessing'!executeTree: aParseTree 	"Save our current context, in case someone is performing another search inside a match."	| oldContext |	oldContext := context.	context := RBSmallDictionary new.	self visitNode: aParseTree.	context := oldContext.	^answer! !!ParseTreeSearcher methodsFor: 'accessing'!executeTree: aParseTree initialAnswer: aValue 	answer := aValue.	^self executeTree: aParseTree! !!ParseTreeSearcher methodsFor: 'accessing'!messages	messages notNil ifTrue: [^messages].	argumentSearches isEmpty ifFalse: [^messages := #()].	messages := Set new.	searches do: 			[:each | 			| searchMessages |			searchMessages := each sentMessages.			RBProgramNode optimizedSelectors 				do: [:sel | searchMessages remove: sel ifAbsent: []].			searchMessages isEmpty ifTrue: [^messages := #()].			messages addAll: searchMessages].	^messages := messages asArray! !!ParseTreeSearcher methodsFor: 'initialize-release'!answer: anObject	answer := anObject! !!ParseTreeSearcher methodsFor: 'initialize-release'!initialize	super initialize.	context := RBSmallDictionary new.	searches := OrderedCollection new.	argumentSearches := OrderedCollection new: 0.	answer := nil! !!ParseTreeSearcher methodsFor: 'testing' stamp: 'pmm 7/12/2006 15:17'!canMatchMethod: aCompiledMethod 	^self messages isEmpty		or: [ self messages anySatisfy: [:each | aCompiledMethod sendsSelector: each] ]! !!ParseTreeSearcher methodsFor: 'private'!foundMatch! !!ParseTreeSearcher methodsFor: 'private'!lookForMoreMatchesInContext: oldContext 	oldContext keysAndValuesDo: 			[:key :value | 			(key isString not and: [key recurseInto]) 				ifTrue: [value do: [:each | self visitNode: each]]]! !!ParseTreeSearcher methodsFor: 'private' stamp: 'pmm 7/12/2006 15:35'!performSearches: aSearchCollection on: aNode 	| value |	 aSearchCollection do: [ :each |			value := each performOn: aNode.			value notNil ifTrue: [				self foundMatch.				^value ] ].	^nil! !!ParseTreeSearcher methodsFor: 'private'!recusivelySearchInContext	"We need to save the matched context since the other searches might overwrite it."	| oldContext |	oldContext := context.	context := RBSmallDictionary new.	self lookForMoreMatchesInContext: oldContext.	context := oldContext! !!ParseTreeSearcher methodsFor: 'searching'!matches: aString do: aBlock 	self addRule: (RBSearchRule searchFor: aString thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'searching'!matchesAnyArgumentOf: stringCollection do: aBlock 	stringCollection do: [:each | self matchesArgument: each do: aBlock]! !!ParseTreeSearcher methodsFor: 'searching'!matchesAnyMethodOf: aStringCollection do: aBlock 	aStringCollection do: [:each | self matchesMethod: each do: aBlock]! !!ParseTreeSearcher methodsFor: 'searching'!matchesAnyOf: aStringCollection do: aBlock 	aStringCollection do: [:each | self matches: each do: aBlock]! !!ParseTreeSearcher methodsFor: 'searching'!matchesAnyTreeOf: treeCollection do: aBlock 	treeCollection do: [:each | self matchesTree: each do: aBlock]! !!ParseTreeSearcher methodsFor: 'searching'!matchesArgument: aString do: aBlock 	self addArgumentRule: (RBSearchRule searchFor: aString thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'searching'!matchesArgumentTree: aBRProgramNode do: aBlock 	self 		addArgumentRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'searching'!matchesMethod: aString do: aBlock 	self addRule: (RBSearchRule searchForMethod: aString thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'searching'!matchesTree: aBRProgramNode do: aBlock 	self addRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'visiting'!visitArgument: aNode 	| value |	value := self performSearches: argumentSearches on: aNode.	^value isNil 		ifTrue: 			[aNode acceptVisitor: self.			aNode]		ifFalse: [value]! !!ParseTreeSearcher methodsFor: 'visiting'!visitNode: aNode 	| value |	value := self performSearches: searches on: aNode.	^value isNil 		ifTrue: 			[aNode acceptVisitor: self.			aNode]		ifFalse: [value]! !!ParseTreeSearcher commentStamp: 'md 8/9/2005 14:55' prior: 0!ParseTreeSearcher walks over a normal source code parse tree using the visitor pattern, and then matches these nodes against the meta-nodes using the match:inContext: methods defined for the meta-nodes.Instance Variables:	answer	<Object>	the "answer" that is propagated between matches	argumentSearches	<Collection of: (Association key: RBProgramNode value: BlockClosure)>	argument searches (search for the BRProgramNode and perform the BlockClosure when its found)	context	<RBSmallDictionary>	a dictionary that contains what each meta-node matches against. This could be a normal Dictionary that is created for each search, but is created once and reused (efficiency).	messages	<Collection>	the sent messages in our searches	searches	<Collection of: (Association key: RBProgramNode value: BlockClosure)>	non-argument searches (search for the BRProgramNode and perform the BlockClosure when its found)!!ParseTreeSearcher class methodsFor: 'private'!buildSelectorString: aSelector 	| stream keywords |	aSelector numArgs = 0 ifTrue: [^aSelector].	stream := WriteStream on: String new.	keywords := aSelector keywords.	1 to: keywords size		do: 			[:i | 			stream nextPutAll: (keywords at: i);				nextPutAll: ' ``@arg';				nextPutAll: i printString;				nextPut: $ ].	^stream contents! !!ParseTreeSearcher class methodsFor: 'private'!buildSelectorTree: aSelector 	aSelector isEmpty ifTrue: [^nil].	^RBParser parseRewriteExpression: '``@receiver ' 				, (self buildSelectorString: aSelector)		onError: [:err :pos | ^nil]! !!ParseTreeSearcher class methodsFor: 'private'!buildTree: aString method: aBoolean 	^aBoolean 		ifTrue: [RBParser parseRewriteMethod: aString]		ifFalse: [RBParser parseRewriteExpression: aString]! !!ParseTreeSearcher class methodsFor: 'instance creation'!getterMethod: aVarName 	^(self new)		matchesMethod: '`method ^' , aVarName do: [:aNode :ans | aNode selector];		yourself! !!ParseTreeSearcher class methodsFor: 'instance creation'!justSendsSuper	^(self new)		matchesAnyMethodOf: 				#('`@method: `@Args ^super `@method: `@Args' 				'`@method: `@Args super `@method: `@Args')			do: [:aNode :ans | true];		yourself! !!ParseTreeSearcher class methodsFor: 'instance creation'!returnSetterMethod: aVarName 	^(self new)		matchesMethod: '`method: `Arg ^' , aVarName , ' := `Arg'			do: [:aNode :ans | aNode selector];		yourself! !!ParseTreeSearcher class methodsFor: 'instance creation'!setterMethod: aVarName 	^(self new)		matchesAnyMethodOf: (Array with: '`method: `Arg ' , aVarName , ' := `Arg'					with: '`method: `Arg ^' , aVarName , ' := `Arg')			do: [:aNode :ans | aNode selector];		yourself! !!ParseTreeSearcher class methodsFor: 'accessing'!treeMatching: aString in: aParseTree 	(self new)		matches: aString do: [:aNode :answer | ^aNode];		executeTree: aParseTree.	^nil! !!ParseTreeSearcher class methodsFor: 'accessing'!treeMatchingStatements: aString in: aParseTree 	| notifier tree lastIsReturn |	notifier := self new.	tree := RBParser parseExpression: aString.	lastIsReturn := tree lastIsReturn.	notifier matches: (lastIsReturn 				ifTrue: ['| `@temps | `@.S1. ' , tree formattedCode]				ifFalse: ['| `@temps | `@.S1. ' , tree formattedCode , '. `@.S2'])		do: [:aNode :answer | ^tree].	notifier executeTree: aParseTree.	^nil! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:48'!addPragma: aPragma	self properties addPragma: aPragma! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47'!pragmaLiteral	"Read a pragma literal."	(hereType == #string or: [ hereType == #literal or: [ hereType == #number ] ])		ifTrue: [ ^ self advance ].	(here == $# and: [ tokenType == #word ])		ifTrue: [ ^ self advance ].	(here == #- and: [ tokenType == #number ])		ifTrue: [ ^ (self advance; advance) negated ].	(here = 'true' or: [ here = 'false' or: [ here = 'nil' ] ])		ifTrue: [ ^ Compiler evaluate: self advance ].	^ self expected: 'Literal constant'! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 10:04'!pragmaPrimitives	| pragmas primitives |	self properties pragmas isEmpty		ifTrue: [ ^ 0 ].	pragmas := Pragma allNamed: #primitive from: self class to: Parser.	primitives := self properties pragmas select: [ :prim |		pragmas anySatisfy: [ :prag | 			prag selector = prim keyword ] ].	primitives isEmpty 		ifTrue: [ ^ 0 ].	primitives size = 1 		ifFalse: [ ^ self notify: 'Ambigous primitives' ].	^ primitives first message sendTo: self! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47'!pragmaSequence	"Parse a sequence of method pragmas."		[ true ] whileTrue: [		(self matchToken: #<)			ifFalse: [ ^ self ].		self pragmaStatement.		(self matchToken: #>)			ifFalse: [ ^ self expected: '>' ] ]! !!Parser methodsFor: 'pragmas' stamp: 'lr 8/19/2006 20:39'!pragmaStatement	"Read a single pragma statement. Parse all generic pragmas in the form of: <key1: val1 key2: val2 ...> and remember them, including primitives."		| selector arguments words index keyword |	(hereType = #keyword or: [ hereType = #word or: [ hereType = #binary ] ])		ifFalse: [  ^ self expected: 'pragma declaration' ].	" This is a ugly hack into the compiler of the FFI package. FFI should be changed to use propre pragmas that can be parsed with the code here. "	(here = #apicall: or: [ here = #cdecl: ])		ifTrue: [ ^ self externalFunctionDeclaration ].	selector := String new.	arguments := OrderedCollection new.	words := OrderedCollection new.	[ hereType = #keyword or: [ (hereType = #word or: [ hereType = #binary ]) and: [ selector isEmpty ] ] ] whileTrue: [		index := self startOfNextToken + requestorOffset.		selector := selector , self advance.		words add: (index to: self endOfLastToken + requestorOffset).		(selector last = $: or: [ selector first isLetter not ])			ifTrue: [ arguments add: self pragmaLiteral ] ].	selector numArgs ~= arguments size		ifTrue: [ ^ self expected: 'pragma argument' ].	(Symbol hasInterned: selector 		ifTrue: [ :value | keyword := value]) 		ifFalse: [ 			keyword := self 				correctSelector: selector wordIntervals: words				exprInterval: (words first first to: words last last)				ifAbort: [ ^ self fail ] ].	self addPragma: (Pragma keyword: keyword arguments: arguments asArray).	^ true! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47'!properties	^ properties ifNil: [ properties := MethodProperties new ]! !!Parser methodsFor: 'primitives' stamp: 'lr 10/5/2006 09:50'!primitive: anIntegerOrString	"Create indexed primitive."		<primitive>	^ anIntegerOrString isInteger		ifTrue: [ anIntegerOrString ]		ifFalse: [ 			anIntegerOrString isString				ifTrue: [ self primitive: anIntegerOrString module: nil ]				ifFalse: [ self expected: 'Indexed primitive' ] ]! !!Parser methodsFor: 'primitives' stamp: 'lr 10/5/2006 09:51'!primitive: aNameString module: aModuleStringOrNil	"Create named primitive."		<primitive>	(aNameString isString and: [ aModuleStringOrNil isNil or: [ aModuleStringOrNil isString ] ])		ifFalse: [ ^ self expected: 'Named primitive' ].	self allocateLiteral: (Array 		with: (aModuleStringOrNil isNil 			ifFalse: [ aModuleStringOrNil asSymbol ])		with: aNameString asSymbol		with: 0 with: 0).	^ 117! !!Parser2 methodsFor: 'accessing' stamp: 'ajh 3/11/2003 12:16'!classEncoding	^ scope classEncoding! !!Parser2 methodsFor: 'accessing' stamp: 'ajh 3/25/2003 23:45'!encoder	^ self! !!Parser2 methodsFor: 'accessing' stamp: 'pmm 5/28/2006 16:03'!realParserClass	^ SqueakParser! !!Parser2 methodsFor: 'accessing' stamp: 'ajh 3/10/2003 22:17'!requestor	"Return the source code editor"	^ requestor! !!Parser2 methodsFor: 'accessing' stamp: 'ajh 6/9/2002 19:47'!requestor: editor	"set the source code editor"	requestor _ editor! !!Parser2 methodsFor: 'error correction' stamp: 'md 4/14/2007 00:37'!correctSelector: messageNode	"Correct the proposed selector in messageNode, correcting the original text if such action is indicated.  Fail if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| alternatives aStream choice userSelection lines firstLine sel spots newSel |	sel _ messageNode selector.	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [^ sel].	spots _ messageNode selectorParts collect: [:token | token sourceInterval].	userSelection _ requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	requestor select.	alternatives _ messageNode owningScope possibleSelectorsFor: sel asString.	aStream _ WriteStream on: (String new: 200).	aStream nextPutAll: (sel asString contractTo: 35); cr.	firstLine _ 1. 	alternatives do: [:s | aStream nextPutAll: s; cr].	aStream nextPutAll: 'cancel'.	lines _ Array with: firstLine with: (alternatives size + firstLine).		choice _ (PopUpMenu labels: aStream contents lines: lines)		startUpWithCaption: 'Unknown selector, please confirm, correct, or cancel'.	(choice = 0) | (choice > (lines at: 2)) ifTrue: [^ self fail].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice = 1 ifTrue: [^ sel].	newSel _ alternatives at: choice - 1.	self substituteSelector: newSel in: messageNode.	((sel last ~~ $:) and: [newSel last == $:]) ifTrue: [^ self fail].	^ (messageNode owningScope lookupSelector: newSel)		ifNil: [self halt: 'chosen selector expected to exist']! !!Parser2 methodsFor: 'error correction' stamp: 'ms 9/16/2006 18:32'!correctVariable: variableNode	"Correct the variableNode to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps, and uppercase variables as Globals or ClassVars,	depending on whether the context is nil (class=UndefinedObject)."	| varName spot alternatives aStream choice userSelection temp binding declareSize prevToken nextToken tokenChange |	varName _ variableNode name.	"If we can't ask the user for correction, make it undeclared"	self interactive ifFalse: [		Transcript show: ' (' , varName , ' is Undeclared) '.		varName _ varName asSymbol.		Undeclared at: varName put: nil.		^ GlobalVar new assoc: (Undeclared associationAt: varName); scope: scope	].	spot _ variableNode sourceInterval.	temp _ varName first isLowercase.	"First check to see if the requestor knows anything about the variable"	(temp and: [(binding _ requestor bindingOf: varName) notNil])		ifTrue: [^ GlobalVar new assoc: binding; scope: scope].	userSelection _ requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	alternatives _ variableNode owningScope possibleVarsFor: varName.	aStream _ WriteStream on: (String new: 200).	temp ifTrue: [		declareSize _ 1.		aStream nextPutAll: 'declare temp'; cr.	] ifFalse: [		declareSize _ 1.		self classEncoding ifNotNil: [			declareSize _ declareSize + 1.  			aStream nextPutAll: 'declare class variable'; cr].		aStream nextPutAll: 'declare global'; cr.	].	alternatives do: [:name | aStream nextPutAll: name; cr].	aStream nextPutAll: 'cancel'.	choice _ (PopUpMenu labels: aStream contents				lines: {declareSize. declareSize + alternatives size})		startUpWithCaption:(('Unknown variable: ', varName, 'please correct, or cancel:') asText makeBoldFrom: 19 to: 19 + varName size).	(choice = 0 or: [choice > (declareSize + alternatives size)]) ifTrue: [^ self fail].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	temp ifTrue: [		choice = 1 ifTrue: [^ self declareTempAndPaste: variableNode]	] ifFalse: [		declareSize = 1 ifTrue: [			choice = 1 ifTrue: [^ self declareGlobal: variableNode].		] ifFalse: [ "declareSize = 2"			choice = 1 ifTrue: [^ self declareClassVar: variableNode].			choice = 2 ifTrue: [^ self declareGlobal: variableNode].		].	].	"Spelling correction"	varName _ alternatives at: choice - declareSize.	prevToken := variableNode token previous.	nextToken := variableNode token next.	tokenChange := SqueakToken value: varName start: spot first prevToken: prevToken.	nextToken previous: tokenChange.	variableNode changeToken: tokenChange.	self substituteWord: varName wordInterval: spot offset: 0.	^ (variableNode owningScope lookupVar: varName)		ifNil: [self halt: 'var should have been found']! !!Parser2 methodsFor: 'error correction' stamp: 'ajh 3/20/2003 01:30'!declareClassVar: variableNode	self classEncoding theNonMetaClass		addClassVarName: variableNode name asSymbol.	^ (variableNode owningScope lookupVar: variableNode name)		ifNil: [self halt: 'should be found']! !!Parser2 methodsFor: 'error correction' stamp: 'ajh 3/20/2003 01:30'!declareGlobal: variableNode	Smalltalk at: variableNode name asSymbol put: nil.	^ (variableNode owningScope lookupVar: variableNode name)		ifNil: [self halt: 'should be found']! !!Parser2 methodsFor: 'error correction' stamp: 'ms 9/17/2006 14:51'!declareTempAndPaste: variableNode	| name insertion theTextString methodBody pos start c var tempNode prev prevToken nextToken tokenChange |		name := variableNode name.	theTextString := requestor text string.	methodBody := variableNode root body.	methodBody temporaries notEmpty ifTrue: [  		"Paste it after last temp"		prev := pos := methodBody temporaries last stop + 1.		prevToken := methodBody temporaries last token previous.		nextToken := methodBody temporaries last token next.		(theTextString at: pos) isSeparator ifTrue: [			insertion := name, ' '.			pos := pos + 1.  start _ pos.		] ifFalse: [			insertion := ' ', name.			start := pos + 1.		].		self substituteWord: insertion			wordInterval: (pos to: pos - 1) offset: 0.	] ifFalse: [		"No bars - insert some with CR & tab"		insertion := '| ', name, ' |', String cr.		prev := pos := methodBody statements first start - 1.		start := 0.		[pos = 0 or: [(c := theTextString at: pos) = Character cr]] whileFalse: [			c isSeparator ifTrue: [				insertion := c asString, insertion.				start := start + 1.			].			pos := pos - 1.		].		pos := pos + 1.		self substituteWord: insertion			wordInterval: (pos to: pos - 1) offset: 0.		start := pos + 2 + start.				prevToken := SqueakToken value: '|' start: start.		methodBody parent lastTokenOfPatternMethod insertAfterMe: prevToken.		nextToken := SqueakToken value: '|' start: start + 1.		prevToken insertAfterMe: nextToken.	].	var := methodBody owningScope addTemp: name.	"change token to be linked with the other"	tokenChange := SqueakToken value: name  start: start prevToken: prevToken.	nextToken previous: tokenChange.	tempNode := RBVariableNode new		identifierToken: tokenChange;		binding: var.	methodBody root adjustPositionsAfter: prev by: insertion size.	methodBody temporaries: (methodBody temporaries copyWith: tempNode).	^ (variableNode owningScope lookupVar: name)		ifNil: [self halt: 'should have been found']! !!Parser2 methodsFor: 'error correction' stamp: 'ajh 3/12/2003 14:34'!queryUninitializedTemp: variableNode	| varStart varName |	self interactive ifFalse: [^ self].	varName _ variableNode name.	varStart _ variableNode start.	requestor selectFrom: varStart to: varStart + varName size - 1; select.	((PopUpMenu labels:'yesno') startUpWithCaption:		((varName , ' appears to beundefined at this point.Proceed anyway?') asText makeBoldFrom: 1 to: varName size))		= 1 ifFalse: [^ self fail]! !!Parser2 methodsFor: 'error correction' stamp: 'ajh 3/15/2003 13:27'!removeUnusedTemp: variableNode	"Removing unused temp, variableNode, if verified by the user"	| varName interval |	self interactive ifFalse: [^ self].  "don't remove and continue"	varName _ variableNode name.	((PopUpMenu labels: 'yes\no' withCRs) startUpWithCaption:		((varName , ' appears to beunused in this method.OK to remove it?') asText makeBoldFrom: 1 to: varName size))			= 1 ifFalse: [^ self].  "don't remove and continue"	"Remove temp then continue"	interval _ variableNode sourceInterval.	(requestor text at: interval last + 1) isSeparator ifTrue: [		interval _ interval first to: interval last + 1].	self substituteWord: '' wordInterval: interval offset: 0.	variableNode root adjustPositionsAfter: interval first by: 0 - interval size.	variableNode parent removeTemporaryNamed: varName.	^ self! !!Parser2 methodsFor: 'error correction' stamp: 'ms 9/17/2006 15:05'!substituteSelector: newSel in: messageNode	"Substitute the correctSelector into the (presuamed interactive) receiver."	| offset newParts |	newParts _ OrderedCollection new.	offset _ 0.	newSel keywords	  with: (messageNode selectorParts)	  do: [:word :tok |		newParts add: ((SqueakToken value: word start: tok sourceInterval first + offset) substitueTo: tok).		offset _ self substituteWord: word wordInterval: tok sourceInterval offset: offset.	  ].	messageNode changeSelectorParts: newParts asArray.! !!Parser2 methodsFor: 'error correction' stamp: 'ajh 3/11/2003 23:22'!substituteWord: correctWord wordInterval: spot offset: o	"Substitute the correctSelector into the (presuamed interactive) receiver."	requestor		correctFrom: (spot first + o)		to: (spot last + o)		with: correctWord.	^ o + correctWord size - spot size! !!Parser2 methodsFor: 'error correction' stamp: 'ajh 3/19/2003 16:43'!variable: varNode shadows: semVar	self interactive ifFalse: [		^ Transcript show: '(', varNode name, ' is shadowed)'].	self notify: 'Name already defined' at: varNode start.! !!Parser2 methodsFor: 'old protocol' stamp: 'ajh 3/11/2003 20:01'!endOfLastToken	^ endOfMethodPattern! !!Parser2 methodsFor: 'error handling' stamp: 'ajh 3/6/2003 01:03'!fail	^ failBlock value! !!Parser2 methodsFor: 'error handling' stamp: 'ajh 5/19/2004 17:31'!interactive	requestor == nil ifTrue: [^ false].	(requestor isKindOf: SyntaxError) ifTrue: [^ false].	(requestor respondsTo: #interactive) ifTrue: [^ requestor interactive].	^ true! !!Parser2 methodsFor: 'error handling' stamp: 'ms 1/7/2007 02:01'!notify: string at: location	requestor isNil		ifTrue: [			SyntaxErrorNotification					inClass: (self classEncoding ifNil: [FakeClassPool])					category: (self classEncoding ifNil: [FakeClassPool]) category					withCode: 						(source contents							copyReplaceFrom: location							to: location - 1							with: string , ' ->')					doitFlag: doitFlag]		ifFalse: [requestor					notify: string , ' ->'					at: location					in: source].	^self fail! !!Parser2 methodsFor: 'public access' stamp: 'ajh 3/11/2003 14:35'!parse: sourceStreamOrString class: behavior	^ self parse: sourceStreamOrString readStream class: behavior		noPattern: false notifying: nil ifFail: [nil]! !!Parser2 methodsFor: 'public access' stamp: 'md 11/22/2005 18:08'!parse: sourceStream class: class category: aCategory noPattern: noPattern context: ctxt notifying: req ifFail: aBlock         "Answer a MethodNode for the argument, sourceStream, that is the root of         a parse tree. Parsing is done with respect to the argument, class, to find         instance, class, and pool variables; and with respect to the argument,         ctxt, to find temporary variables. Errors in parsing are reported to the         argument, req, if not nil; otherwise aBlock is evaluated. The argument         noPattern is a Boolean that is true if the the sourceStream does not         contain a method header (i.e., for DoIts)."         	^ self parse: sourceStream class: class  noPattern: noPattern context: ctxt notifying: req ifFail: aBlock ! !!Parser2 methodsFor: 'public access' stamp: 'ajh 9/14/2002 09:28'!parse: sourceStream class: behavior noPattern: noPattern context: context notifying: req ifFail: aBlock	"Backwards compatibilty"	context ifNotNil: [self error: 'Use Compiler-evaluate... instead'].	^ self parse: sourceStream class: behavior noPattern: noPattern notifying: req ifFail: aBlock! !!Parser2 methodsFor: 'public access' stamp: 'ms 1/7/2007 01:49'!parse: sourceStream class: parseScope noPattern: doitBool notifying: req ifFail: aBlock	"Parse sourceStream into a embedded BlockNode if doitFlag is true (no method header) or a MethodNode if doitFlag is false.  Parsing is done with respect to parseScope to find non-local variables.  Errors in parsing are reported to req if not nil followed by executing the fail block."	| parser |	source := sourceStream.	requestor := req.	doitFlag := doitBool.	scope := parseScope parseScope.	failBlock := [^ aBlock value].	parser := self realParserClass.	^ [	| tree |		tree := doitFlag 			ifTrue: [parser parseDoIt: source]			ifFalse: [parser parseMethod: source].		[tree verifyIn: scope] on: SemanticWarning do: [:ex | ex correctIn: self]	 ] on: UnhandledError do: [:uEx | | ex |		ex := uEx exception.		(SmaCCParserError handles: ex)			ifTrue: [self notify: ex description at: ex tag position]			ifFalse: [uEx pass]	 ]! !!Parser2 methodsFor: 'public access' stamp: 'ajh 3/6/2003 00:42'!parseArgsAndTemps: aString notifying: req 	"No initialization required.  Parse the argument, aString, notifying req if an error occurs. Otherwise, answer a two-element Array containing Arrays of strings (the argument names and temporary variable names)."	aString == nil ifTrue: [^ #()].	^ (self parse: aString readStream class: nil noPattern: false notifying: req ifFail: [^ nil]) tempNames! !!Parser2 methodsFor: 'public access' stamp: 'ms 7/15/2006 15:35'!parseMethodComment: aString setPattern: aBlock	"Answer the method comment for the argument, aString. Evaluate aBlock with the methodNode containing the selector and arguments"	| methodNode comments |	methodNode := self realParserClass parseMethod: aString.	endOfMethodPattern := methodNode methodPatternStop.	aBlock value: methodNode.	comments := methodNode comments.	comments isEmpty ifTrue: [^ nil].	^ comments first! !!Parser2 methodsFor: 'public access' stamp: 'md 10/25/2007 15:34'!parseSelector: aString 	"Answer the message selector for the argument, aString, which should parse successfully up to the temporary declaration or the end of the method header."	| methodNode |	[methodNode := self realParserClass parseMethodPattern: aString.	endOfMethodPattern := methodNode methodPatternStop.	^ methodNode selector] on: SmaCCParserError do: [^nil].! !!Parser2 methodsFor: '*persephone' stamp: 'md 8/20/2007 13:59'!parseDoit: sourceStreamOrString	^ self parse: sourceStreamOrString readStream class: nil		noPattern: true notifying: nil ifFail: [nil]! !!Parser2 commentStamp: 'ajh 3/24/2003 21:36' prior: 0!This mirrors the old Parser protocol but delegates to the real parser which is SqueakParser.!!Parser2 class methodsFor: 'initialization' stamp: 'ajh 7/7/2004 13:49'!initialize	Smalltalk at: #ParseError put: SmaCCParserError.! !!ParserTest methodsFor: 'accessing'!buildArgumentSearch	self 		createArgumentSearchWith: 'aSmalllintContext'		selectors: #(#checkMethod: #checkClass:)		inClass: BasicLintRuleTest! !!ParserTest methodsFor: 'accessing'!buildMessageSearch	self 		createSearchWith: '``@receiver -> ``@arg'		selectors: #(superSends superSends)		inClass: TransformationRuleTest! !!ParserTest methodsFor: 'accessing'!buildMethodArgumentSearch	"Two argument methods"	self 		createMethodSearchWith: '`arg1: `arg1 `arg2: `arg2 | `@temps | `@.Stmts'		selectors: #(#subclassOf:overrides: #createMatcherFor:method: #createParseTreeRule:name:)		inClass: BasicLintRuleTest class! !!ParserTest methodsFor: 'accessing'!buildMethodSearch	"Simple forwarders"	self 		createMethodSearchWith: '`@methodName: `@args ^`@object `@methodName: `@args'		selectors: #(#problemCount isEmpty)		inClass: TransformationRuleTest! !!ParserTest methodsFor: 'accessing'!buildMethodTitleSearch	self 		createMethodSearchWith: 'initialize | `@temps | `@.Stmts'		selectors: #(#initialize)		inClass: BasicLintRuleTest! !!ParserTest methodsFor: 'accessing'!buildSimpleLiteralSearch	| search |	search := ParseTreeSearcher new.	search 		matchesAnyTreeOf: (Array with: (RBParser 						parseExpression: '#(''bugs'' ''possible bugs'' ''unnecessary code'' ''intention revealing'' ''miscellaneous'')'))		do: 			[:aNode :answer | 			answer				remove: self currentSelector ifAbsent: [self error: 'failed'];				yourself].	search answer: #(#protocols) asBag.	(classSearches at: BasicLintRuleTest class ifAbsentPut: [Set new]) 		add: search! !!ParserTest methodsFor: 'accessing'!buildSimpleVariableSearch	self 		createSearchWith: 'result'		selectors: #(#checkClass: #checkMethod: #isEmpty #problemCount #resetResult #resetResult #resetResult #result #result: #resultClass: #viewResults)		inClass: BasicLintRuleTest! !!ParserTest methodsFor: 'accessing'!buildStatementSearch	"Two or more statements"	self 		createSearchWith: '| `@temps | ``@.Stmts1. ``.Stmt1. ``@.Stmts2. ``.Stmt2. ``@.Stmts3'		selectors: #(#checkMethod: #rewriteUsing: #viewResults #superSends)		inClass: TransformationRuleTest! !!ParserTest methodsFor: 'accessing'!compare: anObject to: anotherObject 	self assert: anObject hash = anotherObject hash.	self assert: anObject = anotherObject! !!ParserTest methodsFor: 'accessing'!createArgumentSearchWith: aCodeString selectors: selectorCollection inClass: aClass 	| search |	search := ParseTreeSearcher new.	search matchesAnyArgumentOf: (Array with: aCodeString)		do: 			[:aNode :answer | 			answer				remove: self currentSelector ifAbsent: [self error: 'failed'];				yourself].	search answer: selectorCollection asBag.	(classSearches at: aClass ifAbsentPut: [Set new]) add: search! !!ParserTest methodsFor: 'accessing'!createMethodSearchWith: aCodeString selectors: selectorCollection inClass: aClass 	| search |	search := ParseTreeSearcher new.	search matchesAnyMethodOf: (Array with: aCodeString)		do: 			[:aNode :answer | 			answer				remove: self currentSelector ifAbsent: [self error: 'failed'];				yourself].	search answer: selectorCollection asBag.	(classSearches at: aClass ifAbsentPut: [Set new]) add: search! !!ParserTest methodsFor: 'accessing'!createSearchWith: aCodeString selectors: selectorCollection inClass: aClass 	| search |	search := ParseTreeSearcher new.	search matches: aCodeString		do: 			[:aNode :answer | 			answer				remove: self currentSelector ifAbsent: [self error: 'failed'];				yourself].	search answer: selectorCollection asBag.	(classSearches at: aClass ifAbsentPut: [Set new]) add: search! !!ParserTest methodsFor: 'accessing'!currentSelector	^currentSelector! !!ParserTest methodsFor: 'accessing'!setUp	super setUp.	classSearches := Dictionary new.	self		buildMethodSearch;		buildSimpleVariableSearch;		buildSimpleLiteralSearch;		buildMessageSearch;		buildStatementSearch;		buildArgumentSearch;		buildMethodTitleSearch;		buildMethodArgumentSearch! !!ParserTest methodsFor: 'private'!parseError: each 	RBParser parseExpression: each first		onError: [:string :pos | ^self assert: pos = each last].	self error: 'Parser didn''t fail'! !!ParserTest methodsFor: 'private'!treeWithEverything	^RBParser 		parseMethod: 'method: arg1 | temps | temps := #(10). temps foo; foo. ^(temps collect: [:e | ])'! !!ParserTest methodsFor: 'private' stamp: 'md 8/2/2005 22:29'!verifySelector: aSelector inClass: aClass 	| myTree otherTree source |	source := aClass sourceCodeAt: aSelector.	source isNil ifTrue: [^self].	myTree := aClass parseTreeFor: aSelector.	otherTree := Parser new 				parse: (ReadStream on: source)				class: aClass				noPattern: false				context: nil				notifying: "SilentCompilerErrorHandler new" nil				ifFail: [^self].	self assert: (myTree notNil or: [otherTree isNil]).	"self should: 			[""	((Compiler new 		compile: myTree formattedCode		in: aClass		notifying: nil		ifFail: [self assert: false]) generate 		isEqualTo: (Compiler new 				compile: otherTree formattedCode				in: aClass				notifying: nil				ifFail: [self assert: false]) generate) 			ifFalse: [self halt]"	"]"! !!ParserTest methodsFor: 'tests'!testAllSearches	classSearches keysAndValuesDo: 			[:class :searches | 			class selectors do: 					[:sel | 					currentSelector := sel.					searches 						do: [:each | each executeTree: (class parseTreeFor: sel) initialAnswer: each answer]]].	classSearches 		do: [:searches | searches do: [:each | self assert: each answer isEmpty]]! !!ParserTest methodsFor: 'tests'!testBestNodeFor	| tree |	tree := self treeWithEverything.	tree nodesDo: 			[:each | 			each sourceInterval isEmpty 				ifFalse: 					[self assert: ((tree bestNodeFor: each sourceInterval) = each 								or: [each parent isCascade and: [each parent messages last = each]])]]! !!ParserTest methodsFor: 'tests'!testBlockRewrites	| rewriter tree |	tree := RBParser 				parseMethod: 'method: asdf	<primitive: 1>	<primitive: 2>	^asdf + self foo + asdf'.	rewriter := ParseTreeRewriter new.	rewriter 		replace: 'asdf'		with: 'fdsa'		when: [:aNode | aNode parent parent isReturn].	rewriter replace: 'self foo'		withValueFrom: [:aNode | RBVariableNode named: aNode selector asString].	rewriter 		replaceArgument: 'asdf'		withValueFrom: [:aNode | RBVariableNode named: 'xxx']		when: [:aNode | false].	rewriter executeTree: tree.	self compare: tree		to: (RBParser 				parseMethod: 'method: asdf	<primitive: 1>	<primitive: 2>	^asdf +  foo + fdsa')! !!ParserTest methodsFor: 'tests'!testCascadeReplacement	| cascade |	cascade := RBParser parseExpression: 'self foo; bar; baz'.	(cascade messages at: 2) 		replaceWith: (RBParser parseExpression: 'self bar: 2').	self compare: cascade		to: (RBParser parseExpression: 'self foo; bar: 2; baz')! !!ParserTest methodsFor: 'tests'!testComparingTrees	| class |	class := BasicLintRuleTest class.	class selectors 		do: [:each | self compare: (class parseTreeFor: each) to: (class parseTreeFor: each)]! !!ParserTest methodsFor: 'tests'!testCopy	| tree |	tree := self treeWithEverything.	self compare: tree to: tree copy! !!ParserTest methodsFor: 'tests' stamp: 'ms 4/1/2007 12:11'!testCreationProtocol	| messageNode |	self compare: (RBMessageNode 				receiver: (RBVariableNode named: 'self')				selector: #+				arguments: (Array with: (RBLiteralNode value: 0)))		to: (RBParser parseExpression: 'self + 0').	messageNode := RBMessageNode receiver: (RBVariableNode named: 'self')				selector: #foo.	self compare: (RBMethodNode selector: #bar				body: (RBSequenceNode statements: (OrderedCollection 								with: (RBCascadeNode messages: (OrderedCollection with: messageNode with: messageNode)))))		to: (RBParser parseMethod: 'bar self foo; foo')! !!ParserTest methodsFor: 'tests' stamp: 'nk 2/23/2005 15:58'!testEquivalentExceptRenaming	#(('a 3-4' 'a 4-3' false ) ('a #[3 4]' 'a #(3 4)' false ) ('a variable1 ~~ "comment" variable2' 'a variable1 ~~ variable2' true ) ('a variable1' 'a variable2' false ) ('a [:a :b | a + b]' 'a [:b :a | a + b]' false ) ('a | a b | a + b' 'a | b a | a + b' true ) ('a | a | a msg1; msg2' 'a | b | b msg2; msg2' false ) ('a c' 'a d' true ) ('a | a b | a := b. ^b msg1' 'a | a b | b := a. ^a msg1' true ) ('a | a b | a := b. ^b msg1: a' 'a | a b | b := a. ^b msg1: a' false ) ('a: b b + 4' 'a: e e + 4' true ) ('a: b b + 4' 'b: b b + 4' false ) ('a: b b: c b + c' 'a: c b: b c + b' true ) ('a: a b: b a + b' 'a: b b: a a + b' false ) ) do: [:each | self assert: ((RBParser parseMethod: each first)				equalTo: (RBParser parseMethod: (each at: 2))				exceptForVariables: #('c' ))				== each last ]! !!ParserTest methodsFor: 'tests'!testFormatter	| class |	class := BasicLintRuleTest class.	class selectors do: 			[:each | 			self compare: (class parseTreeFor: each)				to: (RBParser parseMethod: (class parseTreeFor: each) printString)]! !!ParserTest methodsFor: 'tests'!testIntervals	| tree |	tree := self treeWithEverything.	tree nodesDo: 			[:each | 			(each parent isNil or: [each parent isCascade not]) 				ifTrue: 					[| newNode source |					source := tree source copyFrom: each start to: each stop.					newNode := each isMethod 								ifTrue: [RBParser parseMethod: source]								ifFalse: [RBParser parseExpression: source].					self compare: each to: newNode]]! !!ParserTest methodsFor: 'tests'!testIsA	| nodes types |	nodes := Bag new.	types := Set new.	#(#(#isAssignment 1) #(#isBlock 1) #(#isCascade 1) #(#isLiteral 1) #(#isMessage 3) #(#isMethod 1) #(#isReturn 1) #(#isSequence 2) #(#isValue 14) #(#isVariable 7) #(#isUsed 9) #(#isDirectlyUsed 8) #(#hasParentheses 1) #(#isBinary 0) #(#isPrimitive 0) #(#isImmediate 9)) 		do: 			[:each | 			each last timesRepeat: [nodes add: each first].			types add: each first].	self treeWithEverything nodesDo: 			[:each | 			types do: 					[:sel | 					((each respondsTo: sel) and: [each perform: sel]) 						ifTrue: [nodes remove: sel]]].	self assert: nodes isEmpty! !!ParserTest methodsFor: 'tests'!testLiteralIntevals	| tree |	tree := RBParser parseExpression: '#(#a b #( c ))'.	self assert: tree token value first start = 3.	self assert: tree token value first stop = 4.	self assert: tree token value last value first start = 11! !!ParserTest methodsFor: 'tests'!testMethodPatterns	#(#('+ a ^self + a' #+) #('foo ^self foo' #foo) #('foo: a bar: b ^a + b' #foo:bar:)) 		do: [:each | self assert: (RBParser parseMethodPattern: each first) == each last]! !!ParserTest methodsFor: 'tests' stamp: 'md 2/26/2006 14:48'!testModifying	| tree |	tree := RBParser 				parseMethod: 'foo: a bar: b | c | self first. self second. a + b + c'.	self deny: tree lastIsReturn.	self deny: (tree body statements at: 2) isUsed.	self assert: tree body statements last arguments first isUsed.	self assert: (tree isLast: tree body statements last).	self deny: (tree isLast: tree body statements first).	self assert: (tree defines: 'a').	self deny: (tree defines: 'c').	self assert: (tree body defines: 'c').	self deny: (tree body defines: 'a').	tree		addReturn;		selector: #bar:foo:.	(tree body)		addTemporaryNamed: 'd';		removeTemporaryNamed: 'c'.	self compare: tree		to: (RBParser 				parseMethod: 'bar: a foo: b | d | self first. self second. ^a + b + c').	self 		assert: ((tree argumentNames asSet)				removeAll: #('a' 'b');				yourself) isEmpty.	self 		assert: ((tree allDefinedVariables asSet)				removeAll: #('a' 'b' 'd');				yourself) isEmpty.	tree := RBParser parseExpression: 'self foo: 0'.	tree selector: #+.	self compare: tree to: (RBParser parseExpression: 'self + 0').	self should: [tree selector: #foo] raise: TestResult error.! !!ParserTest methodsFor: 'tests'!testMultimatch	| rewriter count |	count := 0.	rewriter := ParseTreeRewriter new.	rewriter 		replace: '``@object at: ``@foo'		with: '``@object foo: ``@foo'		when: [:aNode | (count := count + 1) == 2].	self compare: (rewriter				executeTree: (RBParser parseExpression: 'self at: (bar at: 3)');				tree)		to: (RBParser parseExpression: 'self at: (bar foo: 3)')! !!ParserTest methodsFor: 'tests'!testNodesDo	| size |	size := 0.	self treeWithEverything nodesDo: [:e | size := size + 1].	self assert: size = 18! !!ParserTest methodsFor: 'tests' stamp: 'nk 2/23/2005 14:44'!testNumberParsing	2 to: 32		do: 			[:radix | | radixString |			radixString := radix printString, 'r'.			0 to: 72				do: 					[:i | 					self 						assert: (RBParser 								parseExpression: (radixString, (i radix: radix)))									value = i]]! !!ParserTest methodsFor: 'tests'!testParserErrors	#(#('self foo. + 3' 11) #('#(' 2) #('self 0' 6) #('self asdf;;asfd' 11)) 		do: [:each | self parseError: each]! !!ParserTest methodsFor: 'tests'!testParsingLiteralMessages	self assert: (RBParser parseExpression: 'self nil') isMessage.	self assert: (RBParser parseExpression: 'self true') isMessage.	self assert: (RBParser parseExpression: 'self false') isMessage.	self assert: (RBParser parseExpression: 'self -1') isMessage! !!ParserTest methodsFor: 'tests'!testPatternCascade	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter replace: 'self `;messages; foo: 4; `;messages1'		with: 'self `;messages1; bar: 4; `;messages'.	self compare: (rewriter				executeTree: (RBParser 							parseExpression: 'self foo; printString; foo: 4; bar. self foo: 4');				tree)		to: (RBParser 				parseExpression: 'self bar; bar: 4; foo; printString. self foo:4')! !!ParserTest methodsFor: 'tests' stamp: 'ms 4/1/2007 12:32'!testPositions	| blockNode |	blockNode := RBParser parseExpression: '[:a :b | ]'.	self assert: blockNode left = 1.	self assert: blockNode right = 10.	self assert: blockNode bar = 8.	self assert: blockNode sourceInterval = (1 to: 10).	self assert: blockNode size = 1.	"test dummy collection protocol"	blockNode printString.	"coverage"	self deny: (blockNode isLast: (RBVariableNode named: 'b')).	self compare: blockNode		to: (RBBlockNode 				arguments: (OrderedCollection with: (RBVariableNode named: 'a')						with: (RBVariableNode named: 'b'))				body: (RBSequenceNode statements: OrderedCollection new)).				! !!ParserTest methodsFor: 'tests' stamp: 'ms 4/1/2007 13:49'!testPrimitives	self assert: (Object parseTreeFor: #basicAt:) isPrimitive.	#(('foo ^true' false ) ('foo <some: tag> ^true' false ) (' foo <some: tag> <primitive: 123> ^true' true ) ) do: [:each | self assert: (RBParser parseMethod: each first) isPrimitive = each last]! !!ParserTest methodsFor: 'tests'!testQuerying	| tree aNode arg1Node bNode |	tree := RBParser 				parseMethod: ('test: a`	| b |`	b := (self foo: a; bar) baz.`	b := super test: b.`	^[:arg1 | self foa1 + (super foo: arg1 foo: a foo: b)]' 						copyReplaceAll: '`'						with: (String with: (Character value: 13))).	self 		assert: tree selfMessages asSortedCollection asArray = #(#bar #foa1 #foo:).	self assert: tree superMessages asSortedCollection asArray 				= #(#foo:foo:foo: #test:).	aNode := tree whichNodeIsContainedBy: (112 to: 112).	self assert: aNode name = 'a'.	bNode := tree whichNodeIsContainedBy: (119 to: 119).	self assert: bNode name = 'b'.	arg1Node := tree whichNodeIsContainedBy: (102 to: 105).	self assert: arg1Node name = 'arg1'.	self assert: (arg1Node statementNode isMessage 				and: [arg1Node statementNode selector = #+]).	self assert: (arg1Node whoDefines: 'arg1') isBlock.	self assert: (aNode whoDefines: 'a') isMethod.	self assert: (aNode whoDefines: 'b') isSequence.	self assert: (tree whichNodeIsContainedBy: (91 to: 119)) selector 				= #foo:foo:foo:.	self assert: (tree whichNodeIsContainedBy: (69 to: 121)) isBlock.	self assert: (tree whichNodeIsContainedBy: (69 to: 118)) isNil.	self assert: aNode blockVariables asSortedCollection asArray = #('arg1').	self assert: aNode temporaryVariables asSortedCollection asArray = #('b').	self assert: tree allDefinedVariables asSortedCollection asArray 				= #('a' 'arg1' 'b').	self assert: tree allArgumentVariables asSortedCollection asArray 				= #('a' 'arg1').	self 		assert: tree allTemporaryVariables asSortedCollection asArray = #('b')! !!ParserTest methodsFor: 'tests' stamp: 'nk 2/23/2005 15:58'!testReadBeforeWritten	#(('a ifTrue: [^self]' true ) ('self foo. a := b' false ) ('condition ifTrue: [a := b] ifFalse: [self foo: a]' true ) ('condition ifTrue: [a := b] ifFalse: [self foo]. a isNil' true ) ('condition ifTrue: [a := b]. a := c' false ) ('[a := b] whileFalse: [a isNil]' false ) ('self foo: b' false ) ) do: 		[:each | 		self assert: ((RBReadBeforeWrittenTester readBeforeWritten: #('a' ) in: (RBParser parseExpression: each first))				includes: 'a')				== each last.		self assert: (RBReadBeforeWrittenTester isVariable: 'a' readBeforeWrittenIn: (RBParser parseExpression: each first))				= each last].	#('| temp read written written1 |			read ifTrue: [^self].			written1 := self foo ifFalse: [written := true] ifTrue: [written := false].			[temp := true] whileTrue: [temp notNil & written].			^temp' '| read written |			self foo ifTrue: [written := true] ifFalse: [written := false].			self foo ifTrue: [read := true].			^read' '| read written |			self foo do: [:i | i].			[| i | i := 1. i == 1] whileFalse: [read notNil]' '| written |			[written := 2] whileFalse.			self do: [:each | | read | each & read]' '| read |			self do: [:each | read := each].			self do: [:each | each & read]' ) do: 		[:each | 		| read | 		read := RBReadBeforeWrittenTester variablesReadBeforeWrittenIn: (RBParser parseExpression: each).		self assert: (read size = 1 and: [read includes: 'read'])]! !!ParserTest methodsFor: 'tests'!testReadBeforeWritten1	self 		assert: (RBReadBeforeWrittenTester variablesReadBeforeWrittenIn: (RBParser 						parseMethod: 'addAll: aCollection 	"Answer aCollection, having added all elements	 of aCollection to the receiver.	 Fail if aCollection is not a kind of	 Collection."	| newSize elementsSize growSize |	(newSize := aCollection size * 2) > elements size ifTrue: [self rehash: newSize].	elementsSize := elements size.	growSize := elementsSize // 2.	aCollection do: 			[:newObject | 			| hashIndex element |			newObject == nil ifFalse: 					[hashIndex := self hashIndexFor: newObject.										[(element := elements at: hashIndex) == nil						ifTrue: 							[elements at: hashIndex put: newObject.							(elementCount := elementCount + 1) > growSize ifTrue: 									[self expand.									elementsSize := elements size.									growSize := elementsSize // 2].							true]						ifFalse: [element == newObject]]							whileFalse: 								[(hashIndex := hashIndex + 1) > elementsSize ifTrue: [hashIndex := 1]]]].	^aCollection')) 				isEmpty! !!ParserTest methodsFor: 'tests'!testReplacingNodes	| tree search block |	tree := RBParser 				parseMethod: '+ a | a b | self ifTrue: [a] ifFalse: [b := c]. a := b. [:b :c :a | a foo: a; foo1: a; foo2: a foo: b]. ^a'.	search := ParseTreeSearcher new.	block := [:aNode :answer | aNode replaceWith: (RBVariableNode named: 'q')].	search		matches: 'a' do: block;		matchesArgument: 'a' do: block.	search executeTree: tree.	self 		assert: tree = (RBParser 						parseMethod: '+ q | q b | self ifTrue: [q] ifFalse: [b := c]. q := b. [:b :c :q | q foo: q; foo1: q; foo2: q foo: b]. ^q').	self 		assert: tree removeDeadCode = (RBParser 						parseMethod: '+ q | q b | self ifTrue: [] ifFalse: [b := c]. q := b. ^q')! !!ParserTest methodsFor: 'tests'!testRewriteMethods	#(#('arg1: a arg2: b | temp1 temp2 | self stmt1 ifTrue: [^a]. self arg1: a arg2: b' 'arg2: a arg1: b | temp1 temp2 | self stmt1 ifTrue: [^a]. self arg2: b arg2: a' '`arg1: `var1 `arg2: `var2 | `@temps | ``@.stmts. self `arg1: `var1 `arg2: `var2. `@.stmts1' '`arg2: `var1 `arg1: `var2 | `@temps | ``@.stmts. self `arg2: `var2 `arg2: `var1. `@.stmts1') #('arg1: a arg2: b | temp1 temp2 | self stmt1. self arg1: a arg2: b' 'arg1: a arg2: b | temp1 temp2 | [self stmt1] repeat' '`@args: `@vars | `@temps | `@.stmts. self `@args: `@vars' '`@args: `@vars | `@temps | [`@.stmts] repeat') #('+ a | temps | ^self primitiveValue' '- a | temps | ^self primitiveValue' '+ `temp | `@tmps | `@.stmts' '- `temp | `@tmps | `@.stmts') #('a self stmt1. self stmt2' 'a self stmt1. self stmt2' 'b | `@temps | `@.stmts' 'c | `@temps | `@.stmts')) 		do: 			[:each | 			| rewrite |			rewrite := ParseTreeRewriter new.			rewrite replaceMethod: (each at: 3) with: each last.			self compare: (RBParser 						parseMethod: (rewrite								executeTree: (RBParser parseMethod: each first);								tree) formattedCode)				to: (RBParser parseMethod: (each at: 2)).			rewrite := ParseTreeRewriter new.			rewrite replaceTree: (RBParser parseRewriteMethod: (each at: 3))				withTree: (RBParser parseRewriteMethod: each last).			self compare: (RBParser 						parseMethod: (rewrite								executeTree: (RBParser parseMethod: each first);								tree) formattedCode)				to: (RBParser parseMethod: (each at: 2))]! !!ParserTest methodsFor: 'tests' stamp: 'bh 3/16/2000 23:16'!testRewrites	#(('[:c | |a| a foo1; foo2]' '[:c | |a| b foo1; foo2]' 'a' 'b' ) ('self foo: 1. bar foo1 foo: 2. (self foo: a) foo: (b foo: c)' 'self bar: 1. bar foo1 bar: 2. (self bar: a) bar: (b bar: c)' '``@rcvr foo: ``@arg1' '``@rcvr bar: ``@arg1' ) ('3 + 4' '4 + 4' '3' '4' ) ('a := self a' 'b := self a' 'a' 'b' ) ('^self at: 1 put: 2' '^self put: 1 put: 2' '^`@rcvr `at: `@arg1 put: `@arg2' '^`@rcvr put: `@arg1 put: `@arg2' ) ('1 + 2 + 3' '0 + 0 + 0' '`#literal' '0' ) ('1 + 2 + 3. 3 foo: 4' '3 + (2 + 1). 4 foo: 3' '``@rcvr `msg: ``@arg' '``@arg `msg: ``@rcvr' ) ('self foo: a bar: b. 1 foo: a bar: b' '2 foo: a bar: b. 1 foo: a bar: b' 'self `@msg: `@args' '2 `@msg: `@args' ) ('a := b. a := c + d' 'b := a. a := c + d' '`var1 := `var2' '`var2 := `var1' ) ('^self foo value: 1' 'self return: (self foo value: 1)' '^`@anything' 'self return: `@anything' ) ('self first; second. self first; second. self a. self b' '2 timesRepeat: [self first; second]. self a. self b' '`.Stmt1. `.Stmt1. `@.stmts' '2 timesRepeat: [`.Stmt1]. `@.stmts' ) ('[:a | self a: 1 c: 2; b]' '[:a | self d: 2 e: 1; f. self halt]' '`@rcvr `msg1: `@arg1 `msg2: `@arg2; `msg' '`@rcvr d: `@arg2 e: `@arg1; f. self halt' )  ) do: 		[:each | 		| rewrite | 		rewrite := ParseTreeRewriter new.		rewrite replace: (each at: 3)			with: each last.		self compare: (RBParser parseExpression: (rewrite executeTree: (RBParser parseExpression: each first);				 tree) formattedCode)			to: (RBParser parseExpression: (each at: 2))]! !!ParserTest methodsFor: 'tests'!testSearching	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '``@rcv at: ``@arg `sel: ``@arg1'		do: [:aNode :answer | answer + 1].	self 		assert: (searcher executeTree: (RBParser 						parseExpression: 'self at: 1 put: 2; at: 2 ifAbsent: []; ifAbsent: 2 at: 1; at: 4; foo')				initialAnswer: 0) = 2.	searcher := ParseTreeSearcher new.	searcher matches: '``@rcv `at: ``@arg1 `at: ``@arg2'		do: [:aNode :answer | answer + 1].	self 		assert: (searcher executeTree: (RBParser 						parseExpression: 'self at: 1 at: 3; at: 1 put: 32; at: 2; foo; at: 1 at: 1 at: 2')				initialAnswer: 0) = 1.	searcher := ParseTreeSearcher new.	searcher matchesMethod: 'at: `object `put: `o1 ``@rcv `put: 1'		do: [:aNode :answer | true].	self assert: (searcher 				executeTree: (RBParser parseMethod: 'at: a put: b self foo put: 1')				initialAnswer: false)! !!ParserTest methodsFor: 'long running' stamp: 'dvf 8/27/2003 15:01'!verifyParser	SystemNavigation new allBehaviorsDo: 			[:each | 			each compilerClass = Compiler 				ifTrue: [each selectors do: [:sel | self verifySelector: sel inClass: each]]]! !!PatternLoggingFormatTestCase methodsFor: 'setup'!setUp	LoggingMultiplexer reset			! !!PatternLoggingFormatTestCase methodsFor: 'testing'!testFormattedPrinting	| stream result |	stream := '' copy writeStream.	'foobar' printWithFormat: '10' on: stream.	result := stream contents.	self assert: result = '    foobar'		description: 'result should be ''    foobar'', is ''', result, ''''.	stream := '' copy writeStream.	'foobar' printWithFormat: '-10' on: stream.	result := stream contents.	self assert: result = 'foobar    '		description: 'result should be ''foobar      '', is ''', result, ''''.	stream := '' copy writeStream.	'foobar' printWithFormat: '5' on: stream.	result := stream contents.	self assert: result = 'foobar'		description: '3. result should be ''foobar'', is ''', result, ''''.	stream := '' copy writeStream.	'foobar' printWithFormat: '-5' on: stream.	result := stream contents.	self assert: result = 'foobar'		description: '4. result should be ''foobar'', is ''', result, ''''.			! !!PatternLoggingFormatTestCase methodsFor: 'testing'!testFormattedPrintingWithTruncation	| stream result |	stream := '' copy writeStream.	'foobar' printWithFormat: '10.5' on: stream.	result := stream contents.	self assert: result = '     oobar'		description: '1. result should be ''oobar'', is ''', result, '''' .	stream := '' copy writeStream.	'foobar' printWithFormat: '-10.5' on: stream.	result := stream contents.	self assert: result = 'oobar     '		description: '2. result should be ''foobar      '', is ''', result, ''''.	stream := '' copy writeStream.	'foobar' printWithFormat: '.5' on: stream.	result := stream contents.	self assert: result = 'oobar'		description: '3. result should be ''oobar'', is ''', result, ''''.	stream := '' copy writeStream.	'foobar' printWithFormat: '10.10' on: stream.	result := stream contents.	self assert: result = '    foobar'		description: '4. result should be ''    foobar'', is ''', result, '''' .			! !!PatternLoggingFormatTestCase methodsFor: 'testing'!testGetFormatModifier	| formatter stream formatString |	formatter := PatternLoggingFormatter new.	stream := '20c' readStream.	self assert: (formatString := formatter getFormatModifierFrom: stream) = '20'		description: 'format string should be ''20'', is ', formatString.	stream := '-20.30c' readStream.	self assert: (formatString := formatter getFormatModifierFrom: stream) = '-20.30'		description: 'format string should be ''-20.30'', is ', formatString			! !!PatternLoggingFormatTestCase methodsFor: 'testing'!testPatternLoggingFormat	| stream format event |	format := PatternLoggingFormatter new.	format formatString: '%p - %m'.	event := LoggingEvent logMessage: 'Test message'.	stream := '' copy writeStream.	format formatEvent: event on: stream from: nil.	self assert: stream contents = 'DEBUG - Test message'			! !!PatternLoggingFormatTestCase methodsFor: 'testing' stamp: 'jp 10/13/2006 12:04'!testPatternLoggingFormat2	| stream format event ts expected actual |	ts := DateAndTime now.	format := PatternLoggingFormatter new.	format formatString: '%d %c %p - %m'.	event := LoggingEvent logInfo: 'Test message'.	event timeStamp: ts.	stream := '' copy writeStream.	format formatEvent: event on: stream from: nil.	expected := ts toothpickPrintString , ' debug INFO - Test message'.	actual := stream contents.	self assert: actual = expected description: 'Expected ' , expected , ' got ' ,actual			! !!PatternLoggingFormatter methodsFor: 'parsing'!category: anEvent format: format logger: aLogger on: aStream	anEvent categoryString printWithFormat: format on: aStream			! !!PatternLoggingFormatter methodsFor: 'parsing'!context: anEvent format: format logger: aLogger on: aStream	anEvent context  printWithFormat: format on: aStream			! !!PatternLoggingFormatter methodsFor: 'parsing'!date: anEvent format: format logger: aLogger on: aStream	self tsFormatter formatTimestamp: anEvent timeStamp on: aStream.			! !!PatternLoggingFormatter methodsFor: 'parsing'!getDateFormatModifierFrom: aStream	(aStream peekFor: ${) ifFalse: [^nil].	^(aStream upTo: $}) contents			! !!PatternLoggingFormatter methodsFor: 'parsing'!getFormatModifierFrom: aStream	| newStream element formatChars |	formatChars := '1234567890-.'.	newStream := '' copy writeStream.	[aStream atEnd]		whileFalse:			[element := aStream peek.			(formatChars includes: element)				ifFalse: [^newStream contents].			newStream nextPut: aStream next].	^newStream contents			! !!PatternLoggingFormatter methodsFor: 'parsing'!loggerName: anEvent format: format logger: aLogger on: aStream	aLogger name printWithFormat: format on: aStream			! !!PatternLoggingFormatter methodsFor: 'parsing'!message: anEvent format: format logger: aLogger on: aStream	anEvent messageString printWithFormat: format on: aStream			! !!PatternLoggingFormatter methodsFor: 'parsing'!priority: anEvent format: format logger: aLogger on: aStream	anEvent levelString printWithFormat: format on: aStream			! !!PatternLoggingFormatter methodsFor: 'parsing'!processPunctuation: aCharacter on: aStream	(aCharacter == $n)		ifTrue: [aStream cr]		ifFalse: [(aCharacter == $t)			ifTrue: [aStream tab]			ifFalse: [aStream nextPut: $%]]			! !!PatternLoggingFormatter methodsFor: 'parsing'!tokenDictionary	^Dictionary new		at: $c put: #category:format:logger:on:;		at: $d put: #date:format:logger:on:;		at: $l put: #loggerName:format:logger:on:;		at: $m put: #message:format:logger:on:;		at: $p put: #priority:format:logger:on:;		at: $x put: #context:format:logger:on:;	yourself			! !!PatternLoggingFormatter methodsFor: 'configuring'!configureFromDictionary: aDictionary 	self formatString: ( aDictionary at: 'pattern' ifAbsent: [ self defaultFormatString ])			! !!PatternLoggingFormatter methodsFor: 'accessing'!defaultFormatString	^'%p - %m'			! !!PatternLoggingFormatter methodsFor: 'accessing'!formatString	^formatString			! !!PatternLoggingFormatter methodsFor: 'accessing'!formatString: anObject	formatString := anObject			! !!PatternLoggingFormatter methodsFor: 'printing'!formatEvent: anEvent on: aStream from: aLogger 	| formatStream |	formatStream := self formatString readStream.	[ formatStream atEnd ] whileFalse: 		[ | c |			( c := formatStream next ) = $% 				ifTrue: 				[ | formatModifier conversionToken |					formatModifier := self getFormatModifierFrom: aStream.					conversionToken := formatStream next.					( 'nt%' includes: conversionToken ) 						ifTrue: [ self processPunctuation: conversionToken on: aStream ]						ifFalse: 						[ | conversionMethod |							conversionMethod := self tokenDictionary 								at: conversionToken 								ifAbsent: [ ^ self error: 'Illegal token' ].							"Must intercept date modifiers here"							(conversionToken == $d) 							ifTrue: [formatModifier := self getDateFormatModifierFrom: aStream].							self 								perform: conversionMethod 								withArguments: ( Array with: anEvent with: formatModifier with: aLogger with: aStream )						]				]				ifFalse: [ aStream nextPut: c ]		]			! !!PatternLoggingFormatter methodsFor: 'initialize'!initialize	self tsFormatter: ISO8601TimestampFormatter new			! !!PatternLoggingFormatter commentStamp: '<historical>' prior: 0!PatternLoggingFormat provides a printf()-like was of formatting the output of a LoggingEvent. This is useful for e.g. outputting events to a comma-delimited file. The goal of this class is to format a LoggingEvent and return the results as a String. The results depend on the conversion pattern. The conversion pattern is closely related to the conversion pattern of the printf function in C. A conversion pattern is composed of literal text and format control expressions called conversion specifiers. You are free to insert any literal text within the conversion pattern. Each conversion specifier starts with a percent sign (%) and is followed by optional format modifiers and a conversion character. The conversion character specifies the type of data, e.g. category, priority, date, thread name. The format modifiers control such things as field width, padding, left and right justification.Note that there is no explicit separator between text and conversion specifiers. The pattern parser knows when it has reached the end of a conversion specifier when it reads a conversion character. In the example above the conversion specifier %-5p means the priority of the logging event should be left justified to a width of five characters. The following conversion specifiers are currently supported:%c	 	- Used to output the category of the logging event.%d		- Used to output the timestamp of the logging event. For formatting info, see below.%l		- Used to output the name of the Logger associated with the event.%m		- Used to output the message associated with the logging event.%n		- Outputs the platform dependent line separator character or characters. %p		- Used to output the priority of the logging event.%t		- Outputs a tab character. %x		- Used to output the context  of the logging event.%%	- The sequence %% outputs a single percent sign. By default the relevant information is output as is. However, with the aid of format modifiers it is possible to change the minimum field width, the maximum field width and justification. The optional format modifier is placed between the percent sign and the conversion character. The first optional format modifier is the left justification flag which is just the minus (-) character. Then comes the optional minimum field width modifier. This is a decimal constant that represents the minimum number of characters to output. If the data item requires fewer characters, it is padded on either the left or the right until the minimum width is reached. The default is to pad on the left (right justify) but you can specify right padding with the left justification flag. The padding character is space. If the data item is larger than the minimum field width, the field is expanded to accommodate the data. The value is never truncated. This behavior can be changed using the maximum field width modifier which is designated by a period followed by a decimal constant. If the data item is longer than the maximum field, then the extra characters are removed from the beginning of the data item and not from the end. For example, it the maximum field width is eight and the data item is ten characters long, then the first two characters of the data item are dropped. This behavior deviates from the printf function in C where truncation is done from the end. Below are various format modifier examples for the category conversion specifier. Format		left   	min.	max.	comment modifier	justify	width	width%20c 		false 	20 		none 	Left pad with spaces if the category name is 									less than 20 characters long.  %-20c 		true 	20 		none 	Right pad with spaces if the category name is 									less than 20 characters long.  %.30c 		NA 		none 	30 		Truncate from the beginning if the category 									name is longer than 30 characters.  %20.30c 	false 	20 		30 		Left pad with spaces if the category name is 									shorter than 20 characters. However, if category 									name is longer than 30 characters, then truncate 									from the beginning.  %-20.30c 	true 	20 		30		Right pad with spaces if the category name is 									shorter than 20 characters. However, if category 									name is longer than 30 characters, then truncate from 									the beginning.  Outputting Dates:Used to output the date of the logging event. The date conversion specifier may be followed by a date format specifier enclosed between braces. For example, %d{HH:mm:ss,SSS} or %d{dd MMM yyyy HH:mm:ss,SSS}. If no date format specifier is given then ISO8601 format is assumed. The date format specifier admits the same syntax as the time pattern string of the SimpleDateFormat. Although part of the standard JDK, the performance of SimpleDateFormat is quite poor. For better results it is recommended to use the log4j date formatters. These can be specified using one of the strings "ABSOLUTE", "DATE" and "ISO8601" for specifying AbsoluteTimeDateFormat, DateTimeDateFormat and respectively ISO8601DateFormat. For example, %d{ISO8601} or %d{ABSOLUTE}. AbsoluteTimeDateFormat - Formats a Date in the format "HH:mm:ss,SSS" for example, "15:49:37,459". DateTimeDateFormat - Formats a Date in the format "dd MMM YYYY HH:mm:ss,SSS" for example, "06 Nov 1994 15:49:37,459". ISO8601DateFormat - Formats a Date in the format "YYYY-mm-dd HH:mm:ss,SSS" for example "1999-11-27 15:49:37,459". SimpleDateFormatThese dedicated date formatters perform significantly better than SimpleDateFormat. Instance Variables:	patternString	<String>	the formatString!!PatternLoggingFormatter class methodsFor: 'configuring'!mappingKey	^ 'pattern'			! !!PatternLoggingFormatter class methodsFor: 'instance creation'!new	^super new initialize			! !!PersephoneExample methodsFor: 'examples' stamp: 'md 4/15/2007 15:30'!exampleAssert	self assert: [^true].	^false! !!PersephoneExample methodsFor: 'examples' stamp: 'md 4/15/2007 15:30'!exampleAssertDelay	self assert: [(Delay forSeconds: 2) wait. true].! !!PersephoneExample methodsFor: 'examples' stamp: 'md 4/15/2007 14:41'!exampleSend	^ 1 sin.! !!PersephoneExample methodsFor: 'examples' stamp: 'md 3/20/2007 14:47'!exampleSimple	^ 1 ! !!PersephoneExample class methodsFor: 'accessing' stamp: 'md 3/31/2007 19:13'!compilerClass	^PECompiler! !!PersephoneExample class methodsFor: 'accessing' stamp: 'md 3/20/2007 17:24'!parseTreeFor: aSymbol	^(self compiledMethodAt: aSymbol) reflectiveMethod methodNode! !!PersephoneExample class methodsFor: 'compiling' stamp: 'md 3/20/2007 17:28'!recompile: selector from: oldClass	| jMethod |	jMethod := (oldClass >> selector) reflectiveMethodOrNil.	(jMethod notNil and: [ jMethod hasMethodClass not ]) ifTrue: [ jMethod methodClass: oldClass ].	super recompile: selector from: oldClass.	! !!PersephoneSystemTest methodsFor: 'tests' stamp: 'md 3/30/2007 16:42'!testInvalidateOrderedCollectionAdd		| cm1 cm2 |	PERecompiler new recompileClass: OrderedCollection.	cm1 := (OrderedCollection>>#add: ) invalidate.	cm2 := (OrderedCollection>>#add: ) invalidate.		self deny: cm1 == cm2. 	OrderedCollection compileAll.! !!PersephoneSystemTest methodsFor: 'tests' stamp: 'md 3/30/2007 16:42'!testRecompileOrderedCollection		PERecompiler new recompileClass: OrderedCollection.	(OrderedCollection>>#add: ) reflectiveMethod class = ReflectiveMethod.	OrderedCollection compileAll.! !!PersephoneTODO methodsFor: 'todo' stamp: 'md 7/26/2007 10:46'!todo'	- properties different between ReflectiveMethod and MethodNode 	- selector doubled between ReflectiveMethod and MethodNode 	- Problem: source slow --> save stop in property.	- check tests JMethod, move over.	-> RBSequenceNode: temporaries optionally	-> RBMethodNode: get binding from parent, no annotation	-> RBMethod ir as pragma	-> RBMethodNode>>primitiveNode: Generate from pragma. no iVar	-> RBMethodNode:  scope as properties	-> annotation as property	-> VariableNode: Token as annotation	-> RBProgramNode coments: return nil		'	! !!PersephoneTest methodsFor: 'tests - ast' stamp: 'md 11/21/2007 13:40'!testBlockArgs	| ast |	ast := PEParser new parseDoit: '[:a :b | 5 + 6]'.	self assert: (ast body statements at: 1) arguments first isVariableDefinition.	self assert: (ast body statements at: 1) arguments first isArg.! !!PersephoneTest methodsFor: 'tests' stamp: 'md 3/31/2007 19:45'!testCheckTwinClassBinding		| method |	PersephoneExample compileAll.	method :=  (PersephoneExample>>#exampleSimple).		self assert: method reflectiveMethod classBinding notNil.	self assert: method reflectiveMethod classBinding  == method compiledMethod classBinding.	! !!PersephoneTest methodsFor: 'tests' stamp: 'md 3/31/2007 19:46'!testCheckTwinClassBinding2		| method |	PERecompiler new recompileClass: PersephoneExample.	method :=  (PersephoneExample>>#exampleSimple).		self assert: method reflectiveMethod classBinding notNil.	self assert: method reflectiveMethod classBinding  == method compiledMethod classBinding.	! !!PersephoneTest methodsFor: 'tests' stamp: 'md 3/27/2007 20:14'!testCheckTwinConsistency	"When we nil out the methodNode, it will be recreated from source"		| method |	PersephoneExample compileAll. 	method :=  (PersephoneExample>>#exampleSimple).		self assert: method reflectiveMethod compiledMethod == method compiledMethod.		PersephoneExample new exampleSimple.	self assert: method reflectiveMethod compiledMethod == method compiledMethod.		! !!PersephoneTest methodsFor: 'tests' stamp: 'md 3/20/2007 17:26'!testCheckTwinSourcePointer		| method |	PersephoneExample compileAll.	method :=  (PersephoneExample>>#exampleSimple).		self assert: method reflectiveMethod sourcePointer > 0.	self assert: method reflectiveMethod sourcePointer  == method compiledMethod sourcePointer.			PersephoneExample new exampleSimple.	self assert: method reflectiveMethod compiledMethod == method compiledMethod.		! !!PersephoneTest methodsFor: 'tests' stamp: 'md 3/20/2007 14:48'!testDeleteMethodNode	"When we nil out the methodNode, it will be recreated from source"		PersephoneExample compileAll.	self assert: (PersephoneExample>>#exampleSimple) isReflectiveMethod.		self assert: ((PersephoneExample>>#exampleSimple) methodNode isKindOf: RBMethodNode).					(PersephoneExample>>#exampleSimple) methodNode: nil.	self assert: ((PersephoneExample>>#exampleSimple) methodNode  isKindOf: RBMethodNode).		PersephoneExample new exampleSimple.		self assert: (PersephoneExample>>#exampleSimple) isInvalid not.		! !!PersephoneTest methodsFor: 'tests' stamp: 'md 3/26/2007 12:08'!testHasReflectiveMethod	"When we nil out the methodNode, it will be recreated from source"		| method |	PersephoneExample compileAll.	method :=  (PersephoneExample>>#exampleSimple).		self assert: method hasReflectiveMethod.		PersephoneExample new exampleSimple.		self assert: method hasReflectiveMethod		! !!PersephoneTest methodsFor: 'tests' stamp: 'md 3/1/2007 21:36'!testInValidate	"When we compile a new method, this will be a RefectiveMethod"		PersephoneExample compileAll.	self assert: (PersephoneExample>>#exampleSimple) isReflectiveMethod.		self assert: (PersephoneExample>>#exampleSimple) isInvalid.					PersephoneExample new exampleSimple.		self assert: (PersephoneExample>>#exampleSimple) isInvalid not.			(PersephoneExample>>#exampleSimple) invalidate.	self assert: (PersephoneExample>>#exampleSimple) isReflectiveMethod.		self assert: (PersephoneExample>>#exampleSimple) isInvalid.! !!PersephoneTest methodsFor: 'tests' stamp: 'md 3/1/2007 20:29'!testRecompile	"When we compile a new method, this will be a RefectiveMethod"		PersephoneExample compileAll.	self assert: (PersephoneExample>>#exampleSimple) isReflectiveMethod.			"Now we run it. It a cm is generated"	PersephoneExample new exampleSimple.		self assert: (PersephoneExample>>#exampleSimple) isCompiledMethod.			PersephoneExample compileAll.	self assert: (PersephoneExample>>#exampleSimple) isReflectiveMethod.				! !!PersephoneTest methodsFor: 'tests' stamp: 'md 3/1/2007 20:51'!testRecompileInValid	"When we compile a new method, this will be a RefectiveMethod"		PersephoneExample compileAll.	self assert: (PersephoneExample>>#exampleSimple) isReflectiveMethod.		self assert: (PersephoneExample>>#exampleSimple) isInvalid.				PersephoneExample new exampleSimple.		self assert: (PersephoneExample>>#exampleSimple) isCompiledMethod.		self assert: (PersephoneExample>>#exampleSimple) isInvalid not.			PersephoneExample compileAll.	self assert: (PersephoneExample>>#exampleSimple) isReflectiveMethod.		self assert: (PersephoneExample>>#exampleSimple) isInvalid.					! !!PersephoneTest methodsFor: 'tests - literalCollector' stamp: 'md 4/16/2007 21:17'!testSimple	| collector |		collector := PELiteralCollector new visitNode: (PersephoneExample>>#exampleSend) methodNode.	self assert: collector literals =#(1 sin). ! !!PluggableButtonIRCeMorph methodsFor: 'accessing' stamp: 'sbw 5/11/2004 21:48'!adoptPaneColor: paneColor 	self		submorphsDo: [:m | m adoptPaneColor: paneColor].	Preferences gradientWindowLook		ifFalse: [^ self].	self borderWidth > 0		ifTrue: [self borderWidth: 1;				 borderColor: paneColor].! !!PluggableButtonMorph methodsFor: '*network-irc-gui' stamp: 'sbw 2/21/2002 21:40'!showSelectionFeedback: boolean	showSelectionFeedback _ boolean! !!PluggableIRCHighlightingListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/23/2004 11:46'!getList	"Answer the list to be displayed. Caches the returned list in the 'list' ivar"	getListSelector == nil		ifTrue: [^ #()].	model isNil		ifTrue: [^ #()].	list := model perform: getListSelector.	list == nil		ifTrue: [^ #()].	^ list! !!PluggableIRCHighlightingListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 09:10'!highlightSpecificMorph: aMorph color: aColor 	aMorph		ifNotNil: [aMorph color: aColor;				 changed]! !!PluggableIRCHighlightingListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/30/2004 09:08'!list: listOfStrings 	"Set the receiver's list as specified"	"sbw - special handling. If the list contains StringMorphs use them as-is."	| morphList h loc index converter item aSelector font |	scroller removeAllMorphs.	list := listOfStrings				ifNil: [Array new].	list isEmpty		ifTrue: [self setScrollDeltas.			^ self selectedMorph: nil].	"NOTE: we will want a quick StringMorph init message, possibly even  	combined with event install and positioning"	font := Preferences standardListFont.	converter := self valueOfProperty: #itemConversionMethod.	converter		ifNil: [converter := #asStringOrText].	morphList := list				collect: [:each | 					item := each.					item isStringMorph						ifFalse: [item := item perform: converter].					item isText						ifTrue: [StringMorph								contents: item								font: font								emphasis: (item emphasisAt: 1)]						ifFalse: [item isStringMorph								ifTrue: [item]								ifFalse: [StringMorph contents: item font: font]]].	(aSelector := self valueOfProperty: #balloonTextSelectorForSubMorphs)		ifNotNil: [morphList				do: [:m | m balloonTextSelector: aSelector]].	self highlightSelector		ifNotNil: [model				perform: self highlightSelector				with: list				with: morphList].	"Lay items out vertically and install them in the scroller"	h := morphList first height.	"self listItemHeight"	loc := 0 @ 0.	morphList		do: [:m | 			m				bounds: (loc extent: 9999 @ h).			loc := loc + (0 @ h)].	scroller addAllMorphs: morphList.	index := self getCurrentSelectionIndex.	self		selectedMorph: ((index = 0					or: [index > morphList size])				ifFalse: [morphList at: index]).	self setScrollDeltas.	scrollBar setValue: 0.0.	"The following line of code enables us to work both with and without  	Skins II."	(Smalltalk includesKey: #ImportedSkin)		ifTrue: [self perform: #setColorsFromSkin]! !!PluggableIRCHighlightingListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/23/2004 10:54'!listMorphClass	^ LazyIRCListMorph! !!PluggableIRCTextEntryMorph methodsFor: 'accessing' stamp: 'sbw 3/13/2005 01:00'!drawOn: aCanvas 	self tagWhenEmpty isNil		ifFalse: [self text isEmpty				ifTrue: [self tagWhenEmpty show]				ifFalse: [self tagWhenEmpty hide]].	super drawOn: aCanvas! !!PluggableIRCTextEntryMorph methodsFor: 'accessing' stamp: 'sbw 3/13/2005 00:14'!tagWhenEmpty	^tagWhenEmpty! !!PluggableIRCTextEntryMorph methodsFor: 'accessing' stamp: 'sbw 3/13/2005 00:58'!tagWhenEmpty: aTextMorph 	tagWhenEmpty := aTextMorph.	aTextMorph isNil		ifFalse: [aTextMorph setToAdhereToEdge: #adjustedCenter.			self addMorph: aTextMorph]! !!PluggableIRCTextEntryMorph methodsFor: 'as yet unclassified' stamp: 'sbw 3/13/2005 00:13'!wantsFrameAdornments	^ false! !!PluggableIRCTextEntryMorph commentStamp: '<historical>' prior: 0!Used in the channels browser for filters input from user.!!PluggableIRCTextMorph methodsFor: 'as yet unclassified' stamp: 'sbw 2/19/2002 22:31'!handlesKeyboard: evt 	^ true! !!PluggableIRCTextMorph methodsFor: 'as yet unclassified' stamp: 'sbw 2/28/2002 22:01'!keyStroke: evt 	keysInputPane isNil		ifFalse: [keysInputPane keyStroke: evt]! !!PluggableIRCTextMorph methodsFor: 'as yet unclassified' stamp: 'sbw 2/19/2002 22:42'!keysInputPane: obj	keysInputPane _ obj! !!PluggableIRCTextMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 07:11'!setText: aText 	scrollBar setValue: 0.0.	textMorph		ifNil: [textMorph := TextMorphIRCEditView new contents: aText wrappedTo: self innerBounds width - 6.			textMorph setEditView: self.			textMorph keysRecvr: self.			scroller addMorph: textMorph]		ifNotNil: [textMorph newContents: aText].	self hasUnacceptedEdits: false.	self setScrollDeltas! !!PluggableInterceptingIRCTextMorph methodsFor: 'as yet unclassified' stamp: 'sbw 2/23/2002 12:56'!addIntercept: char 	^ textMorph addIntercept: char ! !!PluggableInterceptingIRCTextMorph methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 13:46'!clearInterceptActive	^ textMorph clearInterceptActive! !!PluggableInterceptingIRCTextMorph methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 13:51'!interceptActive	^ textMorph interceptActive! !!PluggableInterceptingIRCTextMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/27/2004 07:16'!setText: aText 	"The only way we differ from our parent is by specifying a unique  	edit view class."	scrollBar setValue: 0.0.	textMorph		ifNil: [textMorph := TextMorphForInterceptingIRCEditView new contents: aText wrappedTo: self innerBounds width - 6.			textMorph setEditView: self.			scroller addMorph: textMorph]		ifNotNil: [textMorph newContents: aText].	self hasUnacceptedEdits: false.	self setScrollDeltas! !!PluggableMultiColumnIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/19/2004 21:20'!calculateColumnOffsetsFrom: maxWidths 	| offsets previous current |	offsets := Array new: maxWidths size.	1		to: offsets size		do: [:indx | offsets at: indx put: (maxWidths at: indx)].	2		to: offsets size		do: [:indx | 			previous := offsets at: indx - 1.			current := offsets at: indx.			current := previous + current.			offsets at: indx put: current].	^ offsets! !!PluggableMultiColumnIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/23/2004 07:47'!calculateColumnWidthsFrom: arrayOfMorphs 	| maxWidths hMorph widest padRight |	maxWidths := Array new: arrayOfMorphs size - 1.	padRight := 8.	listMorph isNil ifFalse: [listMorph listChanged].	1		to: maxWidths size		do: [:idx | 			hMorph := headerStrings at: idx.			hMorph fitContents.			widest := hMorph width + 10.			listMorph isNil				ifFalse: [listMorph columnWidths isNil						ifFalse: [widest := widest										max: (listMorph columnWidths at: idx)]].			maxWidths at: idx put: widest + padRight].	^ maxWidths! !!PluggableMultiColumnIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/13/2004 13:07'!createHeaderMorphsFrom: collection 	| strMorph result headerFont |	headerFont := Preferences windowTitleFont.	result := OrderedCollection new.	headerHeight := 0.	collection		do: [:str | 			strMorph := str isText						ifTrue: [StringMorph								contents: str								font: headerFont								emphasis: (str emphasisAt: 1)]						ifFalse: [StringMorph								contents: str								font: headerFont								emphasis: 1].			headerHeight < strMorph height				ifTrue: [headerHeight := strMorph height].			result add: strMorph].	headerHeight := headerHeight + 4.	^ result! !!PluggableMultiColumnIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 3/3/2002 19:02'!drawHeaderBackgroundOn: aCanvas 	| colorToUse |	colorToUse _ headerBackColor == nil				ifTrue: [Color white]				ifFalse: [headerBackColor].	aCanvas fillRectangle: self headerRect color: colorToUse! !!PluggableMultiColumnIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/23/2004 08:30'!drawHeaderLinesOn: aCanvas 	self listMorph isNil		ifFalse: [self drawHeaderLinesUsingListMorphWidthsOn: aCanvas]! !!PluggableMultiColumnIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/23/2004 08:35'!drawHeaderLinesUsingListMorphWidthsOn: aCanvas 	| dividerColor hRect translate widths org dst cw vert horz vLineWidth pad |	widths := self listMorph columnWidths.	widths isNil ifTrue: [^self].	dividerColor := Color lightGray.	hRect := self headerRect.	org := hRect bottomLeft.	dst := hRect bottomRight.	aCanvas		line: org		to: dst		width: 2		color: dividerColor.	widths size > 1		ifFalse: [^ self].	translate := hRect topLeft.	vert := headerHeight + self innerBounds height.	vLineWidth := 1.	pad := self listMorph columnPadding // 2.	pad := pad - vLineWidth.	horz := 0.	1		to: widths size - 1		do: [:index | 			cw := widths at: index.			horz := horz + cw.			horz := horz + pad.			org := horz @ 0 translateBy: translate.			dst := horz @ vert translateBy: translate.			aCanvas				line: org				to: dst				width: vLineWidth				color: dividerColor]! !!PluggableMultiColumnIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/23/2004 08:37'!drawHeaderStringsOn: aCanvas 	self listMorph isNil		ifFalse: [self drawHeaderStringsUsingListMorphWidthsOn: aCanvas].! !!PluggableMultiColumnIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/23/2004 08:47'!drawHeaderStringsUsingListMorphWidthsOn: aCanvas 	| hRect translate posn widths horz pad strMorph cw |	widths := self listMorph columnWidths.	(widths isNil or: [headerStrings == nil]) ifTrue: [^ self].	hRect := self headerRect.	translate := hRect topLeft + (2 @ 2).	horz _ 0.	pad _ 0.	1 to: headerStrings size do: [:index |		strMorph _ headerStrings at: index.		posn _ horz @ 0 translateBy: translate.		strMorph			position: posn;			drawOn: aCanvas.		cw _ widths at: index.		horz _ horz + cw + pad		]! !!PluggableMultiColumnIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/23/2004 08:03'!drawOn: aCanvas 	super drawOn: aCanvas.	self drawHeaderBackgroundOn: aCanvas.	self drawHeaderLinesOn: aCanvas.	self drawHeaderStringsOn: aCanvas! !!PluggableMultiColumnIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 3/3/2002 18:48'!headerBackColor: aColor	headerBackColor _ aColor! !!PluggableMultiColumnIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/21/2004 22:23'!headerRect	^ (scroller bounds topLeft translateBy: 0 @ headerHeight negated)		corner: (scroller bounds topLeft translateBy: scroller bounds width @ 0)! !!PluggableMultiColumnIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/1/2004 18:35'!headerStrings	headerStrings isNil ifTrue: [^Array new: 1].	^ headerStrings! !!PluggableMultiColumnIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 3/3/2002 15:48'!headerStrings: collection 	"We get a list of strings. Convert them to morphs and then save them."	headerStrings _ self createHeaderMorphsFrom: collection! !!PluggableMultiColumnIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 3/3/2002 17:27'!innerBounds	| inner |	inner _ super innerBounds copy.	headerHeight isNil ifFalse: [		inner _ inner withTop: (inner top + headerHeight)		].	^ inner! !!PluggableMultiColumnIRCListMorph methodsFor: 'as yet unclassified' stamp: 'sbw 5/21/2004 20:13'!listMorphClass	^ MulticolumnLazyIRCListMorph! !!PluggableMultiColumnIRCListMorph class methodsFor: 'as yet unclassified' stamp: 'sbw 5/1/2004 17:53'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel headerStrings: headers 	| listMorph |	listMorph := self new.	listMorph headerStrings: headers.	listMorph		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: nil		keystroke: #arrowKey:from:.	^ listMorph! !!PluggableTextMorph methodsFor: '*network-irc-gui' stamp: 'sbw 1/11/2003 09:26'!replaceSetTextSelector: aSymbol	setTextSelector _ aSymbol! !!PragmaTest methodsFor: 'accessing' stamp: 'ms 9/4/2006 00:25'!expectedFailures	Smalltalk at: #ExternalFunction ifAbsent:[^#(#testApicall #testCdecl #testCdeclNoModule)].	^#()! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/19/2006 00:12'!methodApicall	^'methodApicall: aHWND		<apicall: Win32HDC ''GetDC'' (Win32Window bool bool*) module: ''user32.dll''>		^self externalCallFailed'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/19/2006 00:15'!methodCdecl	^'XCloseDisplay: aDisplay		<cdecl: void ''XCloseDisplay'' (X11Display*) module:''X11''>		^self externalCallFailed'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/25/2006 08:36'!methodCdeclNoModule	^'ffiTestShort: c1 with: c2 with: c3 with: c4		"FFITester ffiTestShort: $A with: 65 with: 65.0 with: $A"		<cdecl: short ''ffiTestShorts'' (short short short short)>		^self externalCallFailed'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/16/2006 21:03'!methodDoublePragma	^'methodDoublePragma		<hello: 5>		<hello: 2>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/16/2006 20:56'!methodDoublePrimitive	^'methodDoublePrimitive		<primitive: 5>		<primitive: 2>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/26/2006 22:53'!methodNoPragma	^'methodNoPragma: aNum		^aNum'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/16/2006 21:04'!methodPragmaAfterBeforTemps	^'methodPragmaAfterBeforTemps		<hello: 5>		| aTemp |		<world: #ok>		<blue: true>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/20/2006 20:49'!methodPragmaTwoParam	^'methodDoublePragma		<hello: 5 by: 2>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/25/2006 07:56'!methodPragmaUnarayMessage	^'methodPragmaUnarayMessage		<hello>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/16/2006 21:05'!methodPrimitive	^'methodPrimitive		<primitive: 4>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/16/2006 21:05'!methodPrimitivePragma	^'methodPrimitivePragma		<hello: 1>		<primitive: 4>		<hello: 1>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/22/2006 13:31'!methodPrimitiveString	^'methodPrimitiveString		<primitive: ''aFunctionName''>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/22/2006 13:33'!methodPrimitiveStringModule	^'methodPrimitiveStringModule		<primitive: ''aFunctionName'' module: ''aModuleName''>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/16/2006 21:06'!methodSinglePragma	^'methodSinglePragma		<hello: 5>'! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/19/2006 00:10'!testApicall	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodApicall in: self class notifying: [nil].		self assert: ((aRBMethode compiledMethod literalAt: 1) isKindOf: ExternalLibraryFunction).	self assert: (aRBMethode compiledMethod primitive = 120)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/19/2006 00:15'!testCdecl	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodCdecl in: self class notifying: [nil].		self assert: ((aRBMethode compiledMethod literalAt: 1) isKindOf: ExternalLibraryFunction).	self assert: (aRBMethode compiledMethod primitive = 120)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/25/2006 08:37'!testCdeclNoModule	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodCdeclNoModule in: self class notifying: [nil].		self assert: ((aRBMethode compiledMethod literalAt: 1) isKindOf: ExternalLibraryFunction).	self assert: (aRBMethode compiledMethod primitive = 120)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/16/2006 21:03'!testDoublePragma	| aRBMethode |	"self debug: #testDoublePragma"	aRBMethode := ClosureCompiler new parseClosure: self methodDoublePragma in: self class notifying: [nil].		self assert: (aRBMethode compiledMethod pragmas first keyword = #hello:).	self assert: (aRBMethode compiledMethod pragmas second keyword = #hello:)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 9/4/2006 00:24'!testDoublePrimitive	"self debug: #testDoublePrimitive"	self should: [ClosureCompiler new parseClosure: self methodDoublePrimitive in: self class notifying: [^nil]] raise: Warning! !!PragmaTest methodsFor: 'testing' stamp: 'pmm 8/19/2006 22:18'!testIsPrimitve	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodPrimitive in: self class notifying: [nil].		self assert: aRBMethode isPrimitive! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/26/2006 22:54'!testNoPragma	"self debug: #testDoublePrimitive"	self shouldnt: [ClosureCompiler new parseClosure: self methodNoPragma in: self class notifying: nil] raise: Error! !!PragmaTest methodsFor: 'testing' stamp: 'ms 9/10/2006 20:21'!testPragmaAfterBeforTemp	"self debug: #testPragmaAfterBeforTemp"	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodPragmaAfterBeforTemps in: self class notifying: nil.	self assert: (aRBMethode compiledMethod pragmas first keyword = #hello:).	self assert: (aRBMethode compiledMethod pragmas second keyword = #world:)	! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/20/2006 20:50'!testPragmaTwoParam	"self debug: #testPragmaAfterBeforTemp"	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodPragmaTwoParam in: self class notifying: nil.	self assert: (aRBMethode compiledMethod pragmas first keyword = #hello:by:)	! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/25/2006 07:57'!testPragmaUnarayMessage	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodPragmaUnarayMessage in: self class notifying: [nil].		self assert: (aRBMethode compiledMethod pragmas first keyword = #hello)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/16/2006 21:05'!testPrimitiveNumber	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodPrimitive in: self class notifying: [nil].		self assert: (aRBMethode compiledMethod primitive = 4)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 9/4/2006 00:33'!testPrimitivePragmaNumber	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodPrimitivePragma in: self class notifying: [^nil].		self assert: (aRBMethode compiledMethod primitive = 4)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/22/2006 13:31'!testPrimitiveString	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodPrimitiveString in: self class notifying: [nil].		self assert: (aRBMethode compiledMethod primitive = 117)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/22/2006 13:33'!testPrimitiveStringModule	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodPrimitiveStringModule in: self class notifying: [nil].		self assert: (aRBMethode compiledMethod primitive = 117)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/16/2006 21:06'!testSinglePragma	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodSinglePragma in: self class notifying: [nil].	self assert: (aRBMethode compiledMethod pragmas first keyword = #hello:)	! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:12'!setWindowColorFor: modelSymbol to: incomingColor	| aColor aPrefSymbol aColorSpec |	aColorSpec := WindowColorRegistry registeredWindowColorSpecFor: modelSymbol.	aColorSpec ifNil: [^self].	aColor := incomingColor asNontranslucentColor.	(aColor = ColorPickerMorph perniciousBorderColor or: [aColor = Color black]) 		ifTrue: [^ self].		aPrefSymbol :=  self windowColorPreferenceForClassNamed: aColorSpec classSymbol.	self 		addPreference: aPrefSymbol  		categories:  { #'window colors' }		default:  aColor 		balloonHelp: aColorSpec helpMessage translated		projectLocal: false		changeInformee: nil		changeSelector: nil		viewRegistry: (PreferenceViewRegistry registryOf: #windowColorPreferences)! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:13'!windowColorFor: aModelClassName	| classToCheck prefSymbol |	self checkForWindowColors.	classToCheck := Smalltalk at: aModelClassName.	prefSymbol := self windowColorPreferenceForClassNamed: classToCheck name.	[(classToCheck ~~ Object) and: [(self preferenceAt: prefSymbol) isNil]]		whileTrue: 				[classToCheck := classToCheck superclass.				prefSymbol := self windowColorPreferenceForClassNamed: classToCheck name].	^self valueOfPreference: prefSymbol ifAbsent: [Color white].! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:14'!windowSpecificationPanel	"Put up a panel for specifying window colors"	"Preferences windowSpecificationPanel"	| aPanel buttonRow aButton aRow aSwatch aColor aWindow aMiniWorld aStringMorph |	aPanel := AlignmentMorph newColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap;		layoutInset: 0.	aPanel addMorph: (buttonRow := AlignmentMorph newRow color: (aColor := Color tan lighter)).		buttonRow addTransparentSpacerOfSize: 2@0.	buttonRow addMorphBack: (SimpleButtonMorph new label: '?'; target: self; actionSelector: #windowColorHelp; setBalloonText: 'Click for an explanation of this panel'; color: Color veryVeryLightGray; yourself).	buttonRow addTransparentSpacerOfSize: 8@0.	#(	('Bright' 	installBrightWindowColors	yellow					'Use standard bright colors for all windows.')		('Pastel'		installPastelWindowColors	paleMagenta					'Use standard pastel colors for all windows.')		('White'	installUniformWindowColors		white					'Use white backgrounds for all standard windows.')) do:		[:quad |			aButton := (SimpleButtonMorph new target: self)				label: quad first;				actionSelector: quad second;				color: (Color colorFrom: quad third);				setBalloonText: quad fourth;				yourself.			buttonRow addMorphBack: aButton.			buttonRow addTransparentSpacerOfSize: 10@0].	self windowColorTable do:		[:colorSpec | 			aRow _ AlignmentMorph newRow color: aColor.			aSwatch _ ColorSwatch new				target: self;				getSelector: #windowColorFor:;				putSelector: #setWindowColorFor:to:;				argument: colorSpec classSymbol;				extent: (40 @ 20);				setBalloonText: 'Click here to change the standard color to be used for ', colorSpec wording, ' windows.';				yourself.			aRow addMorphFront: aSwatch.			aRow addTransparentSpacerOfSize: (12 @ 1).			aRow addMorphBack: (aStringMorph := StringMorph contents: colorSpec wording font: TextStyle defaultFont).			aStringMorph setBalloonText: colorSpec helpMessage.			aPanel addMorphBack: aRow].	 Smalltalk isMorphic                ifTrue:                        [aWindow := aPanel wrappedInWindowWithTitle: 'Window Colors'.					" don't allow the window to be picked up by clicking inside "					aPanel on: #mouseDown send: #yourself to: aPanel.					self currentWorld addMorphCentered: aWindow.					aWindow activateAndForceLabelToShow ]                ifFalse:                        [(aMiniWorld := MVCWiWPasteUpMorph newWorldForProject: nil)						addMorph: aPanel.                           aMiniWorld startSteppingSubmorphsOf: aPanel.                        MorphWorldView openOn: aMiniWorld                                label: 'Window Colors'                                extent: aMiniWorld fullBounds extent]! !!Process methodsFor: '*ProcessSpecific' stamp: 'mvl 3/13/2007 12:24'!environmentAt: key 	^self environmentAt: key ifAbsent:[nil]! !!Process methodsFor: '*ProcessSpecific' stamp: 'mvl 3/13/2007 12:24'!environmentAt: key  ifAbsent: aBlock	env ifNil: [ ^ aBlock value ].	^env at: key ifAbsent: aBlock.! !!Process methodsFor: '*ProcessSpecific' stamp: 'mvl 3/13/2007 12:12'!environmentAt: key put: value	env ifNil: [ env _ Dictionary new ].	env at: key put: value.! !!Process methodsFor: '*context' stamp: 'ms 10/31/2007 16:00'!ctxtEnvironmentAt: key  ifAbsentPut: aBlock		"ly for context awar link of geppetto."	env ifNil: [ env := Dictionary new].	^env ctxtAt: key ifAbsentPut: aBlock.! !!ProcessLocalVariable commentStamp: 'mvl 3/13/2007 12:28' prior: 0!My subclasses have values specific to the active process. They can be read with #value and set with #value:!!ProcessLocalVariable class methodsFor: 'accessing' stamp: 'mvl 3/13/2007 14:27'!value: anObject	Processor activeProcess environmentAt: self put: anObject! !!ProcessSpecificTest methodsFor: 'testing' stamp: 'mvl 3/13/2007 14:13'!checkDynamic: value	self assert: TestDynamicVariable value = value! !!ProcessSpecificTest methodsFor: 'testing' stamp: 'mvl 3/13/2007 14:13'!checkLocal: value	self assert: TestLocalVariable value = value! !!ProcessSpecificTest methodsFor: 'testing' stamp: 'mvl 3/13/2007 15:02'!testDynamicVariable	| s1 s2 p1stopped p2stopped |	s1 := Semaphore new.	s2 := Semaphore new.	p1stopped := p2stopped := false.	[		TestDynamicVariable value: 1 during:[			self checkDynamic: 1.			(Delay forMilliseconds: 30) wait.			self checkDynamic: 1.			TestDynamicVariable value: 3 during:[				(Delay forMilliseconds: 30) wait.				self checkDynamic: 3			].			self checkDynamic: 1.		].		self checkDynamic: nil.		p1stopped := true.		s1 signal.	] fork.	[		TestDynamicVariable value: 2 during:[			self checkDynamic: 2.			(Delay forMilliseconds: 30) wait.			self checkDynamic: 2.		].		self checkDynamic: nil.		p2stopped := true.		s2 signal.	] fork.	"Set a maximum wait timeout so that the test case will complete 	 even if the processes fail to signal us."	s1 waitTimeoutSeconds: 2.	s2 waitTimeoutSeconds: 2.	self assert: p1stopped.	self assert: p2stopped.! !!ProcessSpecificTest methodsFor: 'testing' stamp: 'mvl 3/13/2007 15:03'!testLocalVariable	| s1 s2 p1stopped p2stopped |	s1 := Semaphore new.	s2 := Semaphore new.	p1stopped := p2stopped := false.	[		self checkLocal: 0.		TestLocalVariable value: 1.		self checkLocal: 1.		(Delay forMilliseconds: 30) wait.		self checkLocal: 1.		TestLocalVariable value: 2.		self checkLocal: 2.		p1stopped := true.		s1 signal.	] fork.	[		(Delay forMilliseconds: 30) wait.		self checkLocal: 0.		TestLocalVariable value: 3.		self checkLocal: 3.		(Delay forMilliseconds: 30) wait.		self checkLocal: 3.		TestLocalVariable value: 4.		self checkLocal: 4.		p2stopped := true.		s2 signal.	] fork.	"Set a maximum wait timeout so that the test case will complete 	 even if the processes fail to signal us."	s1 waitTimeoutMSecs: 5000.	s2 waitTimeoutMSecs: 5000.	self assert: p1stopped.	self assert: p2stopped.! !!ProcessSpecificTest commentStamp: 'mvl 3/13/2007 13:52' prior: 0!A ProcessSpecificTest is a test case for process local and dynamic variables.!!ProcessSpecificVariable commentStamp: 'mvl 3/13/2007 13:53' prior: 0!My subclasses (not instances of them) keep state specific to the current process.There are two kinds of process-specific variables: process-local (state availablefor read and write in all methods inside the process), and dynamic variables(implementing dynamic scope).!!ProcessSpecificVariable class methodsFor: 'accessing' stamp: 'mvl 3/13/2007 14:32'!default	"Answer the default value for the variable. The default for the default value is nil."	^nil! !!ProcessSpecificVariable class methodsFor: 'accessing' stamp: 'mvl 3/13/2007 15:13'!hash	hash ifNil:[hash := super hash].	^hash! !!ProcessSpecificVariable class methodsFor: 'accessing' stamp: 'mvl 3/13/2007 14:33'!value	"Answer the current value for this variable in the current context."	^Processor activeProcess environmentAt: self ifAbsent: [self default].! !!ProcessSpecificVariable class methodsFor: 'class initialization' stamp: 'mvl 3/13/2007 16:07'!initialize	"Add Process::env if it is missing"		(Process instVarNames includes: 'env')	ifFalse: [ Process addInstVarName: 'env'].! !!ProgrammaticNoInlineAnnotation methodsFor: 'testing' stamp: 'pmm 11/4/2006 18:41'!isSourceVisible	^false! !!ProgrammaticNoInlineAnnotation class methodsFor: 'accessing' stamp: 'pmm 11/4/2006 18:41'!keys	^#()! !!ProtectInstanceVariableRefactoring methodsFor: 'private-accessing'!getterSetterMethods	| matcher |	matcher := ParseTreeSearcher new.	matcher		answer: Set new;		matchesAnyMethodOf: (Array 					with: '`method ^' , variableName					with: ('`method: `arg <1s> := `arg' expandMacrosWith: variableName)					with: ('`method: `arg ^<1s> := `arg' expandMacrosWith: variableName))			do: 				[:aNode :answer | 				(class subclassRedefines: aNode selector) 					ifFalse: [answer add: aNode selector].				answer].	(class whichSelectorsReferToInstanceVariable: variableName) do: 			[:each | 			self 				checkClass: class				selector: each				using: matcher].	^matcher answer! !!ProtectInstanceVariableRefactoring methodsFor: 'transforming'!inline: aSelector 	self onError: 			[self performComponentRefactoring: (InlineAllSendersRefactoring 						model: self model						sendersOf: aSelector						in: class)]		do: []! !!ProtectInstanceVariableRefactoring methodsFor: 'transforming'!transform	self setOption: #inlineExpression toUse: [:ref :string | true].	self getterSetterMethods do: [:each | self inline: each]! !!ProtectInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition definesInstanceVariable: variableName in: class! !!ProtectInstanceVariableTest methodsFor: 'tests'!testProtectInstanceVariable	| refactoring class |	refactoring := ProtectInstanceVariableRefactoring 				variable: 'rewrite' , 'Rule1'				class: SubclassOfClassToRename.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #SubclassOfClassToRename.	self 		assert: (class parseTreeFor: #calls1) = (RBParser 						parseMethod: 'calls1								^rewriteRule1 := (rewriteRule1 := self calls)').	self 		assert: (class parseTreeFor: #calls) = (RBParser 						parseMethod: 'calls								^rewriteRule1 := rewriteRule1 , rewriteRule1').	self deny: (class directlyDefinesMethod: ('rewrite' , 'Rule1') asSymbol).	self deny: (class directlyDefinesMethod: ('rewrite' , 'Rule1:') asSymbol)! !!ProtectInstanceVariableTest methodsFor: 'failure tests' stamp: 'bh 4/29/2000 21:33'!testVariableNotDefined	| refactoring |	refactoring := ProtectInstanceVariableRefactoring variable: 'rewrite' class: SubclassOfClassToRename.	self shouldFail: refactoring.! !!ProtoObject methodsFor: '*newcompiler' stamp: 'ms 4/23/2007 17:46'!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	"Normally this method is inlined but when blocks are stored 	in temporaries and passed by argument this method is called."	^ ifNotNilBlock valueWithPossibleArgs: {self}! !!ProtoObject methodsFor: '*newcompiler' stamp: 'ms 4/23/2007 17:47'!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	"Normally this method is inlined but when blocks are stored 	in temporaries and passed by argument this method is called."	^ ifNotNilBlock valueWithPossibleArgs: {self}! !!ProtocolEnvironment methodsFor: 'initialize-release'!class: aClass protocols: aCollection	class := aClass.	protocols := aCollection! !!ProtocolEnvironment methodsFor: 'private'!defaultLabel	| stream |	stream := String new writeStream.	stream nextPutAll: class name;		nextPut: $>.	protocols do: 			[:each | 			stream nextPutAll: each;				nextPut: $ ].	^stream contents! !!ProtocolEnvironment methodsFor: 'testing'!includesCategory: aCategory	^(super includesCategory: aCategory)		and: [(environment classNamesFor: aCategory)				inject: false into: [:bool :each | bool					or:						[| aClass |						aClass := Smalltalk at: each ifAbsent: [nil].						aClass == class or: [aClass class == class]]]]! !!ProtocolEnvironment methodsFor: 'testing'!includesClass: aClass	^aClass == class and: [super includesClass: aClass]! !!ProtocolEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass	^aClass == class and: [(super includesProtocol: aProtocol in: aClass)			and: [protocols includes: aProtocol]]! !!ProtocolEnvironment methodsFor: 'testing'!includesSelector: aSelector in: aClass 	^(super includesSelector: aSelector in: aClass) and: 			[protocols 				includes: (environment whichProtocolIncludes: aSelector in: aClass)]! !!ProtocolEnvironment methodsFor: 'testing'!isEmpty	^protocols isEmpty! !!ProtocolEnvironment methodsFor: 'copying'!postCopy	protocols := protocols copy.	^super postCopy! !!ProtocolEnvironment methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	super storeOn: aStream.	aStream		nextPutAll: ' class: ';		nextPutAll: class name;		nextPutAll: ' protocols: '.	protocols asArray storeOn: aStream.	aStream nextPut: $)! !!ProtocolEnvironment class methodsFor: 'instance creation'!onEnvironment: anEnvironment class: aClass protocols: aCollection	^(self onEnvironment: anEnvironment)		class: aClass protocols: aCollection; yourself! !!PullUpClassVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isMetaclass: class) not! !!PullUpClassVariableRefactoring methodsFor: 'private-accessing'!subclassDefiningVariable	| subclasses |	subclasses := class allSubclasses 				select: [:each | each directlyDefinesClassVariable: variableName].	subclasses isEmpty 		ifTrue: 			[self refactoringError: 'Could not find a class defining ' , variableName].	subclasses size > 1 		ifTrue: [self refactoringError: 'Multiple subclasses define ' , variableName].	^subclasses asArray first! !!PullUpClassVariableRefactoring methodsFor: 'transforming'!transform	| subclass |	subclass := self subclassDefiningVariable.	subclass removeClassVariable: variableName.	class addClassVariable: variableName! !!PullUpClassVariableTest methodsFor: 'failure tests'!testMetaClassFailure	self 		shouldFail: (PullUpClassVariableRefactoring variable: #RecursiveSelfRule				class: LintRuleTest class)! !!PullUpClassVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (PullUpClassVariableRefactoring variable: #Foo				class: LintRuleTest)! !!PullUpClassVariableTest methodsFor: 'tests'!testPullUpClassVariable	| refactoring |	refactoring := PullUpClassVariableRefactoring variable: #RecursiveSelfRule				class: LintRuleTest.	self executeRefactoring: refactoring.	self assert: ((refactoring model classNamed: #LintRuleTest) 				directlyDefinesClassVariable: #RecursiveSelfRule).	self deny: ((refactoring model classNamed: #TransformationRuleTest) 				directlyDefinesClassVariable: #RecursiveSelfRule)! !!PullUpInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition withBlock: 			[(class hierarchyDefinesInstanceVariable: variableName) 				ifFalse: [self refactoringError: 'No subclass defines ' , variableName].			(class subclasses 				detect: [:each | (each directlyDefinesInstanceVariable: variableName) not]				ifNone: [nil]) notNil 				ifTrue: 					[self 						refactoringWarning: 'Not all subclasses have an instance variable named ' 								, variableName , '.'].			true]! !!PullUpInstanceVariableRefactoring methodsFor: 'transforming'!transform	class allSubclasses do: 			[:each | 			(each directlyDefinesInstanceVariable: variableName) 				ifTrue: [each removeInstanceVariable: variableName]].	class addInstanceVariable: variableName! !!PushDownClassVariableRefactoring methodsFor: 'preconditions' stamp: 'rr 3/11/2004 22:03'!findDestinationClass	| classVarName classes classVar cond |	classVarName := variableName asSymbol.	classVar := class realClass classPool associationAt: classVarName.	cond := [:eachClass | ((eachClass allCallsOn: classVar) 							select: [:eachRef | eachRef actualClass = eachClass])  isEmpty].	classes := class withAllSubclasses reject: [:each | (cond value: each realClass) 												and: [cond value: each realClass class]].	destinationClass := classes isEmpty ifTrue: [nil] ifFalse: [classes asOrderedCollection  first].	classes do: 			[:each | 			(destinationClass includesClass: each) 				ifTrue: [destinationClass := each]				ifFalse: 					[(each includesClass: destinationClass) 						ifFalse: [self signalMultipleReferenceError]]].	destinationClass = class ifTrue: [self signalStillReferencedError].	^destinationClass! !!PushDownClassVariableRefactoring methodsFor: 'preconditions'!preconditions	"Preconditions are that only one subclass refers to the class variable."	^(RBCondition definesClassVariable: variableName in: class) 		& (RBCondition withBlock: 					[self findDestinationClass.					true])! !!PushDownClassVariableRefactoring methodsFor: 'preconditions'!signalMultipleReferenceError	self signalReferenceError: ('Multiple subclasses reference <1s>' 				expandMacrosWith: variableName)! !!PushDownClassVariableRefactoring methodsFor: 'preconditions'!signalReferenceError: errorString 	class realClass isNil 		ifTrue: [self refactoringError: errorString]		ifFalse: 			[| classVarName error |			error := '<1s><n>Browse references?' expandMacrosWith: errorString.			classVarName := variableName asSymbol.			self refactoringError: error				with: 					[self 						openBrowserOn: (VariableEnvironment referencesToClassVariable: classVarName								in: class realClass)]]! !!PushDownClassVariableRefactoring methodsFor: 'preconditions'!signalStillReferencedError	self signalReferenceError: ('<1p> has references to <2s>' 				expandMacrosWith: class				with: variableName)! !!PushDownClassVariableRefactoring methodsFor: 'transforming'!transform	class removeClassVariable: variableName.	destinationClass isNil ifTrue: [^self].	destinationClass addClassVariable: variableName! !!PushDownClassVariableTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:09'!testModelNonExistantName	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	self shouldFail: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: (model classNamed: #SomeClass))! !!PushDownClassVariableTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:09'!testModelPushDownToMultipleSubclassesFailure	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #Subclass) compile: 'foo ^Foo' classified: #(#accessing).	model 		defineClass: 'SomeClass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model metaclassNamed: #AnotherSubclass) compile: 'bar ^Foo'		classified: #(#accessing).	self shouldFail: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: (model classNamed: #SomeClass))! !!PushDownClassVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (PushDownClassVariableRefactoring variable: #Foo				class: BasicLintRuleTest)! !!PushDownClassVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:09'!testModelPushDownVariable	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model classNamed: #Subclass.	class compile: 'foo ^Foo' classified: #(#accessing).	self executeRefactoring: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: class superclass).	self deny: (class superclass directlyDefinesClassVariable: #Foo).	self assert: (class directlyDefinesClassVariable: #Foo)! !!PushDownClassVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:09'!testModelPushDownVariableToClassDownTwoLevels	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model metaclassNamed: #AnotherSubclass.	class compile: 'bar ^Foo' classified: #(#accessing).	class := class nonMetaclass.	self executeRefactoring: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: class superclass superclass).	self 		deny: (class superclass superclass directlyDefinesClassVariable: #Foo).	self deny: (class superclass directlyDefinesClassVariable: #Foo).	self assert: (class directlyDefinesClassVariable: #Foo)! !!PushDownClassVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:10'!testModelPushDownVariableToMultipleClassesInSameHierarchy	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model classNamed: #Subclass.	class compile: 'foo ^Foo' classified: #(#accessing).	model 		defineClass: 'Subclass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model metaclassNamed: #AnotherSubclass) compile: 'bar ^Foo'		classified: #(#accessing).	self executeRefactoring: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: class superclass).	self deny: (class superclass directlyDefinesClassVariable: #Foo).	self assert: (class directlyDefinesClassVariable: #Foo)! !!PushDownClassVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:10'!testModelRemoveUnusedVariable	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	self 		assert: ((model classNamed: #SomeClass) directlyDefinesVariable: #Foo).	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	self executeRefactoring: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: (model classNamed: #SomeClass)).	self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: #Foo).	self deny: ((model classNamed: #Subclass) directlyDefinesVariable: #Foo)! !!PushDownClassVariableTest methodsFor: 'tests'!testPushDownClassVariable	| refactoring |	refactoring := PushDownClassVariableRefactoring variable: #Foo1				class: LintRuleTest.	self assert: ((refactoring model classNamed: #LintRuleTest) 				directlyDefinesClassVariable: #Foo1).	self executeRefactoring: refactoring.	(refactoring model classNamed: #LintRuleTest) withAllSubclasses 		do: [:each | self deny: (each directlyDefinesClassVariable: #Foo1)]! !!PushDownInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	| references |	references := RBCondition referencesInstanceVariable: variableName				in: class.	class realClass isNil 		ifTrue: 			[references 				errorMacro: ('<1s> is referenced.' expandMacrosWith: variableName)]		ifFalse: 			[references				errorMacro: ('<1s> is referenced.<n>Browse references?' 							expandMacrosWith: variableName);				errorBlock: 						[self openBrowserOn: (BrowserEnvironment new instVarRefsTo: variableName									in: class realClass)]].	^(RBCondition definesInstanceVariable: variableName in: class) 		& references not! !!PushDownInstanceVariableRefactoring methodsFor: 'transforming'!transform	class removeInstanceVariable: variableName.	class subclasses do: 			[:each | 			(each withAllSubclasses detect: 					[:aClass | 					(aClass whichSelectorsReferToInstanceVariable: variableName) isEmpty not]				ifNone: [nil]) notNil 				ifTrue: [each addInstanceVariable: variableName]]! !!PushDownInstanceVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:10'!testModelPushDownToMetaclass	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model metaclassNamed: #SomeClass) addInstanceVariable: 'foo'.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model metaclassNamed: #Subclass) compile: 'foo ^foo'		classified: #(#accessing).	self executeRefactoring: (PushDownInstanceVariableRefactoring 				model: model				variable: 'foo'				class: (model metaclassNamed: #SomeClass)).	self 		deny: ((model metaclassNamed: #SomeClass) directlyDefinesVariable: 'foo').	self 		assert: ((model metaclassNamed: #Subclass) directlyDefinesVariable: 'foo')! !!PushDownInstanceVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:10'!testModelPushDownToMultipleSubclasses	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: ''foo'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #Subclass) compile: 'foo ^foo' classified: #(#accessing).	model 		defineClass: 'SomeClass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #AnotherSubclass) compile: 'bar ^foo'		classified: #(#accessing).	self executeRefactoring: (PushDownInstanceVariableRefactoring 				model: model				variable: 'foo'				class: (model classNamed: #SomeClass)).	self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: 'foo').	self 		assert: ((model classNamed: #Subclass) directlyDefinesVariable: 'foo').	self assert: ((model classNamed: #AnotherSubclass) 				directlyDefinesVariable: 'foo')! !!PushDownInstanceVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:10'!testModelRemoveUnusedVariable	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: ''foo'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	self executeRefactoring: (PushDownInstanceVariableRefactoring 				model: model				variable: 'foo'				class: (model classNamed: #SomeClass)).	self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: 'foo').	self deny: ((model classNamed: #Subclass) directlyDefinesVariable: 'foo')! !!PushDownInstanceVariableTest methodsFor: 'tests'!testPushDownInstanceVariable	| refactoring |	refactoring := PushDownInstanceVariableRefactoring variable: 'foo1'				class: LintRuleTest.	self executeRefactoring: refactoring.	(refactoring model classNamed: #LintRuleTest) withAllSubclasses 		do: [:each | self deny: (each directlyDefinesInstanceVariable: 'foo1')]! !!PushDownInstanceVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (PushDownInstanceVariableRefactoring variable: 'foo'				class: BasicLintRuleTest)! !!PushDownMethodRefactoring methodsFor: 'preconditions'!preconditions	| condition |	condition := selectors inject: RBCondition empty				into: 					[:cond :each | 					cond & (RBCondition definesSelector: each in: class) 						& (RBCondition subclassesOf: class referToSelector: each) not].	^condition & (RBCondition isAbstractClass: class)! !!PushDownMethodRefactoring methodsFor: 'transforming'!pushDown: aSelector 	| code protocols refactoring |	code := class sourceCodeFor: aSelector.	protocols := class protocolsFor: aSelector.	refactoring := ExpandReferencedPoolsRefactoring 				model: self model				forMethod: (class parseTreeFor: aSelector)				fromClass: class				toClasses: class subclasses.	self performComponentRefactoring: refactoring.	class subclasses do: 			[:each | 			(each directlyDefinesMethod: aSelector) 				ifFalse: [each compile: code classified: protocols]]! !!PushDownMethodRefactoring methodsFor: 'transforming'!transform	selectors do: [:each | self pushDown: each].	selectors do: [:each | class removeMethod: each]! !!PushDownMethodRefactoring methodsFor: 'initialize-release'!pushDown: selectorCollection from: aClass 	class := self classObjectFor: aClass.	selectors := selectorCollection! !!PushDownMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' pushDown: '.	selectors asArray storeOn: aStream.	aStream nextPutAll: ' from: '.	class storeOn: aStream.	aStream nextPut: $)! !!PushDownMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk pushDown: selectorCollection from: aClass 	^(self new)		model: aRBSmalltalk;		pushDown: selectorCollection from: aClass;		yourself! !!PushDownMethodRefactoring class methodsFor: 'instance creation'!pushDown: selectorCollection from: aClass 	^self new pushDown: selectorCollection from: aClass! !!PushDownMethodTest methodsFor: 'tests'!testPushDownMethod	| refactoring class |	refactoring := PushDownMethodRefactoring pushDown: #(#name:)				from: LintRuleTest.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #LintRuleTest.	self deny: (class directlyDefinesMethod: #name:).	class subclasses do: 			[:each | 			self assert: (each parseTreeFor: #name:) 						= (RBParser parseMethod: 'name: aString name := aString')]! !!PushDownMethodTest methodsFor: 'tests' stamp: 'bh 3/17/2000 13:33'!testPushDownMethodThatReferencesPoolDictionary	| refactoring class parseTree |	parseTree := LintRuleTest parseTreeFor: #junk.	self		proceedThroughWarning: 			[refactoring := PushDownMethodRefactoring pushDown: #(junk ) from: LintRuleTest.			self executeRefactoring: refactoring].	class := refactoring model classNamed: #LintRuleTest.	self deny: (class directlyDefinesMethod: #junk).	class subclasses do: 		[:each | 		self assert: (each parseTreeFor: #junk)				= parseTree.		self assert: (each directlyDefinesPoolDictionary: 'TextConstants' asSymbol)]! !!PushDownMethodTest methodsFor: 'failure tests'!testPushDownMethodOnNonAbstractClass	| refactoring |	refactoring := PushDownMethodRefactoring pushDown: #(#yourself)				from: Object.	self shouldFail: refactoring! !!PushDownMethodTest methodsFor: 'failure tests'!testPushDownNonExistantMenu	| refactoring |	refactoring := PushDownMethodRefactoring 				pushDown: #(#someMethodThatDoesNotExist)				from: LintRuleTest.	self shouldFail: refactoring! !!PushUpInstanceVariableTest methodsFor: 'tests'!testPullUpInstVar	| refactoring |	self proceedThroughWarning: 			[refactoring := PullUpInstanceVariableRefactoring variable: 'result'						class: LintRuleTest.			self executeRefactoring: refactoring].	self assert: ((refactoring model classNamed: #LintRuleTest) 				directlyDefinesInstanceVariable: 'result').	self deny: ((refactoring model classNamed: #BasicLintRuleTest) 				directlyDefinesInstanceVariable: 'result')! !!PushUpInstanceVariableTest methodsFor: 'failure tests'!testPullUpVariableNotDefined	self shouldFail: (PullUpInstanceVariableRefactoring 				variable: 'notDefinedVariable'				class: LintRuleTest)! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkBackReferencesTo: aSelector 	| definingClass pushUpParseTree |	definingClass := class superclass whoDefinesMethod: aSelector.	definingClass isNil ifTrue: [^self].	pushUpParseTree := class parseTreeFor: aSelector.	class superclass allSubclasses do: 			[:each | 			each selectors do: 					[:sel | 					| parseTree |					parseTree := each parseTreeFor: sel.					(parseTree notNil and: 							[(parseTree superMessages includes: aSelector) 								and: [definingClass == (each whoDefinesMethod: aSelector)]]) 						ifTrue: 							[removeDuplicates := true.							(aSelector == sel 								and: [parseTree equalTo: pushUpParseTree exceptForVariables: #()]) 									ifFalse: 										[self 											refactoringError: ('Cannot push up <1s> since it would override the method defined in <2p>' 													expandMacrosWith: aSelector													with: definingClass)]]]]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkClassVars	selectors do: [:each | self checkClassVarsFor: each]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkClassVarsFor: aSelector 	class nonMetaclass classVariableNames do: 			[:each | 			((class whichSelectorsReferToClassVariable: each) includes: aSelector) 				ifTrue: 					[self refactoringError: ('<1p> refers to <2s> which is defined in <3p>' 								expandMacrosWith: aSelector								with: each								with: class)]]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkInstVars	selectors do: [:each | self checkInstVarsFor: each]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkInstVarsFor: aSelector 	class instanceVariableNames do: 			[:each | 			((class whichSelectorsReferToInstanceVariable: each) includes: aSelector) ifTrue: 					[self						refactoringError: ('<1p> refers to <2s> which is defined in <3p>' expandMacrosWith: aSelector								with: each								with: class)]]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkSiblingSuperSendsFrom: aRBClass 	aRBClass selectors do: 			[:each | 			| tree |			tree := aRBClass parseTreeFor: each.			tree notNil 				ifTrue: 					[tree superMessages do: 							[:aSelector | 							(selectors includes: aSelector) 								ifTrue: 									[| definer |									definer := aRBClass superclass whoDefinesMethod: aSelector.									(definer notNil and: [class includesClass: definer]) 										ifTrue: 											[self 												refactoringError: ('Cannot push up <1s> since <2p>>><3s> sends a super message to it.' 														expandMacrosWith: aSelector														with: aRBClass														with: each)]]]]].	aRBClass allSubclasses do: [:each | self checkSiblingSuperSendsFrom: each]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkSuperMessages	self checkSuperSendsFromPushedUpMethods.	self checkSuperSendsFromSiblings! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkSuperSendsFromPushedUpMethods	selectors do: 			[:each | 			| parseTree |			parseTree := class parseTreeFor: each.			(parseTree superMessages 				detect: [:sup | class superclass directlyDefinesMethod: sup]				ifNone: [nil]) notNil 				ifTrue: 					[self 						refactoringError: ('Cannot push up <1s> since it sends a super message that is defined in the superclass.' 								expandMacrosWith: each)]]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkSuperSendsFromSiblings	| siblings |	siblings := class superclass subclasses reject: [:each | each = class].	siblings do: [:aRBClass | self checkSiblingSuperSendsFrom: aRBClass]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkSuperclass	| overrideSelectors |	overrideSelectors := selectors 				select: [:each | class superclass definesMethod: each].	overrideSelectors := overrideSelectors reject: 					[:each | 					| myTree superTree |					myTree := class parseTreeFor: each.					superTree := class superclass parseTreeFor: each.					superTree equalTo: myTree exceptForVariables: #()].	overrideSelectors isEmpty ifTrue: [^self].	class superclass isAbstract 		ifFalse: 			[self refactoringError: ('Non-abstract class <2p> already defines <1p>' 						expandMacrosWith: overrideSelectors asArray first						with: class superclass)].	overrideSelectors do: [:each | self checkBackReferencesTo: each]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!preconditions	^(selectors inject: (RBCondition hasSuperclass: class)		into: [:cond :each | cond & (RBCondition definesSelector: each in: class)]) 			& (RBCondition withBlock: 						[self checkInstVars.						self checkClassVars.						self checkSuperclass.						self checkSuperMessages.						true])! !!PushUpMethodRefactoring methodsFor: 'private'!copyDownMethod: aSelector 	| oldProtocol oldSource superclassDefiner subclasses refactoring |	superclassDefiner := class superclass whoDefinesMethod: aSelector.	superclassDefiner isNil ifTrue: [^self].	oldSource := superclassDefiner sourceCodeFor: aSelector.	oldSource isNil 		ifTrue: 			[self 				refactoringError: ('Source code for <1s> superclass method not available' 						expandMacrosWith: aSelector)].	oldProtocol := superclassDefiner protocolsFor: aSelector.	subclasses := class superclass subclasses 				reject: [:each | each directlyDefinesMethod: aSelector].	subclasses isEmpty ifTrue: [^self].	((superclassDefiner parseTreeFor: aSelector) superMessages 		detect: [:each | superclassDefiner directlyDefinesMethod: each]		ifNone: [nil]) notNil 		ifTrue: 			[self 				refactoringError: ('Cannot push up <1s> since we must copy down the superclass method in <2p><n>to the other subclasses, and the superclass method sends a super message which is overriden.' 						expandMacrosWith: aSelector						with: superclassDefiner)].	self 		refactoringWarning: 'Do you want to copy down the superclass method to the classes that don''t define ' 				, aSelector.	refactoring := ExpandReferencedPoolsRefactoring 				model: self model				forMethod: (superclassDefiner parseTreeFor: aSelector)				fromClass: superclassDefiner				toClasses: subclasses.	self performComponentRefactoring: refactoring.	subclasses do: [:each | each compile: oldSource classified: oldProtocol]! !!PushUpMethodRefactoring methodsFor: 'transforming'!copyDownMethods	selectors do: [:each | self copyDownMethod: each]! !!PushUpMethodRefactoring methodsFor: 'transforming'!pushUp: aSelector 	| source refactoring |	source := class sourceCodeFor: aSelector.	source isNil 		ifTrue: [self refactoringError: 'Source for method not available'].	refactoring := ExpandReferencedPoolsRefactoring 				model: self model				forMethod: (class parseTreeFor: aSelector)				fromClass: class				toClasses: (Array with: class superclass).	self performComponentRefactoring: refactoring.	class superclass compile: source		classified: (class protocolsFor: aSelector)! !!PushUpMethodRefactoring methodsFor: 'transforming'!pushUpMethods	selectors do: [:each | self pushUp: each]! !!PushUpMethodRefactoring methodsFor: 'transforming'!removeDuplicateMethods	selectors do: [:each | self removeDuplicatesOf: each]! !!PushUpMethodRefactoring methodsFor: 'transforming'!removeDuplicatesOf: aSelector 	| tree |	tree := class superclass parseTreeFor: aSelector.	class superclass allSubclasses do: 			[:each | 			((each directlyDefinesMethod: aSelector) and: 					[(tree equalTo: (each parseTreeFor: aSelector) exceptForVariables: #()) 						and: [(each superclass whoDefinesMethod: aSelector) == class superclass]]) 				ifTrue: 					[removeDuplicates 						ifFalse: 							[removeDuplicates := true.							self 								refactoringWarning: 'Do you want to remove duplicate subclass methods?'].					each removeMethod: aSelector]]! !!PushUpMethodRefactoring methodsFor: 'transforming'!removePushedUpMethods	selectors do: [:each | class removeMethod: each]! !!PushUpMethodRefactoring methodsFor: 'transforming'!transform	self		copyDownMethods;		pushUpMethods;		removePushedUpMethods;		removeDuplicateMethods! !!PushUpMethodRefactoring methodsFor: 'initialize-release'!pushUp: selectorCollection from: aClass 	class := self classObjectFor: aClass.	selectors := selectorCollection.	removeDuplicates := false! !!PushUpMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' pushUp: '.	selectors asArray storeOn: aStream.	aStream nextPutAll: ' from: '.	class storeOn: aStream.	aStream nextPut: $)! !!PushUpMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk pushUp: selectorCollection from: aClass 	^(self new)		model: aRBSmalltalk;		pushUp: selectorCollection from: aClass;		yourself! !!PushUpMethodRefactoring class methodsFor: 'instance creation'!pushUp: selectorCollection from: aClass 	^self new pushUp: selectorCollection from: aClass! !!PushUpMethodTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:11'!testPushUpAndCopyDown	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #Foo2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model classNamed: #Foo1.	class compile: 'yourself ^1' classified: #(#accessing).	self executeRefactoring: (PushUpMethodRefactoring 				model: model				pushUp: #(#yourself)				from: class).	self assert: (class superclass parseTreeFor: #yourself) 				= (RBParser parseMethod: 'yourself ^1').	self deny: (class directlyDefinesMethod: #yourself).	class := model classNamed: #Foo2.	self assert: (class directlyDefinesMethod: #yourself).	self assert: (class parseTreeFor: #yourself) 				= ((model classNamed: #Object) parseTreeFor: #yourself)! !!PushUpMethodTest methodsFor: 'tests'!testPushUpMethodWithCopyOverriddenMethodsDown	| refactoring |	self proceedThroughWarning: 			[refactoring := PushUpMethodRefactoring pushUp: #(#isComposite)						from: CompositeLintRuleTest.			self executeRefactoring: refactoring].	self 		assert: ((refactoring model classNamed: #BasicLintRuleTest) 				parseTreeFor: #isComposite) = (RBParser parseMethod: 'isComposite ^false').	self 		assert: ((refactoring model classNamed: ('Foo' , 'LintRuleTest') asSymbol) 				parseTreeFor: #isComposite) = (RBParser parseMethod: 'isComposite ^false').	self 		assert: ((refactoring model classNamed: #LintRuleTest) 				parseTreeFor: #isComposite) = (RBParser parseMethod: 'isComposite ^true').	self deny: ((refactoring model classNamed: #CompositeLintRuleTest) 				directlyDefinesMethod: #isComposite)! !!PushUpMethodTest methodsFor: 'failure tests'!testPushUpClassMethod	| class |	class := model classNamed: #Object.	class addClassVariable: #Foo.	class metaclass compile: 'foo ^Foo' classified: #(#accessing).	self shouldFail: (PushUpMethodRefactoring 				model: model				pushUp: #(#foo)				from: class metaclass)! !!PushUpMethodTest methodsFor: 'failure tests'!testPushUpReferencesInstVar	self shouldFail: (PushUpMethodRefactoring pushUp: #(#checkClass:)				from: BasicLintRuleTest)! !!PushUpMethodTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:11'!testPushUpWithInvalidSuperSend	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #Foo2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #Foo2) compile: 'yourself ^super yourself + 1'		classified: #(#accessing).	class := model classNamed: #Foo1.	class compile: 'yourself ^1' classified: #(#accessing).	self shouldFail: (PushUpMethodRefactoring 				model: model				pushUp: #(#yourself)				from: class)! !!PushUpMethodTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:11'!testPushUpWithMethodThatCannotBePushedDown	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #SomeClass) compile: 'yourself ^54'		classified: #(#accessing).	self shouldFail: (PushUpMethodRefactoring 				model: model				pushUp: #(#yourself)				from: (model classNamed: #SomeClass))! !!PushUpMethodTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:11'!testPushUpWithSuperSendThatCannotBeCopiedDown	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #Object) compile: 'foo ^3' classified: #(#accessing).	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #Subclass) compile: 'foo ^super foo'		classified: #(#accessing).	model 		defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #Foo2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(class := model classNamed: #Foo2) compile: 'foo ^1'		classified: #(#accessing).	self shouldFail: (PushUpMethodRefactoring 				model: model				pushUp: #(#foo)				from: class)! !!RBAbstractClass methodsFor: 'comparing'!= aRBClass 	^self class = aRBClass class 		and: [self name = aRBClass name and: [self model = aRBClass model]]! !!RBAbstractClass methodsFor: 'comparing'!hash	^self name hash bitXor: self class hash! !!RBAbstractClass methodsFor: 'variable accessing'!addInstanceVariable: aString 	self privateInstanceVariableNames add: aString.	model addInstanceVariable: aString to: self! !!RBAbstractClass methodsFor: 'variable accessing'!removeInstanceVariable: aString 	self privateInstanceVariableNames remove: aString.	model removeInstanceVariable: aString from: self! !!RBAbstractClass methodsFor: 'variable accessing'!renameInstanceVariable: oldName to: newName around: aBlock 	self privateInstanceVariableNames 		at: (self privateInstanceVariableNames indexOf: oldName asString)		put: newName asString.	model 		renameInstanceVariable: oldName		to: newName		in: self		around: aBlock! !!RBAbstractClass methodsFor: 'variable accessing'!typeOfClassVariable: aSymbol 	^model classNamed: #Object! !!RBAbstractClass methodsFor: 'variable accessing'!whoDefinesClassVariable: aString 	| sprClass |	(self directlyDefinesClassVariable: aString) ifTrue: [^self].	sprClass := self superclass.	^sprClass isNil 		ifTrue: [nil]		ifFalse: [sprClass whoDefinesClassVariable: aString]! !!RBAbstractClass methodsFor: 'variable accessing'!whoDefinesInstanceVariable: aString 	| sprClass |	(self directlyDefinesInstanceVariable: aString) ifTrue: [^self].	sprClass := self superclass.	^sprClass isNil 		ifTrue: [nil]		ifFalse: [sprClass whoDefinesInstanceVariable: aString]! !!RBAbstractClass methodsFor: 'method accessing'!addMethod: aRBMethod 	self newMethods at: aRBMethod selector put: aRBMethod.	removedMethods notNil 		ifTrue: [removedMethods remove: aRBMethod selector ifAbsent: []]! !!RBAbstractClass methodsFor: 'method accessing'!allSelectors	| class selectors |	class := self.	selectors := Set new.	[class notNil] whileTrue: 			[selectors addAll: class selectors.			class := class superclass].	^selectors! !!RBAbstractClass methodsFor: 'method accessing' stamp: 'md 1/17/2006 14:17'!bindingOf: aString 	^self realClass classPool associationAt: aString asSymbol		ifAbsent: [self realClass classPool associationAt: aString asString ifAbsent: [nil]]! !!RBAbstractClass methodsFor: 'method accessing'!compile: aString 	^self compile: aString		classified: (self protocolsFor: (RBParser parseMethodPattern: aString))! !!RBAbstractClass methodsFor: 'method accessing'!compile: aString classified: aSymbolCollection 	| change method |	change := model 				compile: aString				in: self				classified: aSymbolCollection.	method := RBMethod 				for: self				source: aString				selector: change selector.	self addMethod: method! !!RBAbstractClass methodsFor: 'method accessing'!compileTree: aBRMethodNode 	^self compileTree: aBRMethodNode		classified: (self protocolsFor: aBRMethodNode selector)! !!RBAbstractClass methodsFor: 'method accessing'!compileTree: aBRMethodNode classified: aSymbolCollection 	| method source |	source := aBRMethodNode formattedCode.	model 		compile: source		in: self		classified: aSymbolCollection.	method := RBMethod 				for: self				source: source				selector: aBRMethodNode selector."	method parseTree: aBRMethodNode."	self addMethod: method! !!RBAbstractClass methodsFor: 'method accessing' stamp: 'bh 4/8/2000 18:58'!existingMethodsThatReferTo: aSymbol 	| existingMethods |	existingMethods := self realClass thoroughWhichSelectorsReferTo: aSymbol special:false byte:0.	(newMethods isNil and: [removedMethods isNil]) ifTrue: [^existingMethods].	^existingMethods 		reject: [:each | (self hasRemoved: each) or: [self newMethods includesKey: each]]! !!RBAbstractClass methodsFor: 'method accessing'!methodFor: aSelector 	^self newMethods at: aSelector		ifAbsent: 			[| compiledMethod class |			(self hasRemoved: aSelector) ifTrue: [^nil].			class := self realClass.			class isNil ifTrue: [^nil].			compiledMethod := class compiledMethodAt: aSelector ifAbsent: [nil].			compiledMethod isNil 				ifTrue: [nil]				ifFalse: 					[RBMethod 						for: self						fromMethod: compiledMethod						andSelector: aSelector]]! !!RBAbstractClass methodsFor: 'method accessing'!parseTreeFor: aSelector 	| class |	class := self whoDefinesMethod: aSelector.	class isNil ifTrue: [^nil].	^(class methodFor: aSelector) parseTree! !!RBAbstractClass methodsFor: 'method accessing' stamp: 'jmb 1/23/2003 15:50'!protocolsFor: aSelector 	| change |	change := self isMeta 				ifTrue: [model changes changeForMetaclass: name selector: aSelector]				ifFalse: [model changes changeForClass: name selector: aSelector].	^change isNil 		ifTrue: 			[self isDefined 				ifTrue: 					[Array with: (BrowserEnvironment new whichProtocolIncludes: aSelector in: self realClass)]				ifFalse: [#(#accessing)]]		ifFalse: [change protocols]! !!RBAbstractClass methodsFor: 'method accessing'!removeMethod: aSelector 	self newMethods removeKey: aSelector ifAbsent: [].	model removeMethod: aSelector from: self.	self removedMethods add: aSelector! !!RBAbstractClass methodsFor: 'method accessing'!selectors	| selectors |	selectors := Set new.	selectors addAll: self newMethods keys.	self isDefined 		ifTrue: 			[selectors addAll: self realClass selectors.			removedMethods notNil 				ifTrue: [removedMethods do: [:each | selectors remove: each ifAbsent: []]]].	^selectors! !!RBAbstractClass methodsFor: 'method accessing'!sourceCodeFor: aSelector 	| class |	class := self whoDefinesMethod: aSelector.	class isNil ifTrue: [^nil].	^(class methodFor: aSelector) source! !!RBAbstractClass methodsFor: 'method accessing'!whichSelectorsReferToClass: aRBClass 	| selectors |	selectors := Set new.	self newMethods do: 			[:each | 			(each refersToClassNamed: aRBClass name) 				ifTrue: [selectors add: each selector]].	(self isDefined and: [aRBClass isDefined]) 		ifTrue: 			[selectors addAll: (self existingMethodsThatReferTo: aRBClass classBinding).			selectors addAll: (self existingMethodsThatReferTo: aRBClass name)].	^selectors! !!RBAbstractClass methodsFor: 'method accessing' stamp: 'md 1/17/2006 14:17'!whichSelectorsReferToClassVariable: aString 	| selectors |	selectors := Set new.	self newMethods 		do: [:each | (each refersToVariable: aString) ifTrue: [selectors add: each selector]].	self isDefined 		ifTrue: 			[| binding |			binding := self bindingOf: aString.			binding isNil ifTrue: [^selectors].			selectors addAll: ((self realClass whichSelectorsReferTo: binding) 						reject: [:each | self hasRemoved: each])].	^selectors! !!RBAbstractClass methodsFor: 'method accessing'!whichSelectorsReferToInstanceVariable: aString 	| selectors |	selectors := Set new.	self newMethods 		do: [:each | (each refersToVariable: aString) ifTrue: [selectors add: each selector]].	self isDefined 		ifTrue: 			[selectors addAll: ((self realClass whichSelectorsAccess: aString) 						reject: [:each | self hasRemoved: each])].	^selectors! !!RBAbstractClass methodsFor: 'method accessing'!whichSelectorsReferToSymbol: aSymbol 	| selectors |	selectors := Set new.	self newMethods 		do: [:each | (each refersToSymbol: aSymbol) ifTrue: [selectors add: each selector]].	self isDefined 		ifTrue: [selectors addAll: (self existingMethodsThatReferTo: aSymbol)].	^selectors! !!RBAbstractClass methodsFor: 'method accessing'!whoDefinesMethod: aSelector 	| sprClass |	(self directlyDefinesMethod: aSelector) ifTrue: [^self].	sprClass := self superclass.	^sprClass isNil 		ifTrue: [nil]		ifFalse: [sprClass whoDefinesMethod: aSelector]! !!RBAbstractClass methodsFor: 'private'!addSubclass: aRBClass 	self subclasses add: aRBClass! !!RBAbstractClass methodsFor: 'private'!privateInstanceVariableNames	instanceVariableNames isNil 		ifTrue: 			[self isDefined 				ifTrue: [self instanceVariableNames: self realClass instVarNames]				ifFalse: [instanceVariableNames := OrderedCollection new]].	^instanceVariableNames! !!RBAbstractClass methodsFor: 'private'!superclass: aRBClass 	self superclass notNil ifTrue: [self superclass removeSubclass: self].	superclass := aRBClass.	superclass notNil ifTrue: [superclass addSubclass: self].! !!RBAbstractClass methodsFor: 'accessing'!allClassVariableNames	^self subclassResponsibility! !!RBAbstractClass methodsFor: 'accessing'!allInstanceVariableNames	| sprClass |	sprClass := self superclass.	^sprClass isNil 		ifTrue: [self instanceVariableNames]		ifFalse: [sprClass allInstanceVariableNames , self instanceVariableNames]! !!RBAbstractClass methodsFor: 'accessing'!allPoolDictionaryNames	^self subclassResponsibility! !!RBAbstractClass methodsFor: 'accessing'!allSubclasses	| allSubclasses index |	index := 1.	allSubclasses := self subclasses asOrderedCollection.	[index <= allSubclasses size] whileTrue: 			[allSubclasses addAll: (allSubclasses at: index) subclasses.			index := index + 1].	^allSubclasses! !!RBAbstractClass methodsFor: 'accessing'!allSuperclasses	| supers sprClass |	supers := OrderedCollection new.	sprClass := self superclass.	[sprClass notNil] whileTrue: 			[supers add: sprClass.			sprClass := sprClass superclass].	^supers! !!RBAbstractClass methodsFor: 'accessing'!classBinding	^Smalltalk associationAt: self name! !!RBAbstractClass methodsFor: 'accessing'!instanceVariableNames	^self privateInstanceVariableNames copy! !!RBAbstractClass methodsFor: 'accessing'!instanceVariableNames: aCollectionOfStrings 	instanceVariableNames := aCollectionOfStrings asOrderedCollection! !!RBAbstractClass methodsFor: 'accessing'!metaclass	^model metaclassNamed: self name! !!RBAbstractClass methodsFor: 'accessing'!model	^model! !!RBAbstractClass methodsFor: 'accessing'!name	^name! !!RBAbstractClass methodsFor: 'accessing'!name: aSymbol 	name := aSymbol! !!RBAbstractClass methodsFor: 'accessing'!newMethods	^newMethods isNil 		ifTrue: [newMethods := IdentityDictionary new]		ifFalse: [newMethods]! !!RBAbstractClass methodsFor: 'accessing'!nonMetaclass	^model classNamed: self name! !!RBAbstractClass methodsFor: 'accessing'!primaryInstance	^self nonMetaclass! !!RBAbstractClass methodsFor: 'accessing'!realClass	^realClass! !!RBAbstractClass methodsFor: 'accessing'!realClass: aClass 	realClass := aClass.	superclass isNil ifTrue: [superclass := LookupSuperclass]! !!RBAbstractClass methodsFor: 'accessing'!removeSubclass: aRBClass 	self subclasses remove: aRBClass ifAbsent: []! !!RBAbstractClass methodsFor: 'accessing'!removedMethods	^removedMethods isNil 		ifTrue: [removedMethods := Set new]		ifFalse: [removedMethods]! !!RBAbstractClass methodsFor: 'accessing'!soleInstance	^self nonMetaclass! !!RBAbstractClass methodsFor: 'accessing'!subclasses	^subclasses isNil 		ifTrue: 			[subclasses := self isDefined 						ifTrue: 							[(self realClass subclasses collect: [:each | model classFor: each]) 								asOrderedCollection]						ifFalse: [OrderedCollection new]]		ifFalse: [subclasses]! !!RBAbstractClass methodsFor: 'accessing'!superclass	^superclass == LookupSuperclass 		ifTrue: [model classFor: self realClass superclass]		ifFalse: [superclass]! !!RBAbstractClass methodsFor: 'accessing'!withAllSubclasses	^(self allSubclasses)		add: self;		yourself! !!RBAbstractClass methodsFor: 'accessing'!withAllSuperclasses	^(self allSuperclasses)		add: self;		yourself! !!RBAbstractClass methodsFor: 'testing' stamp: 'dc 5/18/2007 14:53'!definesClassVariable: aSymbol 	self realClass isTrait ifTrue: [^false].	(self directlyDefinesClassVariable: aSymbol) ifTrue: [^true].	^self superclass notNil 		and: [self superclass definesClassVariable: aSymbol]! !!RBAbstractClass methodsFor: 'testing'!definesInstanceVariable: aString 	(self directlyDefinesInstanceVariable: aString) ifTrue: [^true].	^self superclass notNil 		and: [self superclass definesInstanceVariable: aString]! !!RBAbstractClass methodsFor: 'testing'!definesMethod: aSelector 	(self directlyDefinesMethod: aSelector) ifTrue: [^true].	^self superclass notNil and: [self superclass definesMethod: aSelector]! !!RBAbstractClass methodsFor: 'testing'!definesPoolDictionary: aSymbol 	(self directlyDefinesPoolDictionary: aSymbol) ifTrue: [^true].	^self inheritsPoolDictionaries and: 			[self superclass notNil 				and: [self superclass definesPoolDictionary: aSymbol]]! !!RBAbstractClass methodsFor: 'testing'!definesVariable: aVariableName 	^(self definesClassVariable: aVariableName) 		or: [self definesInstanceVariable: aVariableName]! !!RBAbstractClass methodsFor: 'testing'!directlyDefinesClassVariable: aString 	self subclassResponsibility! !!RBAbstractClass methodsFor: 'testing'!directlyDefinesInstanceVariable: aString 	^self instanceVariableNames includes: aString! !!RBAbstractClass methodsFor: 'testing'!directlyDefinesMethod: aSelector 	self isDefined 		ifTrue: 			[(self hasRemoved: aSelector) ifTrue: [^false].			(self realClass includesSelector: aSelector) ifTrue: [^true]].	^newMethods notNil and: [newMethods includesKey: aSelector]! !!RBAbstractClass methodsFor: 'testing'!directlyDefinesPoolDictionary: aString 	self subclassResponsibility! !!RBAbstractClass methodsFor: 'testing'!directlyDefinesVariable: aVariableName 	^(self directlyDefinesClassVariable: aVariableName) 		or: [self directlyDefinesInstanceVariable: aVariableName]! !!RBAbstractClass methodsFor: 'testing'!hasRemoved: aSelector 	^removedMethods notNil and: [removedMethods includes: aSelector]! !!RBAbstractClass methodsFor: 'testing'!hierarchyDefinesClassVariable: aString 	(self definesClassVariable: aString) ifTrue: [^true].	^(self allSubclasses 		detect: [:each | each directlyDefinesClassVariable: aString]		ifNone: [nil]) notNil! !!RBAbstractClass methodsFor: 'testing'!hierarchyDefinesInstanceVariable: aString 	(self definesInstanceVariable: aString) ifTrue: [^true].	^(self allSubclasses 		detect: [:each | each directlyDefinesInstanceVariable: aString]		ifNone: [nil]) notNil! !!RBAbstractClass methodsFor: 'testing'!hierarchyDefinesMethod: aSelector 	(self definesMethod: aSelector) ifTrue: [^true].	^self subclassRedefines: aSelector! !!RBAbstractClass methodsFor: 'testing'!hierarchyDefinesPoolDictionary: aString 	(self definesPoolDictionary: aString) ifTrue: [^true].	^(self allSubclasses 		detect: [:each | each directlyDefinesPoolDictionary: aString]		ifNone: [nil]) notNil! !!RBAbstractClass methodsFor: 'testing'!hierarchyDefinesVariable: aString 	(self definesVariable: aString) ifTrue: [^true].	^(self allSubclasses 		detect: [:each | each directlyDefinesVariable: aString]		ifNone: [nil]) notNil! !!RBAbstractClass methodsFor: 'testing'!includesClass: aRBClass 	| currentClass |	currentClass := self.	[currentClass notNil and: [currentClass ~= aRBClass]] 		whileTrue: [currentClass := currentClass superclass].	^currentClass = aRBClass! !!RBAbstractClass methodsFor: 'testing'!inheritsPoolDictionaries	^false! !!RBAbstractClass methodsFor: 'testing'!isAbstract	(self whichSelectorsReferToSymbol: #subclassResponsibility) isEmpty 		ifFalse: [^true].	model allReferencesToClass: self do: [:each | ^false].	^true! !!RBAbstractClass methodsFor: 'testing'!isDefined	^self realClass notNil! !!RBAbstractClass methodsFor: 'testing'!isMeta	self subclassResponsibility! !!RBAbstractClass methodsFor: 'testing'!subclassRedefines: aSelector 	"Return true, if one of your subclasses redefines the method with name, aMethod"	self allSubclasses 		do: [:each | (each directlyDefinesMethod: aSelector) ifTrue: [^true]].	^false! !!RBAbstractClass methodsFor: 'initialize-release'!initialize	name := #'Unknown Class'! !!RBAbstractClass methodsFor: 'initialize-release'!model: aRBSmalltalk	model := aRBSmalltalk! !!RBAbstractClass methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: self name! !!RBAbstractClass methodsFor: 'printing'!storeOn: aStream 	aStream nextPutAll: self name! !!RBAbstractClass class methodsFor: 'class initialization'!initialize	LookupSuperclass := Object new! !!RBAbstractCondition methodsFor: 'logical operations'!& aCondition 	^RBConjunctiveCondition new left: self right: aCondition! !!RBAbstractCondition methodsFor: 'logical operations'!not	^RBNegationCondition on: self! !!RBAbstractCondition methodsFor: 'logical operations'!| aCondition 	"(A | B) = (A not & B not) not"	^(self not & aCondition not) not! !!RBAbstractCondition methodsFor: 'checking'!check	self subclassResponsibility! !!RBAbstractCondition methodsFor: 'accessing'!errorBlock	^self errorBlockFor: false! !!RBAbstractCondition methodsFor: 'accessing'!errorString	^self errorStringFor: false! !!RBAbstractCondition methodsFor: 'private'!errorBlockFor: aBoolean 	^nil! !!RBAbstractCondition methodsFor: 'private'!errorMacro	^errorMacro isNil		ifTrue: ['unknown']		ifFalse: [errorMacro]! !!RBAbstractCondition methodsFor: 'private'!errorMacro: aString 	errorMacro := aString! !!RBAbstractCondition methodsFor: 'private'!errorStringFor: aBoolean	^self errorMacro expandMacrosWith: aBoolean! !!RBAbstractTest methodsFor: 'testing' stamp: 'ms 3/31/2007 16:55'!assertPosition: node start: start stop: stop 	self assert: node start = start.	self assert: node stop = stop! !!RBAbstractTest methodsFor: 'accessing' stamp: 'ms 9/16/2006 23:43'!defaultParser		^self class defaultParser! !!RBAbstractTest class methodsFor: 'accessing' stamp: 'ms 3/31/2007 20:43'!defaultParser	^Smalltalk at: #SqueakParser ifAbsent: [RBParser]! !!RBAbstractTest class methodsFor: 'testing' stamp: 'ms 9/16/2006 23:48'!isAbstract		^self  = RBAbstractTest! !!RBArrayNode methodsFor: 'comparing' stamp: 'bh 4/3/2000 12:46'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^statements = anObject statements.! !!RBArrayNode methodsFor: 'comparing' stamp: 'bh 4/3/2000 12:46'!hash	^statements hash.! !!RBArrayNode methodsFor: 'visitor' stamp: 'ajh 3/17/2003 00:25'!acceptVisitor: aProgramNodeVisitor	^ aProgramNodeVisitor acceptArrayNode: self! !!RBArrayNode methodsFor: 'replacing' stamp: 'md 4/7/2007 21:03'!adjustPositionsAfter: sourcePos by: delta	"Slide token positions after sourcePos by delta"	self leftBrace: self leftBrace + delta.	self rightBrace: self rightBrace + delta.	super adjustPositionsAfter: sourcePos by: delta.! !!RBArrayNode methodsFor: 'replacing' stamp: 'ls 1/24/2000 00:27'!replaceNode: oldNode  withNode: newNode	statements := statements collect: [ :statement |		statement == oldNode 			ifTrue: [ newNode ]			ifFalse: [ statement ] ]! !!RBArrayNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:36'!basicFirstToken	self statements 		ifEmpty:[^nil] 		ifNotEmpty:[| stat | 		     		stat := self statements copy.			 		[stat first firstToken = nil] 							whileTrue: [stat removeFirst.										stat ifEmpty:[^nil]].					^stat first firstToken]! !!RBArrayNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:37'!basicLastToken	self statements 		ifEmpty:[^nil] 		ifNotEmpty:[ | stat | 				      stat := OrderedCollection newFrom: self statements.					 [stat last lastToken = nil] 							whileTrue: [stat removeLast.										stat ifEmpty:[^nil]].					^stat last lastToken]! !!RBArrayNode methodsFor: 'accessing' stamp: 'ls 1/24/2000 00:00'!children	^statements! !!RBArrayNode methodsFor: 'accessing' stamp: 'md 4/7/2007 21:07'!leftBrace	^ self propertyAt: #leftBrace ifAbsent: [nil].! !!RBArrayNode methodsFor: 'accessing' stamp: 'md 4/7/2007 21:07'!leftBrace: leftBrace0	leftBrace0 ifNil: [^self removeProperty: #leftBrace ifAbsent: []].	self propertyAt: #leftBrace put: leftBrace0.! !!RBArrayNode methodsFor: 'accessing' stamp: 'ls 1/24/2000 00:02'!periods: periods	"ignored"! !!RBArrayNode methodsFor: 'accessing' stamp: 'nk 3/3/2005 09:47'!precedence	^0! !!RBArrayNode methodsFor: 'accessing' stamp: 'md 4/7/2007 21:05'!rightBrace	^ self propertyAt: #rightBrace ifAbsent: [nil].! !!RBArrayNode methodsFor: 'accessing' stamp: 'md 4/7/2007 21:06'!rightBrace: rightBrace0	rightBrace0 ifNil: [^self removeProperty: #rightBrace ifAbsent: []].	self propertyAt: #rightBrace put: rightBrace0.! !!RBArrayNode methodsFor: 'accessing' stamp: 'md 4/7/2007 21:04'!start	^self leftBrace! !!RBArrayNode methodsFor: 'accessing' stamp: 'md 4/7/2007 21:04'!startWithoutParentheses 	^ self leftBrace! !!RBArrayNode methodsFor: 'accessing' stamp: 'ls 1/24/2000 00:32'!statements	^statements! !!RBArrayNode methodsFor: 'accessing' stamp: 'dvf 11/12/2002 00:47'!statements: statements0 	statements ifNotNil: [self error: 'double initialization'].	statements := statements0.	statements do: [:statement | statement parent: self]! !!RBArrayNode methodsFor: 'accessing' stamp: 'md 4/7/2007 21:03'!stop	^self rightBrace! !!RBArrayNode methodsFor: 'accessing' stamp: 'md 4/7/2007 21:03'!stopWithoutParentheses 	^ self rightBrace! !!RBArrayNode methodsFor: 'testing' stamp: 'ajh 2/25/2003 14:34'!isArray	^ true! !!RBArrayNode methodsFor: 'testing' stamp: 'ls 1/24/2000 00:28'!lastIsReturn	statements isEmpty ifTrue:[ ^false ].	^statements last lastIsReturn! !!RBArrayNode methodsFor: 'initialization' stamp: 'ajh 3/4/2003 02:04'!leftBrace: leftBrace0  rightBrace: rightBrace0  statements: statements0	self leftBrace: leftBrace0.	self rightBrace: rightBrace0.	self statements: statements0.! !!RBArrayNode methodsFor: 'copying' stamp: 'pmm 2/24/2006 11:00'!postCopy	super postCopy.	statements := statements collect: [ :statement |		statement copy		parent: self;		yourself ]! !!RBArrayNode class methodsFor: 'instance creation' stamp: 'ls 1/23/2000 23:56'!leftBrace: leftBrace  rightBrace: rightBrace  statements: statements	^self new leftBrace: leftBrace  rightBrace: rightBrace  statements: statements! !!RBArrayNode class methodsFor: 'instance creation' stamp: 'ajh 3/4/2003 02:03'!statements: statements	^ self new statements: statements! !!RBArrayNodeTest methodsFor: 'method - tested' stamp: 'ms 3/31/2007 20:45'!expectedFailures	Smalltalk at: #SqueakParser ifAbsent:[^#(#testFirstLastToken)].	^#()! !!RBArrayNodeTest methodsFor: 'testing' stamp: 'ms 3/31/2007 16:38'!testFirstLastToken	"self debug: #testFirstLastToken"	| rbNode |	rbNode := (self defaultParser parseMethod: 'test {a := b. jo}') body statements first.	self assert: (rbNode firstToken value = '{').	self assert: (rbNode lastToken value = '}').		rbNode := (self defaultParser parseMethod: 'test ({a := b. 3. {si}})') body statements first.	self assert: (rbNode firstToken value = '(').	self assert: (rbNode lastToken value = ')')	! !!RBArrayNodeTest methodsFor: 'testing' stamp: 'ms 3/31/2007 16:58'!testPosition	"self debug: #testPosition"	| rbNode |	rbNode := (self defaultParser parseMethod: 'test {a := b. jo}') body statements first.	self assertPosition: rbNode start: 6 stop: 17.		rbNode := (self defaultParser parseMethod: 'test ({a := b. 3. {si}})') body statements first.	self assertPosition: rbNode start: 7 stop: 23.	! !!RBAssignmentNode methodsFor: 'comparing'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self variable = anObject variable and: [self value = anObject value]! !!RBAssignmentNode methodsFor: 'comparing'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	^(self variable equalTo: anObject variable withMapping: aDictionary)		and: [self value equalTo: anObject value withMapping: aDictionary]! !!RBAssignmentNode methodsFor: 'comparing'!hash	^self variable hash bitXor: self value hash! !!RBAssignmentNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptAssignmentNode: self! !!RBAssignmentNode methodsFor: 'accessing' stamp: 'ms 7/27/2007 15:46'!assignmentOperator	^ self firstToken 		ifNotNil:[self firstToken next 			ifNotNil:[ self firstToken next next value] 			ifNil:[self defaultAssignmentOperator]] 		ifNil:[self defaultAssignmentOperator].! !!RBAssignmentNode methodsFor: 'accessing'!children	^Array with: value with: variable! !!RBAssignmentNode methodsFor: 'accessing' stamp: 'md 7/6/2007 11:54'!position	^ self propertyAt: #position ifAbsent: [nil].! !!RBAssignmentNode methodsFor: 'accessing' stamp: 'md 7/6/2007 11:54'!position: anInteger	anInteger ifNil: [^self removeProperty: #position ifAbsent: []].	self propertyAt: #position put: anInteger.! !!RBAssignmentNode methodsFor: 'accessing'!precedence	^5! !!RBAssignmentNode methodsFor: 'accessing'!startWithoutParentheses	^variable start! !!RBAssignmentNode methodsFor: 'accessing'!stopWithoutParentheses	^value stop! !!RBAssignmentNode methodsFor: 'accessing'!value	^value! !!RBAssignmentNode methodsFor: 'accessing'!value: aValueNode 	value := aValueNode.	value parent: self! !!RBAssignmentNode methodsFor: 'accessing'!variable	^variable! !!RBAssignmentNode methodsFor: 'accessing'!variable: varNode 	variable := varNode.	variable parent: self! !!RBAssignmentNode methodsFor: 'testing'!assigns: aVariableName 	^variable name = aVariableName or: [value assigns: aVariableName]! !!RBAssignmentNode methodsFor: 'testing'!directlyUses: aNode 	^aNode = value ifTrue: [true] ifFalse: [self isDirectlyUsed]! !!RBAssignmentNode methodsFor: 'testing'!isAssignment	^true! !!RBAssignmentNode methodsFor: 'testing'!uses: aNode 	^aNode = value ifTrue: [true] ifFalse: [self isUsed]! !!RBAssignmentNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:38'!basicFirstToken		^self variable firstToken! !!RBAssignmentNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:38'!basicLastToken		^self value lastToken! !!RBAssignmentNode methodsFor: 'querying' stamp: 'md 7/6/2007 11:49'!bestNodeFor: anInterval 	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	self position isNil ifTrue: [^super bestNodeFor: anInterval].	((anInterval first between: self position and: self position + 1) 		or: [self position between: anInterval first and: anInterval last]) 			ifTrue: [^self].	self children do: 			[:each | 			| node |			node := each bestNodeFor: anInterval.			node notNil ifTrue: [^node]]! !!RBAssignmentNode methodsFor: 'matching'!copyInContext: aDictionary 	^(self class new) variable: (variable copyInContext: aDictionary);		value: (value copyInContext: aDictionary);		yourself! !!RBAssignmentNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^(variable match: aNode variable inContext: aDictionary)		and: [value match: aNode value inContext: aDictionary]! !!RBAssignmentNode methodsFor: 'accessing default' stamp: 'ms 7/27/2007 15:06'!defaultAssignmentOperator	^self class defaultAssignmentOperator! !!RBAssignmentNode methodsFor: 'copying' stamp: 'pmm 2/24/2006 11:00'!postCopy	super postCopy.	variable := variable copy.	variable parent: self.	value := value copy.	value parent: self! !!RBAssignmentNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	value == aNode ifTrue: [self value: anotherNode].	variable == aNode ifTrue: [self variable: anotherNode]! !!RBAssignmentNode methodsFor: 'initialize-release' stamp: 'md 7/6/2007 11:51'!variable: aVariableNode value: aValueNode position: anInteger 	self variable: aVariableNode.	self value: aValueNode.	self position: anInteger! !!RBAssignmentNode methodsFor: '*newcompiler' stamp: 'ms 7/3/2007 21:06'!isClosureEnvironmentCreation	^self value isMessage 		ifTrue: [self value isClosureEnvironmentCreation]		ifFalse: [false]! !!RBAssignmentNode methodsFor: '*newcompiler' stamp: 'ms 7/30/2007 13:52'!isTempClosureRegistration	^variable binding isCaptured		and:[value isVariable]		and:[value binding = variable binding sourceTemp]! !!RBAssignmentNode methodsFor: '*persephone' stamp: 'md 8/23/2007 23:59'!isGlobal	^variable isGlobal! !!RBAssignmentNode methodsFor: '*persephone' stamp: 'md 8/23/2007 23:59'!isInstance	^variable isInstance! !!RBAssignmentNode methodsFor: '*persephone' stamp: 'md 8/24/2007 00:00'!isTemp	^variable isTemp! !!RBAssignmentNode methodsFor: '*persephone' stamp: 'pmm 11/11/2005 16:26'!replaceNode: aNode withNodes: aCollection 	aCollection size = 1		ifTrue: [ self replaceNode: aNode withNode: aCollection anyOne ]		ifFalse: [ self error: 'can replace only one node' ]! !!RBAssignmentNode methodsFor: '*persephone' stamp: 'pmm 7/23/2006 15:53'!variableNode	^self variable copy! !!RBAssignmentNode methodsFor: '*geppetto2' stamp: 'md 3/9/2007 18:25'!addNode: aNode after: anotherNode	parent addNode: aNode after: self! !!RBAssignmentNode methodsFor: '*geppetto2' stamp: 'md 2/12/2007 20:55'!addNode: aNode before: anotherNode	parent addNode: aNode before: self! !!RBAssignmentNode methodsFor: '*Colorer' stamp: 'pmm 7/8/2006 13:46'!markExecuted	super markExecuted.	self variable markExecuted! !!RBAssignmentNode commentStamp: 'md 7/6/2007 11:55' prior: 0!RBAssignmentNode is an AST node for assignment statementsInstance Variables:	value	<RBValueNode>	the value that we're assigning	variable	<RBVariableNode>	the variable being assignedproperties:	#position	<Integer>	position of the :=!!RBAssignmentNode class methodsFor: 'accessing default' stamp: 'ms 7/27/2007 15:07'!defaultAssignmentOperator	^':='! !!RBAssignmentNode class methodsFor: 'instance creation'!variable: aVariableNode value: aValueNode 	^self 		variable: aVariableNode		value: aValueNode		position: nil! !!RBAssignmentNode class methodsFor: 'instance creation'!variable: aVariableNode value: aValueNode position: anInteger 	^self new		variable: aVariableNode		value: aValueNode		position: anInteger! !!RBAssignmentNodeTest methodsFor: 'method - tested' stamp: 'ms 3/31/2007 20:46'!expectedFailures	Smalltalk at: #SqueakParser ifAbsent:[^#(#testFirstLastToken)].	^#()! !!RBAssignmentNodeTest methodsFor: 'testing' stamp: 'ms 9/18/2006 18:37'!testFirstLastToken		| rbNode |	rbNode := (self defaultParser parseMethod: 'test a := b') body statements first.	self assert: (rbNode firstToken value = 'a').	self assert: (rbNode lastToken value = 'b').		rbNode := (self defaultParser parseMethod: 'test (a := b)') body statements first.	self assert: (rbNode firstToken value = '(').	self assert: (rbNode lastToken value = ')')! !!RBAssignmentNodeTest methodsFor: 'testing' stamp: 'ms 3/31/2007 17:37'!testPosition		| rbNode |	rbNode := (self defaultParser parseMethod: 'test a := b') body statements first.	self assertPosition: rbNode start: 6 stop: 11.		rbNode := (self defaultParser parseMethod: 'test (a := b)') body statements first.	self assertPosition: rbNode start: 6 stop: 13.! !!RBAssignmentNodeTest methodsFor: 'testing' stamp: 'ms 3/31/2007 18:47'!testValue		| rbNode |	rbNode := (self defaultParser parseMethod: 'test a := b') body statements first.	self assert: (rbNode value isKindOf: RBVariableNode).		rbNode := (self defaultParser parseMethod: 'test (a := b foo)') body statements first.	self assert: (rbNode value isKindOf: RBMessageNode)! !!RBAssignmentToken methodsFor: 'testing'!isAssignment	^true! !!RBAssignmentToken methodsFor: 'private' stamp: 'ls 1/11/2000 07:00'!length	^2! !!RBAssignmentToken commentStamp: 'md 8/9/2005 14:51' prior: 0!RBAssignmentToken is the first-class representation of the assignment token ':='!!RBBinarySelectorToken methodsFor: 'testing'!isBinary	^true! !!RBBinarySelectorToken commentStamp: 'md 8/9/2005 14:51' prior: 0!RBBinarySelectorToken is the first-class representation of a binary selector (e.g. +)!!RBBlockNode methodsFor: 'comparing' stamp: 'pmm 7/12/2006 15:39'!= anObject	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	self body = anObject body ifFalse: [^false].	^self arguments = anObject arguments! !!RBBlockNode methodsFor: 'comparing' stamp: 'pmm 7/12/2006 15:39'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self arguments size = anObject arguments size ifFalse: [^false].	self arguments with: anObject arguments do: [ :first :second |		(first equalTo: second withMapping: aDictionary)			ifFalse: [^false]].	(self body equalTo: anObject body withMapping: aDictionary)		ifFalse: [^false].	self arguments do: [:each | aDictionary removeKey: each name].	^true! !!RBBlockNode methodsFor: 'comparing'!hash	^self arguments hash bitXor: self body hash! !!RBBlockNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptBlockNode: self! !!RBBlockNode methodsFor: 'replacing' stamp: 'md 4/7/2007 20:20'!adjustPositionsAfter: sourcePos by: delta	"Slide token positions after sourcePos by delta"	self left: self left + delta.	self right: self right + delta.	super adjustPositionsAfter: sourcePos by: delta.! !!RBBlockNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	body == aNode ifTrue: [self body: anotherNode].	self arguments: (arguments 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !!RBBlockNode methodsFor: 'accessing'!allArgumentVariables	^(self argumentNames asOrderedCollection)		addAll: super allArgumentVariables;		yourself! !!RBBlockNode methodsFor: 'accessing'!allDefinedVariables	^(self argumentNames asOrderedCollection) addAll: super allDefinedVariables;		yourself! !!RBBlockNode methodsFor: 'accessing'!argumentNames	^self arguments collect: [:each | each name]! !!RBBlockNode methodsFor: 'accessing'!arguments	^arguments! !!RBBlockNode methodsFor: 'accessing'!arguments: argCollection 	arguments := argCollection.	arguments do: [:each | each parent: self]! !!RBBlockNode methodsFor: 'accessing' stamp: 'md 4/7/2007 15:55'!bar	^ self propertyAt: #bar ifAbsent: [nil].! !!RBBlockNode methodsFor: 'accessing' stamp: 'md 4/7/2007 15:55'!bar: anObject	anObject ifNil: [^self removeProperty: #bar ifAbsent: []].	self propertyAt: #bar put: anObject.! !!RBBlockNode methodsFor: 'accessing'!blockVariables	| vars |	vars := super blockVariables asOrderedCollection.	vars addAll: self argumentNames.	^vars! !!RBBlockNode methodsFor: 'accessing'!body	^body! !!RBBlockNode methodsFor: 'accessing'!body: stmtsNode 	body := stmtsNode.	body parent: self! !!RBBlockNode methodsFor: 'accessing'!children	^self arguments copyWith: self body! !!RBBlockNode methodsFor: 'accessing' stamp: 'md 4/7/2007 20:21'!colons: anObject	anObject ifNil: [^self removeProperty: #colons ifAbsent: []].	self propertyAt: #colons put: anObject.! !!RBBlockNode methodsFor: 'accessing' stamp: 'md 4/7/2007 20:33'!left	^ self propertyAt: #left ifAbsent: [nil].! !!RBBlockNode methodsFor: 'accessing' stamp: 'md 4/7/2007 20:33'!left: anObject	anObject ifNil: [^self removeProperty: #left ifAbsent: []].	self propertyAt: #left put: anObject.! !!RBBlockNode methodsFor: 'accessing'!precedence	^0! !!RBBlockNode methodsFor: 'accessing' stamp: 'md 4/7/2007 20:32'!right	^ self propertyAt: #right ifAbsent: [nil].! !!RBBlockNode methodsFor: 'accessing' stamp: 'md 4/7/2007 20:33'!right: anObject	anObject ifNil: [^self removeProperty: #right ifAbsent: []].	self propertyAt: #right put: anObject.! !!RBBlockNode methodsFor: 'accessing' stamp: 'md 4/7/2007 20:20'!startWithoutParentheses	^self left! !!RBBlockNode methodsFor: 'accessing' stamp: 'md 4/7/2007 20:20'!stopWithoutParentheses	^self right! !!RBBlockNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:39'!basicFirstToken		self arguments ifEmpty: [^self body firstToken] ifNotEmpty: [^self arguments first firstToken]! !!RBBlockNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:39'!basicLastToken		^self body lastToken ifNil:[ self arguments ifEmpty:[^nil] ifNotEmpty:[^self arguments last firstToken]]! !!RBBlockNode methodsFor: 'matching'!copyInContext: aDictionary 	^(self class new)		arguments: (self copyList: arguments inContext: aDictionary);		body: (body copyInContext: aDictionary);		yourself! !!RBBlockNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^(self matchList: arguments		against: aNode arguments		inContext: aDictionary)			and: [body match: aNode body inContext: aDictionary]! !!RBBlockNode methodsFor: 'testing' stamp: 'pmm 7/12/2006 15:17'!defines: aName 	^arguments anySatisfy: [:each | each name = aName]! !!RBBlockNode methodsFor: 'testing'!directlyUses: aNode 	^false! !!RBBlockNode methodsFor: 'testing'!isBlock	^true! !!RBBlockNode methodsFor: 'testing'!isImmediate	^true! !!RBBlockNode methodsFor: 'testing'!isLast: aNode 	^body isLast: aNode! !!RBBlockNode methodsFor: 'testing'!references: aVariableName 	^body references: aVariableName! !!RBBlockNode methodsFor: 'testing'!uses: aNode 	aNode = body ifFalse: [^false].	^parent isMessage		ifTrue: [(#(#ifTrue:ifFalse: #ifTrue: #ifFalse: #ifFalse:ifTrue:) includes: parent selector) not or: [parent isUsed]]		ifFalse: [self isUsed]! !!RBBlockNode methodsFor: 'semantics' stamp: 'ajh 7/8/2004 20:56'!freeNames	"Filter out hidden ones that have space in there name such as 'top env'"	^ ((self freeVars collect: [:var | var name])		reject: [:name | name includes: $ ]) asSortedCollection! !!RBBlockNode methodsFor: 'semantics' stamp: 'md 4/3/2007 13:43'!freeVars	"Return children variable node bindings that refer to variables outside my scope (ignoring global vars)"	| freeVars |	freeVars := Set new.	self scope: self owningScope.	self nodesDo: [:node | | var |		(node isVariable or: [node isReturn and: [node binding notNil]]) ifTrue: [			var := node binding.			(self scope hasOuter: var scope) ifTrue: [				var isGlobal ifFalse: [					freeVars add: var]]]].	^ freeVars! !!RBBlockNode methodsFor: 'semantics' stamp: 'ajh 6/30/2004 14:07'!owningBlock	^ self! !!RBBlockNode methodsFor: 'semantics' stamp: 'md 4/3/2007 13:44'!owningScope	^ self scope ifNil: ["inlined" ^ parent owningScope]! !!RBBlockNode methodsFor: 'semantics' stamp: 'md 4/3/2007 13:44'!scope	^ self propertyAt: #scope ifAbsent: [nil].! !!RBBlockNode methodsFor: 'semantics' stamp: 'md 4/3/2007 13:44'!scope: aSemClosureScope	aSemClosureScope ifNil: [^self removeProperty: #scope ifAbsent: []].	self propertyAt: #scope put: aSemClosureScope.! !!RBBlockNode methodsFor: 'inline' stamp: 'ajh 3/13/2003 02:43'!isInlined	(parent isMessage and: [parent isInlineAndOr]) ifTrue: [^ true].	(parent isMessage and: [parent isInlineIf]) ifTrue: [^ true].	(parent isMessage and: [parent isInlineIfNil]) ifTrue: [^ true].	(parent isMessage and: [parent isInlineToDo]) ifTrue: [^ true].	(parent isMessage and: [parent isInlineWhile]) ifTrue: [^ true].	(parent isMessage and: [parent parent isArray and: [parent parent parent isMessage and: [parent parent parent isInlineCase]]]) ifTrue: [^ true].	(parent isMessage and: [parent isInlineCase]) ifTrue: [^ true].  "otherwise branch"	^ false! !!RBBlockNode methodsFor: 'copying' stamp: 'pmm 9/19/2005 11:32'!postCopy	super postCopy.	arguments := arguments collect: [:each |		each copy		parent: self;		yourself ].	body := body copy.	body parent: self.! !!RBBlockNode methodsFor: 'debugging' stamp: 'ms 11/22/2007 00:20'!sourceMap	"Return a mapping from bytecode pcs to source code ranges"	^ self ir sourceMap asSortedCollection! !!RBBlockNode methodsFor: 'debugging' stamp: 'md 4/6/2007 11:06'!tempNames	"All temp names in context order"	^self scope isNil		ifFalse: [ self scope tempVars allButFirst "without self" collect: [:var | var name] ]		ifTrue: [ #() ]! !!RBBlockNode methodsFor: 'printing' stamp: 'ajh 3/17/2003 09:12'!sourceText	| text |	self parent ifNil: [^ self formattedCode asText].	text := [self root sourceText]		on: Error		do: [^ self formattedCode asText].	text addAttribute: TextColor gray from: 1 to: self start - 1.	text addAttribute: TextColor gray from: self stop + 1 to: text size.	^ text! !!RBBlockNode methodsFor: '*newcompiler' stamp: 'ajh 6/28/2004 13:52'!compiledMethod	^ self ir compiledMethod! !!RBBlockNode methodsFor: '*newcompiler' stamp: 'md 2/21/2006 14:41'!generate	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	^self generate: #(0 0 0 0)! !!RBBlockNode methodsFor: '*newcompiler' stamp: 'ajh 3/10/2003 20:23'!generate: trailer	^ self generateIR compiledMethodWith: trailer! !!RBBlockNode methodsFor: '*newcompiler' stamp: 'md 4/8/2007 17:45'!generateIR	| irm |		irm := ASTTranslator new translateBlockNode: self; ir.	self privIR: irm.	^irm.! !!RBBlockNode methodsFor: '*newcompiler' stamp: 'pmm 8/16/2006 21:34'!generateWith: trailer using: aCompiledMethodClass	^ self generateIR compiledMethodWith: trailer using: aCompiledMethodClass! !!RBBlockNode methodsFor: '*newcompiler' stamp: 'md 4/8/2007 17:48'!ir	^ self propertyAt: #ir ifAbsent: [self generateIR].! !!RBBlockNode methodsFor: '*newcompiler' stamp: 'md 2/27/2006 18:13'!methodNodeFormattedAndDecorated: decorate	"Answer a method node made from pretty-printed (and colorized, if decorate is true) 	 source text."	^ self method methodNodeFormattedAndDecorated: decorate.! !!RBBlockNode methodsFor: '*newcompiler' stamp: 'md 4/8/2007 17:49'!privIR: irMethod	irMethod ifNil: [^self removeProperty: #ir ifAbsent: []].	self propertyAt: #ir put: irMethod.! !!RBBlockNode methodsFor: '*persephone' stamp: 'md 11/11/2007 14:10'!definitions	^self arguments asOrderedCollection addAll: self body temporaries; yourself.! !!RBBlockNode methodsFor: '*persephone' stamp: 'md 11/11/2007 13:39'!enclosingBlockOrMethod	^self! !!RBBlockNode methodsFor: '*persephone' stamp: 'md 4/14/2007 01:57'!numArgs	^self arguments size! !!RBBlockNode methodsFor: '*geppetto2' stamp: 'md 3/8/2007 22:17'!gpAddAfter: aNode	self body: (RBMessageNode			receiver: (RBBlockNode body: self body)			selector: #ensure:			arguments: {RBBlockNode body: aNode copy asSequenceNode}) asSequenceNode.! !!RBBlockNode methodsFor: '*geppetto2' stamp: 'md 3/8/2007 22:17'!gpAddBefore: aNode	self body addNodeFirst: aNode.! !!RBBlockNode methodsFor: '*geppetto2' stamp: 'md 2/27/2007 21:27'!gpreplaceWith: aNode 	self body: aNode copy asSequenceNode.! !!RBBlockNode methodsFor: '*Colorer' stamp: 'pmm 11/27/2006 12:50'!markExecuted	super markExecuted.	self arguments do: [ :each |		each markExecuted ]! !!RBBlockNode commentStamp: 'md 4/7/2007 21:09' prior: 0!RBBlockNode is an AST node that represents a block "[...]".Instance Variables:	arguments	<SequenceableCollection of: RBVariableNode>	the arguments for the block	body	<RBSequenceNode>	the code inside the block		Properties: 	bar	<Integer | nil>	position of the | after the arguments	colons	<SequenceableCollection of: Integer>	positions of each : before each argument	left	<Integer>	position of [	right	<Integer>	position of ]		!!RBBlockNode class methodsFor: 'instance creation'!arguments: argNodes body: sequenceNode 	^(self new)		arguments: argNodes;		body: sequenceNode;		yourself! !!RBBlockNode class methodsFor: 'instance creation'!body: sequenceNode 	^self arguments: #() body: sequenceNode! !!RBBlockNodeTest methodsFor: 'method - tested' stamp: 'ms 3/31/2007 20:46'!expectedFailures	Smalltalk at: #SqueakParser ifAbsent:[^#(#testFirstLastToken)].	^#()! !!RBBlockNodeTest methodsFor: 'testing' stamp: 'ms 9/18/2006 18:42'!testFirstLastToken		| rbNode |	rbNode := (self defaultParser parseMethod: 'test []') body statements first.	self assert: (rbNode firstToken value = '[').	self assert: (rbNode lastToken value = ']').		rbNode := (self defaultParser parseMethod: 'test [:each :a]') body statements first.	self assert: (rbNode firstToken value = '[').	self assert: (rbNode lastToken value = ']').	rbNode := (self defaultParser parseMethod: 'test [:each :a | ^self]') body statements first.	self assert: (rbNode firstToken value = '[').	self assert: (rbNode lastToken value = ']').	rbNode := (self defaultParser parseMethod: 'test [^self]') body statements first.	self assert: (rbNode firstToken value = '[').	self assert: (rbNode lastToken value = ']').	rbNode := (self defaultParser parseMethod: 'test [| temp |]') body statements first.	self assert: (rbNode firstToken value = '[').	self assert: (rbNode lastToken value = ']').	rbNode := (self defaultParser parseMethod: 'test [:each || temp | ^self]') body statements first.	self assert: (rbNode firstToken value = '[').	self assert: (rbNode lastToken value = ']')! !!RBBlockNodeTest methodsFor: 'testing' stamp: 'ms 3/31/2007 17:02'!testPosition		| rbNode |	rbNode := (self defaultParser parseMethod: 'test []') body statements first.	self assertPosition: rbNode start: 6 stop: 7.		rbNode := (self defaultParser parseMethod: 'test [:each :a]') body statements first.	self assertPosition: rbNode start: 6 stop: 15.	rbNode := (self defaultParser parseMethod: 'test [:each :a | ^self]') body statements first.	self assertPosition: rbNode start: 6 stop: 23.	rbNode := (self defaultParser parseMethod: 'test [^self]') body statements first.	self assertPosition: rbNode start: 6 stop: 12.	rbNode := (self defaultParser parseMethod: 'test [| temp |]') body statements first.	self assertPosition: rbNode start: 6 stop: 15.	rbNode := (self defaultParser parseMethod: 'test [:each || temp | ^self]') body statements first.	self assertPosition: rbNode start: 6 stop: 28.! !!RBBlockReplaceRule methodsFor: 'matching'!foundMatchFor: aProgramNode 	^replaceBlock value: aProgramNode! !!RBBlockReplaceRule methodsFor: 'initialize-release'!initialize	super initialize.	replaceBlock := [:aNode | aNode]! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchFor: searchString replaceWith: aBlock 	self searchString: searchString.	replaceBlock := aBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchFor: searchString replaceWith: replBlock when: verifyBlock 	self searchFor: searchString replaceWith: replBlock.	verificationBlock := verifyBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchForMethod: searchString replaceWith: aBlock 	self methodSearchString: searchString.	replaceBlock := aBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchForMethod: searchString replaceWith: replBlock when: verifyBlock 	self searchForMethod: searchString replaceWith: replBlock.	verificationBlock := verifyBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode replaceWith: aBlock 	searchTree := aBRProgramNode.	replaceBlock := aBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode replaceWith: replBlock when: verifyBlock 	self searchForTree: aBRProgramNode replaceWith: replBlock.	verificationBlock := verifyBlock! !!RBBlockReplaceRule commentStamp: 'md 8/9/2005 14:55' prior: 0!RBBlockReplaceRule replaces the matching node by the result of evaluating replaceBlock. This allows arbitrary computation to come up with a replacement.Instance Variables:	replaceBlock	<BlockClosure>	The block that returns the node to replace to matching node with.!!RBBlockReplaceRule class methodsFor: 'instance creation'!searchFor: searchString replaceWith: replaceBlock 	^self new searchFor: searchString replaceWith: replaceBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchFor: searchString replaceWith: replaceBlock when: aBlock 	^self new 		searchFor: searchString		replaceWith: replaceBlock		when: aBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchForMethod: searchString replaceWith: replaceBlock 	^self new searchForMethod: searchString replaceWith: replaceBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchForMethod: searchString replaceWith: replaceBlock when: aBlock 	^self new 		searchForMethod: searchString		replaceWith: replaceBlock		when: aBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchForTree: searchString replaceWith: replaceBlock 	^self new searchForTree: searchString replaceWith: replaceBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchForTree: searchString replaceWith: replaceBlock when: aBlock 	^self new 		searchFor: searchString		replaceWith: replaceBlock		when: aBlock! !!RBCascadeNode methodsFor: 'comparing' stamp: 'pmm 7/12/2006 15:58'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self messages = anObject messages! !!RBCascadeNode methodsFor: 'comparing' stamp: 'pmm 7/13/2006 18:38'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self messages size == anObject messages size ifFalse: [^false].	self messages with: anObject messages do: [ :first :second |		(first equalTo: second withMapping: aDictionary)			ifFalse: [^false]].	^true! !!RBCascadeNode methodsFor: 'comparing' stamp: 'bh 4/10/2001 15:59'!hash	^self messages asArray hash! !!RBCascadeNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptCascadeNode: self! !!RBCascadeNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:39'!basicFirstToken		^self messages first firstToken! !!RBCascadeNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:39'!basicLastToken		^self messages last lastToken! !!RBCascadeNode methodsFor: 'querying'!bestNodeFor: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	messages 		reverseDo: [:each | (each containedBy: anInterval) ifTrue: [^each]].	selectedChildren := (messages 				collect: [:each | each bestNodeFor: anInterval]) 					reject: [:each | each isNil].	^selectedChildren detect: [:each | true] ifNone: [nil]! !!RBCascadeNode methodsFor: 'querying'!whichNodeIsContainedBy: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	messages 		reverseDo: [:each | (each containedBy: anInterval) ifTrue: [^each]].	selectedChildren := (messages 				collect: [:each | each whichNodeIsContainedBy: anInterval]) 					reject: [:each | each isNil].	^selectedChildren detect: [:each | true] ifNone: [nil]! !!RBCascadeNode methodsFor: 'accessing'!children	^self messages! !!RBCascadeNode methodsFor: 'accessing'!messages	^messages! !!RBCascadeNode methodsFor: 'accessing'!messages: messageNodeCollection 	messages := messageNodeCollection.	messages do: [:each | each parent: self]! !!RBCascadeNode methodsFor: 'accessing'!precedence	^4! !!RBCascadeNode methodsFor: 'accessing' stamp: 'ajh 2/25/2003 01:12'!receiver	^ self messages first receiver! !!RBCascadeNode methodsFor: 'accessing'!startWithoutParentheses	^messages first start! !!RBCascadeNode methodsFor: 'accessing'!stopWithoutParentheses	^messages last stop! !!RBCascadeNode methodsFor: 'matching'!copyInContext: aDictionary 	^(self class new) messages: (self copyList: messages inContext: aDictionary);		yourself! !!RBCascadeNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^self matchList: messages		against: aNode messages		inContext: aDictionary! !!RBCascadeNode methodsFor: 'testing'!directlyUses: aNode 	^messages last = aNode and: [self isDirectlyUsed]! !!RBCascadeNode methodsFor: 'testing'!isCascade	^true! !!RBCascadeNode methodsFor: 'testing'!uses: aNode 	^messages last = aNode and: [self isUsed]! !!RBCascadeNode methodsFor: 'initialize-release' stamp: 'md 4/7/2007 12:55'!messages: messageNodes semicolons: integerCollection 	self messages: messageNodes.	self propertyAt: #semicolons put: integerCollection! !!RBCascadeNode methodsFor: 'copying' stamp: 'pmm 9/19/2005 11:32'!postCopy	super postCopy.	messages := messages collect: [:each |		each copy		parent: self;		yourself ]! !!RBCascadeNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	self messages: (messages 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !!RBCascadeNode commentStamp: 'md 4/7/2007 12:56' prior: 0!RBCascadeNode is an AST node for cascaded messages (e.g., "self print1 ; print2").Instance Variables:	messages	<SequenceableCollection of: RBMessageNode>	the messages Properties:			   #semicolons <SequenceableCollection of: Integer>	positions of the ; between messages!!RBCascadeNode class methodsFor: 'instance creation'!messages: messageNodes 	^self new messages: messageNodes! !!RBCascadeNode class methodsFor: 'instance creation'!messages: messageNodes semicolons: integerCollection 	^self new messages: messageNodes semicolons: integerCollection! !!RBCascadeNodeTest methodsFor: 'testing' stamp: 'ms 9/17/2006 00:30'!testFirstLastToken		| rbNode |	rbNode := (self defaultParser parseMethod: 'test i factorial; add: aNum') body statements first.	self assert: (rbNode firstToken value = 'i').	self assert: (rbNode lastToken value = 'aNum')! !!RBCascadeNodeTest methodsFor: 'testing' stamp: 'ms 3/31/2007 17:04'!testPosition		| rbNode |	rbNode := (self defaultParser parseMethod: 'test i factorial; add: aNum') body statements first.	self assertPosition: rbNode start: 6 stop: 27! !!RBClass methodsFor: 'variable accessing'!addClassVariable: aString 	self privateClassVariableNames add: aString asSymbol.	model addClassVariable: aString to: self! !!RBClass methodsFor: 'variable accessing'!addPoolDictionary: aString 	self privatePoolDictionaryNames add: aString asSymbol.	model addPool: aString to: self! !!RBClass methodsFor: 'variable accessing'!removeClassVariable: aString 	self privateClassVariableNames remove: aString asSymbol.	model removeClassVariable: aString from: self! !!RBClass methodsFor: 'variable accessing'!removePoolDictionary: aString 	self privatePoolDictionaryNames remove: aString asSymbol! !!RBClass methodsFor: 'variable accessing'!renameClassVariable: oldName to: newName around: aBlock 	self privateClassVariableNames 		at: (self privateClassVariableNames indexOf: oldName asSymbol)		put: newName asSymbol.	model 		renameClassVariable: oldName		to: newName		in: self		around: aBlock! !!RBClass methodsFor: 'accessing'!allClassVariableNames	| sprClass |	sprClass := self superclass.	^sprClass isNil 		ifTrue: [self classVariableNames]		ifFalse: [sprClass allClassVariableNames , self classVariableNames]! !!RBClass methodsFor: 'accessing'!allPoolDictionaryNames	| sprClass |	sprClass := self superclass.	^sprClass isNil 		ifTrue: [self poolDictionaryNames]		ifFalse: [sprClass allPoolDictionaryNames , self poolDictionaryNames]! !!RBClass methodsFor: 'accessing' stamp: 'bh 11/8/2000 15:22'!category	^category isNil 		ifTrue: 			[self isDefined				ifTrue: [category := self realClass category]				ifFalse: [model environment whichCategoryIncludes: self name]]		ifFalse: [category]! !!RBClass methodsFor: 'accessing'!category: aSymbol 	category := aSymbol! !!RBClass methodsFor: 'accessing'!classVariableNames	^self privateClassVariableNames copy! !!RBClass methodsFor: 'accessing'!classVariableNames: aCollectionOfStrings 	classVariableNames := (aCollectionOfStrings 				collect: [:each | each asSymbol]) asOrderedCollection! !!RBClass methodsFor: 'accessing' stamp: 'bh 11/8/2000 14:38'!definitionString	| definitionStream |	definitionStream := WriteStream on: ''.	definitionStream		nextPutAll: self superclass printString;		nextPutAll: ' subclass: #';		nextPutAll: self name;		nextPutAll: '	instanceVariableNames: '''.	self instanceVariableNames do: 			[:each | 			definitionStream				nextPutAll: each;				nextPut: $ ].	definitionStream nextPutAll: '''	classVariableNames: '''.	self classVariableNames do: 			[:each | 			definitionStream				nextPutAll: each;				nextPut: $ ].	definitionStream nextPutAll: '''	poolDictionaries: '''.	self poolDictionaryNames do: 			[:each | 			definitionStream				nextPutAll: each;				nextPut: $ ].	definitionStream nextPutAll: '''	category: #'''.	definitionStream nextPutAll: self category asString.	definitionStream nextPut: $'.	^definitionStream contents! !!RBClass methodsFor: 'accessing'!nonMetaclass	^self! !!RBClass methodsFor: 'accessing'!poolDictionaryNames	^self privatePoolDictionaryNames copy! !!RBClass methodsFor: 'accessing'!poolDictionaryNames: aCollectionOfStrings 	poolDictionaryNames := (aCollectionOfStrings 				collect: [:each | each asSymbol]) asOrderedCollection! !!RBClass methodsFor: 'accessing'!sharedPools	^self allPoolDictionaryNames 		collect: [:each | Smalltalk at: each asSymbol ifAbsent: [Dictionary new]]! !!RBClass methodsFor: 'testing'!directlyDefinesClassVariable: aString 	^self classVariableNames includes: aString asSymbol! !!RBClass methodsFor: 'testing'!directlyDefinesPoolDictionary: aString 	^self poolDictionaryNames includes: aString asSymbol! !!RBClass methodsFor: 'testing'!isMeta	^false! !!RBClass methodsFor: 'private'!privateClassVariableNames	(self isDefined and: [classVariableNames isNil]) 		ifTrue: [self classVariableNames: self realClass classVarNames].	^classVariableNames! !!RBClass methodsFor: 'private'!privatePoolDictionaryNames	(self isDefined and: [poolDictionaryNames isNil]) 		ifTrue: 			[self poolDictionaryNames: (self realClass sharedPools 						collect: [:each | Smalltalk keyAtValue: each])].	^poolDictionaryNames! !!RBClass methodsFor: 'initialize-release'!realName: aSymbol 	self realClass: (Smalltalk at: aSymbol)! !!RBClass class methodsFor: 'instance creation'!existingNamed: aSymbol 	^(self named: aSymbol)		realName: aSymbol;		yourself! !!RBClass class methodsFor: 'instance creation'!named: aSymbol 	^(self new)		name: aSymbol;		yourself! !!RBClassTest methodsFor: 'set up' stamp: 'bh 11/8/2000 14:12'!setUp	| st |	super setUp.	st := RBNamespace new.	objectClass := st classNamed: #Object.	messageNodeClass := st classNamed: #RBMessageNode.	st defineClass: 'Object subclass: #SomeClassName	instanceVariableNames: ''instanceVariable1 instanceVariable2''	classVariableNames: ''ClassVariable1''	poolDictionaries: ''TextConstants''	category: #''Refactory-Testing'''.	newClass := st classNamed: #SomeClassName! !!RBClassTest methodsFor: 'method tests'!testDefinesClassVariable	self deny: (objectClass definesClassVariable: #ClassVariable1).	self assert: (objectClass definesClassVariable: self objectClassVariable).	self assert: (newClass definesClassVariable: #ClassVariable1).	self deny: (messageNodeClass definesClassVariable: #ClassVariable1).	self 		assert: (messageNodeClass definesClassVariable: self objectClassVariable)! !!RBClassTest methodsFor: 'method tests'!testDefinesInstanceVariable	self deny: (objectClass definesInstanceVariable: 'instanceVariable1').	self assert: (newClass definesInstanceVariable: 'instanceVariable1').	self deny: (messageNodeClass definesInstanceVariable: 'instanceVariable1').	self assert: (messageNodeClass definesInstanceVariable: 'parent').	self assert: (messageNodeClass definesInstanceVariable: 'selector')! !!RBClassTest methodsFor: 'method tests'!testDefinesMethod	self assert: (objectClass definesMethod: #printString).	self assert: (newClass definesMethod: #printString).	self assert: (messageNodeClass definesMethod: #printString)! !!RBClassTest methodsFor: 'method tests' stamp: 'bh 4/3/2000 22:22'!testDefinesPoolDictionary	self deny: (objectClass definesPoolDictionary: #OpcodePool).	self assert: (newClass definesPoolDictionary: #TextConstants).	self deny: (messageNodeClass definesPoolDictionary: #OpcodePool).	self assert: ((RBNamespace new classNamed: #Text) 				definesPoolDictionary: #TextConstants)! !!RBClassTest methodsFor: 'method tests'!testHierarchy	| meta |	meta := objectClass metaclass.	self assert: (objectClass withAllSubclasses includes: meta).	self assert: (meta withAllSuperclasses includes: objectClass)! !!RBColorFormatter methodsFor: 'visitor-double dispatching' stamp: 'nk 3/3/2005 10:50'!acceptLiteralNode: aNode	codeStream withStyleFor: #literal do: [ super acceptLiteralNode: aNode ]! !!RBColorFormatter methodsFor: 'visitor-double dispatching' stamp: 'nk 3/3/2005 11:21'!acceptVariableNode: aNode	| definer usage |	definer := aNode whoDefines: aNode name.	usage := #variable.	definer ifNotNil: [		definer isBlock ifTrue: [ usage := #blockArgument ].		definer isMethod ifTrue: [ usage := #methodArgument ].		definer isSequence ifTrue: [ usage := #temporaryVariable ].	].	^codeStream withStyleFor: usage do: [ super acceptVariableNode: aNode ]! !!RBColorFormatter methodsFor: 'private-formatting' stamp: 'nk 3/3/2005 10:51'!formatMessageSelectorPart: part	^codeStream withStyleFor: #keyword do: [ super formatMessageSelectorPart: part ]	! !!RBColorFormatter methodsFor: 'private-formatting' stamp: 'nk 3/3/2005 10:55'!formatStatementCommentFor: aNode	^codeStream withStyleFor: #comment do: [ super formatStatementCommentFor: aNode ]	! !!RBColorFormatter methodsFor: 'initialize-release' stamp: 'md 9/1/2005 13:50'!initialize	super initialize.	codeStream := ColoredCodeStream on: (Text new: 400).! !!RBColorFormatter methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:15'!visitBlockArgument: aNode	^codeStream withStyleFor: #blockArgument do: [ super visitBlockArgument: aNode ]! !!RBColorFormatter methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:15'!visitMethodArgument: aNode	^codeStream withStyleFor: #methodArgument do: [ super visitMethodArgument: aNode ]! !!RBColorFormatter methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:15'!visitTemporaryVariable: aNode	^codeStream withStyleFor: #temporaryVariable do: [ super visitTemporaryVariable: aNode ]! !!RBColorFormatter commentStamp: '<historical>' prior: 0!I am a specialization of RBFormatter that produces a colorized Text instead of a String as my formatted output.!!RBCondition methodsFor: 'checking'!check	^block value! !!RBCondition methodsFor: 'initialize-release'!errorBlock: anObject	errorBlock := anObject! !!RBCondition methodsFor: 'initialize-release' stamp: 'dvf 11/24/2001 13:14'!type: aSymbol block: aBlock errorString: aString 	self needsWork.  "replaced value with fixTemps. This should simulate closures well enough, we hope."	type := aSymbol.	block := aBlock fixTemps.	self errorMacro: aString! !!RBCondition methodsFor: 'initialize-release'!withBlock: aBlock 	block := aBlock.	type := #(#generic)! !!RBCondition methodsFor: 'accessing'!errorBlockFor: aBoolean	^errorBlock! !!RBCondition methodsFor: 'printing' stamp: 'bh 4/10/2001 16:51'!printOn: aStream 	aStream nextPutAll: type asString! !!RBCondition class methodsFor: 'instance creation'!canUnderstand: aSelector in: aClass	^self new		type: (Array with: #understandsSelector with: aClass with: aSelector)		block: [aClass definesMethod: aSelector]		errorString: aClass printString , ' <1?:does not >understand<1?s:> ' , aSelector printString! !!RBCondition class methodsFor: 'instance creation'!definesClassVariable: aString in: aClass 	^self new 		type: (Array 				with: #definesClassVar				with: aClass				with: aString)		block: [aClass definesClassVariable: aString]		errorString: aClass printString 				, ' <1?:does not >define<1?s:> class variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!definesInstanceVariable: aString in: aClass 	^self new 		type: (Array 				with: #definesInstVar				with: aClass				with: aString)		block: [aClass definesInstanceVariable: aString]		errorString: aClass printString 				, ' <1?:does not >define<1?s:> instance variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!definesSelector: aSelector in: aClass 	^self new		type: (Array with: #definesSelector with: aClass with: aSelector)		block: [aClass directlyDefinesMethod: aSelector]		errorString: aClass printString , ' <1?:does not >define<1?s:> ' , aSelector printString! !!RBCondition class methodsFor: 'instance creation'!definesTempVar: aString in: aClass ignoreClass: subclass 	| condition |	condition := self new.	condition 		type: (Array with: #definesTempVarIgnoring with: aClass with: aString with: subclass)		block: 			[| method |			method := self 						methodDefiningTemporary: aString						in: aClass						ignore: [:class :aSelector | class includesClass: subclass].			method notNil 				ifTrue: 					[condition errorMacro: method printString , ' defines variable ' , aString].			method notNil]		errorString: aClass printString 				, ' <1?:does not >define<1?s:> temporary variable ' , aString.	^condition! !!RBCondition class methodsFor: 'instance creation'!definesTemporaryVariable: aString in: aClass 	| condition |	condition := self new.	condition 		type: (Array with: #definesTempVar with: aClass with: aString)		block: 			[| method |			method := self 						methodDefiningTemporary: aString						in: aClass						ignore: [:class :selector | false].			method notNil 				ifTrue: 					[condition errorMacro: method printString , ' defines variable ' , aString].			method notNil]		errorString: aClass printString 				, ' <1?:does not >define<1?s:> temporary variable ' , aString.	^condition! !!RBCondition class methodsFor: 'instance creation'!directlyDefinesClassVariable: aString in: aClass 	^self new 		type: (Array with: #directlyDefinesClassVar with: aClass with: aString)		block: [aClass directlyDefinesClassVariable: aString]		errorString: aClass printString 				, ' <1?:does not >directly define<1?s:> class variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!directlyDefinesInstanceVariable: aString in: aClass 	^self new 		type: (Array with: #directlyDefinesInstanceVariable with: aClass with: aString)		block: [aClass directlyDefinesInstanceVariable: aString]		errorString: aClass printString 				, ' <1?:does not >directly define<1?s:> instance variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!empty	"Returns an empty condition"	^self new 		type: (Array with: #empty)		block: [true]		errorString: 'Empty'! !!RBCondition class methodsFor: 'instance creation'!hasSubclasses: aClass	^self new		type: (Array with: #hasSubclasses with: aClass)		block: [aClass subclasses isEmpty not]		errorString: aClass printString , ' has <1?:no >subclasses'! !!RBCondition class methodsFor: 'instance creation'!hasSuperclass: aClass 	^self new 		type: (Array with: #hasSuperclass with: aClass)		block: [aClass superclass isNil not]		errorString: aClass printString , ' has <1?a:no> superclass'! !!RBCondition class methodsFor: 'instance creation'!hierarchyOf: aClass canUnderstand: aSelector	^self new		type: (Array with: #hierarchyUnderstandsSelector with: aClass with: aSelector)		block: [aClass hierarchyDefinesMethod: aSelector]		errorString: aClass printString , ' <1?or a subclass:and all subclasses do not> understand<1?s:> ' , aSelector printString! !!RBCondition class methodsFor: 'instance creation'!hierarchyOf: aClass definesVariable: aString 	^self new 		type: (Array 				with: #hierarchyDefinesInstVar				with: aClass				with: aString)		block: [aClass hierarchyDefinesVariable: aString]		errorString: aClass printString 				, ' or one of its subclasses <1?:does not >define<1?s:> variable ' 					, aString! !!RBCondition class methodsFor: 'instance creation'!hierarchyOf: aClass referencesInstanceVariable: aString 	^self new 		type: (Array 				with: #hierarchyReferencesInstVar				with: aClass				with: aString)		block: 			[(aClass withAllSubclasses 				detect: [:each | (each whichSelectorsReferToInstanceVariable: aString) isEmpty not]				ifNone: [nil]) notNil]		errorString: aClass printString 				, ' or subclass <1?:does not >reference<1?s:> instance variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!isAbstractClass: aClass 	^self new 		type: (Array with: #IsAbstractClass with: aClass)		block: [aClass isAbstract]		errorString: aClass printString , ' is <1?:not >an abstract class'! !!RBCondition class methodsFor: 'instance creation'!isClass: anObject	^self new		type: (Array with: #IsClass with: anObject)		block: [anObject isBehavior]		errorString: anObject printString , ' is <1?:not >a behavior'! !!RBCondition class methodsFor: 'instance creation'!isEmptyClass: anObject 	^self new type: (Array with: #IsEmptyClass with: anObject)		block: 			[anObject classVariableNames isEmpty				and: [anObject instanceVariableNames isEmpty and: [anObject selectors isEmpty]]]		errorString: anObject printString , ' is <1?:not > empty'! !!RBCondition class methodsFor: 'instance creation'!isGlobal: aString in: aRBSmalltalk 	^self new 		type: (Array with: #isGlobal with: aString)		block: [aRBSmalltalk includesGlobal: aString asSymbol]		errorString: aString , ' is <1?:not >a class or global variable'! !!RBCondition class methodsFor: 'instance creation'!isImmediateSubclass: subclass of: superClass	^self new		type: (Array with: #immediateSubclass with: superClass with: subclass)		block: [subclass superclass = superClass]		errorString: subclass printString , ' is <1?:not >an immediate subclass of ' , superClass printString! !!RBCondition class methodsFor: 'instance creation'!isMetaclass: anObject 	^self new type: (Array with: #IsMetaclass with: anObject)		block: [anObject isMeta]		errorString: anObject printString , ' is <1?:not >a metaclass'! !!RBCondition class methodsFor: 'instance creation'!isSymbol: aString	^self new		type: (Array with: #isSymbol with: aString)		block: [aString isSymbol]		errorString: aString , ' is <1?:not >a symbol'! !!RBCondition class methodsFor: 'instance creation'!isValidClassName: aString	^self new		type: (Array with: #validClassName with: aString)		block: [self validClassName: aString]		errorString: aString , ' is <1?:not >a valid class name'! !!RBCondition class methodsFor: 'instance creation'!isValidClassVarName: aString for: aClass	^self new		type: (Array with: #validClassVarName with: aString with: aClass)		block: [self checkClassVarName: aString in: aClass]		errorString: aString , ' is <1?:not >a valid class variable name'! !!RBCondition class methodsFor: 'instance creation'!isValidInstanceVariableName: aString for: aClass 	^self new 		type: (Array 				with: #validInstVarName				with: aString				with: aClass)		block: [self checkInstanceVariableName: aString in: aClass]		errorString: aString , ' is <1?:not >a valid instance variable name'! !!RBCondition class methodsFor: 'instance creation'!isValidMethodName: aString for: aClass	^self new		type: (Array with: #validMethodName with: aString with: aClass)		block: [self checkMethodName: aString in: aClass]		errorString: aString printString , ' is <1?:not >a valid method name'! !!RBCondition class methodsFor: 'instance creation'!referencesInstanceVariable: aString in: aClass 	^self new 		type: (Array with: #referencesInstVar with: aClass with: aString)		block: [(aClass whichSelectorsReferToInstanceVariable: aString) isEmpty not]		errorString: aClass printString 				, ' <1?:does not >reference<1?s:> instance variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!subclassesOf: aClass referToSelector: aSelector 	^self new 		type: (Array 				with: #subclassReferences				with: aClass				with: aSelector)		block: 			[(aClass subclasses detect: 					[:each | 					(each selectors detect: 							[:sel | 							| tree |							tree := each parseTreeFor: sel.							tree notNil and: [tree superMessages includes: aSelector]]						ifNone: [nil]) notNil]				ifNone: [nil]) notNil]		errorString: '<1?:no:a> subclass of ' , aClass printString , ' refers to ' 				, aSelector printString! !!RBCondition class methodsFor: 'instance creation'!withBlock: aBlock	^self new withBlock: aBlock! !!RBCondition class methodsFor: 'instance creation'!withBlock: aBlock errorString: aString 	^self new type: #unknown		block: aBlock		errorString: aString! !!RBCondition class methodsFor: 'utilities'!checkClassVarName: aName in: aClass 	| string |	aName isString ifFalse: [^false].	string := aName asString.	(self reservedNames includes: string) ifTrue: [^false].	string isEmpty ifTrue: [^false].	string first isUppercase ifFalse: [^false].	^RBScanner isVariable: string! !!RBCondition class methodsFor: 'utilities'!checkInstanceVariableName: aName in: aClass 	| string |	aName isString ifFalse: [^false].	string := aName asString.	string isEmpty ifTrue: [^false].	(self reservedNames includes: string) ifTrue: [^false].	string first isUppercase ifTrue: [^false].	^RBScanner isVariable: string! !!RBCondition class methodsFor: 'utilities'!checkMethodName: aName in: aClass 	^aName isString and: [RBScanner isSelector: aName]! !!RBCondition class methodsFor: 'utilities'!methodDefiningTemporary: aString in: aClass ignore: aBlock 	| searcher method |	searcher := ParseTreeSearcher new.	method := nil.	"Shut-up the warning"	searcher matches: aString do: [:aNode :answer | ^method].	aClass withAllSubclasses do: 			[:class | 			class selectors do: 					[:each | 					(aBlock value: class value: each) 						ifFalse: 							[| parseTree |							method := class methodFor: each.							parseTree := class parseTreeFor: each.							parseTree notNil ifTrue: [searcher executeTree: parseTree]]]].	^nil! !!RBCondition class methodsFor: 'utilities'!reservedNames	^#('self' 'true' 'false' 'nil' 'thisContext' 'super')! !!RBCondition class methodsFor: 'utilities'!validClassName: aString 	"Class names and class variable names have the same restrictions"	^self checkClassVarName: aString in: self! !!RBConjunctiveCondition methodsFor: 'checking'!check	left check		ifFalse: 			[failed := #leftFailed.			^false].	right check		ifFalse: 			[failed := #rightFailed.			^false].	^true! !!RBConjunctiveCondition methodsFor: 'private'!errorBlockFor: aBoolean 	^aBoolean		ifTrue: [nil]		ifFalse: 			[failed == #leftFailed ifTrue: [left errorBlock] ifFalse: [right errorBlock]]! !!RBConjunctiveCondition methodsFor: 'private'!errorMacro	^errorMacro isNil		ifTrue: [self longMacro]		ifFalse: [super errorMacro]! !!RBConjunctiveCondition methodsFor: 'private'!errorStringFor: aBoolean 	^aBoolean		ifTrue: [self neitherFailed]		ifFalse: [self perform: failed]! !!RBConjunctiveCondition methodsFor: 'private'!leftFailed	^left errorStringFor: false! !!RBConjunctiveCondition methodsFor: 'private'!longMacro	^'(' , left errorMacro , ') <1?AND:OR> (' , right errorMacro , ')'! !!RBConjunctiveCondition methodsFor: 'private'!neitherFailed	^(left errorStringFor: true) , ' AND ' , (right errorStringFor: true)! !!RBConjunctiveCondition methodsFor: 'private'!rightFailed	^right errorStringFor: false! !!RBConjunctiveCondition methodsFor: 'private'!unknownFailed	^(left errorStringFor: false) , ' OR ' , (right errorStringFor: false)! !!RBConjunctiveCondition methodsFor: 'initialize-release'!left: aCondition right: aCondition2 	left := aCondition.	right := aCondition2.	failed := #unknownFailed! !!RBConjunctiveCondition methodsFor: 'printing' stamp: 'bh 4/10/2001 16:52'!printOn: aStream 	aStream nextPutAll: left asString;		nextPutAll: ' & ';		nextPutAll: right asString! !!RBDoItNode methodsFor: 'comparing' stamp: 'ajh 2/26/2003 18:35'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	(self body = anObject body) ifFalse: [^false].	^true! !!RBDoItNode methodsFor: 'comparing' stamp: 'ajh 2/26/2003 18:35'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	(self body equalTo: anObject body withMapping: aDictionary) 		ifFalse: [^false].	^self primitiveSources = anObject primitiveSources! !!RBDoItNode methodsFor: 'comparing' stamp: 'ajh 2/26/2003 18:36'!hash	^ self body hash! !!RBDoItNode methodsFor: 'visitor' stamp: 'ajh 2/26/2003 18:31'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptDoItNode: self! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!addNode: aNode 	^body addNode: aNode! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!addReturn	body addReturn! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!addSelfReturn	^body addSelfReturn! !!RBDoItNode methodsFor: 'accessing' stamp: 'ms 7/3/2007 13:39'!arguments	^#()! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!body	^body! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!body: stmtsNode 	body := stmtsNode.	body parent: self! !!RBDoItNode methodsFor: 'accessing' stamp: 'md 6/29/2005 12:21'!byteSurgeon	byteSurgeon ifNil: [byteSurgeon := false].	^byteSurgeon! !!RBDoItNode methodsFor: 'accessing' stamp: 'md 6/29/2005 12:20'!byteSurgeon: boolean	byteSurgeon := boolean.! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:28'!children	^ {self body}! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!primitiveSources	^self tags 		collect: [:each | self source copyFrom: each first to: each last]! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!source	^source! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!source: anObject	source := anObject! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!start	^1! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!stop	^source size! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!tags	^tags isNil ifTrue: [#()] ifFalse: [tags]! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!tags: aCollectionOfIntervals 	tags := aCollectionOfIntervals! !!RBDoItNode methodsFor: 'matching' stamp: 'ajh 2/26/2003 18:24'!copyInContext: aDictionary 	^(self class new)		body: (body copyInContext: aDictionary);		source: (aDictionary at: '-source-');		yourself! !!RBDoItNode methodsFor: 'matching' stamp: 'ajh 2/26/2003 18:28'!match: aNode inContext: aDictionary 	self class == aNode class ifFalse: [^false].	aDictionary at: '-source-' put: aNode source.	^ body match: aNode body inContext: aDictionary! !!RBDoItNode methodsFor: 'semantics' stamp: 'ajh 7/8/2004 20:56'!freeNames	"Filter out hidden ones that have space in there name such as 'top env'"	^ ((self freeVars collect: [:var | var name])		reject: [:name | name includes: $ ]) asSortedCollection! !!RBDoItNode methodsFor: 'semantics' stamp: 'ajh 7/8/2004 20:59'!freeVars	"Return children variable node bindings that refer to variables outside my scope (ignoring global vars)"	| freeVars |	freeVars := Set new.	scope := self owningScope.	self nodesDo: [:node | | var |		(node isVariable or: [node isReturn and: [node binding notNil]]) ifTrue: [			var := node binding.			(scope hasOuter: var scope) ifTrue: [				var isGlobal ifFalse: [					freeVars add: var]]]].	^ freeVars! !!RBDoItNode methodsFor: 'semantics' stamp: 'ajh 6/30/2004 14:07'!owningBlock	^ self! !!RBDoItNode methodsFor: 'semantics' stamp: 'ajh 3/13/2003 04:25'!owningScope	^ scope! !!RBDoItNode methodsFor: 'semantics' stamp: 'ajh 3/16/2003 08:33'!scope	^ scope ifNil: [		self verifyIn: nil parseScope.		scope	  ]! !!RBDoItNode methodsFor: 'semantics' stamp: 'ajh 3/17/2003 15:34'!scope: aSemScope	scope := aSemScope! !!RBDoItNode methodsFor: 'testing' stamp: 'ajh 6/29/2004 14:11'!isDoIt	^ true! !!RBDoItNode methodsFor: 'testing' stamp: 'ajh 2/26/2003 18:22'!isLast: aNode 	^body isLast: aNode! !!RBDoItNode methodsFor: 'testing' stamp: 'ajh 2/26/2003 18:22'!lastIsReturn	^body lastIsReturn! !!RBDoItNode methodsFor: 'testing' stamp: 'ajh 2/26/2003 18:22'!references: aVariableName 	^body references: aVariableName! !!RBDoItNode methodsFor: 'testing' stamp: 'ajh 2/26/2003 18:22'!uses: aNode 	^body == aNode and: [aNode lastIsReturn]! !!RBDoItNode methodsFor: 'copying' stamp: 'pmm 9/19/2005 11:29'!postCopy	super postCopy.	body := body copy.	body parent: self.! !!RBDoItNode methodsFor: 'printing' stamp: 'ajh 2/26/2003 18:22'!printOn: aStream	aStream nextPutAll: self formattedCode! !!RBDoItNode methodsFor: 'printing' stamp: 'ajh 6/29/2004 14:31'!sourceText	^ (self source ifNil: [self formattedCode]) asText! !!RBDoItNode methodsFor: 'replacing' stamp: 'ajh 2/26/2003 18:57'!replaceNode: aNode withNode: anotherNode	aNode == body ifTrue: [self body: anotherNode].! !!RBDoItNode methodsFor: 'debugging' stamp: 'ms 11/22/2007 00:20'!sourceMap	"Return a mapping from bytecode pcs to source code ranges"	^ self ir sourceMap 	asSortedCollection! !!RBDoItNode methodsFor: 'debugging' stamp: 'ajh 6/29/2004 16:06'!tempNames	"All temp names in context order"	^ self scope tempVars allButFirst "without receiver" collect: [:var | var name]! !!RBDoItNode methodsFor: '*newcompiler' stamp: 'ajh 6/28/2004 13:52'!compiledMethod	^ self ir compiledMethod! !!RBDoItNode methodsFor: '*newcompiler' stamp: 'md 2/21/2006 14:41'!generate	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	^self generate: #(0 0 0 0)! !!RBDoItNode methodsFor: '*newcompiler' stamp: 'ajh 3/10/2003 20:23'!generate: trailer	^ self generateIR compiledMethodWith: trailer! !!RBDoItNode methodsFor: '*newcompiler' stamp: 'ms 11/21/2007 22:57'!generateIR	^ ir := ASTTranslator new		visitNode: self;		ir! !!RBDoItNode methodsFor: '*newcompiler' stamp: 'pmm 8/16/2006 21:34'!generateWith: trailer using: aCompiledMethodClass	^ self generateIR compiledMethodWith: trailer using: aCompiledMethodClass! !!RBDoItNode methodsFor: '*newcompiler' stamp: 'ajh 3/10/2003 20:25'!ir	^ ir ifNil: [self generateIR]! !!RBDoItNode methodsFor: '*newcompiler' stamp: 'md 10/5/2007 13:37'!verifyIn: classOrScope	"Look up vars in classOrScope.  My tree will be annotated with bindings to LexicalScopes and ScopeVars."	ASTChecker new		scope: classOrScope parseScope;		visitNode: self.			Preferences compileBlocksAsClosures ifFalse: [ 		NonClosureScopeFixer new visitNode: self.	]	! !!RBDoItNode methodsFor: '*persephone' stamp: 'pmm 6/11/2006 22:41'!evaluate	^self compiledMethod valueWithReceiver: nil arguments: #()! !!RBDoItNode class methodsFor: 'instance creation' stamp: 'ajh 3/11/2003 19:08'!body: aSequenceNode	^ self new body: aSequenceNode! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'cmm 3/10/2006 17:27'!acceptArrayNode: anArrayNode 	self maybeJoinLinesFrom: [		codeStream nextPutAll: '{ '.		self indent: 1 while: [			self indent.			self formatStatementsFor: anArrayNode.		].		self indent.		codeStream nextPutAll: ' }'.	]! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'cmm 10/21/2007 12:13'!acceptAssignmentNode: anAssignmentNode 	self visitNode: anAssignmentNode variable.	codeStream		space ;		nextPutAll: anAssignmentNode assignmentOperator ;		space.	self visitNode: anAssignmentNode value! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'cmm 3/11/2006 10:24'!acceptBlockNode: aBlockNode 	| seqNode multiline formattedBody formatter |	seqNode := aBlockNode body.	formatter := (self copy) lineStart: 0;				yourself.	formattedBody := formatter format: seqNode.	multiline := self lineLength + formattedBody size > self maxLineSize				or: [formatter isMultiLine].	multiline ifTrue: [self indent].	codeStream nextPutAll: '[ '.	aBlockNode arguments do: 			[:each | 			codeStream nextPutAll: ': '.			self visitBlockArgument: each.			codeStream nextPut: $ ].	aBlockNode arguments isEmpty ifFalse: 			[codeStream nextPutAll: '| '.			multiline ifTrue: [self indent]].	codeStream nextPutAll: formattedBody;		nextPutAll: ' ]'! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'cmm 3/12/2007 17:31'!acceptCascadeNode: aCascadeNode 	| messages |	messages := aCascadeNode messages.	self visitNode: messages first receiver.	self indentWhile: 			[messages do: 					[:each | 					self						indent;						indentWhile: [self formatMessage: each cascade: true]]				separatedBy: [codeStream nextPutAll: ' ;']]! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'ms 4/22/2007 17:29'!acceptDoItNode: aDoItNode 	codeStream nextPutAll: 'DoIt'.	self indentWhile: [			self indent.			self tagBeforeTemporaries ifTrue: [self formatTagFor: aDoItNode].			aDoItNode body statements isEmpty 				ifFalse: [self visitNode: aDoItNode body]]! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'lr 1/4/2007 10:11'!acceptLiteralNode: aLiteralNode	| start |	start := self fullPosition + 1.	self formatLiteral: aLiteralNode value.	aLiteralNode token start 		ifNil: [ aLiteralNode token start: start ]! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'cmm 3/12/2006 13:24'!acceptMessageNode: aMessageNode 	| newFormatter code |	newFormatter := self copy.	code := newFormatter format: aMessageNode receiver.	codeStream nextPutAll: code.	codeStream nextPut: $ .	newFormatter isMultiLine		ifTrue: [lineStart := codeStream position - newFormatter lastLineLength].	self indent: ((self shouldIndent: aMessageNode selector) ifTrue: [1] ifFalse: [0]) 		while: [self formatMessage: aMessageNode cascade: false]! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'SR 9/3/2006 10:13'!acceptMethodNode: aMethodNode 	self formatMethodPatternFor: aMethodNode.	self indentWhile: [			self formatPragmasFor: aMethodNode.			self formatMethodCommentFor: aMethodNode indentBefore: true.			self indent.			self tagBeforeTemporaries ifTrue: [self formatTagFor: aMethodNode].			aMethodNode body statements isEmpty 				ifFalse: [self visitNode: aMethodNode body]]! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'ms 9/4/2006 22:48'!acceptPragmaNode: aPragmaNode	aPragmaNode pragma printOn: codeStream! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'ajh 3/24/2003 13:15'!acceptPseudoNode: aPseudoNode	aPseudoNode isLabel ifTrue: [		codeStream nextPut: $L.		aPseudoNode destination printOn: codeStream.		^ self].	aPseudoNode isGoto ifTrue: [		codeStream nextPut: $G.		aPseudoNode destination printOn: codeStream.		^ self].	aPseudoNode isIf ifTrue: [		codeStream nextPutAll: 'If '.		codeStream nextPut: (aPseudoNode boolean ifTrue: [$t] ifFalse: [$f]).		codeStream space.		aPseudoNode destination printOn: codeStream.		codeStream space.		aPseudoNode otherwise printOn: codeStream.		^ self].! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'cmm 3/10/2006 17:05'!acceptReturnNode: aReturnNode 	codeStream nextPutAll: '^ '.	self visitNode: aReturnNode value! !!RBFormatter methodsFor: 'visitor-double dispatching'!acceptSequenceNode: aSequenceNode 	self formatMethodCommentFor: aSequenceNode indentBefore: false.	self formatTemporariesFor: aSequenceNode.	self tagBeforeTemporaries ifFalse: 			[| parent |			parent := aSequenceNode parent.			(parent notNil and: [parent isMethod]) ifTrue: [self formatTagFor: parent]].	self formatStatementsFor: aSequenceNode! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'ajh 3/19/2003 14:13'!acceptVariableNode: aVariableNode	aVariableNode token start ifNil: [		aVariableNode token start: self fullPosition + 1].	codeStream nextPutAll: aVariableNode name! !!RBFormatter methodsFor: 'accessing'!firstLineLength	^firstLineLength isNil		ifTrue: [codeStream position]		ifFalse: [firstLineLength]! !!RBFormatter methodsFor: 'accessing'!format: aNode 	self visitNode: aNode.	^codeStream contents! !!RBFormatter methodsFor: 'accessing'!isMultiLine	^firstLineLength notNil! !!RBFormatter methodsFor: 'accessing'!lastLineLength	^codeStream position - (lineStart max: 0)! !!RBFormatter methodsFor: 'private-formatting' stamp: 'md 2/26/2006 15:03'!formatLiteral: aValue 	| isArray |	(isArray := aValue class == Array) | (aValue class == ByteArray) ifTrue: 			[codeStream nextPutAll: (isArray ifTrue: ['#('] ifFalse: ['#[']).			self maybeJoinLinesFrom: 					[self indent: 1 while: 							[aValue do: [:each | 									self indent; formatLiteral: each]].					self indent.					codeStream nextPut: (isArray ifTrue: [$)] ifFalse: [$]])].			^self].	aValue isSymbol ifTrue:  [self formatSymbol: aValue. ^self].	aValue class == Character ifTrue: 			[codeStream nextPut: $$;				nextPut: aValue.			^self].	aValue isVariableBinding ifTrue: [		codeStream nextPutAll: '##'; nextPutAll: aValue key.		^ self].	aValue storeOn: codeStream! !!RBFormatter methodsFor: 'private-formatting' stamp: 'cmm 3/14/2006 21:15'!formatMessage: aMessageNode cascade: cascadeBoolean 	| selectorParts arguments multiLine formattedArgs indentFirst length |	selectorParts := aMessageNode selectorParts.	arguments := aMessageNode arguments.	formattedArgs := OrderedCollection new.	multiLine := (aMessageNode selector numArgs > self maximumArgumentsPerLine) or: [ self selectorsToStartOnNewLine includes: aMessageNode selector ].	length := aMessageNode selector size + arguments size + 1.	1 to: arguments size				do: 					[:i | 					| formatter string |					formatter := (self copy) 								lineStart: (selectorParts at: i) length negated;								yourself.					string := formatter format: (arguments at: i).					(multiLine and: [ formatter isMultiLine ]) ifTrue:						[ "redo it with a pre-indent first"						formatter _ (self copy) 							lineStart: (selectorParts at: i) length negated;							yourself.						formatter indentWhile:							[ string _ formatter format: (arguments at: i) ] ].					formattedArgs add: string.					length := length + string size.					multiLine := multiLine or: [formatter isMultiLine]].	multiLine := multiLine or: [length + self lineLength > self maxLineSize].	indentFirst := cascadeBoolean not and: [ multiLine ].	(indentFirst and: [ aMessageNode selector numArgs > self maximumArgumentsPerLine ])		ifTrue: [self indent].	self 		formatMessageSelector: selectorParts		withArguments: formattedArgs		multiline: multiLine! !!RBFormatter methodsFor: 'private-formatting' stamp: 'md 2/26/2006 15:19'!formatMessageSelector: selectorParts withArguments: formattedArgs multiline: multiLine	| selectorPart argStarts |	argStarts := Array new: formattedArgs size.	formattedArgs isEmpty 		ifTrue: [			selectorParts first start ifNil: [				selectorParts first start: self fullPosition + 1].			codeStream nextPutAll: selectorParts first value]		ifFalse: [1 to: formattedArgs size do: [:i | 					i ~~ 1 & multiLine not ifTrue: [codeStream nextPut: $ ].					selectorPart := selectorParts at: i.					selectorPart start ifNil: [selectorPart start: self fullPosition + 1].					self formatMessageSelectorPart: selectorPart.					codeStream nextPut: $ .					argStarts at: i put: self fullPosition.					codeStream nextPutAll: (formattedArgs at: i).					(multiLine and: [i < formattedArgs size]) ifTrue: [self indent]]].	^ argStarts! !!RBFormatter methodsFor: 'private-formatting' stamp: 'nk 1/29/2005 11:22'!formatMessageSelectorPart: part	codeStream nextPutAll: part value.! !!RBFormatter methodsFor: 'private-formatting' stamp: 'cmm 3/10/2006 17:24'!formatMethodCommentFor: aNode indentBefore: aBoolean 	| source |	source := aNode source.	source isNil ifTrue: [^self].	aNode comments do: 			[:each | 			aBoolean ifTrue: [self indent].			codeStream nextPutAll: (aNode source copyFrom: each first to: each last).			aBoolean ifFalse: [self indent]]! !!RBFormatter methodsFor: 'private-formatting' stamp: 'md 8/5/2005 11:08'!formatMethodPatternFor: aMethodNode 	| selectorParts arguments |	selectorParts := aMethodNode selectorParts.	arguments := aMethodNode arguments.	arguments isEmpty		ifTrue: [			selectorParts first start ifNil: [selectorParts first start: self fullPosition + 1].			codeStream nextPutAll: selectorParts first value]		ifFalse: 			[selectorParts with: arguments				do: 					[:selector :arg | 					selector start ifNil: [selector start: self fullPosition + 1].					codeStream nextPutAll: selector value;						nextPut: $ .					self visitMethodArgument: arg.					codeStream nextPut: $ ]]! !!RBFormatter methodsFor: 'private-formatting' stamp: 'ms 9/4/2006 22:49'!formatPragmasFor: aNode	aNode pragmas 		do: [ : each |			self indent.			self visitNode: each ]! !!RBFormatter methodsFor: 'private-formatting'!formatStatementCommentFor: aNode 	| source |	source := aNode source.	source isNil ifTrue: [^self].	aNode comments do: 			[:each | 			| crs |			crs := self newLinesFor: source startingAt: each first.			(crs - 1 max: 0) timesRepeat: [codeStream cr].			crs == 0 ifTrue: [codeStream tab] ifFalse: [self indent].			codeStream nextPutAll: (source copyFrom: each first to: each last)]! !!RBFormatter methodsFor: 'private-formatting'!formatStatementsFor: aSequenceNode 	| statements |	statements := aSequenceNode statements.	statements isEmpty ifTrue: [^self].	1 to: statements size - 1		do: 			[:i | 			self visitNode: (statements at: i).			codeStream nextPut: $..			self formatStatementCommentFor: (statements at: i).			self indent].	self visitNode: statements last.	self formatStatementCommentFor: statements last! !!RBFormatter methodsFor: 'private-formatting' stamp: 'md 8/26/2004 18:34'!formatSymbol: aSymbol 	"Format the symbol, if its not a selector then we must put quotes around it. The and: case below, 	handles the VisualWorks problem of not accepting two bars as a symbol."	codeStream nextPut: $#.	((Scanner isLiteralSymbol: aSymbol) and: [aSymbol ~~ #'||']) 		ifTrue: [codeStream nextPutAll: aSymbol]		ifFalse: [aSymbol asString printOn: codeStream]	"	((RBScanner isSelector: aSymbol) and: [aSymbol ~~ #'||']) 		ifTrue: [codeStream nextPutAll: aSymbol]		ifFalse: [aSymbol asString printOn: codeStream]"! !!RBFormatter methodsFor: 'private-formatting'!formatTagFor: aMethodNode 	| primitiveSources |	primitiveSources := aMethodNode primitiveSources.	primitiveSources do: 			[:each | 			codeStream nextPutAll: each.			self indent]! !!RBFormatter methodsFor: 'private-formatting' stamp: 'nk 1/29/2005 11:30'!formatTemporariesFor: aSequenceNode 	| temps |	temps := aSequenceNode temporaries.	temps isEmpty ifTrue: [^self].	codeStream nextPutAll: '| '.	temps do: 			[:each | 			self visitTemporaryVariable: each.			codeStream nextPut: $ ].	codeStream nextPut: $|.	self indent! !!RBFormatter methodsFor: 'private-formatting' stamp: 'apl 3/26/2005 14:51'!maybeJoinLinesFrom: aBlock 	| statementBegin statementEnd statementText statementLines initialLineLength |	initialLineLength := self lineLength.	statementBegin := codeStream position.	aBlock value.	statementEnd := codeStream position.	statementText := codeStream contents copyFrom: statementBegin + 1				to: statementEnd.	initialLineLength + statementText size < self maxLineSize 		ifTrue: 			[statementLines := statementText asString 						findTokens: String cr , String tab.			codeStream position: statementBegin.			statementLines do: [:line | codeStream nextPutAll: line]				separatedBy: [codeStream space]]! !!RBFormatter methodsFor: 'private-formatting'!newLinesFor: aString startingAt: anIndex 	| count cr lf index char |	cr := Character value: 13.	lf := Character value: 10.	count := 0.	index := anIndex - 1.	[index > 0 and: 			[char := aString at: index.			char isSeparator]] 		whileTrue: 			[char == lf 				ifTrue: 					[count := count + 1.					(aString at: (index - 1 max: 1)) == cr ifTrue: [index := index - 1]].			char == cr ifTrue: [count := count + 1].			index := index - 1].	^count! !!RBFormatter methodsFor: 'private-formatting' stamp: 'cmm 3/12/2006 13:30'!shouldIndent: selectorSymbol	^ (#(and: or:) includes: selectorSymbol) not! !!RBFormatter methodsFor: 'position fill' stamp: 'ajh 3/19/2003 14:12'!fullPosition	^ positionDelta + codeStream position! !!RBFormatter methodsFor: 'private'!indent	firstLineLength isNil ifTrue: [firstLineLength := codeStream position].	codeStream cr.	tabs timesRepeat: [codeStream tab].	lineStart := codeStream position! !!RBFormatter methodsFor: 'private'!indent: anInteger while: aBlock 	tabs := tabs + anInteger.	aBlock value.	tabs := tabs - anInteger! !!RBFormatter methodsFor: 'private'!indentWhile: aBlock 	self indent: 1 while: aBlock! !!RBFormatter methodsFor: 'private'!lineLength	^codeStream position - lineStart! !!RBFormatter methodsFor: 'private'!lineStart: aPosition 	lineStart := aPosition! !!RBFormatter methodsFor: 'private'!maxLineSize	^75! !!RBFormatter methodsFor: 'private' stamp: 'cmm 3/10/2006 16:58'!maximumArgumentsPerLine	^ 1! !!RBFormatter methodsFor: 'private' stamp: 'cmm 5/7/2006 18:03'!needsParenthesisFor: aNode 	| parent |	aNode isValue ifFalse: [^false].	parent _ aNode parent.	parent isNil ifTrue: [^false]."	(aNode isMessage and: [parent isMessage and: [parent receiver == aNode]])		ifTrue: 			[grandparent _ parent parent.			(grandparent notNil and: [grandparent isCascade]) ifTrue: [^true]]."	aNode precedence < parent precedence ifTrue: [^false].	aNode isAssignment & parent isAssignment ifTrue: [^false].	aNode isAssignment | aNode isCascade ifTrue: [^true].	aNode precedence == 0 ifTrue: [^false].	aNode isMessage ifFalse: [^true].	aNode precedence = parent precedence ifFalse: [^true].	aNode isUnary ifTrue: [^false].	aNode isKeyword ifTrue: [^true].	parent receiver == aNode ifFalse: [^true].	^self precedenceOf: parent selector greaterThan: aNode selector! !!RBFormatter methodsFor: 'private'!precedenceOf: parentSelector greaterThan: childSelector 	"Put parenthesis around things that are preceived to have 'lower' precedence. For example, 'a + b * c' 	-> '(a + b) * c' but 'a * b + c' -> 'a * b + c'"	| childIndex parentIndex operators |	operators := #(#($| $& $?) #($= $~ $< $>) #($- $+) #($* $/ $% $\) #($@)).	childIndex := 0.	parentIndex := 0.	1 to: operators size		do: 			[:i | 			((operators at: i) includes: parentSelector first) ifTrue: [parentIndex := i].			((operators at: i) includes: childSelector first) ifTrue: [childIndex := i]].	^childIndex < parentIndex! !!RBFormatter methodsFor: 'private' stamp: 'cmm 3/10/2006 16:58'!selectorsToLeaveOnLine	^#()! !!RBFormatter methodsFor: 'private' stamp: 'cmm 3/14/2006 21:13'!selectorsToStartOnNewLine	^#(and: or:)! !!RBFormatter methodsFor: 'initialize-release' stamp: 'md 2/26/2006 15:01'!initialize	super initialize.	codeStream := WriteStream on: (String new: 60).	tabs := 0.	lineStart := 0.	positionDelta := 0.! !!RBFormatter methodsFor: 'copying' stamp: 'pmm 2/24/2006 11:01'!postCopy	super postCopy.	positionDelta := positionDelta + codeStream position.	lineStart := self lineLength negated.	codeStream := (codeStream ifNil: [ WriteStream on: (String new: 60) ]		ifNotNil: [ codeStream class on: (codeStream contents class new: 60) ]).	firstLineLength := nil! !!RBFormatter methodsFor: 'testing'!startMessageSendOnNewLine: aMessageNode 	(self selectorsToStartOnNewLine includes: aMessageNode selector) 		ifTrue: [^true].	(self selectorsToLeaveOnLine includes: aMessageNode selector) ifTrue: [^false].	^aMessageNode selector numArgs > self maximumArgumentsPerLine! !!RBFormatter methodsFor: 'testing' stamp: 'md 2/26/2006 15:00'!tagBeforeTemporaries	^false! !!RBFormatter methodsFor: 'visiting'!visitNode: aNode 	| parenthesis |	parenthesis := self needsParenthesisFor: aNode.	parenthesis ifTrue: [codeStream nextPut: $(].	aNode acceptVisitor: self.	parenthesis ifTrue: [codeStream nextPut: $)]! !!RBFormatter methodsFor: '*persephone' stamp: 'pmm 6/25/2006 15:32'!acceptObjectLiteralNode: anObjectLiteralNode	codeStream space.	codeStream nextPutAll: anObjectLiteralNode formattedCode! !!RBFormatter commentStamp: 'md 8/9/2005 14:50' prior: 0!RBFormatter formats a parse tree. It is an example of a Visitor. This is rarely called directly. Sending 'formattedCode' to a parse tree uses this algorithm to return a pretty-printed version.Instance Variables:	codeStream	<PositionableStream>	The buffer where the output is accumulated.	firstLineLength	<Integer>	The length of the first line of a message send.	lineStart	<Integer>	The position of the current line's start.	tabs	<Integer>	The number of tabs currently indented.!!RBFormatter class methodsFor: 'as yet unclassified' stamp: 'md 2/26/2006 15:18'!assignmentOperator		^':='! !!RBFormatterTest methodsFor: 'testing' stamp: 'pmm 10/4/2006 14:01'!assertEqualFormattedAfterVerifyCode: aString	| methodNode |	self assert: (self class environment hasClassNamed: 'SqueakParser').	methodNode := self parse: aString.	self assert: (self class environment hasClassNamed: 'ASTChecker').	methodNode verifyIn: self class.	self assert: methodNode formattedCode = aString! !!RBFormatterTest methodsFor: 'testing' stamp: 'pmm 10/4/2006 14:01'!assertEqualFormattedCode: aString	| methodNode |	self assert: (self class environment hasClassNamed: 'SqueakParser').	methodNode := self parse: aString.	self assert: methodNode formattedCode = aString! !!RBFormatterTest methodsFor: 'testing' stamp: 'pmm 10/4/2006 13:58'!testAll	#(		pragmaAndPrimitiveMethodString		pragmaMethodString		primitiveMethodString		threePragmaMethodString	) do: [ :stringSelector |		#(			assertEqualFormattedCode:			assertEqualFormattedAfterVerifyCode:		) do: [ :assertionSelector |			self perform: assertionSelector with: (self perform: stringSelector) ] ]! !!RBFormatterTest methodsFor: 'method - tested' stamp: 'ms 9/11/2007 17:59'!expectedFailures	Smalltalk at: #SqueakParser		ifAbsent: 			[^ #(#testAll #testIsPrimitivePragma )].	^ #()! !!RBFormatterTest methodsFor: 'fixtures' stamp: 'ms 3/31/2007 17:05'!parse: aString	^self defaultParser parseMethod: aString! !!RBFormatterTest methodsFor: 'strings' stamp: 'SR 9/3/2006 10:34'!pragmaAndPrimitiveMethodString	^'pragmaAndPrimitive	<primitive: 21>	<pragma: 21>	'! !!RBFormatterTest methodsFor: 'strings' stamp: 'SR 9/3/2006 10:30'!pragmaMethodString	^'pragma	<pragma: 21>	'! !!RBFormatterTest methodsFor: 'strings' stamp: 'SR 9/3/2006 10:29'!primitiveMethodString	^'primitive	<primitive: 21>	'! !!RBFormatterTest methodsFor: 'strings' stamp: 'ms 9/11/2007 17:59'!testIsPrimitivePragma	| method primitive pragma |	method := self parse: self pragmaAndPrimitiveMethodString.	primitive := method pragmas 				detect: [:each | each pragma keyword = #primitive:].	pragma := method pragmas detect: [:each | each pragma keyword = #pragma:].	self assert: primitive isPrimitive.	self deny: pragma isPrimitive! !!RBFormatterTest methodsFor: 'strings' stamp: 'SR 9/3/2006 10:39'!threePragmaMethodString	^'threePragmas	<integer: 21>	<conference: ''ESUG'' year: 2006>	<yes>	'! !!RBGlobalVariableNode methodsFor: 'testing' stamp: 'md 3/30/2007 09:57'!isGlobal	^true! !!RBGlobalVariableNode methodsFor: 'testing' stamp: 'md 3/30/2007 09:57'!isInstance	^false! !!RBGlobalVariableNode methodsFor: 'testing' stamp: 'md 3/30/2007 09:57'!isTemp	^false! !!RBIdentifierToken methodsFor: 'testing'!isIdentifier	^true! !!RBIdentifierToken methodsFor: 'testing' stamp: 'md 8/26/2004 18:36'!isPatternVariable	^value first == $`.		"value first == RBScanner patternVariableCharacter"! !!RBIdentifierToken commentStamp: 'md 8/9/2005 14:51' prior: 0!RBIdentifierToken is the first class representation of an identifier token (e.g. Class)!!RBInstanceVariableNode methodsFor: 'testing' stamp: 'md 3/30/2007 09:56'!isGlobal	^false! !!RBInstanceVariableNode methodsFor: 'testing' stamp: 'md 3/30/2007 09:56'!isInstance	^true! !!RBInstanceVariableNode methodsFor: 'testing' stamp: 'md 3/30/2007 09:56'!isTemp	^false! !!RBKeywordToken methodsFor: 'testing'!isKeyword	^true! !!RBKeywordToken methodsFor: 'testing' stamp: 'md 8/26/2004 18:37'!isPatternVariable		^value first == $`.		"value first == RBScanner patternVariableCharacter"! !!RBKeywordToken commentStamp: 'md 8/9/2005 14:52' prior: 0!RBKeywordToken is the first-class representation of a keyword token (e.g. add:)!!RBLiteralNode methodsFor: 'comparing'!= anObject 	self == anObject ifTrue: [^true].	self class == anObject class ifFalse: [^false].	self value class == anObject value class ifFalse: [^false].	^self value = anObject value! !!RBLiteralNode methodsFor: 'comparing'!hash	^self value hash! !!RBLiteralNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptLiteralNode: self! !!RBLiteralNode methodsFor: 'replacing' stamp: 'ajh 3/13/2003 16:11'!adjustPositionsAfter: sourcePos by: delta	"Slide token positions after sourcePos by delta"	token start > sourcePos ifTrue: [		token start: token start + delta]! !!RBLiteralNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:40'!basicFirstToken		^self token! !!RBLiteralNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:40'!basicLastToken		^self token! !!RBLiteralNode methodsFor: 'matching'!copyInContext: aDictionary	^self class literalToken: token removePositions! !!RBLiteralNode methodsFor: 'testing'!isImmediate	^true! !!RBLiteralNode methodsFor: 'testing'!isLiteral	^true! !!RBLiteralNode methodsFor: 'testing' stamp: 'ajh 3/3/2003 22:29'!isLiteral: valueTestBlock	^ valueTestBlock value: self value! !!RBLiteralNode methodsFor: 'initialize-release'!literalToken: aLiteralToken 	token := aLiteralToken! !!RBLiteralNode methodsFor: 'initialize-release' stamp: 'ajh 2/27/2003 17:22'!value: object	value := object! !!RBLiteralNode methodsFor: 'accessing'!precedence	^0! !!RBLiteralNode methodsFor: 'accessing' stamp: 'ms 3/31/2007 20:41'!startWithoutParentheses	^self firstToken start! !!RBLiteralNode methodsFor: 'accessing' stamp: 'ms 3/31/2007 20:42'!stopWithoutParentheses	^self lastToken stop! !!RBLiteralNode methodsFor: 'accessing'!token	^token! !!RBLiteralNode methodsFor: 'accessing' stamp: 'md 4/13/2007 22:44'!value	^ (token notNil and: [token isRBToken])		ifTrue: [token realValue]		ifFalse: [value]! !!RBLiteralNode commentStamp: 'md 8/9/2005 14:58' prior: 0!RBLiteralNode is an AST node that represents literals (e.g., #foo, #(1 2 3), true, etc.).Instance Variables:	token	<RBLiteralToken>	the token that contains the literal value as well as its source positions!!RBLiteralNode class methodsFor: 'instance creation' stamp: 'ms 6/17/2007 22:58'!literalToken: aLiteralToken 	^self literalToken: aLiteralToken value: aLiteralToken value! !!RBLiteralNode class methodsFor: 'instance creation' stamp: 'ajh 2/27/2003 17:22'!literalToken: aLiteralToken value: object	^self new literalToken: aLiteralToken; value: object! !!RBLiteralNode class methodsFor: 'instance creation' stamp: 'ms 11/13/2007 17:29'!value: aValue 	^self literalToken: (RBLiteralToken value: aValue)! !!RBLiteralNodeTest methodsFor: 'method - tested' stamp: 'ms 3/31/2007 20:48'!expectedFailures	Smalltalk at: #SqueakParser ifAbsent:[^#(#testFirstLastToken)].	^#()! !!RBLiteralNodeTest methodsFor: 'testing' stamp: 'ms 3/31/2007 17:21'!testFirstLastToken		| rbNode |	rbNode := (self defaultParser parseMethod: 'test true') body statements first.	self assert: (rbNode firstToken value = 'true').	self assert: (rbNode lastToken value = 'true').		rbNode := (self defaultParser parseMethod: 'test false') body statements first.	self assert: (rbNode firstToken value = 'false').	self assert: (rbNode lastToken value = 'false').		rbNode := (self defaultParser parseMethod: 'test nil') body statements first.	self assert: (rbNode firstToken value = 'nil').	self assert: (rbNode lastToken value = 'nil').		rbNode := (self defaultParser parseMethod: 'test 23') body statements first.	self assert: (rbNode firstToken value = '23').	self assert: (rbNode lastToken value = '23').		rbNode := (self defaultParser parseMethod: 'test -23') body statements first.	self assert: (rbNode firstToken value = '-23').	self assert: (rbNode lastToken value = '-23').		rbNode := (self defaultParser parseMethod: 'test $f') body statements first.	self assert: (rbNode firstToken value = '$f').	self assert: (rbNode lastToken value = '$f').		rbNode := (self defaultParser parseMethod: 'test ''bob''') body statements first.	self assert: (rbNode firstToken value = '''bob''').	self assert: (rbNode lastToken value = '''bob''').	rbNode := (self defaultParser parseMethod: 'test #''alice''') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = '''alice''').		rbNode := (self defaultParser parseMethod: 'test #alice') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = 'alice').		rbNode := (self defaultParser parseMethod: 'test #+') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = '+').		rbNode := (self defaultParser parseMethod: 'test #alice:') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = 'alice:').		rbNode := (self defaultParser parseMethod: 'test #alice:bob:') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = 'alice:bob:').		rbNode := (self defaultParser parseMethod: 'test #[3 4 0]') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = ']').	rbNode := (self defaultParser parseMethod: 'test #(alice black hat)') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = ')').		"rbNode := (self defaultParser parseMethod: 'test #:indexOf:') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = ':indexOf:')"								! !!RBLiteralNodeTest methodsFor: 'testing' stamp: 'ms 3/31/2007 17:38'!testPosition		| rbNode |	rbNode := (self defaultParser parseMethod: 'test true') body statements first.	self assertPosition: rbNode start: 6 stop: 9.		rbNode := (self defaultParser parseMethod: 'test false') body statements first.	self assertPosition: rbNode start: 6 stop: 10.		rbNode := (self defaultParser parseMethod: 'test nil') body statements first.	self assertPosition: rbNode start: 6 stop: 8.		rbNode := (self defaultParser parseMethod: 'test 23') body statements first.	self assertPosition: rbNode start: 6 stop: 7.		rbNode := (self defaultParser parseMethod: 'test -23') body statements first.	self assertPosition: rbNode start: 6 stop: 8.		rbNode := (self defaultParser parseMethod: 'test $f') body statements first.	self assertPosition: rbNode start: 6 stop: 7.		rbNode := (self defaultParser parseMethod: 'test ''bob''') body statements first.	self assertPosition: rbNode start: 6 stop: 10.	rbNode := (self defaultParser parseMethod: 'test #''alice''') body statements first.	self assertPosition: rbNode start: 6 stop: 13.		rbNode := (self defaultParser parseMethod: 'test #alice') body statements first.	self assertPosition: rbNode start: 6 stop: 11.		rbNode := (self defaultParser parseMethod: 'test #+') body statements first.	self assertPosition: rbNode start: 6 stop: 7.		rbNode := (self defaultParser parseMethod: 'test #alice:') body statements first.	self assertPosition: rbNode start: 6 stop: 12.		rbNode := (self defaultParser parseMethod: 'test #alice:bob:') body statements first.	self assertPosition: rbNode start: 6 stop: 16.		rbNode := (self defaultParser parseMethod: 'test #[3 4 0]') body statements first.	self assertPosition: rbNode start: 6 stop: 13.	rbNode := (self defaultParser parseMethod: 'test #(alice black hat)') body statements first.	self assertPosition: rbNode start: 6 stop: 23.		"rbNode := (self defaultParser parseMethod: 'test #:indexOf:') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = ':indexOf:')"								! !!RBLiteralNodeTest methodsFor: 'testing' stamp: 'ms 3/31/2007 18:57'!testValue		| rbNode |	rbNode := (self defaultParser parseMethod: 'test true') body statements first.	self assert: (rbNode value = true).		rbNode := (self defaultParser parseMethod: 'test false') body statements first.	self assert: (rbNode value = false).		rbNode := (self defaultParser parseMethod: 'test thisContext') body statements first.	self assert: (rbNode value isKindOf: RBVariableNode).		rbNode := (self defaultParser parseMethod: 'test nil') body statements first.	self assert: (rbNode value = nil).		rbNode := (self defaultParser parseMethod: 'test 23') body statements first.	self assert: (rbNode value = 23).		rbNode := (self defaultParser parseMethod: 'test -23') body statements first.	self assert: (rbNode value = -23).		rbNode := (self defaultParser parseMethod: 'test $f') body statements first.	self assert: (rbNode value = $f).		rbNode := (self defaultParser parseMethod: 'test ''bob''') body statements first.	self assert: (rbNode value = 'bob').	rbNode := (self defaultParser parseMethod: 'test #''alice''') body statements first.	self assert: (rbNode value = #'alice').		rbNode := (self defaultParser parseMethod: 'test #alice') body statements first.	self assert: (rbNode value = #alice).		rbNode := (self defaultParser parseMethod: 'test #+') body statements first.	self assert: (rbNode value = #+).		rbNode := (self defaultParser parseMethod: 'test #alice:') body statements first.	self assert: (rbNode value = #alice:).		rbNode := (self defaultParser parseMethod: 'test #alice:bob:') body statements first.	self assert: (rbNode value = #alice:bob:).	rbNode := (self defaultParser parseMethod: 'test #(alice black hat)') body statements first.	self assert: (rbNode value = #(alice black hat)).		rbNode := (self defaultParser parseMethod: 'test #[3 4 0]') body statements first.	self assert: (rbNode value = (ByteArray with: 3 with: 4 with: 0)).		"rbNode := (self defaultParser parseMethod: 'test #:indexOf:') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = ':indexOf:')"								! !!RBLiteralToken methodsFor: 'testing'!isLiteral	^true! !!RBLiteralToken methodsFor: 'private' stamp: 'ms 6/14/2007 20:38'!length	^stopPosition ifNil: [value size] ifNotNil: [stopPosition - self start + 1]! !!RBLiteralToken methodsFor: 'accessing'!stop: anObject 	stopPosition := anObject! !!RBLiteralToken methodsFor: 'initialize-release'!value: aString start: anInteger stop: stopInteger 	value := aString.	sourcePointer := anInteger.	stopPosition := stopInteger! !!RBLiteralToken commentStamp: 'md 8/9/2005 14:52' prior: 0!RBLiteralToken is the first-class representation of a literal token (entire literals, even literal arrays, are a single token in the ST80 grammar.).Instance Variables:	stopPosition	<Integer>	The position within the source code where the token terminates.!!RBLiteralToken class methodsFor: 'instance creation' stamp: 'ms 11/13/2007 17:28'!value: anObject 	| literal |	literal := anObject class == Array 				ifTrue: [anObject collect: [:each | self value: each]]				ifFalse: [anObject].	^self 		value: literal		start: 0		stop: anObject printString size! !!RBLiteralToken class methodsFor: 'instance creation'!value: aString start: anInteger stop: stopInteger 	^self new		value: aString		start: anInteger		stop: stopInteger! !!RBMessageNode methodsFor: 'comparing' stamp: 'pmm 7/12/2006 15:40'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	(self receiver = anObject receiver 		and: [self selector = anObject selector]) ifFalse: [^false].	^self arguments = anObject arguments! !!RBMessageNode methodsFor: 'comparing' stamp: 'pmm 7/12/2006 15:40'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	((self receiver equalTo: anObject receiver withMapping: aDictionary)		and: [self selector = anObject selector]) ifFalse: [^false].	self arguments with: anObject arguments do: [ :first :second |		(first equalTo: second withMapping: aDictionary)			ifFalse: [^false]].	^true! !!RBMessageNode methodsFor: 'comparing'!hash	^(self receiver hash bitXor: self selector hash)		bitXor: (self arguments isEmpty ifTrue: [0] ifFalse: [self arguments first hash])! !!RBMessageNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptMessageNode: self! !!RBMessageNode methodsFor: 'replacing' stamp: 'ajh 3/13/2003 16:12'!adjustPositionsAfter: sourcePos by: delta	"Slide token positions after sourcePos by delta"	selectorParts do: [:token |		token start > sourcePos ifTrue: [			token start: token start + delta]	].	super adjustPositionsAfter: sourcePos by: delta.! !!RBMessageNode methodsFor: 'replacing' stamp: 'ajh 3/17/2003 13:11'!changeSelectorParts: tokenCollection	| root oldToken newToken |	root := self root.	1 to: selectorParts size do: [:i |		oldToken := selectorParts at: i.		newToken := tokenCollection at: i.		root adjustPositionsAfter: oldToken stop			by: newToken stop - oldToken stop.		selectorParts at: i put: newToken.	].	selector := nil.! !!RBMessageNode methodsFor: 'replacing' stamp: 'md 4/8/2007 17:53'!replaceNode: aNode withNode: anotherNode 	"If we're inside a cascade node and are changing the receiver, change all the receivers"	receiver == aNode 		ifTrue: 			[self receiver: anotherNode.			(parent notNil and: [parent isCascade]) 				ifTrue: [parent messages do: [:each | each receiver: anotherNode]]].	self arguments: (self arguments 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !!RBMessageNode methodsFor: 'accessing' stamp: 'md 4/8/2007 17:52'!arguments	^arguments ifNil: [#()]! !!RBMessageNode methodsFor: 'accessing' stamp: 'md 4/6/2007 11:12'!arguments: argCollection 	arguments := argCollection.	arguments isEmptyOrNil ifTrue: [arguments := nil. ^self].	arguments do: [:each | each parent: self]! !!RBMessageNode methodsFor: 'accessing'!children	^(OrderedCollection with: self receiver) addAll: self arguments;		yourself! !!RBMessageNode methodsFor: 'accessing' stamp: 'ajh 3/15/2003 15:18'!debugHighlightStart	^ self selectorParts first start! !!RBMessageNode methodsFor: 'accessing' stamp: 'ajh 3/15/2003 15:19'!debugHighlightStop	^ self stopWithoutParentheses! !!RBMessageNode methodsFor: 'accessing'!precedence	^self isUnary ifTrue: [1] ifFalse: [self isKeyword ifTrue: [3] ifFalse: [2]]! !!RBMessageNode methodsFor: 'accessing'!receiver	^receiver! !!RBMessageNode methodsFor: 'accessing'!receiver: aValueNode 	receiver := aValueNode.	receiver parent: self! !!RBMessageNode methodsFor: 'accessing'!selector	^selector isNil		ifTrue: [selector := self buildSelector]		ifFalse: [selector]! !!RBMessageNode methodsFor: 'accessing' stamp: 'md 4/6/2007 11:17'!selector: aSelector 	| keywords numArgs |	keywords := aSelector keywords.	numArgs := aSelector numArgs.	numArgs == self arguments size 		ifFalse: 			[self 				error: 'Attempting to assign selector with wrong number of arguments.'].	selectorParts := numArgs == 0 				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]				ifFalse: 					[keywords first last == $: 						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].	selector := aSelector! !!RBMessageNode methodsFor: 'accessing'!sentMessages	^(super sentMessages)		add: self selector;		yourself! !!RBMessageNode methodsFor: 'accessing'!startWithoutParentheses	^receiver start! !!RBMessageNode methodsFor: 'accessing' stamp: 'md 4/6/2007 11:17'!stopWithoutParentheses	^self arguments isEmpty 		ifTrue: [selectorParts first stop]		ifFalse: [self arguments last stop]! !!RBMessageNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:44'!basicFirstToken		^self receiver firstToken! !!RBMessageNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:44'!basicLastToken		self arguments ifEmpty:[^self selectorParts last] ifNotEmpty: [^self arguments last lastToken]! !!RBMessageNode methodsFor: 'querying'!bestNodeFor: anInterval 	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	selectorParts do: 			[:each | 			((anInterval first between: each start and: each stop) 				or: [each start between: anInterval first and: anInterval last]) 					ifTrue: [^self]].	self children do: 			[:each | 			| node |			node := each bestNodeFor: anInterval.			node notNil ifTrue: [^node]]! !!RBMessageNode methodsFor: 'private'!buildSelector	| selectorStream |	selectorStream := WriteStream on: (String new: 50).	selectorParts do: [:each | selectorStream nextPutAll: each value].	^selectorStream contents asSymbol! !!RBMessageNode methodsFor: 'private'!selectorParts	^selectorParts! !!RBMessageNode methodsFor: 'private' stamp: 'ajh 3/11/2003 23:40'!selectorParts: tokenCollection 	selectorParts := tokenCollection.	selector := nil.! !!RBMessageNode methodsFor: 'matching' stamp: 'md 4/6/2007 11:13'!copyInContext: aDictionary 	^(self class new) receiver: (receiver copyInContext: aDictionary);		selectorParts: (selectorParts collect: [:each | each removePositions]);		arguments: (self arguments collect: [:each | each copyInContext: aDictionary]);		yourself! !!RBMessageNode methodsFor: 'matching' stamp: 'pmm 7/12/2006 15:41'!match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	self selector == aNode selector ifFalse: [^false].	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].	self arguments with: aNode arguments do: [ :first :second |		(first match: second inContext: aDictionary)			ifFalse: [^false]].	^true! !!RBMessageNode methodsFor: 'testing'!isBinary	^(self isUnary or: [self isKeyword]) not! !!RBMessageNode methodsFor: 'testing'!isCascaded	^parent notNil and: [parent isCascade]! !!RBMessageNode methodsFor: 'testing'!isFirstCascaded	^self isCascaded and: [parent messages first == self]! !!RBMessageNode methodsFor: 'testing'!isKeyword	^selectorParts first value last == $:! !!RBMessageNode methodsFor: 'testing'!isMessage	^true! !!RBMessageNode methodsFor: 'testing' stamp: 'pmm 1/9/2006 12:05'!isSelfSend	^(self receiver isVariable)		and: [ self receiver name = 'self' ]! !!RBMessageNode methodsFor: 'testing' stamp: 'pmm 4/24/2006 22:30'!isSuperSend	^receiver isVariable		and: [ receiver name = 'super' ]		and: [ receiver binding name = 'self']! !!RBMessageNode methodsFor: 'testing' stamp: 'md 4/6/2007 11:15'!isUnary	^self arguments isEmpty! !!RBMessageNode methodsFor: 'testing' stamp: 'md 4/6/2007 11:15'!lastIsReturn	^ ((#(ifTrue:ifFalse: ifFalse:ifTrue: ifNil:ifNotNil: ifNotNil:ifNil:) includes: self selector)		and: [self arguments first isBlock and: 			[self arguments first body lastIsReturn				and: [self arguments last isBlock and: [self arguments last body lastIsReturn]]]])	  or: [(#(caseOf: caseOf:otherwise:) includes: self selector)		and: [self arguments first isArray and: [self arguments first statements allSatisfy: [:assocMessage | assocMessage arguments first isBlock and: [assocMessage arguments first body lastIsReturn]]]			and: [selector == #caseOf: or: [self arguments second isBlock and: [self arguments second body lastIsReturn]]]]]! !!RBMessageNode methodsFor: 'inline' stamp: 'ajh 2/25/2003 19:47'!isInline	self isInlineAndOr ifTrue: [^ true].	self isInlineCase ifTrue: [^ true].	self isInlineIf ifTrue: [^ true].	self isInlineIfNil ifTrue: [^ true].	self isInlineToDo ifTrue: [^ true].	self isInlineWhile ifTrue: [^ true].	^ false! !!RBMessageNode methodsFor: 'inline' stamp: 'pmm 7/24/2006 21:57'!isInlineAndOr	self receiver isBlock ifTrue: [^ false].	self isCascaded ifTrue: [^ false].	(self selectorParts allSatisfy: [ :each |		| value |		value := each isRBToken			ifTrue: [each realValue]			ifFalse: [each value].		#(and: or:) includes: value ]) ifFalse: [^ false].	(self arguments allSatisfy: [ :each | each isBlock ])  ifFalse: [^ false].	(self arguments allSatisfy: [ :each | each arguments isEmpty ])			ifFalse: [				self notify: 'and: (or:) takes zero-arg block'.				^ false ].	^ true! !!RBMessageNode methodsFor: 'inline' stamp: 'md 4/14/2007 00:39'!isInlineCase	self isCascaded ifTrue: [^ false].	(#(caseOf: caseOf:otherwise:) includes: self selector) ifFalse: [^ false].	self arguments size = 2 ifTrue: [  "otherwise block"		self arguments last isBlock ifFalse: [^ false]].	self arguments first isArray ifFalse: [^ false].	self arguments first statements do: [:assoc |		(assoc isMessage and: [assoc selector == #->]) ifFalse: [^ false].		assoc receiver isBlock ifFalse: [^ false].		assoc receiver arguments isEmpty ifFalse: [self notify: 'caseOf: takes zero-arg blocks'. ^ false].		assoc arguments first isBlock ifFalse: [^ false].		assoc arguments first arguments isEmpty ifFalse: [self notify: 'caseOf: takes zero-arg blocks'].	].	^ true! !!RBMessageNode methodsFor: 'inline' stamp: 'md 4/14/2007 00:38'!isInlineIf	self receiver isBlock ifTrue: [^ false].	self isCascaded ifTrue: [^ false].	(#(ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:) includes: self selector) ifFalse: [^ false].	self arguments do: [:node | node isBlock ifFalse: [^ false]].	self arguments do: [:block |		block arguments isEmpty ifFalse: [			self notify: 'ifTrue:ifFalse: takes zero-arg blocks'.			^ false		]	].	^ true! !!RBMessageNode methodsFor: 'inline' stamp: 'md 4/14/2007 00:38'!isInlineIfNil	| assertNone assertOneOrNone |	self receiver isBlock ifTrue: [^ false].	self isCascaded ifTrue: [^ false].	(#(ifNil: ifNotNil: ifNil:ifNotNil: ifNotNil:ifNil: ifNotNilDo:) includes: self selector) ifFalse: [^ false].	self arguments do: [:node | node isBlock ifFalse: [^ false]].	assertNone := [:block | 		block arguments isEmpty ifFalse: [self notify: 'ifNil: takes zero-arg block'. ^ false]	].	assertOneOrNone := [:block | 		block arguments size > 1 ifTrue: [self notify: 'ifNotNil: takes zero- or one-arg block'. ^ false]	].	self selector caseOf: {		[#ifNil:] 		 	-> [assertNone value: self arguments first].		[#ifNil:ifNotNil:] 	-> [assertNone value: self arguments first. 							   assertOneOrNone value: self arguments last].		[#ifNotNil:] 		  	-> [assertOneOrNone value: self arguments first].		[#ifNotNilDo:] 		  	-> [assertOneOrNone value: self arguments first].		[#ifNotNil:ifNil:] 	-> [assertOneOrNone value: self arguments first. 							   assertNone value: self arguments last]	}.	^ true! !!RBMessageNode methodsFor: 'inline' stamp: 'md 4/14/2007 00:38'!isInlineToDo	| block step |	self receiver isBlock ifTrue: [^ false].	self isCascaded ifTrue: [^ false].	(#(to:do: to:by:do:) includes: self selector) ifFalse: [^ false].	self arguments first isBlock ifTrue: [^ false].	block := self arguments last.	block isBlock ifFalse: [^ false].	block arguments size = 1 ifFalse: [		self notify: 'to:do: block must take one arg'. ^ false].	(ParseTreeSearcher new		matches: block arguments first name , ' := `@object' do: [:n :a | true];		executeTree: block initialAnswer: false) ifTrue: [^ false].	self arguments size = 3 "to:by:do:" ifTrue: [		step := self arguments second.		step isLiteral ifFalse: [^ false].		step value = 0 ifTrue: [self notify: 'by: step can''t be zero'. ^ false].	].	^ true! !!RBMessageNode methodsFor: 'inline' stamp: 'md 4/14/2007 00:38'!isInlineWhile	self isCascaded ifTrue: [^ false].	(#(whileFalse: whileTrue: whileFalse whileTrue) includes: self selector) ifFalse: [^ false].	self receiver isBlock ifFalse: [^ false].	self receiver arguments isEmpty ifFalse: [self notify: 'while receiver block must have no arguments'. ^ false].	self arguments isEmpty ifFalse: [		self arguments first isBlock ifFalse: [^ false].		self arguments first arguments isEmpty ifFalse: [self notify: 'while takes a zero-arg block as its argument'. ^ false].	].	^ true! !!RBMessageNode methodsFor: 'decompiling' stamp: 'ms 7/12/2007 13:19'!isSend	^true! !!RBMessageNode methodsFor: 'copying' stamp: 'md 4/6/2007 11:16'!postCopy	super postCopy.	receiver := receiver copy.	receiver parent: self.	arguments ifNotNil: [		arguments := self arguments collect: [:each |			each copy			parent: self;			yourself ]]! !!RBMessageNode methodsFor: 'initialize-release'!receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 	self receiver: aValueNode.	selectorParts := keywordTokens.	self arguments: valueNodes! !!RBMessageNode methodsFor: '*newcompiler' stamp: 'ms 8/8/2007 20:11'!isClosureEnvironmentCreation	^receiver value = ClosureEnvironment and: [self selector == #new:] and: [arguments first value >= 0]! !!RBMessageNode methodsFor: '*newcompiler' stamp: 'ms 7/31/2007 00:44'!isClosureEnvironmentRegistration	^(receiver isVariable 		and: [receiver binding isLocal]		and: [receiver binding index = -1]		and: [self selector == #privStoreIn:instVar:] 		and: [arguments first binding index == -2]) 		and: [arguments second value == 5]! !!RBMessageNode methodsFor: '*newcompiler' stamp: 'ms 7/27/2007 20:55'!isClosureRegistrationAndCreation	^receiver isClosureEnvironmentCreation 		and: [self selector == #privStoreIn:instVar:] 		and: [arguments first binding index == -2] 		and: [arguments second value == 5]! !!RBMessageNode methodsFor: '*newcompiler' stamp: 'ms 7/31/2007 00:45'!isSelfClosureRegistration	^(receiver isVariable 		and: [receiver binding isLocal]		and: [receiver binding name = 'self']		and: [self selector == #privStoreIn:instVar:] 		and: [arguments first binding index == -1]) 		and: [arguments second value >= 1]! !!RBMessageNode methodsFor: '*persephone' stamp: 'pmm 11/4/2006 18:42'!doNotInline	self addAnnotation: (ProgrammaticNoInlineAnnotation new		key: NoInlineAnnotation key;		yourself)! !!RBMessageNode methodsFor: '*persephone' stamp: 'md 4/14/2007 01:57'!numArgs	^self arguments size! !!RBMessageNode methodsFor: '*Geppetto2' stamp: 'md 2/9/2007 11:03'!addNode: a before: b	parent addNode: a before: self.! !!RBMessageNode commentStamp: 'md 8/9/2005 14:58' prior: 0!RBMessageNode is an AST node that represents a message send.Instance Variables:	arguments	<SequenceableCollection of: RBValueNode>	our argument nodes	receiver	<RBValueNode>	the receiver's node	selector	<Symbol | nil>	the selector we're sending (cached)	selectorParts	<SequenceableCollection of: RBValueToken>	the tokens for each keyword!!RBMessageNode class methodsFor: 'instance creation'!receiver: aValueNode selector: aSymbol 	^self 		receiver: aValueNode		selector: aSymbol		arguments: #()! !!RBMessageNode class methodsFor: 'instance creation'!receiver: aValueNode selector: aSymbol arguments: valueNodes 	^(self new)		receiver: aValueNode;		arguments: valueNodes;		selector: aSymbol;		yourself! !!RBMessageNode class methodsFor: 'instance creation' stamp: 'pmm 7/12/2006 15:18'!receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 	^((keywordTokens anySatisfy: [:each | each isPatternVariable])		ifTrue: [RBPatternMessageNode] ifFalse: [RBMessageNode]) 		new 			receiver: aValueNode			selectorParts: keywordTokens			arguments: valueNodes! !!RBMessageNode class methodsFor: '*persephone' stamp: 'pmm 8/19/2006 13:33'!receiver: aValueNode selector: aSymbol argument: anotherValueNodes	^self		receiver: aValueNode		selector: aSymbol		arguments: (Array with: anotherValueNodes) ! !!RBMessageNodeTest methodsFor: 'testing' stamp: 'ms 9/17/2006 00:31'!testFirstLastToken		| rbNode |	rbNode := (self defaultParser parseMethod: 'test v factorial: w') body statements first.	self assert: (rbNode firstToken value = 'v').	self assert: (rbNode lastToken value = 'w').		rbNode := (self defaultParser parseMethod: 'test v factorial') body statements first.	self assert: (rbNode firstToken value = 'v').	self assert: (rbNode lastToken value = 'factorial')! !!RBMessageNodeTest methodsFor: 'testing' stamp: 'ms 3/31/2007 17:20'!testPosition		| rbNode |	rbNode := (self defaultParser parseMethod: 'test v factorial: w') body statements first.	self assertPosition: rbNode start: 6 stop: 19.		rbNode := (self defaultParser parseMethod: 'test v factorial') body statements first.	self assertPosition: rbNode start: 6 stop: 16.! !!RBMetaclass methodsFor: 'accessing'!allClassVariableNames	^self nonMetaclass allClassVariableNames! !!RBMetaclass methodsFor: 'accessing'!allPoolDictionaryNames	^self nonMetaclass allPoolDictionaryNames! !!RBMetaclass methodsFor: 'accessing'!metaclass	^self! !!RBMetaclass methodsFor: 'testing'!directlyDefinesClassVariable: aString 	^self nonMetaclass directlyDefinesClassVariable: aString! !!RBMetaclass methodsFor: 'testing'!directlyDefinesPoolDictionary: aString 	^self nonMetaclass directlyDefinesPoolDictionary: aString! !!RBMetaclass methodsFor: 'testing'!isMeta	^true! !!RBMetaclass methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' class'! !!RBMetaclass methodsFor: 'printing'!storeOn: aStream 	super storeOn: aStream.	aStream nextPutAll: ' class'! !!RBMetaclass methodsFor: 'initialize-release' stamp: 'dc 5/8/2007 12:29'!realName: aSymbol 	self realClass: (Smalltalk at: aSymbol) classSide! !!RBMetaclass class methodsFor: 'instance creation'!existingNamed: aSymbol 	^(self named: aSymbol)		realName: aSymbol;		yourself! !!RBMetaclass class methodsFor: 'instance creation'!named: aSymbol 	^(self new)		name: aSymbol;		yourself! !!RBMethod methodsFor: 'private'!literal: anObject containsReferenceTo: aSymbol 	anObject = aSymbol ifTrue: [^true].	anObject class = Array ifFalse: [^false].	anObject 		do: [:each | (self literal: each containsReferenceTo: aSymbol) ifTrue: [^true]].	^false! !!RBMethod methodsFor: 'accessing'!method	^compiledMethod! !!RBMethod methodsFor: 'accessing'!method: aCompiledMethod 	compiledMethod := aCompiledMethod! !!RBMethod methodsFor: 'accessing'!modelClass	^class! !!RBMethod methodsFor: 'accessing'!modelClass: aRBClass	class := aRBClass! !!RBMethod methodsFor: 'accessing'!parseTree	^RBParser parseMethod: self source onError: [:str :pos | ^nil]! !!RBMethod methodsFor: 'accessing'!selector	^selector! !!RBMethod methodsFor: 'accessing'!selector: aSymbol 	selector := aSymbol! !!RBMethod methodsFor: 'accessing' stamp: 'dvf 11/8/2003 15:02'!source	^source isNil 		ifTrue: [source := (class realClass sourceCodeAt: selector) string]		ifFalse: [source]! !!RBMethod methodsFor: 'accessing'!source: aString 	source := aString! !!RBMethod methodsFor: 'printing'!printOn: aStream 	class printOn: aStream.	aStream		nextPutAll: '>>';		nextPutAll: self selector! !!RBMethod methodsFor: 'testing'!refersToClassNamed: aSymbol 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: aSymbol asString do: [:node :answer | true].	^(searcher executeTree: self parseTree initialAnswer: false) 		or: [self refersToSymbol: aSymbol]! !!RBMethod methodsFor: 'testing' stamp: 'dvf 9/17/2001 00:46'!refersToSymbol: aSymbol 	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: aSymbol printString do: [:node :answer | true];		matches: '`#literal'			do: [:node :answer | answer or: [self literal: node value containsReferenceTo: aSymbol]].	(RBScanner isSelector: aSymbol) 		ifTrue: 			[searcher 				matches: '`@object ' , (ParseTreeSearcher buildSelectorString: aSymbol)				do: [:node :answer | true]].	^searcher executeTree: self parseTree initialAnswer: false! !!RBMethod methodsFor: 'testing'!refersToVariable: aString 	| searcher tree |	tree := self parseTree.	((tree defines: aString) or: [tree body defines: aString]) 		ifTrue: [^false].	searcher := ParseTreeSearcher new.	searcher		matches: aString do: [:node :answer | true];		matches: '[:`@vars | | `@temps | `@.Stmts]'			do: 				[:node :answer | 				answer or: 						[((node defines: aString) or: [node body defines: aString]) not 							and: [searcher executeTree: node body initialAnswer: false]]].	^searcher executeTree: self parseTree initialAnswer: false! !!RBMethod class methodsFor: 'instance creation'!for: aRBClass fromMethod: aCompiledMethod andSelector: aSymbol 	^(self new)		modelClass: aRBClass;		method: aCompiledMethod;		selector: aSymbol;		yourself! !!RBMethod class methodsFor: 'instance creation'!for: aRBClass source: aString selector: aSelector 	^(self new)		modelClass: aRBClass;		selector: aSelector;		source: aString;		yourself! !!RBMethodName methodsFor: 'accessing'!arguments	^arguments! !!RBMethodName methodsFor: 'accessing'!arguments: nameCollection 	arguments := nameCollection.	self changed: #arguments! !!RBMethodName methodsFor: 'accessing'!moveArgument: aName before: anotherName 	arguments remove: aName ifAbsent: [^self].	arguments add: aName before: anotherName.	self changed: #arguments! !!RBMethodName methodsFor: 'accessing'!selector	^selector! !!RBMethodName methodsFor: 'accessing'!selector: aSymbol 	selector := aSymbol.	self changed: #selector! !!RBMethodName methodsFor: 'testing'!isValid	^(RBCondition checkMethodName: self selector in: self class) 		and: [self selector numArgs == self arguments size]! !!RBMethodName class methodsFor: 'instance creation'!selector: aSymbol arguments: stringCollection 	^(self new)		selector: aSymbol;		arguments: stringCollection;		yourself! !!RBMethodNode methodsFor: 'comparing' stamp: 'pmm 7/12/2006 15:42'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	(self selector = anObject selector and: [self body = anObject body]) 		ifFalse: [^false].	^self arguments = anObject arguments! !!RBMethodNode methodsFor: 'comparing' stamp: 'pmm 7/12/2006 15:43'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	(self selector = anObject selector 		and: [self body equalTo: anObject body withMapping: aDictionary]) 			ifFalse: [^false].	self arguments with: anObject arguments do: [ :first :second |		(first equalTo: second withMapping: aDictionary)			ifFalse: [^false].		aDictionary removeKey: first name ].	^self primitiveSources = anObject primitiveSources! !!RBMethodNode methodsFor: 'comparing'!hash	^(self selector hash bitXor: self body hash)		bitXor: self arguments hash! !!RBMethodNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptMethodNode: self! !!RBMethodNode methodsFor: 'accessing'!addNode: aNode 	^body addNode: aNode! !!RBMethodNode methodsFor: 'accessing' stamp: 'ms 7/26/2006 21:52'!addPragma: aPragma	self properties addPragma: aPragma! !!RBMethodNode methodsFor: 'accessing'!addReturn	body addReturn! !!RBMethodNode methodsFor: 'accessing'!addSelfReturn	^body addSelfReturn! !!RBMethodNode methodsFor: 'accessing'!allArgumentVariables	^(self argumentNames asOrderedCollection)		addAll: super allArgumentVariables;		yourself! !!RBMethodNode methodsFor: 'accessing'!allDefinedVariables	^(self argumentNames asOrderedCollection) addAll: super allDefinedVariables;		yourself! !!RBMethodNode methodsFor: 'accessing'!argumentNames	^self arguments collect: [:each | each name]! !!RBMethodNode methodsFor: 'accessing'!arguments	^arguments! !!RBMethodNode methodsFor: 'accessing'!arguments: variableNodes 	arguments := variableNodes.	arguments do: [:each | each parent: self]! !!RBMethodNode methodsFor: 'accessing'!body	^body! !!RBMethodNode methodsFor: 'accessing'!body: stmtsNode 	body := stmtsNode.	body parent: self! !!RBMethodNode methodsFor: 'accessing' stamp: 'ms 11/11/2006 19:22'!children	^(self arguments copyWith: self body), self pragmas! !!RBMethodNode methodsFor: 'accessing' stamp: 'ajh 3/11/2003 19:58'!methodPatternStop	^ self arguments isEmpty		ifTrue: [self selectorParts first stop]		ifFalse: [self arguments last stop]! !!RBMethodNode methodsFor: 'accessing' stamp: 'ms 9/3/2006 23:54'!pragmas 	^pragmas ifNil: [pragmas := OrderedCollection new]! !!RBMethodNode methodsFor: 'accessing' stamp: 'ms 9/4/2006 00:04'!pragmas: aRBPragmasNode	pragmas := aRBPragmasNode.	pragmas do:[:each | each parent: self]! !!RBMethodNode methodsFor: 'accessing' stamp: 'ajh 3/11/2003 18:27'!primitiveNode	^ primitiveNode ifNil: [PrimitiveNode null]! !!RBMethodNode methodsFor: 'accessing' stamp: 'md 10/2/2006 17:23'!primitiveNode: aPrimitiveNode      (primitiveNode isNil              or: [ primitiveNode num = 0 ]              or: [ primitiveNode num = aPrimitiveNode num ])                      ifTrue: [ primitiveNode := aPrimitiveNode ]                      ifFalse: [ self notify: 'Ambigous primitives' ]! !!RBMethodNode methodsFor: 'accessing' stamp: 'ajh 3/19/2003 22:02'!primitiveSources	| tgs text |	tgs := self tags.	tgs isEmpty ifTrue: [		text := self primitiveText.		text isEmpty ifTrue: [^ #()].		^ {text}	].	^ tgs collect: [:each | self source copyFrom: each first to: each last]! !!RBMethodNode methodsFor: 'accessing' stamp: 'ajh 3/11/2003 18:32'!primitiveStartPosition	| set |	set := self tags.	set isEmpty ifTrue: [^ 0].	set size > 1 ifTrue: [self error: 'only one primitive string expected'].	^ set first first! !!RBMethodNode methodsFor: 'accessing' stamp: 'ajh 3/19/2003 22:02'!primitiveText	| set |	self tags isEmpty ifTrue: [		^ self primitiveNode			ifNil: ['']			ifNotNil: [self primitiveNode sourceText]	].	set := self primitiveSources.	set size > 1 ifTrue: [self error: 'only one primitive string expected'].	^ set first! !!RBMethodNode methodsFor: 'accessing' stamp: 'md 4/1/2007 13:32'!properties	^methodProperties ifNil: [methodProperties := MethodProperties  new]! !!RBMethodNode methodsFor: 'accessing' stamp: 'md 4/1/2007 13:32'!properties: aMethodeProperties 	methodProperties := aMethodeProperties! !!RBMethodNode methodsFor: 'accessing' stamp: 'md 4/7/2007 10:20'!selector	^selector isNil		ifTrue: [selector := self buildSelector]		ifFalse: [selector]! !!RBMethodNode methodsFor: 'accessing'!selector: aSelector 	| keywords numArgs |	keywords := aSelector keywords.	numArgs := aSelector numArgs.	numArgs == arguments size 		ifFalse: 			[self 				error: 'Attempting to assign selector with wrong number of arguments.'].	selectorParts := numArgs == 0 				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]				ifFalse: 					[keywords first last == $: 						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].	selector := aSelector! !!RBMethodNode methodsFor: 'accessing' stamp: 'md 4/7/2007 11:31'!source	^source! !!RBMethodNode methodsFor: 'accessing'!source: anObject	source := anObject! !!RBMethodNode methodsFor: 'accessing'!start	^1! !!RBMethodNode methodsFor: 'accessing' stamp: 'md 4/6/2007 11:22'!stop	^self source size! !!RBMethodNode methodsFor: 'accessing' stamp: 'md 4/7/2007 20:15'!tags		^ self propertyAt: #tags ifAbsent: [#()].! !!RBMethodNode methodsFor: 'accessing' stamp: 'md 4/7/2007 20:14'!tags: aCollectionOfIntervals 	aCollectionOfIntervals ifNil: [^self removeProperty: #tags ifAbsent: []].	self propertyAt: #tags put: aCollectionOfIntervals.! !!RBMethodNode methodsFor: 'replacing' stamp: 'ajh 3/13/2003 16:13'!adjustPositionsAfter: sourcePos by: delta	"Slide token positions after sourcePos by delta"	selectorParts do: [:token |		token start > sourcePos ifTrue: [			token start: token start + delta]	].	super adjustPositionsAfter: sourcePos by: delta.! !!RBMethodNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	aNode == body ifTrue: [self body: anotherNode].	self arguments: (arguments 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !!RBMethodNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:31'!basicFirstToken		^self selectorParts first! !!RBMethodNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:32'!basicLastToken		^self body lastToken ifNil:[^(RBPatternMethodNode selectorParts: self selectorParts arguments: self arguments) lastToken]! !!RBMethodNode methodsFor: 'accessing-token' stamp: 'ms 4/1/2007 17:34'!lastTokenOfPatternMethod		^self arguments ifEmpty: [^self selectorParts last] ifNotEmpty: [ ^self arguments last token]! !!RBMethodNode methodsFor: 'private'!buildSelector	| selectorStream |	selectorStream := WriteStream on: (String new: 50).	selectorParts do: [:each | selectorStream nextPutAll: each value].	^selectorStream contents asSymbol! !!RBMethodNode methodsFor: 'private'!selectorParts	^selectorParts! !!RBMethodNode methodsFor: 'private'!selectorParts: tokenCollection 	selectorParts := tokenCollection! !!RBMethodNode methodsFor: 'matching'!copyInContext: aDictionary 	^(self class new)		selectorParts: (selectorParts collect: [:each | each removePositions]);		arguments: (arguments collect: [:each | each copyInContext: aDictionary]);		body: (body copyInContext: aDictionary);		source: (aDictionary at: '-source-');		yourself! !!RBMethodNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	self class == aNode class ifFalse: [^false].	aDictionary at: '-source-' put: aNode source.	self selector == aNode selector ifFalse: [^false].	^(self matchList: arguments		against: aNode arguments		inContext: aDictionary)			and: [body match: aNode body inContext: aDictionary]! !!RBMethodNode methodsFor: 'testing' stamp: 'pmm 7/12/2006 15:18'!defines: aName 	^arguments anySatisfy: [:each | each name = aName]! !!RBMethodNode methodsFor: 'testing'!isLast: aNode 	^body isLast: aNode! !!RBMethodNode methodsFor: 'testing'!isMethod	^true! !!RBMethodNode methodsFor: 'testing' stamp: 'ms 4/1/2007 13:47'!isPrimitive	^((self primitiveNode num = 0) not) 		or: [self pragmas 				inject: false into: [:bool :each | each isPrimitive | bool]]! !!RBMethodNode methodsFor: 'testing'!lastIsReturn	^body lastIsReturn! !!RBMethodNode methodsFor: 'testing'!references: aVariableName 	^body references: aVariableName! !!RBMethodNode methodsFor: 'testing'!uses: aNode 	^body == aNode and: [aNode lastIsReturn]! !!RBMethodNode methodsFor: 'copying' stamp: 'pmm 12/5/2005 10:00'!postCopy	super postCopy.	body := body copy.	body parent: self.	arguments := arguments collect: [:each |		each copy		parent: self;		yourself ]! !!RBMethodNode methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self formattedCode! !!RBMethodNode methodsFor: 'printing' stamp: 'ajh 2/27/2003 22:44'!sourceText	^ (self source ifNil: [self formattedCode]) asText! !!RBMethodNode methodsFor: 'initialize-release'!selectorParts: tokenCollection arguments: variableNodes 	selectorParts := tokenCollection.	self arguments: variableNodes! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'ms 6/17/2007 16:21'!asBlock	^ (RBBlockNode		arguments: self arguments		body: body)		scope: self scope;		privIR: self ir		! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'ajh 6/28/2004 13:52'!compiledMethod	^ self ir compiledMethod! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'md 2/21/2006 14:42'!generate	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	^self generate: #(0 0 0 0)! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'ajh 3/10/2003 20:21'!generate: trailer	^ self generateIR compiledMethodWith: trailer! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'ms 11/21/2007 22:57'!generateIR	^ ir := ASTTranslator new		visitNode: self;		ir! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'pmm 8/16/2006 21:34'!generateWith: trailer using: aCompiledMethodClass	^ self generateIR compiledMethodWith: trailer using: aCompiledMethodClass! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'ajh 3/10/2003 20:20'!ir	^ ir ifNil: [self generateIR]! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'ms 6/12/2007 17:47'!privIR: irMethod	ir := irMethod! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'md 2/27/2006 17:50'!sourceText: aText	self flag: #fixme! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'md 3/16/2006 18:48'!verifyIn: classOrScope	"Look up vars in classOrScope.  My tree will be annotated with bindings to LexicalScopes and ScopeVars."	ASTChecker new		scope: classOrScope parseScope;		visitNode: self.			Preferences compileBlocksAsClosures ifFalse: [ 		NonClosureScopeFixer new visitNode: self.	]! !!RBMethodNode methodsFor: '*newcompiler-semantics' stamp: 'ajh 7/8/2004 20:56'!freeNames	"Filter out hidden ones that have space in there name such as 'top env'"	^ ((self freeVars collect: [:var | var name])		reject: [:name | name includes: $ ]) asSortedCollection! !!RBMethodNode methodsFor: '*newcompiler-semantics' stamp: 'md 4/13/2007 15:09'!freeVars	"Return children variable node bindings that refer to variables outside my scope (ignoring global vars)"	| freeVars |	freeVars := Set new.	self scope: self owningScope.	self nodesDo: [:node | | var |		(node isVariable or: [node isReturn and: [node binding notNil]]) ifTrue: [			var := node binding.			(self scope hasOuter: var scope) ifTrue: [				var isGlobal ifFalse: [					freeVars add: var]]]].	^ freeVars! !!RBMethodNode methodsFor: '*newcompiler-semantics' stamp: 'ajh 6/30/2004 14:07'!owningBlock	^ self! !!RBMethodNode methodsFor: '*newcompiler-semantics' stamp: 'md 4/8/2007 17:58'!owningScope	^ self scope! !!RBMethodNode methodsFor: '*newcompiler-semantics' stamp: 'ajh 3/16/2003 08:32'!scope	^ scope ifNil: [		self verifyIn: nil parseScope.		scope	  ]! !!RBMethodNode methodsFor: '*newcompiler-semantics' stamp: 'ajh 2/26/2003 15:46'!scope: aSemMethodScope	scope := aSemMethodScope! !!RBMethodNode methodsFor: '*newcompiler-decorating' stamp: 'ms 5/28/2007 11:47'!peekAfterComment	| tokenStream token countNewLine |	self afterComment ifNil:[		countNewLine := 0.		self afterComment: OrderedCollection new.		tokenStream := (SqueakTokenStream forwardOn: self lastTokenOfPatternMethod) selectCommentNewLine.		[tokenStream atEnd 			ifFalse: [				token := tokenStream next.				token isNewLine 				ifTrue: [countNewLine := countNewLine + 1.]. 		 		(countNewLine = 2)]			ifTrue:[true]] 				whileFalse: [token isComment ifTrue:[self afterComment add: token eatToken]].		self afterComment do: [:each | self comments add: (each start to: each stop)]	].	^self afterComment		! !!RBMethodNode methodsFor: '*newcompiler-decorating' stamp: 'md 4/4/2007 17:41'!peekBeforeComment	| tokenStream token |	self beforeComment ifNil: 			[			self beforeComment: OrderedCollection new.			tokenStream := (SqueakTokenStream backwardOn: self firstToken) 						selectCommentNewLine.			[token := tokenStream next.			token isNil] 					whileFalse: 						[token isComment ifTrue: [self beforeComment add: token eatToken]].			self beforeComment do: [:each | self comments add: (each start to: each stop)]].	^ self beforeComment! !!RBMethodNode methodsFor: '*newcompiler-decorating' stamp: 'ms 5/28/2007 12:02'!peekInsideComment		| tokenStream token |	self insideComment ifNil:[		self insideComment: OrderedCollection new.		tokenStream := (SqueakTokenStream forwardOn: self firstToken).		[tokenStream atEnd 			ifFalse:[				token := tokenStream next.				false]			ifTrue:[true]]				whileFalse: [(token isComment and:[token notEaten]) 								ifTrue:[self insideComment add: token eatToken]].		self insideComment do: [:each | self comments add: (each start to: each stop)]	].	^self insideComment! !!RBMethodNode methodsFor: '*newcompiler-debugging' stamp: 'ms 11/22/2007 00:20'!sourceMap	"Return a mapping from bytecode pcs to source code ranges"	source ifNil: [		"No source, use decompile string as source to map from"		^(self class parserClass new			parse: self decompileString			class: self scope classEncoding) sourceMap		].	^ self ir sourceMap asSortedCollection! !!RBMethodNode methodsFor: '*newcompiler-debugging' stamp: 'ajh 6/29/2004 16:06'!tempNames	"All temp names in context order"	^ self scope tempVars allButFirst "without self" collect: [:var | var name]! !!RBMethodNode methodsFor: '*persephone' stamp: 'md 11/11/2007 13:58'!definitions	^self arguments asOrderedCollection addAll: self body temporaries! !!RBMethodNode methodsFor: '*persephone' stamp: 'md 11/11/2007 13:38'!enclosingBlockOrMethod	^self! !!RBMethodNode methodsFor: '*persephone' stamp: 'md 3/31/2007 18:56'!encoder	"hack"	^PEParser new! !!RBMethodNode methodsFor: '*persephone' stamp: 'pmm 9/24/2006 19:10'!hasReturnAtMostAtEnd	^self body hasReturnAtMostAtEnd! !!RBMethodNode methodsFor: '*persephone' stamp: 'pmm 6/4/2006 13:34'!method	^self! !!RBMethodNode methodsFor: '*persephone' stamp: 'md 4/14/2007 01:58'!numArgs	^self arguments size! !!RBMethodNode methodsFor: '*Colorer' stamp: 'pmm 11/27/2006 12:50'!markExecuted	super markExecuted.	self arguments do: [ :each |		each markExecuted ]! !!RBMethodNode commentStamp: 'md 4/7/2007 20:16' prior: 0!RBMethodNode is the AST that represents a Smalltalk method.Instance Variables:	arguments	<SequenceableCollection of: RBVariableNode>	the arguments to the method	body	<BRSequenceNode>	the body/statements of the method	selector	<Symbol | nil>	the method name (cached)	selectorParts	<SequenceableCollection of: RBValueToken>	the tokens for the selector keywords	source	<String>	the source we compiled			Properties:				tags	<Collection of: Interval>	the source location of any resource/primitive tags!!RBMethodNode class methodsFor: 'instance creation'!selector: aSymbol arguments: variableNodes body: aSequenceNode 	^(self new)		arguments: variableNodes;		selector: aSymbol;		body: aSequenceNode;		yourself! !!RBMethodNode class methodsFor: 'instance creation'!selector: aSymbol body: aSequenceNode 	^self 		selector: aSymbol		arguments: #()		body: aSequenceNode! !!RBMethodNode class methodsFor: 'instance creation' stamp: 'pmm 7/12/2006 15:20'!selectorParts: tokenCollection arguments: variableNodes 	^((tokenCollection anySatisfy: [:each | each isPatternVariable]) 		ifTrue: [RBPatternMethodNode] ifFalse: [RBMethodNode]) 		new selectorParts: tokenCollection arguments: variableNodes! !!RBMethodNodeTest methodsFor: 'testing' stamp: 'ms 9/16/2006 23:46'!testChildren		self assert: (self defaultParser parseMethod: 'bar: bob foo: alice ^self') children size = 3! !!RBMethodNodeTest methodsFor: 'testing' stamp: 'ms 4/1/2007 17:45'!testLastFirstToken		| aMethodNode |	aMethodNode := self defaultParser parseMethod: 'boo: ask tim whereIsBrian'.		self assert: (aMethodNode firstToken value = 'boo:').	self assert: (aMethodNode lastToken value = 'whereIsBrian').	self assert: (aMethodNode lastTokenOfPatternMethod  value = 'ask').		aMethodNode := self defaultParser parseMethod: 'i tim whereIsBrian'.		self assert: (aMethodNode firstToken value = 'i').	self assert: (aMethodNode lastToken value = 'whereIsBrian').	self assert: (aMethodNode lastTokenOfPatternMethod  value = 'i')! !!RBMethodNodeTest methodsFor: 'testing' stamp: 'ms 3/31/2007 17:22'!testPosition		| aMethodNode |	aMethodNode := self defaultParser parseMethod: 'boo: ask tim whereIsBrian'.	self assertPosition: aMethodNode start: 1 stop: 25.! !!RBMethodPatternNodeTest methodsFor: 'testing' stamp: 'ms 9/16/2006 22:41'!tesLastFirstToken	| rbMethod |	rbMethod := RBPatternMethodNode selectorParts: {RBKeywordToken value: 'bob:' start: 0} 									 arguments: {RBIdentifierToken value: 'arg' start: 0}.	self assert: (rbMethod firstToken value = 'bob:').	self assert: (rbMethod lastToken value = 'arg')! !!RBNamespace methodsFor: 'private-changes'!addChangeToClass: aRBClass 	^changedClasses at: aRBClass name		put: (Array with: aRBClass nonMetaclass with: aRBClass metaclass)! !!RBNamespace methodsFor: 'private-changes'!addClassVariable: aString to: aRBClass 	^changes addClassVariable: aString to: aRBClass! !!RBNamespace methodsFor: 'private-changes'!addInstanceVariable: aString to: aRBClass 	^changes addInstanceVariable: aString to: aRBClass! !!RBNamespace methodsFor: 'private-changes'!addPool: aString to: aRBClass 	^changes addPool: aString to: aRBClass! !!RBNamespace methodsFor: 'private-changes'!changeClass: aRBClass 	changedClasses at: aRBClass name		put: (Array with: aRBClass nonMetaclass with: aRBClass metaclass).	self flushCaches! !!RBNamespace methodsFor: 'private-changes'!compile: aString in: aRBClass classified: aSymbol 	| change |	change := changes 				compile: aString				in: aRBClass				classified: aSymbol.	self flushCaches.	^change! !!RBNamespace methodsFor: 'private-changes'!flushCaches	implementorsCache := IdentityDictionary new.	sendersCache := IdentityDictionary new! !!RBNamespace methodsFor: 'private-changes'!performChange: aCompositeRefactoryChange around: aBlock 	| oldChanges |	changes addChange: aCompositeRefactoryChange.	oldChanges := changes.	changes := aCompositeRefactoryChange.	aBlock ensure: [changes := oldChanges].	^aCompositeRefactoryChange! !!RBNamespace methodsFor: 'private-changes'!removeClassVariable: aString from: aRBClass 	^changes removeClassVariable: aString from: aRBClass! !!RBNamespace methodsFor: 'private-changes'!removeInstanceVariable: aString from: aRBClass 	^changes removeInstanceVariable: aString from: aRBClass! !!RBNamespace methodsFor: 'private-changes'!removeMethod: aSelector from: aRBClass 	self flushCaches.	^changes removeMethod: aSelector from: aRBClass! !!RBNamespace methodsFor: 'private-changes'!renameClassVariable: oldName to: newName in: aRBClass around: aBlock 	^self performChange: (RenameClassVariableChange 				rename: oldName				to: newName				in: aRBClass)		around: aBlock! !!RBNamespace methodsFor: 'private-changes'!renameInstanceVariable: oldName to: newName in: aRBClass around: aBlock 	^self performChange: (RenameInstanceVariableChange 				rename: oldName				to: newName				in: aRBClass)		around: aBlock! !!RBNamespace methodsFor: 'private-changes'!replaceClassNameIn: definitionString to: aSymbol 	| parseTree |	parseTree := RBParser parseExpression: definitionString.	parseTree receiver: (RBVariableNode named: aSymbol).	^parseTree formattedCode! !!RBNamespace methodsFor: 'accessing' stamp: 'lr 10/15/2007 08:39'!allClassesDo: aBlock 	| seen evalBlock |	seen := Set new.	evalBlock := 			[:each | 			seen add: each first name.			aBlock				value: each first;				value: each last].	newClasses do: evalBlock.	changedClasses do: evalBlock.	environment classesDo: 			[:each | 			(each isMeta or: [each isObsolete]) 				ifFalse: 					[((seen includes: each name) 						or: [self hasRemoved: (self classNameFor: each)]) 							ifFalse: 								[| class |								class := self classFor: each.								class isNil 									ifFalse: 										[aBlock											value: class;											value: class metaclass]]]]! !!RBNamespace methodsFor: 'accessing'!allImplementorsOf: aSelector 	^implementorsCache at: aSelector		ifAbsentPut: [self privateImplementorsOf: aSelector]! !!RBNamespace methodsFor: 'accessing'!allReferencesTo: aSymbol do: aBlock 	(sendersCache at: aSymbol		ifAbsentPut: 			[| refs |			refs := OrderedCollection new.			self allClassesDo: 					[:each | 					(each whichSelectorsReferToSymbol: aSymbol) 						do: [:sel | refs add: (each methodFor: sel)]].			refs]) 			do: aBlock! !!RBNamespace methodsFor: 'accessing'!allReferencesToClass: aRBClass do: aBlock 	self allClassesDo: 			[:each | 			(each whichSelectorsReferToClass: aRBClass) 				do: [:sel | aBlock value: (each methodFor: sel)]]! !!RBNamespace methodsFor: 'accessing'!changes	^changes! !!RBNamespace methodsFor: 'accessing'!environment	^environment! !!RBNamespace methodsFor: 'accessing'!environment: aBrowserEnvironment 	environment := aBrowserEnvironment! !!RBNamespace methodsFor: 'accessing'!name	^changes name! !!RBNamespace methodsFor: 'accessing'!name: aString	^changes name: aString! !!RBNamespace methodsFor: 'accessing' stamp: 'bh 4/3/2000 15:47'!rootClasses	rootClasses isNil 		ifTrue: 			[rootClasses := OrderedCollection new.			Class rootsOfTheWorld do: 					[:each | 					| class |					class := self classFor: each.					(class notNil "and: [class superclass isNil] <- it's protoObject, not nil.") 						ifTrue: [rootClasses add: class]]].	^rootClasses! !!RBNamespace methodsFor: 'accessing-classes' stamp: 'lr 10/15/2007 08:37'!classFor: aBehavior 	| nonMetaclass class |	aBehavior isNil ifTrue: [^ nil].	nonMetaclass := aBehavior isMeta 				ifTrue: [aBehavior soleInstance]				ifFalse: [aBehavior].	class := aBehavior isMeta 				ifTrue: [self metaclassNamed: nonMetaclass name]				ifFalse: [self classNamed: nonMetaclass name].	^ class! !!RBNamespace methodsFor: 'accessing-classes' stamp: 'dc 5/8/2007 13:35'!classNamed: aSymbol 	| class index classes |	aSymbol isNil ifTrue: [^nil].	(self hasRemoved: aSymbol) ifTrue: [^nil].	(newClasses includesKey: aSymbol) 		ifTrue: [^(newClasses at: aSymbol) first].	(changedClasses includesKey: aSymbol) 		ifTrue: [^(changedClasses at: aSymbol) first].		class := environment at: aSymbol ifAbsent: [nil].	(class isBehavior or: [class isTrait])		ifTrue: 			[classes := self createNewClassFor: class.			^class isMeta ifTrue: [classes last] ifFalse: [classes first]].		index := aSymbol 				indexOfSubCollection: ' class'				startingAt: 1				ifAbsent: [^nil].	class := self classNamed: (aSymbol copyFrom: 1 to: index - 1) asSymbol.	^class isNil ifTrue: [nil] ifFalse: [class metaclass]! !!RBNamespace methodsFor: 'accessing-classes'!createNewClassFor: aBehavior 	| nonMeta meta className |	className := (aBehavior isMeta 				ifTrue: [aBehavior soleInstance]				ifFalse: [aBehavior]) name.	nonMeta := (RBClass existingNamed: className)				model: self;				yourself.	meta := (RBMetaclass existingNamed: className)				model: self;				yourself.	^changedClasses at: className put: (Array with: nonMeta with: meta)! !!RBNamespace methodsFor: 'accessing-classes' stamp: 'dc 5/8/2007 13:44'!metaclassNamed: aSymbol 	| class |	aSymbol isNil ifTrue: [^nil].	(self hasRemoved: aSymbol) ifTrue: [^nil].	(newClasses includesKey: aSymbol) 		ifTrue: [^(newClasses at: aSymbol) last].	(changedClasses includesKey: aSymbol) 		ifTrue: [^(changedClasses at: aSymbol) last].	class := environment at: aSymbol ifAbsent: [nil].	(class isBehavior or: [class isTrait])		ifTrue: [^ (self createNewClassFor: class) last].	^ nil! !!RBNamespace methodsFor: 'accessing-classes'!whichCategoryIncludes: aSymbol	^self environment whichCategoryIncludes: aSymbol! !!RBNamespace methodsFor: 'private'!classNameFor: aBehavior 	^(aBehavior isMeta ifTrue: [aBehavior soleInstance] ifFalse: [aBehavior]) 		name! !!RBNamespace methodsFor: 'private'!hasCreatedClassFor: aBehavior 	| className |	className := self classNameFor: aBehavior.	^(newClasses includesKey: className) 		or: [changedClasses includesKey: className]! !!RBNamespace methodsFor: 'private'!privateImplementorsOf: aSelector 	| classes |	classes := Set new.	self allClassesDo: 			[:each | 			(each directlyDefinesMethod: aSelector) ifTrue: [classes add: each]].	^classes! !!RBNamespace methodsFor: 'changes'!defineClass: aString 	| change newClass newClassName |	change := changes defineClass: aString.	newClassName := change changeClassName.	newClass := self classNamed: newClassName.	newClass isNil 		ifTrue: 			[| newMetaclass |			removedClasses				remove: newClassName ifAbsent: [];				remove: newClassName , ' class' ifAbsent: [].			newClass := RBClass named: newClassName.			newMetaclass := RBMetaclass named: newClassName.			newClass model: self.			newMetaclass model: self.			newClasses at: newClassName put: (Array with: newClass with: newMetaclass)].	newClass superclass: (self classNamed: change superclassName).	newClass superclass isNil 		ifTrue: 			[self rootClasses add: newClass.			newClass metaclass superclass: (self classFor: Object class superclass)]		ifFalse: [newClass metaclass superclass: newClass superclass metaclass].	newClass instanceVariableNames: change instanceVariableNames.	newClass classVariableNames: change classVariableNames.	newClass poolDictionaryNames: change poolDictionaryNames.	newClass category: change category.	^change! !!RBNamespace methodsFor: 'changes'!removeClass: aRBClass 	self removeClassNamed: aRBClass name! !!RBNamespace methodsFor: 'changes'!removeClassNamed: aSymbol 	(self classNamed: aSymbol) subclasses 		do: [:each | self removeClassNamed: each name].	removedClasses		add: aSymbol;		add: aSymbol , ' class'.	newClasses removeKey: aSymbol ifAbsent: [].	changedClasses removeKey: aSymbol ifAbsent: [].	self flushCaches.	^changes removeClassNamed: aSymbol! !!RBNamespace methodsFor: 'changes'!renameClass: aRBClass to: aSymbol around: aBlock 	| change value dict |	change := RenameClassChange rename: aRBClass name to: aSymbol.	self performChange: change around: aBlock.	self flushCaches.	dict := (newClasses includesKey: aSymbol) 				ifTrue: [newClasses]				ifFalse: [changedClasses].	removedClasses		add: aRBClass name;		add: aRBClass name , ' class'.	value := dict at: aRBClass name.	dict removeKey: aRBClass name.	dict at: aSymbol put: value.	value first name: aSymbol.	value last name: aSymbol.	value first subclasses do: [:each | each superclass: value first].	value last subclasses do: [:each | each superclass: value last].	^change! !!RBNamespace methodsFor: 'changes'!reparentClasses: aRBClassCollection to: newClass 	aRBClassCollection do: 			[:aClass | 			self defineClass: (self replaceClassNameIn: aClass definitionString						to: newClass name)]! !!RBNamespace methodsFor: 'testing'!hasRemoved: aSymbol 	^removedClasses includes: aSymbol! !!RBNamespace methodsFor: 'testing'!includesClassNamed: aSymbol 	^(self classNamed: aSymbol) notNil! !!RBNamespace methodsFor: 'testing'!includesGlobal: aSymbol 	(self hasRemoved: aSymbol) ifTrue: [^false].	(self includesClassNamed: aSymbol) ifTrue: [^true].	environment at: aSymbol ifAbsent: [^false].	^true! !!RBNamespace methodsFor: 'initialize-release'!initialize	changes := CompositeRefactoryChange new.	environment := BrowserEnvironment new.	newClasses := IdentityDictionary new.	changedClasses := IdentityDictionary new.	removedClasses := Set new.	implementorsCache := IdentityDictionary new.	sendersCache := IdentityDictionary new! !!RBNamespace class methodsFor: 'instance creation'!onEnvironment: aBrowserEnvironment 	^(self new)		environment: aBrowserEnvironment;		yourself! !!RBNamespaceTest methodsFor: 'class tests'!testAllClassesDo	| model classes |	classes := 0.	model := RBNamespace new.	model allClassesDo: 			[:each | 			each name = #Object ifTrue: [each allSubclasses].			classes := classes + 1].	BrowserEnvironment new classesDo: [:each | classes := classes - 1].	self assert: classes = 0! !!RBNamespaceTest methodsFor: 'class tests'!testDefineClassAfterDeletedChange	| st |	st := RBNamespace new.	st removeClassNamed: self class name.	self deny: (st includesClassNamed: self class name).	st defineClass: self class definition.	self assert: (st includesClassNamed: self class name).	self assert: (st classNamed: self class name) notNil! !!RBNamespaceTest methodsFor: 'class tests' stamp: 'bh 11/8/2000 14:13'!testDefineClassChange	| st |	st := RBNamespace new.	st 		defineClass: 'RefactoringBrowserTest subclass: #SmalltalkTestXXX				instanceVariableNames: ''''				classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Testing'''.	self assert: (st includesClassNamed: #SmalltalkTestXXX).	self assert: (st classNamed: #SmalltalkTestXXX) notNil! !!RBNamespaceTest methodsFor: 'class tests'!testImplementors	| st |	st := RBNamespace new.	self assert: ((st allImplementorsOf: #printString) 				includes: (st classNamed: #Object)).	(st classNamed: #Object) removeMethod: #printString.	self deny: ((st allImplementorsOf: #printString) 				includes: (st classNamed: #Object))! !!RBNamespaceTest methodsFor: 'class tests'!testIncludesClass	self assert: (RBNamespace new includesClassNamed: #Object).	self deny: (RBNamespace new includesClassNamed: #Object1).	self 		deny: ((RBNamespace 				onEnvironment: (ClassEnvironment onEnvironment: BrowserEnvironment new						classes: (Array with: Object))) 					includesClassNamed: #OrderedCollection)! !!RBNamespaceTest methodsFor: 'class tests' stamp: 'bh 9/17/2001 02:03'!testModelImplementorsSenders	| model class modelImps refs found |	model := RBNamespace new.	model 		defineClass: 'Object subclass: #Asdf			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Testing'''.	class := model classNamed: #Asdf.	class compile: 'storeOn: aStream ^super storeOn: aStream'		classified: #(#printing).	modelImps := model allImplementorsOf: #storeOn:.	self assert: (modelImps includes: class).	self assert: modelImps size - 1 				= (BrowserEnvironment new implementorsOf: #storeOn:) numberSelectors.	refs := BrowserEnvironment new referencesTo: #storeOn:.	found := false.	model allReferencesTo: #storeOn:		do: 			[:each | 			each modelClass = class 				ifTrue: [found := true]				ifFalse: 					[self 						assert: (refs includesSelector: each selector in: each modelClass realClass)]].	self assert: found! !!RBNamespaceTest methodsFor: 'class tests' stamp: 'bh 11/8/2000 14:13'!testRedefineClassChange	| st |	st := RBNamespace new.	st defineClass: 'nil subclass: #Object				instanceVariableNames: ''a''				classVariableNames: ''A''				poolDictionaries: ''TextConstants''				category: #''Refactory-Testing'''.	self assert: (st includesClassNamed: #Object).	self assert: (st classNamed: #Object) notNil! !!RBNamespaceTest methodsFor: 'class tests' stamp: 'bh 4/10/2001 16:21'!testReferencesPrintOn	| hasFoundObject hasFoundSelf st |	hasFoundObject := false.	hasFoundSelf := false.	st := RBNamespace new.	st allReferencesTo: #printOn:		do: 			[:each | 			hasFoundObject := hasFoundObject or: 							[each selector = #fullPrintString 								and: [each modelClass = (st classNamed: #Object)]].			hasFoundSelf := hasFoundSelf or: 							[each selector = #testReferencesPrintOn 								and: [each modelClass = (st classNamed: self class name)]]].	self assert: hasFoundObject.	self assert: hasFoundSelf! !!RBNamespaceTest methodsFor: 'class tests'!testReferencesPrintOnAfterRemove	| hasFoundObject hasFoundSelf st |	hasFoundObject := false.	hasFoundSelf := false.	st := RBNamespace new.	(st classNamed: #Object) removeMethod: #printString.	st allReferencesTo: #printOn:		do: 			[:each | 			hasFoundObject := hasFoundObject or: 							[each selector = #printString 								and: [each modelClass = (st classNamed: #Object)]].			hasFoundSelf := hasFoundSelf or: 							[each selector = #testReferencesPrintOnAfterRemove 								and: [each modelClass = (st classNamed: self class name)]]].	self deny: hasFoundObject.	self assert: hasFoundSelf! !!RBNamespaceTest methodsFor: 'class tests'!testRemoveClassChange	| st |	st := RBNamespace new.	st removeClassNamed: self class name.	self deny: (st includesClassNamed: self class name).	self assert: (st classNamed: self class name) isNil! !!RBNamespaceTest methodsFor: 'class tests'!testReparentSuperclassChange	| st superclass subclasses |	st := RBNamespace new.	superclass := st classFor: TestCase superclass.	subclasses := TestCase subclasses collect: [:each | st classFor: each].	st reparentClasses: subclasses to: superclass.	subclasses do: [:each | self assert: each superclass = superclass]! !!RBNamespaceTest methodsFor: 'class tests' stamp: 'bh 4/3/2000 15:47'!testRoots	| model |	model := RBNamespace new.	self 		assert: (model rootClasses asSortedCollection: [:a :b | a name < b name]) 				asArray 					= ((Class rootsOfTheWorld collect: [:each | model classFor: each]) 							asSortedCollection: [:a :b | a name < b name]) asArray! !!RBNegationCondition methodsFor: 'checking'!check	^condition check not! !!RBNegationCondition methodsFor: 'initialize-release'!condition: aCondition 	condition := aCondition.	self errorMacro: condition errorMacro! !!RBNegationCondition methodsFor: 'private'!errorBlockFor: aBoolean 	^condition errorBlockFor: aBoolean not! !!RBNegationCondition methodsFor: 'private'!errorStringFor: aBoolean 	^condition errorStringFor: aBoolean not! !!RBNegationCondition methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: 'NOT ';		print: condition! !!RBNegationCondition class methodsFor: 'instance creation'!on: aCondition	^self new condition: aCondition! !!RBParseTreeRule methodsFor: 'matching'!canMatch: aProgramNode 	^true! !!RBParseTreeRule methodsFor: 'matching'!foundMatchFor: aProgramNode	^aProgramNode! !!RBParseTreeRule methodsFor: 'matching'!performOn: aProgramNode 	self context empty.	^((searchTree match: aProgramNode inContext: self context) 		and: [self canMatch: aProgramNode]) 			ifTrue: 				[owner recusivelySearchInContext.				self foundMatchFor: aProgramNode]			ifFalse: [nil]! !!RBParseTreeRule methodsFor: 'private'!context	^owner context! !!RBParseTreeRule methodsFor: 'initialize-release'!methodSearchString: aString 	searchTree := RBParser parseRewriteMethod: aString! !!RBParseTreeRule methodsFor: 'initialize-release'!owner: aParseTreeSearcher	owner := aParseTreeSearcher! !!RBParseTreeRule methodsFor: 'initialize-release'!searchString: aString 	searchTree := RBParser parseRewriteExpression: aString! !!RBParseTreeRule methodsFor: 'accessing'!sentMessages	^searchTree sentMessages! !!RBParseTreeRule commentStamp: 'md 8/9/2005 14:55' prior: 0!RBParseTreeRule is the abstract superclass of all of the parse tree searching rules. A parse tree rule is the first class representation of a particular rule to search for. The owner of a rule is the algorithm that actually executes the search. This arrangement allows multiple searches to be conducted by a single Searcher.Instance Variables:	owner	<ParseTreeSearcher>	The searcher that is actually performing the search.	searchTree	<RBProgramNode>	The parse tree to be searched.!!RBParseTreeRule class methodsFor: 'instance creation'!methodSearch: aString 	^(self new)		methodSearchString: aString;		yourself! !!RBParseTreeRule class methodsFor: 'instance creation'!search: aString 	^(self new)		searchString: aString;		yourself! !!RBParser methodsFor: 'private' stamp: 'tween 6/29/2006 18:42'!addCommentsTo: aNode	| existingComments newComments allComments |		existingComments := aNode comments ifNil:[OrderedCollection new].	newComments := scanner getComments ifNil:[OrderedCollection new].	allComments := existingComments, newComments.	allComments isEmpty ifTrue:[allComments := nil].	aNode comments: allComments! !!RBParser methodsFor: 'private'!nextToken	^nextToken isNil		ifTrue: [nextToken := scanner next]		ifFalse: [nextToken]! !!RBParser methodsFor: 'private' stamp: 'pmm 7/12/2006 15:24'!patchLiteralMessage	currentToken value == true 		ifTrue: 			[^currentToken := RBIdentifierToken value: 'true' start: currentToken start].	currentToken value == false 		ifTrue: 			[^currentToken := RBIdentifierToken value: 'false' start: currentToken start].	currentToken value isNil		ifTrue: 			[^currentToken := RBIdentifierToken value: 'nil' start: currentToken start]! !!RBParser methodsFor: 'private' stamp: 'pmm 7/12/2006 15:14'!patchNegativeLiteral	"Handle the special negative number case for binary message sends."	currentToken value isNumber ifFalse: [^self].	currentToken value <= 0 ifFalse: [^self].	currentToken value = 0 		ifTrue: 			[(source notNil and: 					[source isEmpty not 						and: [(source at: (currentToken start min: source size)) == $-]]) 				ifFalse: [^self]].	nextToken := currentToken.	currentToken := RBBinarySelectorToken value: #- start: nextToken start.	nextToken value: nextToken value negated.	nextToken start: nextToken start + 1! !!RBParser methodsFor: 'private'!step	nextToken notNil ifTrue: 			[currentToken := nextToken.			nextToken := nil.			^currentToken].	currentToken := scanner next! !!RBParser methodsFor: 'testing'!atEnd	^currentToken class == RBToken! !!RBParser methodsFor: 'error handling'!errorBlock	^errorBlock isNil		ifTrue: [[:message :position | ]]		ifFalse: [errorBlock]! !!RBParser methodsFor: 'error handling'!errorPosition	^currentToken start! !!RBParser methodsFor: 'error handling'!parserError: aString 	"Evaluate the block. If it returns raise an error"	self errorBlock value: aString value: self errorPosition.	self error: aString! !!RBParser methodsFor: 'accessing'!errorBlock: aBlock 	errorBlock := aBlock.	scanner notNil ifTrue: [scanner errorBlock: aBlock]! !!RBParser methodsFor: 'accessing'!initializeParserWith: aString type: aSymbol 	source := aString.	self scanner: (RBScanner 				perform: aSymbol				with: (ReadStream on: aString)				with: self errorBlock)! !!RBParser methodsFor: 'accessing'!parseExpression	| node |	node := self parseStatements: false.	self atEnd ifFalse: [self parserError: 'Unknown input at end'].	^node! !!RBParser methodsFor: 'accessing'!parseMethod: aString 	| node |	node := self parseMethod.	self atEnd ifFalse: [self parserError: 'Unknown input at end'].	node source: aString.	^node! !!RBParser methodsFor: 'accessing' stamp: 'bh 3/7/2000 01:40'!parseMethodWithNoComments: aString 	| node |	node := self parseMethodWithNoComments.	self atEnd ifFalse: [self parserError: 'Unknown input at end'].	node source: aString.	^ node! !!RBParser methodsFor: 'initialize-release' stamp: 'ls 1/30/2000 17:55'!initializeForSqueak	emptyStatements := true.	negatedNumbers := true.	scanner notNil ifTrue: [scanner initializeForSqueak]! !!RBParser methodsFor: 'initialize-release' stamp: 'md 10/11/2005 15:49'!scanner: aScanner 	scanner := aScanner.	tags := nil.	self initializeForSqueak.	self step! !!RBParser methodsFor: 'private-parsing'!parseArgs	| args |	args := OrderedCollection new.	[currentToken isIdentifier]		whileTrue: [args add: self parseVariableNode].	^args! !!RBParser methodsFor: 'private-parsing' stamp: 'ls 1/24/2000 00:11'!parseArray	"parse Squeak's {} construct"	| leftBrace node rightBrace |	leftBrace := currentToken start.	self step.	node := RBArrayNode new.	self parseStatementList: false  into: node.	(currentToken isSpecial and: [currentToken value == $}]) ifFalse: [		self parserError: 'expected }' ].	rightBrace := currentToken start.	self step.	node leftBrace: leftBrace.	node rightBrace: rightBrace.	^node! !!RBParser methodsFor: 'private-parsing'!parseAssignment	"Need one token lookahead to see if we have a ':='. This method could 	make it possible to assign the literals true, false and nil."	| node position |	(currentToken isIdentifier and: [self nextToken isAssignment]) 		ifFalse: [^self parseCascadeMessage].	node := self parseVariableNode.	position := currentToken start.	self step.	^RBAssignmentNode 		variable: node		value: self parseAssignment		position: position! !!RBParser methodsFor: 'private-parsing'!parseBinaryMessage	| node |	node := self parseUnaryMessage.		[currentToken isLiteral ifTrue: [self patchNegativeLiteral].	currentToken isBinary] 			whileTrue: [node := self parseBinaryMessageWith: node].	^node! !!RBParser methodsFor: 'private-parsing'!parseBinaryMessageWith: aNode 	| binaryToken |	binaryToken := currentToken.	self step.	^RBMessageNode 		receiver: aNode		selectorParts: (Array with: binaryToken)		arguments: (Array with: self parseUnaryMessage)! !!RBParser methodsFor: 'private-parsing'!parseBinaryPattern	| binaryToken |	currentToken isBinary 		ifFalse: [self parserError: 'Message pattern expected'].	binaryToken := currentToken.	self step.	^RBMethodNode selectorParts: (Array with: binaryToken)		arguments: (Array with: self parseVariableNode)! !!RBParser methodsFor: 'private-parsing'!parseBlock	| position node |	position := currentToken start.	self step.	node := self parseBlockArgsInto: RBBlockNode new.	node left: position.	node body: (self parseStatements: false).	(currentToken isSpecial and: [currentToken value == $]]) 		ifFalse: [self parserError: ''']'' expected'].	node right: currentToken start.	self step.	^node! !!RBParser methodsFor: 'private-parsing'!parseBlockArgsInto: node 	| verticalBar args colons |	args := OrderedCollection new: 2.	colons := OrderedCollection new: 2.	verticalBar := false.	[currentToken isSpecial and: [currentToken value == $:]] whileTrue: 			[colons add: currentToken start.			self step.	":"			verticalBar := true.			args add: self parseVariableNode].	verticalBar 		ifTrue: 			[currentToken isBinary 				ifTrue: 					[node bar: currentToken start.					currentToken value == #| 						ifTrue: [self step]						ifFalse: 							[currentToken value == #'||' 								ifTrue: 									["Hack the current token to be the start 									of temps bar"									currentToken										value: #|;										start: currentToken start + 1]								ifFalse: [self parserError: '''|'' expected']]]				ifFalse: 					[(currentToken isSpecial and: [currentToken value == $]]) 						ifFalse: [self parserError: '''|'' expected']]].	node		arguments: args;		colons: colons.	^node! !!RBParser methodsFor: 'private-parsing'!parseCascadeMessage	| node receiver messages semicolons |	node := self parseKeywordMessage.	(currentToken isSpecial 		and: [currentToken value == $; and: [node isMessage]]) ifFalse: [^node].	receiver := node receiver.	messages := OrderedCollection new: 3.	semicolons := OrderedCollection new: 3.	messages add: node.	[currentToken isSpecial and: [currentToken value == $;]] whileTrue: 			[semicolons add: currentToken start.			self step.			messages add: (currentToken isIdentifier 						ifTrue: [self parseUnaryMessageWith: receiver]						ifFalse: 							[currentToken isKeyword 								ifTrue: [self parseKeywordMessageWith: receiver]								ifFalse: 									[| temp |									currentToken isLiteral ifTrue: [self patchNegativeLiteral].									currentToken isBinary ifFalse: [self parserError: 'Message expected'].									temp := self parseBinaryMessageWith: receiver.									temp == receiver ifTrue: [self parserError: 'Message expected'].									temp]])].	^RBCascadeNode messages: messages semicolons: semicolons! !!RBParser methodsFor: 'private-parsing'!parseKeywordMessage	^self parseKeywordMessageWith: self parseBinaryMessage! !!RBParser methodsFor: 'private-parsing'!parseKeywordMessageWith: node 	| args isKeyword keywords |	args := OrderedCollection new: 3.	keywords := OrderedCollection new: 3.	isKeyword := false.	[currentToken isKeyword] whileTrue: 			[keywords add: currentToken.			self step.			args add: self parseBinaryMessage.			isKeyword := true].	^isKeyword 		ifTrue: 			[RBMessageNode 				receiver: node				selectorParts: keywords				arguments: args]		ifFalse: [node]! !!RBParser methodsFor: 'private-parsing'!parseKeywordPattern	| keywords args |	keywords := OrderedCollection new: 2.	args := OrderedCollection new: 2.	[currentToken isKeyword] whileTrue: 			[keywords add: currentToken.			self step.			args add: self parseVariableNode].	^RBMethodNode selectorParts: keywords arguments: args! !!RBParser methodsFor: 'private-parsing' stamp: 'ms 9/16/2006 20:43'!parseMessagePattern	^currentToken isIdentifier		ifTrue: [self parseUnaryPattern]		ifFalse: 			[currentToken isKeyword				ifTrue: [self parseKeywordPattern]				ifFalse: [self parseBinaryPattern]]! !!RBParser methodsFor: 'private-parsing'!parseMethod	| methodNode |	methodNode := self parseMessagePattern.	self parseResourceTag.	self addCommentsTo: methodNode.	methodNode body: (self parseStatements: true).	methodNode tags: tags.	^methodNode! !!RBParser methodsFor: 'private-parsing' stamp: 'bh 3/7/2000 01:36'!parseMethodWithNoComments	| methodNode |	methodNode := self parseMessagePattern.	self parseResourceTag.	"self addCommentsTo: methodNode."	methodNode body: (self parseStatements: true).	methodNode tags: tags.	^ methodNode! !!RBParser methodsFor: 'private-parsing' stamp: 'ls 1/30/2000 18:16'!parseNegatedNumber	| token |	(self nextToken isLiteral not or: [ self nextToken realValue isNumber not ])		ifTrue: [ self parserError: 'only numbers may be negated' ].	"create a new token out of the $- and the number"	token := RBLiteralToken value: (self nextToken realValue negated) start: currentToken start stop: nextToken stop.	self step.	self step.	^RBLiteralNode literalToken: token! !!RBParser methodsFor: 'private-parsing'!parseParenthesizedExpression	| leftParen node |	leftParen := currentToken start.	self step.	node := self parseAssignment.	^(currentToken isSpecial and: [currentToken value == $)])		ifTrue: 			[node addParenthesis: (leftParen to: currentToken start).			self step.			node]		ifFalse: [self parserError: ''')'' expected']! !!RBParser methodsFor: 'private-parsing'!parsePatternBlock	| position node |	position := currentToken start.	self step.	node := self parseBlockArgsInto: RBPatternBlockNode new.	node left: position.	node body: (self parseStatements: false).	(currentToken isSpecial and: [currentToken value == $}]) 		ifFalse: [self parserError: '''}'' expected'].	node right: currentToken start.	self step.	^node! !!RBParser methodsFor: 'private-parsing' stamp: 'cmm 4/10/2007 21:18'!parsePrimitiveIdentifier	| token |	token := currentToken.	self step.	^RBVariableNode identifierToken: token! !!RBParser methodsFor: 'private-parsing'!parsePrimitiveLiteral	| token |	token := currentToken.	self step.	^RBLiteralNode literalToken: token! !!RBParser methodsFor: 'private-parsing' stamp: 'pmm 9/24/2005 10:49'!parsePrimitiveObject	currentToken isIdentifier ifTrue: [^self parsePrimitiveIdentifier].	currentToken isLiteral ifTrue: [^self parsePrimitiveLiteral].	currentToken isSpecial ifTrue: 			[currentToken value == $[ ifTrue: [^self parseBlock].			currentToken value == $( ifTrue: [^self parseParenthesizedExpression].			currentToken value == ${ ifTrue: [^self parseArray]].	(negatedNumbers and: 		[ currentToken isBinary and:		[ currentToken value == #- ] ]) 	ifTrue:		[ ^self parseNegatedNumber ].	currentToken isPatternBlock ifTrue:[^self parsePatternBlock].	self parserError: 'Variable expected'! !!RBParser methodsFor: 'private-parsing'!parseResourceTag	| start |	[currentToken isBinary and: [currentToken value == #<]] whileTrue: 			[start := currentToken start.			self step.			[scanner atEnd or: [currentToken isBinary and: [currentToken value == #>]]] 				whileFalse: [self step].			(currentToken isBinary and: [currentToken value == #>]) 				ifFalse: [self parserError: '''>'' expected'].			tags isNil 				ifTrue: [tags := OrderedCollection with: (start to: currentToken stop)]				ifFalse: [tags add: (start to: currentToken stop)].			self step]! !!RBParser methodsFor: 'private-parsing' stamp: 'tween 6/29/2006 18:30'!parseStatementList: tagBoolean into: sequenceNode 	| statements return periods returnPosition node |	return := false.	statements := OrderedCollection new.	periods := OrderedCollection new.	self addCommentsTo: sequenceNode.	tagBoolean ifTrue: [self parseResourceTag].		["skip empty statements"		emptyStatements ifTrue: 			[[currentToken isSpecial and: [currentToken value == $.]] whileTrue: 					[periods add: currentToken start.					self step]].		"check if we are finished yet"	 	self atEnd 			or: [currentToken isSpecial and: ['])}' includes: currentToken value]]] 			whileFalse: 				[return ifTrue: [self parserError: 'End of statement list encounted'].				(currentToken isSpecial and: [currentToken value == $^]) 					ifTrue: 						[returnPosition := currentToken start.						self step.						node := RBReturnNode return: returnPosition value: self parseAssignment.						self addCommentsTo: node.						statements add: node.						return := true]					ifFalse: 						[node := self parseAssignment.						self addCommentsTo: node.						statements add: node].				(currentToken isSpecial and: [currentToken value == $.]) 					ifTrue: 						[periods add: currentToken start.						self step]					ifFalse: [return := true].				].	statements notEmpty ifTrue: [self addCommentsTo: statements last].	sequenceNode		statements: statements;		periods: periods.	^sequenceNode! !!RBParser methodsFor: 'private-parsing'!parseStatements: tagBoolean 	| args leftBar rightBar |	args := #().	leftBar := rightBar := nil.	currentToken isBinary 		ifTrue: 			[currentToken value == #| 				ifTrue: 					[leftBar := currentToken start.					self step.					args := self parseArgs.					(currentToken isBinary and: [currentToken value = #|]) 						ifFalse: [self parserError: '''|'' expected'].					rightBar := currentToken start.					self step]				ifFalse: 					[currentToken value == #'||' 						ifTrue: 							[rightBar := (leftBar := currentToken start) + 1.							self step]]].	^self parseStatementList: tagBoolean		into: (RBSequenceNode 				leftBar: leftBar				temporaries: args				rightBar: rightBar)! !!RBParser methodsFor: 'private-parsing' stamp: 'cmm 10/17/2007 16:56'!parseUnaryMessage	| node |	node := self parsePrimitiveObject.		[currentToken isLiteral ifTrue: [self patchLiteralMessage].	currentToken isIdentifier] 			whileTrue: [node := self parseUnaryMessageWith: node].	^node! !!RBParser methodsFor: 'private-parsing'!parseUnaryMessageWith: aNode 	| selector |	selector := currentToken.	self step.	^RBMessageNode 		receiver: aNode		selectorParts: (Array with: selector)		arguments: #()! !!RBParser methodsFor: 'private-parsing'!parseUnaryPattern	| selector |	selector := currentToken.	self step.	^RBMethodNode selectorParts: (Array with: selector) arguments: #()! !!RBParser methodsFor: 'private-parsing'!parseVariableNode	currentToken isIdentifier 		ifFalse: [self parserError: 'Variable name expected'].	^self parsePrimitiveIdentifier! !!RBParser commentStamp: 'md 8/9/2005 14:54' prior: 0!RBParser takes a source code string and generates an AST for it. This is a hand-written, recursive descent parser and has been optimized for speed. The simplest way to call this is either 'RBParser parseExpression: aString' if you want the AST for an expression, or 'RBParser parseMethod: aString' if you want to parse an entire method.Instance Variables:	currentToken	<RBToken>	The current token being processed.	emptyStatements	<Boolean>	True if empty statements are allowed. In IBM, they are, in VW they aren't.	errorBlock	<BlockClosure>	The block to evaluate on a syntax error.	nextToken	<RBToken>	The next token that will be processed. This allows one-token lookahead.	scanner	<RBScanner>	The scanner that generates a stream of tokens to parse.	source	<String>	The source code to parse	tags	<Collection of: Interval>	The source intervals of the tags appearing at the top of a method (e.g. Primitive calls)Shared Variables:	ParserType	<Symbol>	the type code we are parsing!!RBParser class methodsFor: 'accessing' stamp: 'md 7/17/2006 10:39'!format: textOrStream in: aClass notifying: aRequestor contentsSymbol: aSymbol	"Compile a parse tree from the argument, textOrStream. Answer a string containing the original code, formatted nicely.  If aBoolean is true, then decorate the resulting text with color and hypertext actions"	^self format: textOrStream asString in: aClass notifying: aRequestor decorated: (aSymbol == #colorPrint)! !!RBParser class methodsFor: 'accessing' stamp: 'nk 2/23/2005 18:28'!format: aString in: anIgnoredClass notifying: aRequester decorated: decorated 	| parser squeakString node errorBlock |	squeakString := aString asString withBlanksTrimmed.	squeakString isEmpty ifTrue: [ ^squeakString ].	errorBlock := [:message :position | self error: ('{1} at position {2}' format: { message. position}) ].	parser := self new.	parser errorBlock: errorBlock.	parser initializeParserWith: squeakString type: #on:errorBlock:.	node := parser parseMethod: squeakString.	^decorated 		ifTrue: [node colorizedFormattedCode]		ifFalse: [node formattedCode]! !!RBParser class methodsFor: 'accessing'!parseExpression: aString 	^self parseExpression: aString onError: nil! !!RBParser class methodsFor: 'accessing' stamp: 'dvf 11/8/2003 15:02'!parseExpression: aString onError: aBlock 	| node parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString type: #on:errorBlock:.	node := parser parseExpression.	^(node statements size == 1 and: [node temporaries isEmpty])		ifTrue: [node statements first]		ifFalse: [node]! !!RBParser class methodsFor: 'accessing'!parseMethod: aString 	^self parseMethod: aString onError: nil! !!RBParser class methodsFor: 'accessing' stamp: 'dvf 11/8/2003 04:44'!parseMethod: aString onError: aBlock 	| parser squeakString |	squeakString := aString .	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: squeakString type: #on:errorBlock:.	^parser parseMethod: squeakString! !!RBParser class methodsFor: 'accessing' stamp: 'bh 3/7/2000 01:35'!parseMethodWithNoComments: aString 	^ self parseMethodWithNoComments: aString onError: nil! !!RBParser class methodsFor: 'accessing' stamp: 'bh 3/7/2000 01:34'!parseMethodWithNoComments: aString onError: aBlock 	| parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString type: #on:errorBlock:.	^ parser parseMethodWithNoComments: aString! !!RBParser class methodsFor: 'accessing'!parseRewriteExpression: aString 	^self parseRewriteExpression: aString onError: nil! !!RBParser class methodsFor: 'accessing'!parseRewriteExpression: aString onError: aBlock 	| node parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString type: #rewriteOn:errorBlock:.	node := parser parseExpression.	^(node statements size == 1 and: [node temporaries isEmpty])		ifTrue: [node statements first]		ifFalse: [node]! !!RBParser class methodsFor: 'accessing'!parseRewriteMethod: aString 	^self parseRewriteMethod: aString onError: nil! !!RBParser class methodsFor: 'accessing'!parseRewriteMethod: aString onError: aBlock 	| parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString type: #rewriteOn:errorBlock:.	^parser parseMethod: aString! !!RBParser class methodsFor: 'parsing'!parseMethodPattern: aString 	| parser |	parser := self new.	parser errorBlock: [:error :position | ^nil].	parser initializeParserWith: aString type: #on:errorBlock:.	^parser parseMessagePattern selector! !!RBPatternBlockNode methodsFor: 'matching'!addArgumentWithNameBasedOn: aString 	| name index vars |	name := aString.	vars := self allDefinedVariables.	index := 0.	[vars includes: name] whileTrue: 			[index := index + 1.			name := name , index printString].	arguments := arguments copyWith: (RBVariableNode named: name)! !!RBPatternBlockNode methodsFor: 'matching'!copyInContext: aDictionary 	^self replacingBlock value: aDictionary! !!RBPatternBlockNode methodsFor: 'matching' stamp: 'nk 2/26/2005 11:05'!createBlock	| source |	source := self formattedCode.	^Compiler evaluate: source for: self logged: false! !!RBPatternBlockNode methodsFor: 'matching' stamp: 'pmm 7/12/2006 15:25'!createMatchingBlock	self arguments size > 2 		ifTrue: 			[self 				error: 'Search blocks can only contain arguments for the node and matching dictionary'].	self arguments isEmpty 		ifTrue: [self error: 'Search blocks must contain one argument for the node'].	self arguments size = 1 		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary'].	^self createBlock! !!RBPatternBlockNode methodsFor: 'matching' stamp: 'pmm 7/12/2006 15:25'!createReplacingBlock	self arguments size > 1 		ifTrue: 			[self 				error: 'Replace blocks can only contain an argument for the matching dictionary'].	self arguments isEmpty 		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary'].	^self createBlock! !!RBPatternBlockNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	^self matchingBlock value: aNode value: aDictionary! !!RBPatternBlockNode methodsFor: 'matching'!matchingBlock	^valueBlock isNil 		ifTrue: [valueBlock := self createMatchingBlock]		ifFalse: [valueBlock]! !!RBPatternBlockNode methodsFor: 'matching'!replacingBlock	^valueBlock isNil 		ifTrue: [valueBlock := self createReplacingBlock]		ifFalse: [valueBlock]! !!RBPatternBlockNode methodsFor: 'accessing'!sentMessages	^OrderedCollection new! !!RBPatternBlockNode commentStamp: 'md 8/9/2005 14:56' prior: 0!RBPatternBlockNode is the node in matching parse trees (it never occurs in normal Smalltalk code) that executes a block to determine if a match occurs. valueBlock takes two arguments, the first is the actual node that we are trying to match against, and second node is the dictionary that contains all the metavariable bindings that the matcher has made thus far.Instance Variables:	valueBlock	<BlockClosure>	The block to execute when attempting to match this to a node.!!RBPatternBlockToken methodsFor: 'testing'!isPatternBlock	^true! !!RBPatternBlockToken commentStamp: 'md 8/9/2005 14:52' prior: 0!RBPatternBlockToken is the first-class representation of the pattern block token.!!RBPatternMessageNode methodsFor: 'matching'!copyInContext: aDictionary 	| selectors |	self isList ifTrue: [^aDictionary at: self].	selectors := self isSelectorList 				ifTrue: [(aDictionary at: selectorParts first value) keywords]				ifFalse: [selectorParts collect: [:each | aDictionary at: each value]].	^(RBMessageNode new)		receiver: (receiver copyInContext: aDictionary);		selectorParts: (selectors collect: 						[:each | 						(each last == $: ifTrue: [RBKeywordToken] ifFalse: [RBIdentifierToken]) 							value: each							start: nil]);		arguments: (self copyList: arguments inContext: aDictionary);		yourself! !!RBPatternMessageNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	aNode class == self matchingClass ifFalse: [^false].	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].	self isSelectorList ifTrue: 			[^(aDictionary at: selectorParts first value ifAbsentPut: [aNode selector])				== aNode selector and: 						[(aDictionary at: arguments first ifAbsentPut: [aNode arguments])							= aNode arguments]].	^self matchArgumentsAgainst: aNode inContext: aDictionary! !!RBPatternMessageNode methodsFor: 'matching' stamp: 'pmm 7/12/2006 15:44'!matchArgumentsAgainst: aNode inContext: aDictionary 	self arguments size == aNode arguments size ifFalse: [^false].	(self matchSelectorAgainst: aNode inContext: aDictionary) 		ifFalse: [^false].	self arguments with: aNode arguments do: [ :first :second |		(first match: second inContext: aDictionary)			ifFalse: [^false]].	^true! !!RBPatternMessageNode methodsFor: 'matching'!matchSelectorAgainst: aNode inContext: aDictionary 	| keyword |	1 to: selectorParts size		do: 			[:i | 			keyword := selectorParts at: i.			(aDictionary at: keyword value				ifAbsentPut: 					[keyword isPatternVariable 						ifTrue: [(aNode selectorParts at: i) value]						ifFalse: [keyword value]]) 					= (aNode selectorParts at: i) value ifFalse: [^false]].	^true! !!RBPatternMessageNode methodsFor: 'testing-matching'!isList	^isCascadeList and: [parent notNil and: [parent isCascade]]! !!RBPatternMessageNode methodsFor: 'testing-matching'!isPatternNode	^true! !!RBPatternMessageNode methodsFor: 'testing-matching'!isSelectorList	^isList! !!RBPatternMessageNode methodsFor: 'private'!matchingClass	^RBMessageNode! !!RBPatternMessageNode methodsFor: 'initialize-release'!receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 	| message |	super 		receiver: aValueNode		selectorParts: keywordTokens		arguments: valueNodes.	isCascadeList := isList := false.	message := keywordTokens first value.	2 to: message size		do: 			[:i | 			| character |			character := message at: i.			character == self listCharacter 				ifTrue: [isList := true]				ifFalse: 					[character == self cascadeListCharacter 						ifTrue: [isCascadeList := true]						ifFalse: [^self]]]! !!RBPatternMessageNode methodsFor: 'accessing'!sentMessages	^(super sentMessages)		remove: self selector ifAbsent: [];		yourself! !!RBPatternMessageNode commentStamp: 'md 8/9/2005 14:58' prior: 0!RBPatternMessageNode is a RBMessageNode that will match other message nodes without their selectors being equal. Instance Variables:	isCascadeList	<Boolean>	are we matching a list of message nodes in a cascaded message	isList	<Boolean>	are we matching each keyword or matching all keywords together (e.g., `keyword1: would match a one argument method whereas `@keywords: would match 0 or more arguments)!!RBPatternMethodNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:32'!basicLastToken	self arguments ifEmpty: [^self selectorParts last] ifNotEmpty: [ ^self arguments last token]! !!RBPatternMethodNode methodsFor: 'matching'!copyInContext: aDictionary 	| selectors |	selectors := self isSelectorList 				ifTrue: [(aDictionary at: selectorParts first value) keywords]				ifFalse: [selectorParts collect: [:each | aDictionary at: each value]].	^(RBMethodNode new)		selectorParts: (selectors collect: 						[:each | 						(each last == $: ifTrue: [RBKeywordToken] ifFalse: [RBIdentifierToken]) 							value: each							start: nil]);		arguments: (self copyList: arguments inContext: aDictionary);		body: (body copyInContext: aDictionary);		source: (aDictionary at: '-source-');		yourself! !!RBPatternMethodNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	aNode class == self matchingClass ifFalse: [^false].	aDictionary at: '-source-' put: aNode source.	self isSelectorList ifTrue: 			[^(aDictionary at: selectorParts first value ifAbsentPut: [aNode selector])				= aNode selector and: 						[(aDictionary at: arguments first ifAbsentPut: [aNode arguments])							= aNode arguments and: [body match: aNode body inContext: aDictionary]]].	^(self matchArgumentsAgainst: aNode inContext: aDictionary)		and: [body match: aNode body inContext: aDictionary]! !!RBPatternMethodNode methodsFor: 'matching' stamp: 'pmm 7/12/2006 15:45'!matchArgumentsAgainst: aNode inContext: aDictionary 	self arguments size == aNode arguments size ifFalse: [^false].	(self matchSelectorAgainst: aNode inContext: aDictionary) 		ifFalse: [^false].	self arguments with: aNode arguments do: [ :first :second |		(first match: second inContext: aDictionary)			ifFalse: [^false]].	^true! !!RBPatternMethodNode methodsFor: 'matching'!matchSelectorAgainst: aNode inContext: aDictionary 	| keyword |	1 to: selectorParts size		do: 			[:i | 			keyword := selectorParts at: i.			(aDictionary at: keyword value				ifAbsentPut: 					[keyword isPatternVariable 						ifTrue: [(aNode selectorParts at: i) value]						ifFalse: [keyword value]]) 					= (aNode selectorParts at: i) value ifFalse: [^false]].	^true! !!RBPatternMethodNode methodsFor: 'testing-matching'!isPatternNode	^true! !!RBPatternMethodNode methodsFor: 'testing'!isSelectorList	^isList! !!RBPatternMethodNode methodsFor: 'private'!matchingClass	^RBMethodNode! !!RBPatternMethodNode methodsFor: 'initialize-release'!selectorParts: tokenCollection arguments: variableNodes 	super selectorParts: tokenCollection arguments: variableNodes.	isList := (tokenCollection first value at: 2) == self listCharacter! !!RBPatternMethodNode commentStamp: 'md 8/9/2005 14:59' prior: 0!RBPatternMethodNode is a RBMethodNode that will match other method nodes without their selectors being equal. Instance Variables:	isList	<Boolean>	are we matching each keyword or matching all keywords together (e.g., `keyword1: would match a one argument method whereas `@keywords: would match 0 or more arguments)!!RBPatternVariableNode methodsFor: 'matching'!copyInContext: aDictionary 	^aDictionary at: self! !!RBPatternVariableNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	self isAnything ifTrue: [^(aDictionary at: self ifAbsentPut: [aNode]) = aNode].	self isLiteral ifTrue: [^self matchLiteral: aNode inContext: aDictionary].	self isStatement		ifTrue: [^self matchStatement: aNode inContext: aDictionary].	aNode class == self matchingClass ifFalse: [^false].	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode! !!RBPatternVariableNode methodsFor: 'matching'!matchLiteral: aNode inContext: aDictionary 	^aNode class == RBLiteralNode 		and: [(aDictionary at: self ifAbsentPut: [aNode]) = aNode]! !!RBPatternVariableNode methodsFor: 'matching'!matchStatement: aNode inContext: aDictionary 	(aNode parent notNil and: [aNode parent isSequence]) ifFalse: [^false].	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode! !!RBPatternVariableNode methodsFor: 'initialize-release'!identifierToken: anIdentifierToken 	super identifierToken: anIdentifierToken.	self initializePatternVariables! !!RBPatternVariableNode methodsFor: 'initialize-release'!initializePatternVariables	| name |	name := self name.	isAnything := isList := isLiteral := isStatement := recurseInto := false.	2 to: name size		do: 			[:i | 			| character |			character := name at: i.			character == self listCharacter 				ifTrue: [isAnything := isList := true]				ifFalse: 					[character == self literalCharacter 						ifTrue: [isLiteral := true]						ifFalse: 							[character == self statementCharacter 								ifTrue: [isStatement := true]								ifFalse: 									[character == self recurseIntoCharacter 										ifTrue: [recurseInto := true]										ifFalse: [^self]]]]]! !!RBPatternVariableNode methodsFor: 'testing-matching'!isAnything	^isAnything! !!RBPatternVariableNode methodsFor: 'testing-matching'!isList	^isList! !!RBPatternVariableNode methodsFor: 'testing-matching'!isLiteral	^isLiteral! !!RBPatternVariableNode methodsFor: 'testing-matching'!isPatternNode	^true! !!RBPatternVariableNode methodsFor: 'testing-matching'!isStatement	^isStatement! !!RBPatternVariableNode methodsFor: 'testing-matching'!recurseInto	^recurseInto! !!RBPatternVariableNode methodsFor: 'private'!matchingClass	^RBVariableNode! !!RBPatternVariableNode methodsFor: 'accessing'!parent: aBRProgramNode 	"Fix the case where '``@node' should match a single node, not a sequence node."	super parent: aBRProgramNode.	parent isSequence 		ifTrue: 			[(self isStatement or: [parent temporaries includes: self]) 				ifFalse: [isList := false]]! !!RBPatternVariableNode commentStamp: 'md 8/9/2005 14:59' prior: 0!RBPatternVariableNode is an AST node that is used to match several other types of nodes (literals, variables, value nodes, statement nodes, and sequences of statement nodes).The different types of matches are determined by the name of the node. If the name contains a # character, then it will match a literal. If it contains, a . then it matches statements. If it contains no extra characters, then it matches only variables. These options are mutually exclusive.The @ character can be combined with the name to match lists of items. If combined with the . character, then it will match a list of statement nodes (0 or more). If used without the . or # character, then it matches anything except for list of statements. Combining the @ with the # is not supported.Adding another ` in the name will cause the search/replace to look for more matches inside the node that this node matched. This option should not be used for top level expressions since that would cause infinite recursion (e.g., searching only for "``@anything").Instance Variables:	isAnything	<Boolean>	can we match any type of node	isList	<Boolean>	can we match a list of items (@)	isLiteral	<Boolean>	only match a literal node (#)	isStatement	<Boolean>	only match statements (.)	recurseInto	<Boolean>	search for more matches in the node we match (`)!!RBPragmaNode methodsFor: 'visitor' stamp: 'ms 9/4/2006 00:06'!acceptVisitor: aProgramNodeVisitor		^aProgramNodeVisitor acceptPragmaNode: self! !!RBPragmaNode methodsFor: 'testing' stamp: 'pmm 10/4/2006 14:23'!isPrimitive		^#( primitive: primitive:module: )  includes: self pragma keyword! !!RBPragmaNode methodsFor: 'accessing' stamp: 'pmm 10/4/2006 14:12'!method	^self parent! !!RBPragmaNode methodsFor: 'accessing' stamp: 'ms 9/2/2006 18:30'!pragma		^pragma! !!RBPragmaNode methodsFor: 'accessing' stamp: 'ms 9/17/2006 01:50'!pragma: aPragma spec: aSpec start: startPosition stop: stopPosition		pragma := aPragma.	spec := aSpec.	start := startPosition.	stop := stopPosition! !!RBPragmaNode methodsFor: 'accessing' stamp: 'md 4/6/2007 20:15'!pragma: aPragma spec: aSpec start: startPosition stop: stopPosition firstToken: fToken lastToken: lToken		pragma := aPragma.	spec := aSpec.	start := startPosition.	stop := stopPosition.	self firstToken: fToken.	self lastToken: lToken! !!RBPragmaNode methodsFor: 'accessing' stamp: 'pmm 10/4/2006 14:24'!primitive	^self isPrimitive		 ifTrue:[ PrimitiveNode new			num: self primitiveNumber;			spec: self spec;			yourself]		 ifFalse:[ PrimitiveNode null ]	! !!RBPragmaNode methodsFor: 'accessing' stamp: 'ms 9/3/2006 23:36'!primitiveNumber		^primitiveNumber ifNil:[primitiveNumber := 0]! !!RBPragmaNode methodsFor: 'accessing' stamp: 'ms 9/2/2006 18:42'!primitiveNumber: aNum		primitiveNumber := aNum! !!RBPragmaNode methodsFor: 'accessing' stamp: 'ms 9/2/2006 18:31'!spec		^spec! !!RBPragmaNode methodsFor: 'accessing' stamp: 'ms 9/2/2006 18:43'!start		^start! !!RBPragmaNode methodsFor: 'accessing' stamp: 'ms 9/2/2006 18:43'!stop		^stop! !!RBPragmaNode class methodsFor: 'instance creation' stamp: 'ms 9/17/2006 01:50'!pragma: aPragma spec: aSpec start: startPosition stop: stopPosition	^self new pragma: aPragma spec: aSpec start: startPosition stop: stopPosition! !!RBPragmaNode class methodsFor: 'instance creation' stamp: 'ms 9/17/2006 01:41'!pragma: aPragma spec: aSpec start: startPosition stop: stopPosition firstToken: fToken lastToken: lToken	^self new pragma: aPragma spec: aSpec start: startPosition stop: stopPosition firstToken: fToken lastToken: lToken	! !!RBPragmaNodeTest methodsFor: 'method - tested' stamp: 'ms 3/31/2007 20:51'!expectedFailures	Smalltalk at: #SqueakParser ifAbsent:[^#(#testFirstLastToken #testPosition)].	^#()! !!RBPragmaNodeTest methodsFor: 'testing' stamp: 'ms 3/31/2007 17:28'!testFirstLastToken	| aMethodNode |	aMethodNode := (self defaultParser parseMethod: 'test <hello: true>') pragmas first.	self assert: (aMethodNode firstToken value = '<').	self assert: (aMethodNode lastToken value = '>').		aMethodNode := (self defaultParser parseMethod: 'test <primitive: 4> <hello: true>') pragmas second.	self assert: (aMethodNode firstToken value = '<').	self assert: (aMethodNode lastToken value = '>').! !!RBPragmaNodeTest methodsFor: 'testing' stamp: 'ms 3/31/2007 17:27'!testPosition	| aMethodNode |	aMethodNode := (self defaultParser parseMethod: 'test <hello: true>') pragmas first.	self assertPosition: aMethodNode start: 6 stop: 18.		aMethodNode := (self defaultParser parseMethod: 'test <primitive: 4> <hello: true>') pragmas second.	self assertPosition: aMethodNode start: 21 stop: 33.! !!RBProgramNode methodsFor: 'visitor' stamp: 'rr 4/10/2004 16:54'!acceptVisitor: aProgramNodeVisitor 	"self subclassResponsibility"! !!RBProgramNode methodsFor: 'replacing' stamp: 'ajh 3/13/2003 16:09'!adjustPositionsAfter: sourcePos by: delta	"Slide token positions after sourcePos by delta"	self children do: [:node |		node adjustPositionsAfter: sourcePos by: delta]! !!RBProgramNode methodsFor: 'replacing'!removeDeadCode	self children do: [:each | each removeDeadCode]! !!RBProgramNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	self error: 'I don''t store other nodes'! !!RBProgramNode methodsFor: 'replacing'!replaceWith: aNode 	parent isNil ifTrue: [self error: 'This node doesn''t have a parent'].	parent replaceNode: self withNode: aNode! !!RBProgramNode methodsFor: 'accessing'!allArgumentVariables	| children |	children := self children.	children isEmpty ifTrue: [^#()].	^children inject: OrderedCollection new		into: 			[:vars :each | 			vars				addAll: each allArgumentVariables;				yourself]! !!RBProgramNode methodsFor: 'accessing'!allDefinedVariables	| children |	children := self children.	children isEmpty ifTrue: [^#()].	^children inject: OrderedCollection new		into: 			[:vars :each | 			vars addAll: each allDefinedVariables;				yourself]! !!RBProgramNode methodsFor: 'accessing'!allTemporaryVariables	| children |	children := self children.	children isEmpty ifTrue: [^#()].	^children inject: OrderedCollection new		into: 			[:vars :each | 			vars				addAll: each allTemporaryVariables;				yourself]! !!RBProgramNode methodsFor: 'accessing'!asReturn	"Change the current node to a return node."	parent isNil ifTrue: [self error: 'Cannot change to a return without a parent node.'].	parent isSequence ifFalse: [self error: 'Parent node must be a sequence node.'].	(parent isLast: self)		ifFalse: [self error: 'Return node must be last.'].	^parent addReturn! !!RBProgramNode methodsFor: 'accessing'!blockVariables	^parent isNil		ifTrue: [#()]		ifFalse: [parent blockVariables]! !!RBProgramNode methodsFor: 'accessing'!children	^#()! !!RBProgramNode methodsFor: 'accessing' stamp: 'nk 1/29/2005 10:24'!colorFormatterClass	^self class colorFormatterClass! !!RBProgramNode methodsFor: 'accessing' stamp: 'nk 1/29/2005 10:23'!colorizedFormattedCode	^self colorFormatterClass new format: self! !!RBProgramNode methodsFor: 'accessing' stamp: 'md 4/6/2007 20:02'!comment		^ self comments isEmpty		ifTrue: [nil]		ifFalse: [self comments first]! !!RBProgramNode methodsFor: 'accessing' stamp: 'ms 4/7/2007 02:59'!comments	^self propertyAt: #comments ifAbsentPut: [OrderedCollection new].! !!RBProgramNode methodsFor: 'accessing' stamp: 'md 4/6/2007 22:50'!comments: aCollection	aCollection isNil ifTrue: [^self removeProperty: #comments ifAbsent:[]].	self propertyAt: #comments put: aCollection. ! !!RBProgramNode methodsFor: 'accessing' stamp: 'ajh 3/15/2003 15:17'!debugHighlightStart	^ self start! !!RBProgramNode methodsFor: 'accessing' stamp: 'ajh 3/15/2003 15:18'!debugHighlightStop	^ self stop! !!RBProgramNode methodsFor: 'accessing'!formattedCode	^self formatterClass new format: self! !!RBProgramNode methodsFor: 'accessing'!formatterClass	^self class formatterClass! !!RBProgramNode methodsFor: 'accessing'!parent	^parent! !!RBProgramNode methodsFor: 'accessing'!parent: anObject	parent := anObject! !!RBProgramNode methodsFor: 'accessing'!precedence	^6! !!RBProgramNode methodsFor: 'accessing'!sentMessages	| messages |	messages := Set new.	self children do: [:each | messages addAll: each sentMessages].	^messages! !!RBProgramNode methodsFor: 'accessing' stamp: 'ms 6/17/2007 02:45'!sequenceDefinedIn	^ self parent sequenceDefinedIn! !!RBProgramNode methodsFor: 'accessing'!source	^parent notNil ifTrue: [parent source] ifFalse: [nil]! !!RBProgramNode methodsFor: 'accessing'!sourceInterval	^self start to: self stop! !!RBProgramNode methodsFor: 'accessing'!start	self subclassResponsibility! !!RBProgramNode methodsFor: 'accessing'!stop	self subclassResponsibility! !!RBProgramNode methodsFor: 'accessing'!temporaryVariables	^parent isNil		ifTrue: [#()]		ifFalse: [parent temporaryVariables]! !!RBProgramNode methodsFor: 'iterating' stamp: 'bh 3/13/2000 01:48'!allChildren	^self children inject:(OrderedCollection new addAll:self children; yourself) into:[:answer :child| answer addAll:child allChildren; yourself].! !!RBProgramNode methodsFor: 'iterating'!nodesDo: aBlock 	aBlock value: self.	self children do: [:each | each nodesDo: aBlock]! !!RBProgramNode methodsFor: 'testing' stamp: 'pmm 7/12/2006 15:20'!assigns: aVariableName 	^self children anySatisfy: [:each | each assigns: aVariableName]! !!RBProgramNode methodsFor: 'testing'!containedBy: anInterval 	^anInterval first <= self start and: [anInterval last >= self stop]! !!RBProgramNode methodsFor: 'testing' stamp: 'pmm 7/12/2006 15:21'!containsReturn	^self children anySatisfy: [:each | each containsReturn]! !!RBProgramNode methodsFor: 'testing'!defines: aName	^false! !!RBProgramNode methodsFor: 'testing'!directlyUses: aNode	^true! !!RBProgramNode methodsFor: 'testing'!evaluatedFirst: aNode 	self children do: 			[:each | 			each == aNode ifTrue: [^true].			each isImmediate ifFalse: [^false]].	^false! !!RBProgramNode methodsFor: 'testing' stamp: 'pmm 9/24/2005 10:53'!hasParent	^self parent notNil! !!RBProgramNode methodsFor: 'testing'!intersectsInterval: anInterval 	^(anInterval first between: self start and: self stop) 		or: [self start between: anInterval first and: anInterval last]! !!RBProgramNode methodsFor: 'testing' stamp: 'ajh 2/25/2003 14:34'!isArray	^false! !!RBProgramNode methodsFor: 'testing'!isAssignment	^false! !!RBProgramNode methodsFor: 'testing'!isBlock	^false! !!RBProgramNode methodsFor: 'testing'!isCascade	^false! !!RBProgramNode methodsFor: 'testing'!isDirectlyUsed	"This node is directly used as an argument, receiver, or part of an assignment."	^parent isNil		ifTrue: [false]		ifFalse: [parent directlyUses: self]! !!RBProgramNode methodsFor: 'testing' stamp: 'ajh 6/29/2004 14:12'!isDoIt	^ false! !!RBProgramNode methodsFor: 'testing'!isEvaluatedFirst	"Return true if we are the first thing evaluated in this statement."	^parent isNil or: [parent isSequence or: [parent evaluatedFirst: self]]! !!RBProgramNode methodsFor: 'testing'!isImmediate	^false! !!RBProgramNode methodsFor: 'testing'!isLast: aNode 	| children |	children := self children.	^children isEmpty not and: [children last == aNode]! !!RBProgramNode methodsFor: 'testing'!isLiteral	^false! !!RBProgramNode methodsFor: 'testing' stamp: 'ajh 3/3/2003 22:28'!isLiteral: valueTestBlock	^false! !!RBProgramNode methodsFor: 'testing'!isMessage	^false! !!RBProgramNode methodsFor: 'testing'!isMethod	^false! !!RBProgramNode methodsFor: 'testing'!isReturn	^false! !!RBProgramNode methodsFor: 'testing'!isSequence	^false! !!RBProgramNode methodsFor: 'testing' stamp: 'ms 8/6/2007 08:08'!isTemp	^false! !!RBProgramNode methodsFor: 'testing'!isUsed	"Answer true if this node could be used as part of another expression. For example, you could use the 	result of this node as a receiver of a message, an argument, the right part of an assignment, or the 	return value of a block. This differs from isDirectlyUsed in that it is conservative since it also includes 	return values of blocks."	^parent isNil		ifTrue: [false]		ifFalse: [parent uses: self]! !!RBProgramNode methodsFor: 'testing'!isValue	^false! !!RBProgramNode methodsFor: 'testing'!isVariable	^false! !!RBProgramNode methodsFor: 'testing'!lastIsReturn	^self isReturn! !!RBProgramNode methodsFor: 'testing' stamp: 'pmm 7/12/2006 15:21'!references: aVariableName 	^self children anySatisfy: [:each | each references: aVariableName]! !!RBProgramNode methodsFor: 'testing'!uses: aNode	^true! !!RBProgramNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:28'!basicFirstToken	^self subclassResponsibility! !!RBProgramNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:29'!basicLastToken	^self subclassResponsibility! !!RBProgramNode methodsFor: 'accessing-token' stamp: 'md 4/6/2007 20:14'!firstToken	^self propertyAt: #firstToken ifAbsent: [self basicFirstToken].! !!RBProgramNode methodsFor: 'accessing-token' stamp: 'md 4/6/2007 20:14'!firstToken: aToken	self propertyAt: #firstToken put: aToken.! !!RBProgramNode methodsFor: 'accessing-token' stamp: 'md 4/6/2007 20:14'!lastToken	^self propertyAt: #lastToken ifAbsent: [self basicLastToken].! !!RBProgramNode methodsFor: 'accessing-token' stamp: 'md 4/6/2007 20:14'!lastToken: aToken	self propertyAt: #lastToken put: aToken.! !!RBProgramNode methodsFor: 'querying'!bestNodeFor: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	selectedChildren := self children 				select: [:each | each intersectsInterval: anInterval].	^selectedChildren size == 1 		ifTrue: [selectedChildren first bestNodeFor: anInterval]		ifFalse: [self]! !!RBProgramNode methodsFor: 'querying' stamp: 'nk 2/24/2005 14:28'!methodNode	(parent isNil or: [self isMethod]) ifTrue: [^self].	^parent methodNode! !!RBProgramNode methodsFor: 'querying' stamp: 'ajh 2/27/2003 22:40'!root	^ parent		ifNil: [self]		ifNotNil: [parent root]! !!RBProgramNode methodsFor: 'querying'!selfMessages	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'self `@msg: ``@args'		do: 			[:aNode :answer | 			answer				add: aNode selector;				yourself].	^searcher executeTree: self initialAnswer: Set new! !!RBProgramNode methodsFor: 'querying'!statementNode	"Return your topmost node that is contained by a sequence node."	(parent isNil or: [parent isSequence]) ifTrue: [^self].	^parent statementNode! !!RBProgramNode methodsFor: 'querying'!superMessages	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'super `@msg: ``@args'		do: 			[:aNode :answer | 			answer				add: aNode selector;				yourself].	^searcher executeTree: self initialAnswer: Set new! !!RBProgramNode methodsFor: 'querying'!whichNodeIsContainedBy: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	selectedChildren := self children 				select: [:each | each intersectsInterval: anInterval].	^selectedChildren size == 1 		ifTrue: [selectedChildren first whichNodeIsContainedBy: anInterval]		ifFalse: [nil]! !!RBProgramNode methodsFor: 'querying'!whoDefines: aName 	^(self defines: aName)		ifTrue: [self]		ifFalse: [parent notNil				ifTrue: [parent whoDefines: aName]				ifFalse: [nil]]! !!RBProgramNode methodsFor: 'testing-matching' stamp: 'pmm 7/12/2006 16:06'!canMatchMethod: aCompiledMethod 	^self sentMessages allSatisfy: [:each | 		(self class optimizedSelectors includes: each) 			or: [aCompiledMethod refersToLiteral: each]].! !!RBProgramNode methodsFor: 'testing-matching'!isList	^false! !!RBProgramNode methodsFor: 'testing-matching'!isPatternNode	^false! !!RBProgramNode methodsFor: 'testing-matching'!recurseInto	^false! !!RBProgramNode methodsFor: 'meta variable-accessing'!cascadeListCharacter	^$;! !!RBProgramNode methodsFor: 'meta variable-accessing'!listCharacter	^$@! !!RBProgramNode methodsFor: 'meta variable-accessing'!literalCharacter	^$#! !!RBProgramNode methodsFor: 'meta variable-accessing'!recurseIntoCharacter	^$`! !!RBProgramNode methodsFor: 'meta variable-accessing'!statementCharacter	^$.! !!RBProgramNode methodsFor: 'enumeration'!collect: aBlock 	"Hacked to fit collection protocols"	^aBlock value: self! !!RBProgramNode methodsFor: 'enumeration'!do: aBlock 	"Hacked to fit collection protocols"	aBlock value: self! !!RBProgramNode methodsFor: 'enumeration'!size	"Hacked to fit collection protocols"	^1! !!RBProgramNode methodsFor: 'copying'!copyCommentsFrom: aNode 	"Add all comments from aNode to us. If we already have the comment, then don't add it."	| newComments |	newComments := OrderedCollection new.	aNode nodesDo: [:each | newComments addAll: each comments].	self nodesDo: 			[:each | 			each comments do: [:comment | newComments remove: comment ifAbsent: []]].	newComments isEmpty ifTrue: [^self].	newComments := newComments asSortedCollection: [:a :b | a first < b first].	self comments: newComments! !!RBProgramNode methodsFor: 'matching'!copyInContext: aDictionary	^self copy! !!RBProgramNode methodsFor: 'matching'!copyList: matchNodes inContext: aDictionary 	| newNodes |	newNodes := OrderedCollection new.	matchNodes do: 			[:each | 			| object |			object := each copyInContext: aDictionary.			newNodes addAll: object].	^newNodes! !!RBProgramNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	^self = aNode! !!RBProgramNode methodsFor: 'matching'!matchList: matchNodes against: programNodes inContext: aDictionary 	^self		matchList: matchNodes		index: 1		against: programNodes		index: 1		inContext: aDictionary! !!RBProgramNode methodsFor: 'matching'!matchList: matchNodes index: matchIndex against: programNodes index: programIndex inContext: aDictionary 	| node currentIndex currentDictionary nodes |	matchNodes size < matchIndex ifTrue: [^programNodes size < programIndex].	node := matchNodes at: matchIndex.	node isList 		ifTrue: 			[currentIndex := programIndex - 1.						[currentDictionary := aDictionary copy.			programNodes size < currentIndex or: 					[nodes := programNodes copyFrom: programIndex to: currentIndex.					(currentDictionary at: node ifAbsentPut: [nodes]) = nodes and: 							[(self 								matchList: matchNodes								index: matchIndex + 1								against: programNodes								index: currentIndex + 1								inContext: currentDictionary) 									ifTrue: 										[currentDictionary keysAndValuesDo: [:key :value | aDictionary at: key put: value].										^true].							false]]] 					whileFalse: [currentIndex := currentIndex + 1].			^false].	programNodes size < programIndex ifTrue: [^false].	(node match: (programNodes at: programIndex) inContext: aDictionary) 		ifFalse: [^false].	^self 		matchList: matchNodes		index: matchIndex + 1		against: programNodes		index: programIndex + 1		inContext: aDictionary! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/15/2003 14:57'!decompileString	^ self formattedCode! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/4/2003 00:50'!isCaseBranch	^ false! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/2/2003 23:22'!isDup	^ false! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/2/2003 23:22'!isGoto	^ false! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/1/2003 20:12'!isIf	^ false! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/2/2003 23:22'!isLabel	^ false! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/2/2003 23:22'!isPop	^ false! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/3/2003 18:42'!isPseudo	^ false! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/23/2003 22:23'!isPseudoSend	^ false! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ms 7/12/2007 13:19'!isSend	^ false! !!RBProgramNode methodsFor: 'comparing'!equalTo: aNode exceptForVariables: variableNameCollection 	| dictionary |	dictionary := Dictionary new.	(self equalTo: aNode withMapping: dictionary) ifFalse: [^false].	dictionary keysAndValuesDo: 			[:key :value | 			(key = value or: [variableNameCollection includes: key]) ifFalse: [^false]].	^true! !!RBProgramNode methodsFor: 'comparing'!equalTo: aNode withMapping: aDictionary 	^self = aNode! !!RBProgramNode methodsFor: 'properties' stamp: 'md 4/1/2007 13:35'!hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ].! !!RBProgramNode methodsFor: 'properties' stamp: 'md 3/29/2007 14:48'!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ].! !!RBProgramNode methodsFor: 'properties' stamp: 'md 4/1/2007 13:36'!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		properties isNil ifTrue: [ ^ aBlock value ].	^ properties at: aKey ifAbsent: aBlock.! !!RBProgramNode methodsFor: 'properties' stamp: 'md 3/29/2007 14:48'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ].! !!RBProgramNode methodsFor: 'properties' stamp: 'md 4/7/2007 12:39'!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	properties ifNil: [ properties :=  RBSmallIdentityDictionary new: 1].	^ properties at: aKey put: anObject! !!RBProgramNode methodsFor: 'properties' stamp: 'md 3/29/2007 14:51'!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ].! !!RBProgramNode methodsFor: 'properties' stamp: 'md 4/1/2007 13:36'!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer.! !!RBProgramNode methodsFor: 'inline' stamp: 'ajh 2/25/2003 19:48'!isInline	^ false! !!RBProgramNode methodsFor: 'semantics' stamp: 'ajh 6/30/2004 14:08'!owningBlock	^ parent owningBlock! !!RBProgramNode methodsFor: 'semantics' stamp: 'ajh 3/13/2003 04:19'!owningScope	^ parent owningScope! !!RBProgramNode methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: self formattedCode;		nextPut: $)! !!RBProgramNode methodsFor: 'printing' stamp: 'md 7/28/2006 15:25'!shortPrintOn: aStream 		aStream nextPutAll: self formattedCode.! !!RBProgramNode methodsFor: '*newcompiler-decorating' stamp: 'ms 10/27/2006 14:38'!addComment	"add comment on the tree"	ASTCommenter new		visitNode: self! !!RBProgramNode methodsFor: '*newcompiler-decorating' stamp: 'md 4/6/2007 19:55'!afterComment	^ self propertyAt: #afterComment ifAbsent: [nil]! !!RBProgramNode methodsFor: '*newcompiler-decorating' stamp: 'md 4/6/2007 19:56'!afterComment: aString	aString ifNil: [^self removeProperty: #afterComment ifAbsent: []].	self propertyAt: #afterComment put: aString.! !!RBProgramNode methodsFor: '*newcompiler-decorating' stamp: 'md 4/6/2007 19:57'!beforeComment	^ self propertyAt: #beforeComment ifAbsent: [nil]! !!RBProgramNode methodsFor: '*newcompiler-decorating' stamp: 'md 4/6/2007 19:58'!beforeComment: anOrderedCollection	anOrderedCollection ifNil: [^self removeProperty: #beforeComment ifAbsent: []].	self propertyAt: #beforeComment put: anOrderedCollection.! !!RBProgramNode methodsFor: '*newcompiler-decorating' stamp: 'md 4/6/2007 19:58'!insideComment	^ self propertyAt: #insideComment ifAbsent: [nil]! !!RBProgramNode methodsFor: '*newcompiler-decorating' stamp: 'md 4/6/2007 19:58'!insideComment: aCollection	aCollection ifNil: [^self removeProperty: #insideComment ifAbsent: []].	self propertyAt: #insideComment put: aCollection.! !!RBProgramNode methodsFor: '*newcompiler-decorating' stamp: 'ms 5/28/2007 11:35'!peekAfterComment		| tokenStream token |	self afterComment ifNil:[		self afterComment: OrderedCollection new.		tokenStream := (SqueakTokenStream forwardOn: self lastToken next).		[tokenStream atEnd 			ifFalse: [				token := tokenStream next.				token isNewLine or: [token isSignificant] or:[token isEaten]]			ifTrue:[true]]				whileFalse: [					token isComment ifTrue:[self afterComment add: token eatToken.] 					].		self afterComment do: [:each | self comments add: (each start to: each stop)]	].	^self afterComment! !!RBProgramNode methodsFor: '*newcompiler-decorating' stamp: 'ms 5/10/2007 11:42'!peekAfterCommentUntil: aToken		| tokenStream token |	self afterComment ifNil:[		self afterComment: OrderedCollection new.		tokenStream := (SqueakTokenStream forwardOn: self lastToken) selectCommentNewLine.		[token := tokenStream next.		 aToken = token or:[tokenStream atEnd or:[token isNewLine]]] 				whileFalse: [self afterComment add: token eatToken].		self afterComment do: [:each | self comments add: (each start to: each stop)]	].	^self afterComment! !!RBProgramNode methodsFor: '*newcompiler-decorating' stamp: 'ms 5/28/2007 14:04'!peekBeforeComment	| tokenStream token countNewLine |	self beforeComment ifNil: 			[countNewLine := 0.			self beforeComment: OrderedCollection new.			tokenStream := (SqueakTokenStream backwardOn: self firstToken) selectCommentNewLineWithPipe.			[tokenStream atEnd 				ifFalse:[ 					token := tokenStream next.					token isNewLine ifTrue: [countNewLine := countNewLine + 1].					(countNewLine > 0 and: [token value = '|']) or: (token isSignificant) or: [tokenStream atEnd]]				ifTrue:[true]] 					whileFalse: 						[token isComment ifTrue: [self beforeComment add: token eatToken]].			self beforeComment do: [:each | self comments add: (each start to: each stop)]].	^ self beforeComment! !!RBProgramNode methodsFor: '*newcompiler-decorating' stamp: 'md 4/4/2007 17:43'!peekInsideComment		| tokenStream token |	self insideComment ifNil:[		self insideComment: OrderedCollection new.		tokenStream := (SqueakTokenStream forwardOn: self firstToken).		[token := tokenStream next.		 token = self lastToken or:[tokenStream atEnd]]				whileFalse: [(token isComment and:[token notEaten]) 								ifTrue:[self insideComment add: token eatToken]].		self insideComment do: [:each | self comments add: (each start to: each stop)]	].	^self insideComment! !!RBProgramNode methodsFor: '*newcompiler' stamp: 'ms 7/27/2007 20:49'!isClosureEnvironmentCreation	^false! !!RBProgramNode methodsFor: '*newcompiler' stamp: 'ms 7/3/2007 21:14'!isClosureEnvironmentRegistration	^false! !!RBProgramNode methodsFor: '*newcompiler' stamp: 'ms 7/27/2007 20:50'!isClosureRegistrationAndCreation	^false! !!RBProgramNode methodsFor: '*newcompiler' stamp: 'ms 7/29/2007 02:40'!isSelfClosureRegistration	^false! !!RBProgramNode methodsFor: '*newcompiler' stamp: 'ms 7/30/2007 13:46'!isTempClosureRegistration	^false! !!RBProgramNode methodsFor: '*persephone-annotations' stamp: 'pmm 6/11/2006 15:09'!addAnnotation: anAnnotation	^(self annotations includesKey: anAnnotation key)		ifFalse: [ self annotations at: anAnnotation key put: anAnnotation ]		ifTrue: [ (self annotations at: anAnnotation key) mergeValueOf: anAnnotation ]! !!RBProgramNode methodsFor: '*persephone-annotations' stamp: 'pmm 10/9/2005 23:07'!addValue: anObject toAnnotationAt: aSymbol	^(self annotationAt: aSymbol)		addValue: anObject! !!RBProgramNode methodsFor: '*persephone-annotations' stamp: 'pmm 10/9/2005 22:14'!annotationAt: aSymbol	^self annotations at: aSymbol ifAbsentPut: [ Annotation forKey: aSymbol ]! !!RBProgramNode methodsFor: '*persephone-annotations' stamp: 'md 3/28/2007 17:48'!annotationAt: aSymbol ifAbsent: aBlock	annotations ifNil: aBlock.	^self annotations at: aSymbol ifAbsent: aBlock! !!RBProgramNode methodsFor: '*persephone-annotations' stamp: 'md 4/12/2007 13:39'!annotations	^annotations ifNil: [annotations := RBSmallIdentityDictionary new: 1]! !!RBProgramNode methodsFor: '*persephone-annotations' stamp: 'md 3/1/2007 20:09'!annotations: anArray	annotations := anArray! !!RBProgramNode methodsFor: '*persephone-annotations' stamp: 'md 5/18/2007 17:03'!annotationsDo: aTwoArgumentBlock	self hasAnnotations ifFalse: [^self].	annotations valuesDo: [ :each |		aTwoArgumentBlock value: each ]! !!RBProgramNode methodsFor: '*persephone-annotations' stamp: 'md 5/18/2007 17:03'!hasAnnotation: aKey	self hasAnnotations ifFalse: [^false].	^self annotations includesKey: aKey! !!RBProgramNode methodsFor: '*persephone-annotations' stamp: 'md 3/28/2007 17:20'!hasAnnotations	annotations ifNil: [^false].	^self annotations notEmpty! !!RBProgramNode methodsFor: '*persephone-annotations' stamp: 'pmm 1/19/2006 22:55'!hasVisibleAnnotations	^self hasAnnotations		and: [ self annotations anySatisfy: [ :each | each isSourceVisible ] ]! !!RBProgramNode methodsFor: '*persephone-annotations' stamp: 'md 5/18/2007 17:00'!numberOfAnnotations	self hasAnnotations ifFalse: [^0].	^self annotations size! !!RBProgramNode methodsFor: '*persephone-annotations' stamp: 'md 5/18/2007 17:00'!numberOfSourceVisibleAnnotations	self hasAnnotations ifFalse: [^0].	^(self annotations select: [ :each | each isSourceVisible ]) size! !!RBProgramNode methodsFor: '*persephone-annotations' stamp: 'md 5/18/2007 17:00'!removeAnnotation: annotName	self hasAnnotations ifFalse: [^self].	self annotations removeKey: annotName ifAbsent:[].! !!RBProgramNode methodsFor: '*persephone-annotations' stamp: 'md 5/18/2007 17:00'!sourceVisibleAnnotations	self hasAnnotations ifFalse: [^self].	self annotations select: [ :each | each isSourceVisible ]! !!RBProgramNode methodsFor: '*persephone-annotations' stamp: 'md 5/18/2007 17:00'!sourceVisibleAnnotationsDo: aOneArgumentBlock	self hasAnnotations ifFalse: [^self].	self annotations valuesDo: [ :each |		each isSourceVisible ifTrue: [			aOneArgumentBlock value: each ] ]! !!RBProgramNode methodsFor: '*persephone-annotations' stamp: 'pmm 10/27/2005 09:12'!valueOfAnnotation: aSymbol	^(self annotationAt: aSymbol) value! !!RBProgramNode methodsFor: '*persephone' stamp: 'md 8/25/2007 12:14'!asInstrumentedNode	^(self class environment classNamed: self instrumentedClassname)		fromUninstrumented: self! !!RBProgramNode methodsFor: '*persephone' stamp: 'md 5/18/2007 16:18'!asSequenceNode	^RBSequenceNode statements: {self}! !!RBProgramNode methodsFor: '*persephone' stamp: 'md 11/11/2007 13:38'!enclosingBlockOrMethod	^self parent enclosingBlockOrMethod! !!RBProgramNode methodsFor: '*persephone' stamp: 'pmm 9/24/2006 10:32'!evaluate	^(RBDoItNode body: (RBSequenceNode statement: self copy))		evaluate! !!RBProgramNode methodsFor: '*persephone' stamp: 'md 8/25/2007 12:25'!instrumentedClassname	^'PEInstrumented' , (self className allButFirst: 2)! !!RBProgramNode methodsFor: '*persephone' stamp: 'md 10/22/2007 15:38'!isInstrumented	^false! !!RBProgramNode methodsFor: '*persephone' stamp: 'pmm 8/7/2006 09:50'!literalEqual: other	^self == other! !!RBProgramNode methodsFor: '*persephone' stamp: 'pmm 6/4/2006 13:33'!method	^self parent method! !!RBProgramNode methodsFor: '*persephone' stamp: 'pmm 7/24/2006 10:03'!replaceNodeAndSetParent: oldNode  withNode: newNode	self replaceNode: oldNode  withNode: newNode.	newNode parent: self! !!RBProgramNode methodsFor: '*geppetto2' stamp: 'md 2/7/2007 11:03'!addBefore: aNode	"insert this code in front of myself, if possible. Will horribly fail else"	parent addNode: aNode before: self. ! !!RBProgramNode methodsFor: '*geppetto2' stamp: 'md 3/29/2007 16:19'!addLinkAnnotation: aLink	self annotationAt: #link ifAbsent: [self addAnnotation: (Annotation forKey: #link)]. 	(self annotationAt: #link) addValue: aLink.		self resetCache.! !!RBProgramNode methodsFor: '*geppetto2' stamp: 'md 2/20/2007 08:09'!executeBlockAfter: aBlock	self link: (aBlock link control: #after).! !!RBProgramNode methodsFor: '*geppetto2' stamp: 'md 2/20/2007 08:09'!executeBlockBefore: aBlock	self link: aBlock link! !!RBProgramNode methodsFor: '*geppetto2' stamp: 'md 8/25/2007 14:50'!gpAddAfter: aNode	"insert this code in front of myself, if possible. Will horribly fail else"	"parent addNode: aNode after: self. "		| instrumented |	instrumented := self asInstrumentedNode.	instrumented after: aNode.		self parent replaceNodeAndSetParent: self withNode: instrumented. 	^instrumented.! !!RBProgramNode methodsFor: '*geppetto2' stamp: 'md 9/1/2007 11:13'!gpAddBefore: aNode	| instrumented |	"parent addNode: aNode before: self."	 	instrumented := self asInstrumentedNode.	instrumented before: aNode.		self parent replaceNodeAndSetParent: self withNode: instrumented. 	^instrumented.! !!RBProgramNode methodsFor: '*geppetto2' stamp: 'md 2/27/2007 21:26'!gpreplaceWith: aNode	^self replaceWith: aNode! !!RBProgramNode methodsFor: '*geppetto2' stamp: 'md 2/19/2007 17:59'!hasAnyLink	^self hasAnnotation: #link! !!RBProgramNode methodsFor: '*geppetto2' stamp: 'md 2/19/2007 18:01'!hasLink: aLink	self hasAnyLink ifFalse: [^false.]. 	^(self annotationAt: #link) values includes: aLink.	! !!RBProgramNode methodsFor: '*geppetto2' stamp: 'md 3/1/2007 17:34'!link: aLink	aLink hookOn: self.		! !!RBProgramNode methodsFor: '*geppetto2' stamp: 'md 2/19/2007 18:23'!links	self hasAnyLink ifFalse: [^#()].	^(self annotationAt: #link) values! !!RBProgramNode methodsFor: '*geppetto2' stamp: 'md 3/29/2007 16:19'!removeAllLinks	self hasAnyLink ifFalse: [^self].	self removeAnnotation: #link.	self resetCache.! !!RBProgramNode methodsFor: '*geppetto2' stamp: 'md 3/29/2007 16:19'!removeLink: aLink	self hasAnyLink ifFalse: [^self].	(self annotationAt: #link) values remove: aLink ifAbsent:[]..	(self annotationAt: #link) values ifEmpty: [self removeAllLinks].		self resetCache.! !!RBProgramNode methodsFor: '*geppetto2' stamp: 'md 3/1/2007 17:37'!resetCache	self methodNode resetCache.! !!RBProgramNode methodsFor: '*geppetto2' stamp: 'md 2/26/2007 17:32'!supportedReifications	^(GPParameter subclasses select: [:each | 		each nodes anySatisfy: [:class | self isKindOf: class]]) collect: [:each | each key]. ! !!RBProgramNode methodsFor: '*Colorer' stamp: 'pmm 4/28/2006 19:18'!markExecuted	(self annotationAt: CLExecutedAnnotation key) increment! !!RBProgramNode methodsFor: '*Colorer' stamp: 'pmm 4/28/2006 19:23'!resetExecutionCount	(self annotationAt: CLExecutedAnnotation key) reset! !!RBProgramNode methodsFor: '*Colorer' stamp: 'pmm 4/28/2006 20:46'!wasExecuted	^(self annotationAt: CLExecutedAnnotation key) wasExecuted! !!RBProgramNode methodsFor: '*features' stamp: 'md 8/20/2007 11:34'!addFeatureAnnotation: aFeature	self annotationAt: #features ifAbsent: [self addAnnotation: (Annotation forKey: #features)]. 	(self annotationAt: #features) addValue: aFeature.! !!RBProgramNode commentStamp: 'md 7/6/2007 14:44' prior: 0!RBProgramNode is an abstract class that represents an abstract syntax tree node in a Smalltalk program.Subclasses must implement the following messages:	accessing		start		stop	visitor		acceptVisitor:The #start and #stop methods are used to find the source that corresponds to this node. "source copyFrom: self start to: self stop" should return the source for this node.The #acceptVisitor: method is used by RBProgramNodeVisitors (the visitor pattern). This will also require updating all the RBProgramNodeVisitors so that they know of the new node.Subclasses might also want to redefine match:inContext: and copyInContext: to do parse tree searching and replacing.Subclasses that contain other nodes should override equalTo:withMapping: to compare nodes while ignoring renaming temporary variables, and children that returns a collection of our children nodes.Instance Variables:	parent	<RBProgramNode>	the node we're contained inProperties:	comments	<Collection of: Interval>	the intervals in the source that have comments for this node	Shared Variables:	FormatterClass	<Behavior>	the formatter class that is used when we are formatted!!RBProgramNode class methodsFor: 'accessing' stamp: 'nk 1/29/2005 10:25'!colorFormatterClass	^Smalltalk at: #RBColorFormatter ifAbsent: [ self formatterClass ]! !!RBProgramNode class methodsFor: 'accessing'!formatterClass	^FormatterClass isNil ifTrue: [RBFormatter] ifFalse: [FormatterClass]! !!RBProgramNode class methodsFor: 'accessing'!formatterClass: aClass 	FormatterClass := aClass! !!RBProgramNode class methodsFor: 'accessing' stamp: 'md 10/11/2005 15:08'!initialize	"self initialize"	Preferences 		addPreference: #useRBASTForPrettyPrint		categories: #(#browsing )		default: false		balloonHelp: 'if set, the RB AST formatter will be used for pretty-printing'! !!RBProgramNode class methodsFor: 'accessing'!optimizedSelectors	^#(#== #ifTrue: #ifTrue:ifFalse: #ifFalse: #ifFalse:ifTrue: #whileTrue: #whileTrue #whileFalse: #whileFalse #to:do: #yourself #and: #or:)! !!RBProgramNode class methodsFor: 'accessing' stamp: 'md 10/11/2005 15:09'!unload	Preferences removePreference: #useRBASTForPrettyPrint ! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching' stamp: 'ls 1/24/2000 00:31'!acceptArrayNode: anArrayNode 	anArrayNode children do: [:each | self visitNode: each]! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching'!acceptAssignmentNode: anAssignmentNode 	self visitNode: anAssignmentNode variable.	self visitNode: anAssignmentNode value! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching' stamp: 'nk 1/29/2005 11:10'!acceptBlockNode: aBlockNode 	self visitBlockArguments: aBlockNode arguments.	self visitNode: aBlockNode body! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching'!acceptCascadeNode: aCascadeNode 	aCascadeNode messages do: [:each | self visitNode: each]! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching' stamp: 'ajh 2/26/2003 18:34'!acceptDoItNode: aDoItNode 	self visitNode: aDoItNode body! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching'!acceptLiteralNode: aLiteralNode! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching'!acceptMessageNode: aMessageNode 	(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 		ifTrue: [self visitNode: aMessageNode receiver].	aMessageNode arguments do: [:each | self visitNode: each]! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching' stamp: 'ms 9/19/2006 14:45'!acceptMethodNode: aMethodNode	self visitMethodArguments: aMethodNode arguments.	aMethodNode pragmas do: [:each | self visitNode: each].	self visitNode: aMethodNode body! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching' stamp: 'ms 9/4/2006 00:06'!acceptPragmaNode: aPragmaNode! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching' stamp: 'ajh 3/3/2003 12:43'!acceptPseudoNode: aVariableNode! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching'!acceptReturnNode: aReturnNode 	self visitNode: aReturnNode value! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching' stamp: 'nk 1/29/2005 11:08'!acceptSequenceNode: aSequenceNode 	self visitTemporaryVariables: aSequenceNode temporaries.	aSequenceNode statements do: [:each | self visitNode: each]! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching'!acceptVariableNode: aVariableNode! !!RBProgramNodeVisitor methodsFor: 'copying'!postCopy! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitArgument: each 	"Here to allow subclasses to detect arguments or temporaries."	^self visitNode: each! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitArguments: aNodeCollection 	^aNodeCollection do: [:each | self visitArgument: each]! !!RBProgramNodeVisitor methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:10'!visitBlockArgument: each 	"Here to allow subclasses to detect arguments or temporaries."	^self visitArgument: each! !!RBProgramNodeVisitor methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:09'!visitBlockArguments: aNodeCollection 	^aNodeCollection do: [:each | self visitBlockArgument: each]! !!RBProgramNodeVisitor methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:09'!visitMethodArgument: each 	"Here to allow subclasses to detect arguments or temporaries."	^self visitArgument: each! !!RBProgramNodeVisitor methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:09'!visitMethodArguments: aNodeCollection 	^aNodeCollection do: [:each | self visitMethodArgument: each]! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitNode: aNode 	^aNode acceptVisitor: self! !!RBProgramNodeVisitor methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:14'!visitTemporaryVariable: aNode	^self visitArgument: aNode! !!RBProgramNodeVisitor methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:07'!visitTemporaryVariables: aNodeCollection 	^aNodeCollection do: [:each | self visitTemporaryVariable: each]! !!RBProgramNodeVisitor methodsFor: '*persephone' stamp: 'md 8/25/2007 12:32'!acceptInstrumentedAssignmentNode: anAssignmentNode	^self		acceptInstrumentedNode: anAssignmentNode		fallback: #acceptAssignmentNode:! !!RBProgramNodeVisitor methodsFor: '*persephone' stamp: 'md 8/25/2007 12:32'!acceptInstrumentedLiteralNode: aLiteralNode	^self		acceptInstrumentedNode: aLiteralNode		fallback: #acceptLiteralNode:! !!RBProgramNodeVisitor methodsFor: '*persephone' stamp: 'md 8/25/2007 12:32'!acceptInstrumentedMessageNode: aMessageNode	^self		acceptInstrumentedNode: aMessageNode		fallback: #acceptMessageNode:! !!RBProgramNodeVisitor methodsFor: '*persephone' stamp: 'md 8/25/2007 12:32'!acceptInstrumentedNode: anInstrumentedNode fallback: aSymbol	| result |	self visitBeforeCode: anInstrumentedNode before.	result := self perform: aSymbol with: anInstrumentedNode.	self visitAfterCode: anInstrumentedNode after.	^result! !!RBProgramNodeVisitor methodsFor: '*persephone' stamp: 'md 8/25/2007 12:32'!acceptInstrumentedObjectLiteralNode: aLiteralNode	^self		acceptInstrumentedNode: aLiteralNode		fallback: #acceptObjectLiteralNode:! !!RBProgramNodeVisitor methodsFor: '*persephone' stamp: 'md 8/25/2007 12:32'!acceptInstrumentedReturnNode: aReturnNode	self visitBeforeCode: aReturnNode before.	^self acceptReturnNode: aReturnNode.! !!RBProgramNodeVisitor methodsFor: '*persephone' stamp: 'md 8/25/2007 12:33'!acceptInstrumentedSequenceNode: aReturnNode	self visitBeforeCode: aReturnNode before.	^self acceptSequenceNode: aReturnNode.! !!RBProgramNodeVisitor methodsFor: '*persephone' stamp: 'md 8/25/2007 12:33'!acceptInstrumentedVariableNode: aVariableNode	^self		acceptInstrumentedNode: aVariableNode		fallback: #acceptVariableNode:! !!RBProgramNodeVisitor methodsFor: '*persephone' stamp: 'pmm 6/25/2006 15:29'!acceptObjectLiteralNode: anObjectLiteralNode	^self acceptLiteralNode: anObjectLiteralNode! !!RBProgramNodeVisitor methodsFor: '*persephone' stamp: 'md 8/25/2007 12:33'!visitAfterCode: aCollection	self visitInsertedCode: aCollection! !!RBProgramNodeVisitor methodsFor: '*persephone' stamp: 'md 8/25/2007 12:33'!visitBeforeCode: aCollection	self visitInsertedCode: aCollection! !!RBProgramNodeVisitor methodsFor: '*persephone' stamp: 'md 8/25/2007 12:33'!visitInsertedCode: aCollection	aCollection do: [ :each |		self visitNode: each ]! !!RBProgramNodeVisitor commentStamp: '<historical>' prior: 0!RBProgramNodeVisitor is an abstract visitor for the RBProgramNodes.Here is a short Tutorial.We want to parse an expression:tree := RBParser parseExpression: '3 + 4'Now we have the AST (Abstrakt syntax tree). Have a look at it with the ObjectExplorerer:tree exploreWe can easyly walk across the tree using the RBProgramNodeVisitor:RBProgramNodeVisitor new visitNode: tree.Of course, nothing happens, as all the visitor-methods are only stubs in this class.So you need to subclass that to do anything usefull.As an example, we would like to walk the tree and get all Literals back.So we make a subclass:RBProgramNodeVisitor subclass: #TestVisitor	instanceVariableNames: 'literals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-AST-Visitors'initialize	literals := Set new.literals	^literalsacceptLiteralNode: aLiteralNode	literals add: aLiteralNode value.	 (TestVisitor new visitNode: tree) literals!!RBPseudoBlockNode methodsFor: 'accessing' stamp: 'md 11/17/2004 12:20'!arguments	^arguments! !!RBPseudoBlockNode methodsFor: 'accessing' stamp: 'md 11/17/2004 12:20'!arguments: aCollection	arguments := aCollection! !!RBPseudoBlockNode methodsFor: 'accessing' stamp: 'md 10/21/2004 14:58'!block	^ block.! !!RBPseudoBlockNode methodsFor: 'accessing' stamp: 'md 10/21/2004 14:59'!block: aSeqNum	block := aSeqNum.! !!RBPseudoBlockNode methodsFor: 'accessing' stamp: 'md 10/21/2004 14:59'!successor	^successor.! !!RBPseudoBlockNode methodsFor: 'accessing' stamp: 'md 10/21/2004 14:59'!successor: aSeqNum	successor := aSeqNum.! !!RBPseudoBlockNode methodsFor: 'testing' stamp: 'md 10/21/2004 15:01'!isBlock	^true.! !!RBPseudoDupNode methodsFor: 'testing' stamp: 'ajh 3/2/2003 23:24'!isDup	^ true! !!RBPseudoGotoNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/3/2003 21:20'!destination	^ destination! !!RBPseudoGotoNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/9/2003 13:44'!destination: seqNum	destination := seqNum! !!RBPseudoGotoNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/20/2003 01:16'!forValue	"true if sequence before me is for value, false if for effect"	^ forValue and: [self isRet not]! !!RBPseudoGotoNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/4/2003 22:18'!forValue: boolean	"true if sequence before me is for value, false if for effect"	forValue := boolean! !!RBPseudoGotoNode methodsFor: 'testing' stamp: 'ajh 3/2/2003 23:23'!isGoto	^ true! !!RBPseudoGotoNode methodsFor: 'testing' stamp: 'ajh 3/20/2003 19:05'!isRet	"is return"	^ self destination = #return! !!RBPseudoIfNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/3/2003 21:20'!boolean	^ boolean! !!RBPseudoIfNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/1/2003 23:08'!boolean: bool	boolean := bool! !!RBPseudoIfNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/3/2003 21:20'!destination	^ destination! !!RBPseudoIfNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/9/2003 13:45'!destination: seqNum	destination := seqNum! !!RBPseudoIfNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/3/2003 21:20'!otherwise	^ otherwise! !!RBPseudoIfNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/2/2003 23:19'!otherwise: instructionSequence	otherwise := instructionSequence! !!RBPseudoIfNode methodsFor: 'testing' stamp: 'ajh 3/1/2003 20:13'!isIf	^ true! !!RBPseudoLabelNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/3/2003 21:21'!destination	^ destination! !!RBPseudoLabelNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/9/2003 13:45'!destination: seqNum	destination := seqNum! !!RBPseudoLabelNode methodsFor: 'testing' stamp: 'ajh 3/2/2003 23:23'!isLabel	^ true! !!RBPseudoNode methodsFor: 'visitor' stamp: 'ajh 3/17/2003 00:25'!acceptVisitor: aProgramNodeVisitor	^ aProgramNodeVisitor acceptPseudoNode: self! !!RBPseudoNode methodsFor: 'testing' stamp: 'md 10/21/2004 15:01'!isBlock	^false.! !!RBPseudoNode methodsFor: 'testing' stamp: 'ajh 3/3/2003 18:41'!isPseudo	^ true! !!RBPseudoNode methodsFor: 'accessing' stamp: 'ajh 3/20/2003 17:20'!mapInstr	^ mapInstr! !!RBPseudoNode methodsFor: 'accessing' stamp: 'ajh 3/20/2003 17:19'!mapInstr: irInstr	mapInstr := irInstr! !!RBPseudoNode commentStamp: 'ajh 6/27/2004 15:13' prior: 0!Used by IRDecompiler to represent intermediate nodes that eventually get reduced to real parse nodes.!!RBPseudoPopNode methodsFor: 'testing' stamp: 'ajh 3/2/2003 23:23'!isPop	^ true! !!RBPseudoSendNode methodsFor: 'accessing' stamp: 'md 11/15/2004 18:07'!arguments	^arguments! !!RBPseudoSendNode methodsFor: 'accessing' stamp: 'md 11/15/2004 18:07'!arguments: aCollection	arguments:= aCollection.! !!RBPseudoSendNode methodsFor: 'accessing' stamp: 'ajh 3/23/2003 22:23'!selector	^ selector! !!RBPseudoSendNode methodsFor: 'accessing' stamp: 'ajh 3/23/2003 22:23'!selector: aSelector	selector := aSelector! !!RBPseudoSendNode methodsFor: 'testing' stamp: 'ajh 3/23/2003 22:23'!isPseudoSend	^ true! !!RBPseudoSendNode methodsFor: 'testing' stamp: 'ms 7/12/2007 13:20'!isSend	^ true! !!RBReadBeforeWrittenTester methodsFor: 'visitor-double dispatching' stamp: 'bh 3/15/2000 16:45'!acceptAssignmentNode: anAssignmentNode 	self visitNode: anAssignmentNode value.	self variableWritten: anAssignmentNode! !!RBReadBeforeWrittenTester methodsFor: 'visitor-double dispatching' stamp: 'bh 3/15/2000 16:46'!acceptBlockNode: aBlockNode 	self processBlock: aBlockNode.! !!RBReadBeforeWrittenTester methodsFor: 'visitor-double dispatching' stamp: 'pmm 7/12/2006 15:51'!acceptMessageNode: aMessageNode 	((#(#whileTrue: #whileFalse: #whileTrue #whileFalse) 		includes: aMessageNode selector) and: [aMessageNode receiver isBlock]) 		ifTrue: [self executeTree: aMessageNode receiver body]		ifFalse: 			[(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 				ifTrue: [self visitNode: aMessageNode receiver]].	((#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: aMessageNode selector) 		and: 			[ aMessageNode arguments allSatisfy: [:each | each isBlock] ]) 			ifTrue: [^self processIfTrueIfFalse: aMessageNode].	aMessageNode arguments do: [:each | self visitNode: each]! !!RBReadBeforeWrittenTester methodsFor: 'visitor-double dispatching' stamp: 'bh 3/15/2000 16:46'!acceptSequenceNode: aSequenceNode 	self processStatementNode: aSequenceNode! !!RBReadBeforeWrittenTester methodsFor: 'visitor-double dispatching' stamp: 'bh 3/15/2000 16:47'!acceptVariableNode: aVariableNode 	self variableRead: aVariableNode! !!RBReadBeforeWrittenTester methodsFor: 'initialize-release'!checkNewTemps: aBoolean 	checkNewTemps := aBoolean! !!RBReadBeforeWrittenTester methodsFor: 'initialize-release' stamp: 'bh 3/15/2000 16:37'!initialize	scopeStack := OrderedCollection with: Dictionary new.	read := Set new.	checkNewTemps := true.! !!RBReadBeforeWrittenTester methodsFor: 'initialize-release'!initializeVars: varNames 	varNames do: [:each | self currentScope at: each put: nil]! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:40'!copyDictionary: aDictionary 	"We could send aDictionary the copy message, but that doesn't copy the associations."	| newDictionary |	newDictionary := Dictionary new: aDictionary size.	aDictionary		keysAndValuesDo: [:key :value | newDictionary at: key put: value].	^newDictionary! !!RBReadBeforeWrittenTester methodsFor: 'private'!createScope	scopeStack add: (self copyDictionary: scopeStack last)! !!RBReadBeforeWrittenTester methodsFor: 'private'!currentScope	^scopeStack last! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:41'!processBlock: aNode 	| newScope |	self createScope.	self executeTree: aNode body.	newScope := self removeScope.	newScope keysAndValuesDo: 			[:key :value | 			(value == true and: [(self currentScope at: key) isNil]) 				ifTrue: [self currentScope at: key put: value]]! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:42'!processIfTrueIfFalse: aNode 	| trueScope falseScope |	self createScope.	self executeTree: aNode arguments first body.	trueScope := self removeScope.	self createScope.	self executeTree: aNode arguments last body.	falseScope := self removeScope.	self currentScope keysAndValuesDo: 			[:key :value | 			value isNil 				ifTrue: 					[(trueScope at: key) == (falseScope at: key) 						ifTrue: [self currentScope at: key put: (trueScope at: key)]						ifFalse: 							[((trueScope at: key) == true or: [(falseScope at: key) == true]) 								ifTrue: [self currentScope at: key put: true]]]]! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:42'!processStatementNode: aNode 	| temps |	(checkNewTemps not or: [aNode temporaries isEmpty]) 		ifTrue: 			[aNode statements do: [:each | self executeTree: each].			^self].	self createScope.	temps := aNode temporaries collect: [:each | each name].	self initializeVars: temps.	aNode statements do: [:each | self executeTree: each].	self removeScope keysAndValuesDo: 			[:key :value | 			(temps includes: key) 				ifTrue: [value == true ifTrue: [read add: key]]				ifFalse: 					[(self currentScope at: key) isNil 						ifTrue: [self currentScope at: key put: value]]]! !!RBReadBeforeWrittenTester methodsFor: 'private'!removeScope	^scopeStack removeLast! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:44'!variableRead: aNode 	(self currentScope includesKey: aNode name) ifTrue: 			[(self currentScope at: aNode name) isNil				ifTrue: [self currentScope at: aNode name put: true]]! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:45'!variableWritten: aNode 	(self currentScope includesKey: aNode variable name) ifTrue: 			[(self currentScope at: aNode variable name) isNil				ifTrue: [self currentScope at: aNode variable name put: false]]! !!RBReadBeforeWrittenTester methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:39'!executeTree: aParseTree 	^self visitNode: aParseTree! !!RBReadBeforeWrittenTester methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:39'!read	self currentScope		keysAndValuesDo: [:key :value | value == true ifTrue: [read add: key]].	^read! !!RBReadBeforeWrittenTester class methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:48'!isVariable: aString readBeforeWrittenIn: aBRProgramNode 	^(self isVariable: aString writtenBeforeReadIn: aBRProgramNode) not! !!RBReadBeforeWrittenTester class methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:49'!isVariable: aString writtenBeforeReadIn: aBRProgramNode 	^(self readBeforeWritten: (Array with: aString) in: aBRProgramNode) 		isEmpty! !!RBReadBeforeWrittenTester class methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:49'!readBeforeWritten: varNames in: aParseTree 	^(self new)		checkNewTemps: false;		initializeVars: varNames;		executeTree: aParseTree;		read! !!RBReadBeforeWrittenTester class methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:49'!variablesReadBeforeWrittenIn: aParseTree 	^(self new)		executeTree: aParseTree;		read! !!RBReplaceRule methodsFor: 'matching'!canMatch: aProgramNode 	^verificationBlock value: aProgramNode! !!RBReplaceRule methodsFor: 'matching'!foundMatchFor: aProgramNode 	self subclassResponsibility! !!RBReplaceRule methodsFor: 'initialize-release'!initialize	super initialize.	verificationBlock := [:aNode | true]! !!RBReplaceRule commentStamp: 'md 8/9/2005 14:56' prior: 0!RBReplaceRule is the abstract superclass of all of the transforming rules. The rules change the source code by replacing the node that matches the rule. Subclasses implement different strategies for this replacement.Subclasses must implement the following messages:	matching		foundMatchFor:Instance Variables:	verificationBlock	<BlockClosure>	Is evaluated with the matching node. This allows for further verification of a match beyond simple tree matching.!!RBReturnNode methodsFor: 'comparing'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self value = anObject value! !!RBReturnNode methodsFor: 'comparing'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	^self value equalTo: anObject value withMapping: aDictionary! !!RBReturnNode methodsFor: 'comparing'!hash	^self value hash! !!RBReturnNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptReturnNode: self! !!RBReturnNode methodsFor: 'replacing' stamp: 'md 7/6/2007 11:59'!adjustPositionsAfter: sourcePos by: delta	"Slide token positions after sourcePos by delta"	self return: self return + delta.	super adjustPositionsAfter: sourcePos by: delta.! !!RBReturnNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	value == aNode ifTrue: [self value: anotherNode]! !!RBReturnNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:34'!basicFirstToken		^self value firstToken! !!RBReturnNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:34'!basicLastToken		^self value lastToken! !!RBReturnNode methodsFor: 'semantics' stamp: 'ajh 7/8/2004 20:57'!binding	^  self homeBinding! !!RBReturnNode methodsFor: 'semantics' stamp: 'md 4/3/2007 13:41'!homeBinding	^ self propertyAt: #binding ifAbsent: [nil].! !!RBReturnNode methodsFor: 'semantics' stamp: 'md 4/3/2007 13:42'!homeBinding: aSemVar	aSemVar ifNil: [^self removeProperty: #binding ifAbsent: []].	self propertyAt: #binding put: aSemVar.! !!RBReturnNode methodsFor: 'accessing'!children	^Array with: value! !!RBReturnNode methodsFor: 'accessing' stamp: 'md 7/6/2007 12:01'!return	^ self propertyAt: #return ifAbsent: [nil].! !!RBReturnNode methodsFor: 'accessing' stamp: 'md 7/6/2007 12:01'!return: returnInteger	returnInteger ifNil: [^self removeProperty: #return ifAbsent: []].	self propertyAt: #return put: returnInteger.! !!RBReturnNode methodsFor: 'accessing' stamp: 'md 7/6/2007 11:59'!return: returnInteger value: aValueNode 	self return: returnInteger.	self value: aValueNode! !!RBReturnNode methodsFor: 'accessing' stamp: 'md 7/6/2007 11:59'!start	^self return! !!RBReturnNode methodsFor: 'accessing'!stop	^value stop! !!RBReturnNode methodsFor: 'accessing'!value	^value! !!RBReturnNode methodsFor: 'accessing'!value: valueNode 	value := valueNode.	value parent: self! !!RBReturnNode methodsFor: 'testing'!containsReturn	^true! !!RBReturnNode methodsFor: 'testing'!isReturn	^true! !!RBReturnNode methodsFor: 'matching'!copyInContext: aDictionary 	^(self class new) value: (value copyInContext: aDictionary); yourself! !!RBReturnNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^value match: aNode value inContext: aDictionary! !!RBReturnNode methodsFor: 'copying' stamp: 'pmm 9/19/2005 11:30'!postCopy	super postCopy.	value := value copy.	value parent: self! !!RBReturnNode methodsFor: '*geppetto2' stamp: 'md 2/9/2007 11:14'!addNode: aNode after: anotherNode	self halt. "TODO"! !!RBReturnNode methodsFor: '*geppetto2' stamp: 'md 2/7/2007 13:27'!addNode: aNode before: anotherNode	parent addNode: aNode before: self! !!RBReturnNode commentStamp: 'md 7/6/2007 11:56' prior: 0!RBReturnNode is an AST node that represents a return expression.Instance Variables:	value	<RBValueNode>	the value that is being returnedproperties:	#return	<Integer>	the position of the ^ character!!RBReturnNode class methodsFor: 'instance creation'!return: returnInteger value: aValueNode 	^self new return: returnInteger value: aValueNode! !!RBReturnNode class methodsFor: 'instance creation'!value: aNode	^self return: nil value: aNode! !!RBReturnNodeTest methodsFor: 'method - tested' stamp: 'ms 3/31/2007 20:49'!expectedFailures	Smalltalk at: #SqueakParser ifAbsent:[^#(#testFirstLastToken)].	^#()! !!RBReturnNodeTest methodsFor: 'testing' stamp: 'ms 9/18/2006 18:52'!testFirstLastToken	| aMethodNode |	aMethodNode := (self defaultParser parseMethod: 'test ^i owe: you') body statements first.		self assert: (aMethodNode firstToken value = '^').	self assert: (aMethodNode lastToken value = 'you').		aMethodNode := (self defaultParser parseMethod: 'test ^(i owe: you)') body statements first.		self assert: (aMethodNode firstToken value = '^').	self assert: (aMethodNode lastToken value = ')')! !!RBReturnNodeTest methodsFor: 'testing' stamp: 'ms 3/31/2007 17:38'!testPosition	| aMethodNode |	aMethodNode := (self defaultParser parseMethod: 'test ^i owe: you') body statements first.	self assertPosition: aMethodNode start: 6 stop: 16.		aMethodNode := (self defaultParser parseMethod: 'test ^(i owe: you)') body statements first.	self assertPosition: aMethodNode start: 6 stop: 18.! !!RBScanner methodsFor: 'testing'!atEnd	^characterType == #eof! !!RBScanner methodsFor: 'testing'!isReadable	^true! !!RBScanner methodsFor: 'testing'!isWritable	^false! !!RBScanner methodsFor: 'accessing'!classificationTable: anObject	classificationTable := anObject! !!RBScanner methodsFor: 'accessing'!contents	| contentsStream |	contentsStream := WriteStream on: (Array new: 50).	self do: [:each | contentsStream nextPut: each].	^contentsStream contents! !!RBScanner methodsFor: 'accessing'!errorBlock: aBlock 	errorBlock := aBlock! !!RBScanner methodsFor: 'accessing'!extendedLanguage	^extendedLanguage! !!RBScanner methodsFor: 'accessing'!extendedLanguage: aBoolean 	extendedLanguage := aBoolean! !!RBScanner methodsFor: 'accessing'!flush! !!RBScanner methodsFor: 'accessing'!getComments	| oldComments |	comments isEmpty ifTrue: [^nil].	oldComments := comments.	comments := OrderedCollection new: 1.	^oldComments! !!RBScanner methodsFor: 'accessing'!next	| token |	buffer reset.	tokenStart := stream position.	characterType == #eof ifTrue: [^RBToken start: tokenStart + 1].	"The EOF token should occur after the end of input"	token := self scanToken.	self stripSeparators.	^token! !!RBScanner methodsFor: 'accessing'!nextPut: anObject 	"Provide an error notification that the receiver does not	implement this message."	self shouldNotImplement! !!RBScanner methodsFor: 'accessing' stamp: 'bh 3/7/2000 02:17'!scanToken	"fast-n-ugly. Don't write stuff like this. Has been found to cause cancer in laboratory rats. Basically a 	case statement. Didn't use Dictionary because lookup is pretty slow."	characterType == #alphabetic ifTrue: [^self scanIdentifierOrKeyword].	(characterType == #digit 		or: [currentCharacter == $- and: [(self classify: stream peek) == #digit]]) 			ifTrue: [^self scanNumber].	characterType == #binary ifTrue: [^self scanBinary: RBBinarySelectorToken].	characterType == #special ifTrue: [^self scanSpecialCharacter].	currentCharacter == $' ifTrue: [^self scanLiteralString].	currentCharacter == $# ifTrue: [^self scanLiteral].	currentCharacter == $$ ifTrue: [^self scanLiteralCharacter].	extendedLanguage 		ifTrue: 			[currentCharacter == PatternVariableCharacter 				ifTrue: [^self scanPatternVariable].			currentCharacter == $} ifTrue: [^self scanSpecialCharacter]].	^self scannerError: 'Unknown character'! !!RBScanner methodsFor: 'private'!classify: aCharacter 	| index |	aCharacter isNil ifTrue: [^nil].	index := aCharacter asInteger.	index == 0 ifTrue: [^#separator].	index > 255 ifTrue: [^nil].	^classificationTable at: index! !!RBScanner methodsFor: 'private'!previousStepPosition	^characterType == #eof 		ifTrue: [stream position]		ifFalse: [stream position - 1]! !!RBScanner methodsFor: 'private'!step	stream atEnd ifTrue: 			[characterType := #eof.			^currentCharacter := nil].	currentCharacter := stream next.	characterType := self classify: currentCharacter.	^currentCharacter! !!RBScanner methodsFor: 'error handling'!errorBlock	^errorBlock isNil		ifTrue: [[:message :position | ]]		ifFalse: [errorBlock]! !!RBScanner methodsFor: 'error handling'!errorPosition	^stream position! !!RBScanner methodsFor: 'error handling'!scannerError: aString 	"Evaluate the block. If it returns raise an error"	self errorBlock value: aString value: self errorPosition.	self error: aString! !!RBScanner methodsFor: 'initialize-release' stamp: 'ls 1/30/2000 19:14'!initializeForSqueak	numberType := #scanNumberIBM.	separatorsInLiterals := true.	extendedLiterals := true.	extendedSymbols := true.	nameSpaceCharacter := nil.! !!RBScanner methodsFor: 'initialize-release' stamp: 'md 10/11/2005 15:49'!on: aStream 	buffer := WriteStream on: (String new: 60).	stream := aStream.	classificationTable := self class classificationTable.	extendedLanguage := false.	comments := OrderedCollection new.	self initializeForSqueak.! !!RBScanner methodsFor: 'private-scanning'!scanAnySymbol	characterType == #alphabetic ifTrue: [^self scanSymbol].	characterType == #binary ifTrue: [^self scanBinary: RBLiteralToken].	^RBToken new! !!RBScanner methodsFor: 'private-scanning'!scanBinary: aClass 	"This doesn't parse according to the ANSI draft. It only parses 1 or 2 letter binary tokens."	| val |	buffer nextPut: currentCharacter.	self step.	(characterType == #binary and: [currentCharacter ~~ $-]) ifTrue: 			[buffer nextPut: currentCharacter.			self step].	val := buffer contents.	val := val asSymbol.	^aClass value: val start: tokenStart! !!RBScanner methodsFor: 'private-scanning'!scanByteArray	| byteStream number |	byteStream := WriteStream on: (ByteArray new: 100).	self step.		[self stripSeparators.	characterType == #digit] whileTrue: 				[number := self scanNumber value.				(number isInteger and: [number between: 0 and: 255]) 					ifFalse: [self scannerError: 'Expecting 8-bit integer'].				byteStream nextPut: number].	currentCharacter == $] ifFalse: [self scannerError: ''']'' expected'].	self step.	"]"	^RBLiteralToken 		value: byteStream contents		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning'!scanExponentMultipler	| exponent isExpNegative position |	currentCharacter == $e		ifTrue: 			[position := stream position.			self step.			(isExpNegative := currentCharacter == $-) ifTrue: [self step].			exponent := self scanNumberOfBase: 10.			exponent isNil				ifTrue: 					["Did not read a valid exponent, e must be start of a message send"					stream position: position - 1.					self step.					exponent := 0]				ifFalse: [isExpNegative ifTrue: [exponent := exponent negated]]]		ifFalse: [exponent := 0].	^10 raisedToInteger: exponent! !!RBScanner methodsFor: 'private-scanning' stamp: 'ls 1/30/2000 19:21'!scanExtendedSymbol	"scan symbols like #. which are allowed by Squeak but aren't standard"	| token |	token := RBLiteralToken value: (currentCharacter asString asSymbol) start: tokenStart stop: stream position.	self step.	^token! !!RBScanner methodsFor: 'private-scanning'!scanIdentifierOrKeyword	| tokenType token name |	self scanName.	currentCharacter == nameSpaceCharacter 		ifTrue: 			[token := self scanNamespaceName.			token notNil ifTrue: [^token]].	(currentCharacter == $: and: [stream peek ~~ $=]) 		ifTrue: 			[buffer nextPut: currentCharacter.			self step.	":"			tokenType := RBKeywordToken]		ifFalse: [tokenType := RBIdentifierToken].	name := buffer contents.	name = 'true' 		ifTrue: 			[^RBLiteralToken 				value: true				start: tokenStart				stop: self previousStepPosition].	name = 'false' 		ifTrue: 			[^RBLiteralToken 				value: false				start: tokenStart				stop: self previousStepPosition].	name = 'nil' 		ifTrue: 			[^RBLiteralToken 				value: nil				start: tokenStart				stop: self previousStepPosition].	^tokenType value: name start: tokenStart! !!RBScanner methodsFor: 'private-scanning' stamp: 'md 4/28/2006 15:02'!scanLiteral	self step.	separatorsInLiterals ifTrue: [self stripSeparators].	characterType == #alphabetic ifTrue: [^self scanSymbol].	characterType == #binary 		ifTrue: [^(self scanBinary: RBLiteralToken) stop: self previousStepPosition].	currentCharacter == $' ifTrue: [^self scanStringSymbol].	currentCharacter == $( ifTrue: [^self scanLiteralArray].	currentCharacter == $[ ifTrue: [^self scanByteArray].	(extendedSymbols and: [ '._' includes: currentCharacter ])		ifTrue: [^self scanExtendedSymbol ].	(separatorsInLiterals and: [currentCharacter == ${]) 		ifTrue: [^self scanQualifier].	self scannerError: 'Expecting a literal type'! !!RBScanner methodsFor: 'private-scanning'!scanLiteralArray	| arrayStream start |	arrayStream := WriteStream on: (Array new: 10).	self step.	start := tokenStart.		[self stripSeparators.	tokenStart := stream position.	currentCharacter == $)] 			whileFalse: 				[arrayStream nextPut: self scanLiteralArrayParts.				buffer reset].	self step.	^RBLiteralToken 		value: arrayStream contents		start: start		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning'!scanLiteralArrayParts	currentCharacter == $# ifTrue: [^self scanLiteral].	characterType == #alphabetic 		ifTrue: 			[| token value |			token := self scanSymbol.			value := token value.			value == #nil ifTrue: [token value: nil].			value == #true ifTrue: [token value: true].			value == #false ifTrue: [token value: false].			^token].	(characterType == #digit 		or: [currentCharacter == $- and: [(self classify: stream peek) == #digit]]) 			ifTrue: [^self scanNumber].	characterType == #binary 		ifTrue: [^(self scanBinary: RBLiteralToken) stop: self previousStepPosition].	currentCharacter == $' ifTrue: [^self scanLiteralString].	currentCharacter == $$ ifTrue: [^self scanLiteralCharacter].	currentCharacter == $( ifTrue: [^self scanLiteralArray].	currentCharacter == $[ ifTrue: [^self scanByteArray].	^self scannerError: 'Unknown character in literal array'! !!RBScanner methodsFor: 'private-scanning'!scanLiteralCharacter	| token |	self step.	"$"	token := RBLiteralToken 				value: currentCharacter				start: tokenStart				stop: stream position.	self step.	"char"	^token! !!RBScanner methodsFor: 'private-scanning'!scanLiteralString	self step.		[currentCharacter isNil 		ifTrue: [self scannerError: 'Unmatched '' in string literal.'].	currentCharacter == $' and: [self step ~~ $']] 			whileFalse: 				[buffer nextPut: currentCharacter.				self step].	^RBLiteralToken 		value: buffer contents		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning' stamp: 'pmm 7/12/2006 16:08'!scanName	[ #(alphabetic digit) includes: characterType ] whileTrue: 			[buffer nextPut: currentCharacter.			self step]! !!RBScanner methodsFor: 'private-scanning'!scanNamespaceName	extendedLiterals 		ifTrue: 			[stream peek == $: ifFalse: [^nil].			buffer next: 2 put: $:.			self step]		ifFalse: 			[(stream atEnd or: [(self classify: stream peek) ~~ #alphabetic]) 				ifTrue: [^nil].			buffer nextPut: $.].	self step.	self scanName.	currentCharacter == nameSpaceCharacter ifTrue: [self scanNamespaceName].	^RBIdentifierToken value: buffer contents start: tokenStart! !!RBScanner methodsFor: 'private-scanning'!scanNumber	^RBLiteralToken 		value: (self perform: numberType)		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning'!scanNumberIBM	| number isNegative |	isNegative := false.	currentCharacter == $- 		ifTrue: 			[isNegative := true.			self step].	number := self scanNumberWithoutExponent.	^(isNegative ifTrue: [number negated] ifFalse: [number]) 		* self scanExponentMultipler! !!RBScanner methodsFor: 'private-scanning'!scanNumberOfBase: anInteger 	"Scan a number. Return the number or nil if the current input isn't a valid number."	| number digits fraction isFloat succeeded |	digits := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' copyFrom: 1 to: anInteger.	number := 0.	succeeded := false.	[digits includes: currentCharacter] whileTrue: 			[number := number * anInteger + (digits indexOf: currentCharacter) - 1.			self step.			succeeded := true].	succeeded ifFalse: [^nil].	isFloat := false.	(currentCharacter == $. and: [digits includes: stream peek]) ifTrue: 			[self step.			isFloat := true.			fraction := 1 / anInteger.			[digits includes: currentCharacter] whileTrue: 					[number := number + (((digits indexOf: currentCharacter) - 1) * fraction).					fraction := fraction / anInteger.					self step]].	^isFloat ifTrue: [number asFloat] ifFalse: [number]! !!RBScanner methodsFor: 'private-scanning'!scanNumberWithoutExponent	"Scan an IBM number with the radix -- don't scan the exponent though"	| number base |	base := self scanNumberOfBase: 10.	(currentCharacter == $r and: [base isInteger])		ifTrue: 			[| position |			position := stream position.			self step.			number := self scanNumberOfBase: base.			number isNil ifTrue: 					["Did not read a correct number, r must be start of a message send."					stream position: position - 1.					self step.					number := base]]		ifFalse: [number := base].	^number! !!RBScanner methodsFor: 'private-scanning'!scanPatternVariable	buffer nextPut: currentCharacter.	self step.	currentCharacter == ${ 		ifTrue: 			[self step.			^RBPatternBlockToken value: '`{' start: tokenStart].	[characterType == #alphabetic] whileFalse: 			[characterType == #eof 				ifTrue: [self scannerError: 'Meta variable expected'].			buffer nextPut: currentCharacter.			self step].	^self scanIdentifierOrKeyword! !!RBScanner methodsFor: 'private-scanning' stamp: 'bh 4/29/2000 18:01'!scanQualifier	| nameStream qualifierClass |	qualifierClass := Smalltalk at: #QualifiedName ifAbsent: [].	qualifierClass isNil ifTrue: [^ self scannerError: 'Unknown character'].	self step.	"{"	nameStream := WriteStream on: (String new: 10).	[currentCharacter == $}]		whileFalse: 			[nameStream nextPut: currentCharacter.			self step].	self step.	"}"	^ RBLiteralToken		value: (qualifierClass pathString: nameStream contents)		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning' stamp: 'ls 1/21/2000 22:38'!scanSpecialCharacter	| character |	currentCharacter == $: ifTrue: 			[self step.			^currentCharacter == $=				ifTrue: 					[self step.					RBAssignmentToken start: tokenStart]				ifFalse: [RBSpecialCharacterToken value: $: start: tokenStart]].	currentCharacter = $_ ifTrue:		[ self step.  ^RBShortAssignmentToken start: tokenStart ].	character := currentCharacter.	self step.	^RBSpecialCharacterToken value: character start: tokenStart! !!RBScanner methodsFor: 'private-scanning'!scanStringSymbol	| literalToken |	literalToken := self scanLiteralString.	literalToken value: literalToken value asSymbol.	^literalToken! !!RBScanner methodsFor: 'private-scanning'!scanSymbol	| lastPosition hasColon value startPosition |	hasColon := false.	startPosition := lastPosition := stream position.	[characterType == #alphabetic] whileTrue: 			[self scanName.			currentCharacter == $: 				ifTrue: 					[buffer nextPut: $:.					hasColon := true.					lastPosition := stream position.					self step]].	value := buffer contents.	(hasColon and: [value last ~~ $:]) 		ifTrue: 			[stream position: lastPosition.			self step.			value := value copyFrom: 1 to: lastPosition - startPosition + 1].	^RBLiteralToken 		value: value asSymbol		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning'!stripComment	| start stop |	start := stream position.	[self step == $"] whileFalse: 			[characterType == #eof				ifTrue: [self scannerError: 'Unmatched " in comment.']].	stop := stream position.	self step.	comments add: (start to: stop)! !!RBScanner methodsFor: 'private-scanning'!stripSeparators		[[characterType == #separator]		whileTrue: [self step].	currentCharacter == $"]		whileTrue: [self stripComment]! !!RBScanner commentStamp: 'md 8/9/2005 14:54' prior: 0!RBScanner is a stream that returns a sequence of token from the string that it is created on. The tokens know where they came from in the source code and which comments were attached to them.Instance Variables:	buffer	<PositionableStream>	Accumulates the text for the current token.	characterType	<ByteSymbol>	The type of the next character. (e.g. #alphabetic, etc.)	classificationTable	<Array of: Symbol>	Mapping from Character values to their characterType.	comments	<Collection of: Interval>	Source intervals of scanned comments that must be attached to the next token.	currentCharacter	<Character>	The character currently being processed.	errorBlock	<BlockClosure>	The block to execute on lexical errors.	extendedLiterals	<Boolean>	True if IBM-type literals are allowed. In VW, this is false.	nameSpaceCharacter	<Character>	The character used to separate namespaces.	numberType	<ByteSymbol>	The method to perform: to scan a number. 	separatorsInLiterals	<Boolean>	True if separators are allowed within literals.	stream	<PositionableStream>	Contains the text to be scanned.	tokenStart	<Integer>	The source position of the beginning of the current tokenClass Instance Variables:	classificationTable	<Array>		the default classification table for all charactersShared Variables:	PatternVariableCharacter	<Character>	the character that starts a pattern node!!RBScanner class methodsFor: 'accessing'!classificationTable	ClassificationTable isNil ifTrue: [self initialize].	^ClassificationTable! !!RBScanner class methodsFor: 'accessing'!patternVariableCharacter	^PatternVariableCharacter! !!RBScanner class methodsFor: 'class initialization' stamp: 'ls 3/20/2004 14:17'!initialize	PatternVariableCharacter := $`.	ClassificationTable := Array new: 255.	self initializeChars: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' to: #alphabetic.	self initializeChars: (128 to: 255) asByteArray asString to: #alphabetic.	self initializeChars: '01234567890' to: #digit.	self initializeChars: '!!!!%&*+,-/<=>?@\~|' to: #binary.	ClassificationTable at: 177 put: #binary.	"plus-or-minus"	ClassificationTable at: 183 put: #binary.	"centered dot"	ClassificationTable at: 215 put: #binary.	"times"	ClassificationTable at: 247 put: #binary.	"divide"	self initializeChars: '().:;[]^{}_' to: #special.	#(9 10 12 13 26 32) do: [:i | ClassificationTable at: i put: #separator]! !!RBScanner class methodsFor: 'class initialization'!initializeChars: characters to: aSymbol 	characters do: [:c | ClassificationTable at: c asInteger put: aSymbol]! !!RBScanner class methodsFor: 'testing'!isSelector: aSymbol 	| scanner token |	scanner := self basicNew.	scanner on: (ReadStream on: aSymbol asString).	scanner step.	token := scanner scanAnySymbol.	token isLiteral ifFalse: [^false].	token value isEmpty ifTrue: [^false].	^scanner atEnd! !!RBScanner class methodsFor: 'testing'!isVariable: aString 	| scanner token |	aString isString ifFalse: [^false].	aString isEmpty ifTrue: [^false].	(ClassificationTable at: aString first asInteger) == #alphabetic		ifFalse: [^false].	scanner := self basicNew.	scanner on: (ReadStream on: aString asString).	scanner errorBlock: [:s :p | ^false].	scanner step.	token := scanner scanIdentifierOrKeyword.	token isKeyword ifTrue: [^false].	^scanner atEnd! !!RBScanner class methodsFor: 'instance creation'!on: aStream 	| str |	str := self basicNew on: aStream.	str		step;		stripSeparators.	^str! !!RBScanner class methodsFor: 'instance creation'!on: aStream errorBlock: aBlock 	| str |	str := self basicNew on: aStream.	str		errorBlock: aBlock;		step;		stripSeparators.	^str! !!RBScanner class methodsFor: 'instance creation'!rewriteOn: aStream 	| str |	str := self basicNew on: aStream.	str		extendedLanguage: true;		step;		stripSeparators.	^str! !!RBScanner class methodsFor: 'instance creation'!rewriteOn: aStream errorBlock: aBlock 	| str |	str := self basicNew on: aStream.	str		extendedLanguage: true;		errorBlock: aBlock;		step;		stripSeparators.	^str! !!RBSearchRule methodsFor: 'testing' stamp: 'bh 4/29/2000 18:15'!canMatch: aProgramNode 	self needsWork.	"testing #copy to attempt to fix block closure issue"	owner answer: (answerBlock copy value: aProgramNode value: owner answer).	^ true! !!RBSearchRule methodsFor: 'initialize-release'!searchFor: aString thenDo: aBlock 	self searchString: aString.	answerBlock := aBlock! !!RBSearchRule methodsFor: 'initialize-release'!searchForMethod: aString thenDo: aBlock 	self methodSearchString: aString.	answerBlock := aBlock! !!RBSearchRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode thenDo: aBlock 	searchTree := aBRProgramNode.	answerBlock := aBlock! !!RBSearchRule commentStamp: 'md 8/9/2005 14:56' prior: 0!RBSearchRule is a parse tree rule that simply searches for matches to the rule. Every time a match is found, answerBlock is evaluated with the node that matches and the cureent answer. This two-argument approach allows a collection to be formed from all of the matches (Think inject:into:).Instance Variables:	answerBlock	<BlockClosure>	Block to evaluate with the matching node and the current answer.!!RBSearchRule class methodsFor: 'instance creation'!searchFor: aString thenDo: aBlock 	^self new searchFor: aString thenDo: aBlock! !!RBSearchRule class methodsFor: 'instance creation'!searchForMethod: aString thenDo: aBlock 	^self new searchForMethod: aString thenDo: aBlock! !!RBSearchRule class methodsFor: 'instance creation'!searchForTree: aBRProgramNode thenDo: aBlock 	^self new searchForTree: aBRProgramNode thenDo: aBlock! !!RBSequenceNode methodsFor: 'comparing' stamp: 'pmm 7/12/2006 15:45'!= anObject 	"Can't send = to the temporaries and statements collection since they might change from arrays to OCs"	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	self temporaries size = anObject temporaries size ifFalse: [^false].	^self temporaries = anObject temporaries		and: [ self statements = anObject statements ]! !!RBSequenceNode methodsFor: 'comparing' stamp: 'pmm 7/13/2006 18:38'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self statements size == anObject statements size ifFalse: [^false].	self statements with: anObject statements do: [ :first :second |		(first equalTo: second withMapping: aDictionary)			ifFalse: [^false]].	aDictionary values asSet size = aDictionary size ifFalse: [^false].	"Not a one-to-one mapping"	self temporaries		do: [:each | aDictionary removeKey: each name ifAbsent: []].	^true! !!RBSequenceNode methodsFor: 'comparing'!hash	^self temporaries hash bitXor: (self statements isEmpty			ifTrue: [0]			ifFalse: [self statements first hash])! !!RBSequenceNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptSequenceNode: self! !!RBSequenceNode methodsFor: 'adding nodes'!addNode: aNode 	aNode parent: self.	(statements isEmpty not and: [statements last isReturn])		ifTrue: [self error: 'Cannot add statement after return node'].	statements := statements asOrderedCollection add: aNode; yourself! !!RBSequenceNode methodsFor: 'adding nodes' stamp: 'pmm 9/19/2005 17:54'!addNode: aNode after: anotherNode 	| index |	index := self indexOfNode: anotherNode.	index = 0 ifTrue: [^self addNode: aNode].	statements := (statements asOrderedCollection)				add: aNode afterIndex: index;				yourself.	aNode parent: self! !!RBSequenceNode methodsFor: 'adding nodes'!addNode: aNode before: anotherNode 	| index |	index := self indexOfNode: anotherNode.	index = 0 ifTrue: [^self addNode: aNode].	statements := (statements asOrderedCollection)				add: aNode beforeIndex: index;				yourself.	aNode parent: self! !!RBSequenceNode methodsFor: 'adding nodes'!addNodeFirst: aNode 	aNode parent: self.	statements := (statements asOrderedCollection)				addFirst: aNode;				yourself! !!RBSequenceNode methodsFor: 'adding nodes'!addNodes: aCollection 	aCollection do: [:each | each parent: self].	(statements isEmpty not and: [statements last isReturn]) 		ifTrue: [self error: 'Cannot add statement after return node'].	statements := (statements asOrderedCollection)				addAll: aCollection;				yourself! !!RBSequenceNode methodsFor: 'adding nodes' stamp: 'pmm 9/24/2005 10:52'!addNodes: aCollection after: anotherNode 	aCollection inject: anotherNode into: [ :node :each |		self addNode: each after: node.		each ]! !!RBSequenceNode methodsFor: 'adding nodes'!addNodes: aCollection before: anotherNode 	aCollection do: [:each | self addNode: each before: anotherNode]! !!RBSequenceNode methodsFor: 'adding nodes'!addNodesFirst: aCollection 	aCollection do: [:each | each parent: self].	statements := (statements asOrderedCollection)				addAllFirst: aCollection;				yourself! !!RBSequenceNode methodsFor: 'adding nodes'!addSelfReturn	| node |	self lastIsReturn ifTrue: [^self].	node := RBReturnNode value: (RBVariableNode named: 'self').	self addNode: node! !!RBSequenceNode methodsFor: 'adding nodes'!addTemporariesNamed: aCollection 	aCollection do: [:each | self addTemporaryNamed: each]! !!RBSequenceNode methodsFor: 'adding nodes' stamp: 'md 4/14/2007 00:59'!addTemporaryNamed: aString 	| variableNode |	variableNode := RBVariableNode named: aString.	variableNode parent: self.	temporaries := self temporaries copyWith: variableNode! !!RBSequenceNode methodsFor: 'accessing'!addReturn	| node |	statements isEmpty ifTrue: [^nil].	statements last isReturn ifTrue: [^statements last].	node := RBReturnNode value: statements last.	statements at: statements size put: node.	node parent: self.	^node! !!RBSequenceNode methodsFor: 'accessing'!allDefinedVariables	^(self temporaryNames asOrderedCollection) addAll: super allDefinedVariables;		yourself! !!RBSequenceNode methodsFor: 'accessing'!allTemporaryVariables	^(self temporaryNames asOrderedCollection)		addAll: super allTemporaryVariables;		yourself! !!RBSequenceNode methodsFor: 'accessing'!children	^(OrderedCollection new) addAll: self temporaries;		addAll: self statements;		yourself! !!RBSequenceNode methodsFor: 'accessing' stamp: 'ms 9/4/2007 01:50'!isEmpty	^self statements isEmpty 		or:[self statements size = 1 			and:[self statements first isLiteral]			and:[self statements first value = nil]]! !!RBSequenceNode methodsFor: 'accessing' stamp: 'md 4/7/2007 20:28'!leftBar: anObject	anObject ifNil: [^self removeProperty: #leftBar ifAbsent: []].	self propertyAt: #leftBar put: anObject.! !!RBSequenceNode methodsFor: 'accessing' stamp: 'md 4/7/2007 20:19'!periods: anObject	anObject ifNil: [^self removeProperty: #periods ifAbsent: []].	self propertyAt: #periods put: anObject.! !!RBSequenceNode methodsFor: 'accessing' stamp: 'md 4/14/2007 01:00'!removeTemporaryNamed: aName 	temporaries := temporaries reject: [:each | each name = aName].	temporaries isEmpty ifTrue: [temporaries := nil].! !!RBSequenceNode methodsFor: 'accessing' stamp: 'md 4/7/2007 20:27'!rightBar: anObject	anObject ifNil: [^self removeProperty: #rightBar ifAbsent: []].	self propertyAt: #rightBar put: anObject.! !!RBSequenceNode methodsFor: 'accessing' stamp: 'ms 6/17/2007 02:44'!sequenceDefinedIn	^self! !!RBSequenceNode methodsFor: 'accessing' stamp: 'ms 7/16/2007 01:30'!start	^self firstToken ifNil: [0] ifNotNil: [self firstToken start]! !!RBSequenceNode methodsFor: 'accessing'!statements	^statements! !!RBSequenceNode methodsFor: 'accessing'!statements: stmtCollection 	statements := stmtCollection.	statements do: [:each | each parent: self]! !!RBSequenceNode methodsFor: 'accessing' stamp: 'ms 7/16/2007 01:31'!stop	^self lastToken ifNil: [0] ifNotNil: [self lastToken stop]! !!RBSequenceNode methodsFor: 'accessing' stamp: 'md 4/6/2007 14:03'!temporaries	^temporaries ifNil: [#()].! !!RBSequenceNode methodsFor: 'accessing'!temporaries: tempCollection 	temporaries := tempCollection.	temporaries do: [:each | each parent: self]! !!RBSequenceNode methodsFor: 'accessing' stamp: 'md 4/8/2007 17:50'!temporaryNames	^self temporaries collect: [:each | each name]! !!RBSequenceNode methodsFor: 'accessing'!temporaryVariables	^(super temporaryVariables asOrderedCollection) addAll: self temporaryNames;		yourself! !!RBSequenceNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:35'!basicFirstToken		self temporaries 			ifEmpty: [self statements 							ifEmpty:[^nil] 							ifNotEmpty:[| stat | 				     					stat := OrderedCollection newFrom: self statements.					 					[stat first firstToken = nil] 												whileTrue: [stat removeFirst.															stat ifEmpty:[^nil]].										^stat first firstToken]]			ifNotEmpty: [^self temporaries first firstToken]! !!RBSequenceNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:36'!basicLastToken		self statements 		ifEmpty:[self temporaries 						ifEmpty:[^nil]						ifNotEmpty:[^self temporaries last lastToken]] 		ifNotEmpty:[ | stat | 				      stat := OrderedCollection newFrom: self statements.					 [stat last lastToken = nil] 							whileTrue: [stat removeLast.										stat ifEmpty:[self temporaries 														ifEmpty:[^nil]														ifNotEmpty:[^self temporaries last lastToken]]].					^stat last lastToken]! !!RBSequenceNode methodsFor: 'querying' stamp: 'md 4/14/2007 00:57'!bestNodeFor: anInterval 	| node |	node := super bestNodeFor: anInterval.	node == self 		ifTrue: 			[(self temporaries isEmpty and: [statements size == 1]) 				ifTrue: [^statements first]].	^node! !!RBSequenceNode methodsFor: 'querying' stamp: 'md 4/14/2007 00:57'!whichNodeIsContainedBy: anInterval 	| node |	node := super whichNodeIsContainedBy: anInterval.	node == self 		ifTrue: 			[(self temporaries isEmpty and: [statements size == 1]) 				ifTrue: [^statements first]].	^node! !!RBSequenceNode methodsFor: 'matching' stamp: 'md 4/14/2007 00:59'!copyInContext: aDictionary 	^(self class new)		temporaries: (self copyList: self temporaries inContext: aDictionary);		statements: (self copyList: statements inContext: aDictionary);		yourself! !!RBSequenceNode methodsFor: 'matching' stamp: 'md 4/6/2007 22:49'!match: aNode inContext: aDictionary 	self class == aNode class ifFalse: [^false].	^(self matchList: self temporaries		against: aNode temporaries		inContext: aDictionary) and: 				[self matchList: statements					against: aNode statements					inContext: aDictionary]! !!RBSequenceNode methodsFor: 'testing' stamp: 'md 4/14/2007 00:58'!defines: aName 	^self temporaries anySatisfy: [:each | each name = aName]! !!RBSequenceNode methodsFor: 'testing'!directlyUses: aNode 	^false! !!RBSequenceNode methodsFor: 'testing'!isLast: aNode 	| last |	statements isEmpty ifTrue: [^false].	last := statements last.	^last == aNode or: [last isMessage and: [(#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: last selector)				and: [last arguments inject: false into: [:bool :each | bool or: [each isLast: aNode]]]]]! !!RBSequenceNode methodsFor: 'testing'!isSequence	^true! !!RBSequenceNode methodsFor: 'testing'!lastIsReturn	^statements isEmpty not and: [statements last lastIsReturn]! !!RBSequenceNode methodsFor: 'testing' stamp: 'pmm 7/12/2006 15:21'!references: aVariableName 	^statements anySatisfy: [:each | each references: aVariableName]! !!RBSequenceNode methodsFor: 'testing'!uses: aNode 	statements isEmpty ifTrue: [^false].	aNode == statements last ifFalse: [^false].	^self isUsed! !!RBSequenceNode methodsFor: 'private'!indexOfNode: aNode 	"Try to find the node by first looking for ==, and then for ="	^(1 to: statements size) detect: [:each | (statements at: each) == aNode]		ifNone: [statements indexOf: aNode]! !!RBSequenceNode methodsFor: 'initialize-release' stamp: 'md 4/7/2007 20:28'!leftBar: leftInteger temporaries: variableNodes rightBar: rightInteger 	self leftBar: leftInteger.	variableNodes ifNotEmpty: [self temporaries: variableNodes] ifEmpty: [#()].	self rightBar: rightInteger! !!RBSequenceNode methodsFor: 'copying' stamp: 'md 4/14/2007 00:58'!postCopy	super postCopy.	temporaries := self temporaries collect: [:each |		each copy		parent: self;		yourself ].	statements := statements collect: [:each |		each copy		parent: self;		yourself ]! !!RBSequenceNode methodsFor: 'replacing' stamp: 'md 8/2/2005 22:25'!removeDeadCode	(self isUsed ifTrue: [statements size - 1] ifFalse: [statements size]) 		to: 1		by: -1		do: [:i | (statements at: i) isImmediate ifTrue: [statements removeAt: i]].	super removeDeadCode! !!RBSequenceNode methodsFor: 'replacing'!removeNode: aNode	self replaceNode: aNode withNodes: #()! !!RBSequenceNode methodsFor: 'replacing' stamp: 'md 4/14/2007 00:57'!replaceNode: aNode withNode: anotherNode 	self statements: (statements 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]]).	self temporaries: (self temporaries 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]]).	anotherNode parent: self! !!RBSequenceNode methodsFor: 'replacing'!replaceNode: aNode withNodes: aCollection 	| index newStatements |	index := self indexOfNode: aNode.	newStatements := OrderedCollection new: statements size + aCollection size.	1 to: index - 1 do: [:i | newStatements add: (statements at: i)].	newStatements addAll: aCollection.	index + 1 to: statements size		do: [:i | newStatements add: (statements at: i)].	aCollection do: [:each | each parent: self].	statements := newStatements! !!RBSequenceNode methodsFor: '*newcompiler-decorating' stamp: 'md 4/4/2007 17:37'!peekAfterComment	"| tokenStream token countNewLine |"	self afterComment ifNil:[		"countNewLine := 0."		self afterComment: OrderedCollection new.		"tokenStream := (SqueakTokenStream forwardOn: self lastToken) selectCommentNewLine.		[token := tokenStream next.		 token isNewLine ifTrue: [countNewLine := countNewLine + 1.]. 		 tokenStream atEnd] 				whileFalse: [countNewLine = 1 ifTrue: [token isComment ifTrue:[afterComment add: token eatToken]]].		afterComment do: [:each | self comments add: (each start to: each stop)]"	].	^self afterComment! !!RBSequenceNode methodsFor: '*persephone' stamp: 'pmm 7/22/2006 13:34'!asSequenceNode	^self! !!RBSequenceNode methodsFor: '*persephone' stamp: 'md 3/21/2007 13:40'!countReturns	^PEReturnCounter returnsIn: self! !!RBSequenceNode methodsFor: '*persephone' stamp: 'pmm 9/24/2006 10:32'!evaluate	^(RBDoItNode body: self copy)		evaluate! !!RBSequenceNode methodsFor: '*persephone' stamp: 'md 7/25/2007 15:01'!gpAddBefore: aNode	self addNodeFirst: aNode.! !!RBSequenceNode methodsFor: '*persephone' stamp: 'pmm 8/28/2006 11:37'!hasReturnAtMostAtEnd	"returns true if I contain at most one return and it is a the end"		| returns |	returns := self countReturns.	^self statements isEmpty		or: [ returns = 0 ]		or: [ returns = 1			and: [ self statements last isReturn ] ]! !!RBSequenceNode commentStamp: 'md 4/7/2007 20:30' prior: 0!RBSequenceNode is an AST node that represents a sequence of statements. Both RBBlockNodes and RBMethodNodes contain these.Instance Variables:	statements	<SequenceableCollection of: RBStatementNode>	the statement nodes	temporaries	<SequenceableCollection of: RBVariableNode>	the temporaries defined			Properties:	leftBar	<Integer | nil>	the position of the left | in the temporaries definition	rightBar	<Integer | nil>	the position of the right | in the temporaries definition	periods	<SequenceableCollection of: Integer>	the positions of all the periods that separate the statements!!RBSequenceNode class methodsFor: 'instance creation'!leftBar: leftInteger temporaries: variableNodes rightBar: rightInteger 	^self new		leftBar: leftInteger		temporaries: variableNodes		rightBar: rightInteger! !!RBSequenceNode class methodsFor: 'instance creation'!statements: statementNodes 	^self temporaries: #() statements: statementNodes! !!RBSequenceNode class methodsFor: 'instance creation'!temporaries: variableNodes statements: statementNodes 	^(self new)		temporaries: variableNodes;		statements: statementNodes;		yourself! !!RBSequenceNode class methodsFor: '*persephone' stamp: 'pmm 9/19/2006 18:33'!statement: aNode	^self statements: (Array with: aNode) ! !!RBSequenceNodeTest methodsFor: 'method - tested' stamp: 'ms 3/31/2007 20:50'!expectedFailures	Smalltalk at: #SqueakParser ifAbsent:[^#(#testFirstLastToken #testPosition)].	^#()! !!RBSequenceNodeTest methodsFor: 'testing' stamp: 'ms 9/18/2006 23:09'!testFirstLastToken		| rbNode |	rbNode := (self defaultParser parseMethod: 'test | a b |') body.	self assert: (rbNode firstToken value = '|').	self assert: (rbNode lastToken value = '|').		rbNode := (self defaultParser parseMethod: 'test []. u. []') body.	self assert: (rbNode firstToken value = '[').	self assert: (rbNode lastToken value = ']').		rbNode := (self defaultParser parseMethod: 'test | | []. {}') body.	self assert: (rbNode firstToken value = '|').	self assert: (rbNode lastToken value = '}').		rbNode := (self defaultParser parseMethod: 'test  | |') body.	self assert: (rbNode firstToken value  = '|').	self assert: (rbNode lastToken value = '|').		rbNode := (self defaultParser parseMethod: 'test  ||') body.	self assert: (rbNode firstToken value  = '||').	self assert: (rbNode lastToken value = '||').		rbNode := (self defaultParser parseMethod: 'test  || ^self') body.	self assert: (rbNode firstToken value  = '||').	self assert: (rbNode lastToken value = 'self').		rbNode := (self defaultParser parseMethod: 'test  [: each || tmp | ^3]') 					body statements first body.	self assert: (rbNode firstToken value  = '||').	self assert: (rbNode lastToken value = '3').		rbNode := (self defaultParser parseMethod: 'test ^self') body.	self assert: (rbNode firstToken value  = '^').	self assert: (rbNode lastToken value = 'self')! !!RBSequenceNodeTest methodsFor: 'testing' stamp: 'ms 3/31/2007 20:37'!testPosition		| rbNode |	rbNode := (self defaultParser parseMethod: 'test | a b |') body.	self assertPosition: rbNode start: 6 stop: 12.		rbNode := (self defaultParser parseMethod: 'test []. u. []') body.	self assertPosition: rbNode start: 6 stop: 14.		rbNode := (self defaultParser parseMethod: 'test | | []. {}') body.	self assertPosition: rbNode start: 6 stop: 15.		rbNode := (self defaultParser parseMethod: 'test | |') body.	self assertPosition: rbNode start: 6 stop: 8.		rbNode := (self defaultParser parseMethod: 'test ||') body.	self assertPosition: rbNode start: 6 stop: 7.		rbNode := (self defaultParser parseMethod: 'test || ^self') body.	self assertPosition: rbNode start: 6 stop: 13.		rbNode := (self defaultParser parseMethod: 'test [: each || tmp | ^3]') 					body statements first body.	self assertPosition: rbNode start: 14 stop: 24.		rbNode := (self defaultParser parseMethod: 'test ^self') body.	self assertPosition: rbNode start: 6 stop: 10.! !!RBShortAssignmentToken methodsFor: 'private' stamp: 'ls 1/11/2000 07:00'!length	^1! !!RBSmallDictionary methodsFor: 'adding'!add: anAssociation 	self at: anAssociation key put: anAssociation value.	^anAssociation! !!RBSmallDictionary methodsFor: 'adding'!at: key put: value 	| index |	index := self findIndexFor: key.	^index == 0 		ifTrue: [self privateAt: key put: value]		ifFalse: [values at: index put: value]! !!RBSmallDictionary methodsFor: 'adding' stamp: 'md 4/13/2007 11:49'!noCheckAdd: anObject	^self add: anObject! !!RBSmallDictionary methodsFor: 'accessing' stamp: 'md 4/13/2007 11:47'!associationAt: key ifAbsent: aBlock	 	| index |	index := self findIndexFor: key.	^index == 0 ifTrue: [aBlock value] ifFalse: [ key -> (values at: index)].! !!RBSmallDictionary methodsFor: 'accessing'!at: key ifAbsent: aBlock 	| index |	index := self findIndexFor: key.	^index == 0 ifTrue: [aBlock value] ifFalse: [values at: index]! !!RBSmallDictionary methodsFor: 'accessing'!at: key ifAbsentPut: aBlock 	| index |	index := self findIndexFor: key.	^index == 0 		ifTrue: [self privateAt: key put: aBlock value]		ifFalse: [values at: index]! !!RBSmallDictionary methodsFor: 'accessing' stamp: 'md 3/30/2007 16:05'!empty	tally := 0! !!RBSmallDictionary methodsFor: 'accessing' stamp: 'md 3/30/2007 16:04'!size	^tally! !!RBSmallDictionary methodsFor: 'enumerating'!associationsDo: aBlock 	self keysAndValuesDo: [:key :value | aBlock value: key -> value]! !!RBSmallDictionary methodsFor: 'enumerating' stamp: 'md 3/30/2007 16:03'!do: aBlock 	1 to: tally do: [:i | aBlock value: (values at: i)]! !!RBSmallDictionary methodsFor: 'enumerating' stamp: 'md 3/30/2007 16:09'!keysAndValuesDo: aBlock 	1 to: tally do: [:i | aBlock value: (array at: i) value: (values at: i)]! !!RBSmallDictionary methodsFor: 'enumerating' stamp: 'md 3/30/2007 16:08'!keysDo: aBlock 	1 to: tally do: [:i | aBlock value: (array at: i)]! !!RBSmallDictionary methodsFor: 'copying' stamp: 'md 3/29/2007 23:26'!copy	^self shallowCopy postCopy! !!RBSmallDictionary methodsFor: 'copying' stamp: 'md 3/30/2007 16:09'!postCopy	array := array copy.	values := values copy! !!RBSmallDictionary methodsFor: 'private' stamp: 'md 3/30/2007 16:09'!findIndexFor: aKey 	1 to: tally do: [:i | (array at: i) = aKey ifTrue: [^i]].	^0! !!RBSmallDictionary methodsFor: 'private' stamp: 'md 3/30/2007 16:04'!growKeysAndValues	self growTo: tally * 2! !!RBSmallDictionary methodsFor: 'private' stamp: 'md 3/30/2007 16:08'!growTo: aSize 	| newKeys newValues |	newKeys := Array new: aSize.	newValues := Array new: aSize.	1 to: tally		do: 			[:i | 			newKeys at: i put: (array at: i).			newValues at: i put: (values at: i)].	array := newKeys.	values := newValues! !!RBSmallDictionary methodsFor: 'private' stamp: 'md 3/30/2007 16:08'!privateAt: key put: value 	tally == array size ifTrue: [self growKeysAndValues].	tally := tally + 1.	array at: tally put: key.	^values at: tally put: value! !!RBSmallDictionary methodsFor: 'private' stamp: 'md 4/13/2007 16:45'!rehash	"do nothing for now"! !!RBSmallDictionary methodsFor: 'testing'!includesKey: aKey 	^(self findIndexFor: aKey) ~~ 0! !!RBSmallDictionary methodsFor: 'initialize-release' stamp: 'md 4/3/2007 12:10'!initialize: size	array := Array new: size.	values := Array new: size.	tally := 0! !!RBSmallDictionary methodsFor: 'removing' stamp: 'md 3/29/2007 23:24'!remove:anAssociation	self removeKey: anAssociation key.! !!RBSmallDictionary methodsFor: 'removing'!remove: oldObject ifAbsent: anExceptionBlock 	self removeKey: oldObject key ifAbsent: anExceptionBlock.	^oldObject! !!RBSmallDictionary methodsFor: 'removing' stamp: 'md 3/30/2007 16:09'!removeKey: key ifAbsent: aBlock 	| index value |	index := self findIndexFor: key.	index == 0 ifTrue: [^aBlock value].	value := values at: index.	index to: tally - 1 do: [:i | 			array at: i put: (array at: i + 1).			values at: i put: (values at: i + 1)].	array at: tally put: nil.	values at: tally put: nil.	tally := tally - 1.	^value! !!RBSmallDictionary commentStamp: 'md 4/1/2007 12:34' prior: 0!RBSmallDictionary is a special dictionary optimized for small collections. In addition to the normal dictionary protocol, it also supports an #empty message which "empties" the collection but may hang on to the original elements (so it could collect garbage). Without #empty we would either need to create a new dictionary or explicitly remove everything from the dictionary. Both of these take more time and #empty.Instance Variables:array <Array of: Object> array of keys (we don't use Associations for our key value pairs)tally <Integer> the size of the dictionaryvalues <Array of: Object> array of our values!!RBSmallDictionary class methodsFor: 'instance creation' stamp: 'md 3/31/2007 11:19'!new	^self basicNew initialize: 2! !!RBSmallDictionary class methodsFor: 'instance creation' stamp: 'md 4/3/2007 12:09'!new: aSize 	^self basicNew initialize: aSize.! !!RBSmallDictionaryTest methodsFor: 'tests' stamp: 'md 4/13/2007 11:35'!testAdd		| dict |	dict := RBSmallDictionary new.	dict add: #a -> 1.	dict add: #b -> 2.	self assert: (dict at: #a) = 1.	self assert: (dict at: #b) = 2! !!RBSmallDictionaryTest methodsFor: 'tests' stamp: 'md 4/13/2007 11:37'!testAddAll		| dict1 dict2 |	dict1 := RBSmallDictionary new.	dict1 at: #a put:1 ; at: #b put: 2. 	dict2 := RBSmallDictionary new.	dict2 at: #a put: 3 ; at: #c put: 4.	dict1 addAll: dict2.	self assert: (dict1 at: #a) = 3.	self assert: (dict1 at: #b) = 2.	self assert: (dict1 at: #c) = 4.! !!RBSmallDictionaryTest methodsFor: 'tests' stamp: 'md 4/13/2007 11:37'!testComma		| dict1 dict2 dict3 |	dict1 := RBSmallDictionary new.	dict1 at: #a put:1 ; at: #b put: 2. 	dict2 := RBSmallDictionary new.	dict2 at: #a put: 3 ; at: #c put: 4.	dict3 := dict1, dict2.	self assert: (dict3 at: #a) = 3.	self assert: (dict3 at: #b) = 2.	self assert: (dict3 at: #c) = 4.! !!RBSmallDictionaryTest methodsFor: 'tests' stamp: 'md 4/13/2007 11:37'!testPseudo	"(self run: #testPseudo)"	"true and false are valid keys"		| dict1  |	dict1 := RBSmallDictionary new.	self shouldnt: [dict1 at: true put: #true] raise: Error.	self assert: (dict1 at: true) = #true.			self shouldnt: [dict1 at: false put: #false] raise: Error.	self assert: (dict1 at: false) = #false.! !!RBSmallDictionaryTest methodsFor: 'association-tests' stamp: 'md 4/13/2007 11:37'!testAddAssociation	"self run:#testAddAssociation"	"self debug:#testAddAssociation"		| dict |	dict := RBSmallDictionary new.	dict at: #a put: 1.	dict at: #b put: 2.	self assert: (dict at: #a) = 1.	self assert: (dict at: #b) = 2.		dict at: #a put: 10.	dict at: #c put: 2.		self assert: (dict at: #a) = 10.	self assert: (dict at: #b) = 2.	self assert: (dict at: #c) = 2		! !!RBSmallDictionaryTest methodsFor: 'association-tests' stamp: 'md 4/13/2007 11:37'!testAssociationsSelect	| answer d |	d := RBSmallDictionary new.	d at: (Array with: #hello with: #world)	  put: #fooBar.	d at: Smalltalk put: #'Smalltalk is the key'.	d at: #Smalltalk put: Smalltalk.	answer := d				associationsSelect: [:assoc | assoc key == #Smalltalk						and: [assoc value == Smalltalk]].	self		should: [answer isKindOf: RBSmallDictionary].	self		should: [answer size == 1].	self		should: [(answer at: #Smalltalk)				== Smalltalk].	answer := d				associationsSelect: [:assoc | assoc key == #NoSuchKey						and: [assoc value == #NoSuchValue]].	self		should: [answer isKindOf: RBSmallDictionary].	self		should: [answer size == 0]! !!RBSmallDictionaryTest methodsFor: 'association-tests' stamp: 'md 4/13/2007 11:38'!testIncludesAssociation	"self run:#testIncludesAssociation"		| dict |	dict := RBSmallDictionary new.	dict at: #a put: 1.	dict at: #b put: 2.	self assert: (dict includesAssociation: (#a -> 1)).	self assert: (dict includesAssociation: (#b -> 2)).		! !!RBSmallDictionaryTest methodsFor: 'association-tests' stamp: 'md 4/13/2007 11:38'!testIncludesAssociationNoValue	"self run:#testIncludesAssociationNoValue"	"self debug:#testIncludesAssociationNoValue"		| dict a1 a3 |	a1 := Association key: #Italie.	a3 := Association key: #France value: 'Paris'.		self assert: (a1 key = #Italie).	self assert: (a1 value isNil).		dict := RBSmallDictionary new.	dict add: a1.	dict add: a3.	self assert: (dict includesKey: #France).	self assert: (dict includesKey: #Italie).	self assert: (dict at: #Italie) isNil.	self assert: (dict at: #France) = 'Paris'			! !!RBSmallDictionaryTest methodsFor: 'basic tests' stamp: 'md 4/13/2007 11:42'!testAtError	"self run: #testAtError"		| dict |	dict := RBSmallDictionary new.	dict at: #a put: 666.	self shouldnt: [ dict at: #a ] raise: Error.	self should: [ dict at: #b ] raise: Error.		! !!RBSmallDictionaryTest methodsFor: 'basic tests' stamp: 'md 4/13/2007 11:42'!testAtIfAbsent	"self run: #testAtIfAbsent"		| dict |	dict := RBSmallDictionary new.	dict at: #a put: 666.		self assert: (dict at: #a ifAbsent: [nil]) = 666.		self assert: (dict at: #b ifAbsent: [nil]) isNil.	! !!RBSmallDictionaryTest methodsFor: 'basic tests' stamp: 'md 4/13/2007 11:42'!testAtNil	"(self run: #testAtNil)"	"nil is a valid key in squeak. In VW nil is not a valid key"	"Ansi 1.9 p, 168    		5.7.2.5 Message: at: key put: newElement    		Synopsis    			Store newElement at key in the receiver. Answer newElement.    		Definition: <abstractDictionary>    		If lookup succeeds for key, then newElement replaces the element previously stored at key.    		Otherwise, the newElement is stored at the new key. In either case, subsequent successful    		lookups for key will answer newElement.  Answer newElement.    		The result is undefined if the key is nil.		This clearly indicates that different smalltalks where doing different assumptions."				| dict1  |	dict1 := RBSmallDictionary new.	self shouldnt: [ dict1 at: nil put: #none] raise: Error.	self assert: (dict1 at: nil) = #none. 	! !!RBSmallDictionaryTest methodsFor: 'basic tests' stamp: 'md 4/13/2007 11:42'!testAtPut	"self run: #testAtPut"	"self debug: #testAtPut"		| adictionary |	adictionary := RBSmallDictionary new.	adictionary at: #a put: 3.	self assert: (adictionary at: #a) = 3.	adictionary at: #a put: 3.	adictionary at: #a put: 4.	self assert: (adictionary at: #a) = 4.	adictionary at: nil put: 666.	self assert: (adictionary at: nil) = 666	! !!RBSmallDictionaryTest methodsFor: 'basic tests' stamp: 'md 4/13/2007 11:42'!testAtPutNil	"self run: #testAtPut"	"self debug: #testAtPut"		| dict |	dict := RBSmallDictionary new.	dict at: nil put: 1.	self assert: (dict at: nil) = 1.	dict at: #a put: nil.	self assert: (dict at: #a) = nil.	dict at: nil put: nil.	self assert: (dict at: nil) = nil.			! !!RBSmallDictionaryTest methodsFor: 'basic tests' stamp: 'md 4/13/2007 11:42'!testDictionaryConcatenation	"self run: #testDictionaryConcatenation"			| dict1 dict2 dict3 |	dict1 := RBSmallDictionary new.	dict1 at: #a put: 'Nicolas' ; at: #b put: 'Damien'. 		dict2 := RBSmallDictionary new.	dict2 at: #a put: 'Christophe' ; at: #c put: 'Anthony'.	dict3 := dict1, dict2.		self assert: (dict3 at: #a) = 'Christophe'.	self assert: (dict3 at: #b) = 'Damien'.	self assert: (dict3 at: #c) = 'Anthony'.		! !!RBSmallDictionaryTest methodsFor: 'basic tests' stamp: 'md 4/13/2007 11:42'!testIncludesKey	"self run:#testIncludesKey"	"self debug:#testIncludesKey"		| dict a1 a2 a3 |	a1 := Association key: 'Italie'.	a2 := Association new.	a3 := Association key: 'France' value: 'Paris'.		dict := RBSmallDictionary new.	dict add: a1 .	dict add: a2.	dict add: a3.	self assert: (dict includesKey: #France).	self assert: (dict includesKey: 'France').	self assert: (dict includesKey: #Italie).	self assert: (dict includesKey: nil).				self assert: (dict at: 'France' ) = 'Paris'.! !!RBSmallDictionaryTest methodsFor: 'basic tests' stamp: 'md 4/13/2007 11:42'!testKeys	"self run:#testKeys "		| a1 a2  dict | 	a1 := Association key: 'France' value: 'Paris'.	a2 := Association key: 'Italie' value: 'Rome'.	dict := RBSmallDictionary new.	dict add: a1.	dict add: a2.	 			self assert: (dict keys size) = 2.		self assert: (dict keys includes: #France)				! !!RBSmallDictionaryTest methodsFor: 'basic tests' stamp: 'md 4/13/2007 11:42'!testKeysDo	"self run: #testKeysDo"	"self debug: #testKeysDo"		| dict res |	dict := RBSmallDictionary new.		dict at: #a put: 33.	dict at: #b put: 66.		res := OrderedCollection new.	dict keysDo: [ :each | res add: each].		self assert: res asSet = #(a b) asSet.		! !!RBSmallDictionaryTest methodsFor: 'basic tests' stamp: 'md 4/13/2007 11:42'!testOccurrencesOf	"self run:#testOccurrencesOf"		| dict |	dict := RBSmallDictionary new.	dict at: #a put: 1.	dict at: #b put: 2.	dict at: #c put: 1.	dict at: #d put: 3.	dict at: nil put: nil.	dict at: #z put: nil.			self assert: (dict occurrencesOf: 1 ) = 2.	self assert: (dict occurrencesOf: nil ) = 2.				! !!RBSmallDictionaryTest methodsFor: 'basic tests' stamp: 'md 4/13/2007 11:43'!testPseudoVariablesAreValidKeys	"(self run: #testPseudoVariablesAreValidKeys)"	"true and false are valid keys"		| dict1  |	dict1 := RBSmallDictionary new.	self shouldnt: [dict1 at: true put: #true] raise: Error.	self assert: (dict1 at: true) = #true.			self shouldnt: [dict1 at: false put: #false] raise: Error.	self assert: (dict1 at: false) = #false.! !!RBSmallDictionaryTest methodsFor: 'basic tests' stamp: 'md 4/13/2007 11:43'!testRemoveKey		"self run:#testRemoveKey "	| dict | 	dict := RBSmallDictionary new.	dict at: #a put: 1.	dict at: #b put: 2.	 	self assert: (dict keys size) = 2.	dict removeKey: #a.	self assert: dict keys size  = 1.	self should: [dict at: #a] raise: Error.	self assert: (dict at: #b) = 2		! !!RBSmallDictionaryTest methodsFor: 'basic tests' stamp: 'md 4/13/2007 11:43'!testValues	"self run:#testValues "		| a1 a2 a3 dict | 	a1 := Association key: 'France' value: 'Paris'.	a2 := Association key: 'Italie' value: 'Rome'.	dict := RBSmallDictionary new.	dict add: a1.	dict add: a2.	 	self assert: (dict values size ) = 2.	self assert: (dict values includes: 'Paris').		a3 := Association new.	dict add: a3.	self assert: (dict values size ) = 3.	self assert: (dict values includes: nil).								! !!RBSmallDictionaryTest methodsFor: 'smalldictTests' stamp: 'md 4/13/2007 11:55'!testRehash	| dictionary |	dictionary := RBSmallDictionary new: 100.	dictionary		add: 1 -> 3;		at: 2 put: 4;		at: 1 put: 4.	self assert: dictionary size = 2.	self assert: (dictionary inject: 0 into: [:sum :each | sum + each]) = 8.	self assert: (dictionary includesKey: 1).	self deny: (dictionary includesKey: 3).		dictionary rehash.		self assert: dictionary size = 2.	self assert: (dictionary inject: 0 into: [:sum :each | sum + each]) = 8.	self assert: (dictionary includesKey: 1).	self deny: (dictionary includesKey: 3).				! !!RBSmallDictionaryTest methodsFor: 'smalldictTests' stamp: 'md 4/13/2007 11:29'!testSmallDictionary	| dictionary total |	dictionary := RBSmallDictionary new: 100.	dictionary		add: 1 -> 3;		at: 2 put: 4;		at: 1 put: 4.	self assert: dictionary size = 2.	self assert: (dictionary inject: 0 into: [:sum :each | sum + each]) = 8.	self assert: (dictionary includesKey: 1).	self deny: (dictionary includesKey: 3).	total := 0.	dictionary keysDo: [:each | total := total + each].	self assert: total = 3.	dictionary removeKey: 2.	dictionary copy associationsDo: [:each | dictionary remove: each].	self assert: dictionary size = 0! !!RBSmallIdentityDictionary methodsFor: 'private' stamp: 'md 4/2/2007 08:21'!findIndexFor: aKey 	1 to: tally do: [:i | (array at: i) == aKey ifTrue: [^i]].	^0! !!RBSmallIdentityDictionary methodsFor: 'accessing' stamp: 'md 4/2/2007 08:27'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet := IdentitySet new: self size.	self keysDo: [:key | aSet add: key].	^ aSet! !!RBSpecialCharacterToken methodsFor: 'testing'!isSpecial	^true! !!RBSpecialCharacterToken methodsFor: 'private' stamp: 'md 8/30/2006 17:21'!length	^1! !!RBSpecialCharacterToken commentStamp: 'md 8/9/2005 14:53' prior: 0!RBSpecialCharacterToken is the first class representation of special characters.!!RBStringReplaceRule methodsFor: 'matching'!foundMatchFor: aProgramNode 	| newTree |	newTree := replaceTree copyInContext: self context.	newTree copyCommentsFrom: aProgramNode.	^newTree! !!RBStringReplaceRule methodsFor: 'initialize-release'!methodReplaceString: replaceString 	replaceTree := RBParser parseRewriteMethod: replaceString! !!RBStringReplaceRule methodsFor: 'initialize-release'!replaceString: replaceString 	replaceTree := RBParser parseRewriteExpression: replaceString.	searchTree isSequence = replaceTree isSequence 		ifFalse: 			[searchTree isSequence 				ifTrue: [replaceTree := RBSequenceNode statements: (Array with: replaceTree)]				ifFalse: [searchTree := RBSequenceNode statements: (Array with: searchTree)]]! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchFor: searchString replaceWith: replaceString 	self searchString: searchString.	self replaceString: replaceString! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchFor: searchString replaceWith: replaceString when: aBlock 	self searchFor: searchString replaceWith: replaceString.	verificationBlock := aBlock! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchForMethod: searchString replaceWith: replaceString 	self methodSearchString: searchString.	self methodReplaceString: replaceString! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchForMethod: searchString replaceWith: replaceString when: aBlock 	self searchForMethod: searchString replaceWith: replaceString.	verificationBlock := aBlock! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode replaceWith: replaceNode 	searchTree := aBRProgramNode.	replaceTree := replaceNode! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode replaceWith: replaceString when: aBlock 	self searchForTree: aBRProgramNode replaceWith: replaceString.	verificationBlock := aBlock! !!RBStringReplaceRule commentStamp: 'md 8/9/2005 14:56' prior: 0!RBStringReplaceRule replaces a matched tree with another tree (which may include metavariable from the matching tree). This is a very succint syntax for specifying most rewrites.Instance Variables:	replaceTree	<RBProgramNode>	The tree to replace the matched tree with.!!RBStringReplaceRule class methodsFor: 'instance creation'!searchFor: searchString replaceWith: replaceString 	^self new searchFor: searchString replaceWith: replaceString! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchFor: searchString replaceWith: replaceString when: aBlock 	^self new 		searchFor: searchString		replaceWith: replaceString		when: aBlock! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchForMethod: searchString replaceWith: replaceString	^self new searchForMethod: searchString replaceWith: replaceString! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchForMethod: searchString replaceWith: replaceString when: aBlock 	^self new 		searchForMethod: searchString		replaceWith: replaceString		when: aBlock! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchForTree: searchString replaceWith: replaceString 	^self new searchForTree: searchString replaceWith: replaceString! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchForTree: searchString replaceWith: replaceString when: aBlock 	^self new 		searchForTree: searchString		replaceWith: replaceString		when: aBlock! !!RBTempVariableNode methodsFor: 'testing' stamp: 'md 8/22/2007 07:42'!isArgument	"is this an argument variable?"	^self method arguments includes: self! !!RBTempVariableNode methodsFor: 'testing' stamp: 'md 3/30/2007 09:55'!isGlobal	^false! !!RBTempVariableNode methodsFor: 'testing' stamp: 'md 3/30/2007 09:55'!isInstance	^false! !!RBTempVariableNode methodsFor: 'testing' stamp: 'md 3/30/2007 09:55'!isTemp	^true! !!RBToken methodsFor: 'testing'!isAssignment	^false! !!RBToken methodsFor: 'testing'!isBinary	^false! !!RBToken methodsFor: 'testing'!isIdentifier	^false! !!RBToken methodsFor: 'testing'!isKeyword	^false! !!RBToken methodsFor: 'testing'!isLiteral	^false! !!RBToken methodsFor: 'testing'!isPatternBlock	^false! !!RBToken methodsFor: 'testing'!isPatternVariable	^false! !!RBToken methodsFor: 'testing' stamp: 'md 9/1/2005 16:02'!isRBToken	^true.! !!RBToken methodsFor: 'testing'!isSpecial	^false! !!RBToken methodsFor: 'accessing'!length	^self subclassResponsibility! !!RBToken methodsFor: 'accessing' stamp: 'ms 9/17/2006 02:05'!next	^next! !!RBToken methodsFor: 'accessing' stamp: 'ms 9/17/2006 02:05'!next: aToken	next := aToken! !!RBToken methodsFor: 'accessing' stamp: 'ms 9/17/2006 02:04'!previous	^previous! !!RBToken methodsFor: 'accessing' stamp: 'ms 9/17/2006 02:05'!previous: aToken	aToken ifNotNil:[aToken next: self].	previous := aToken! !!RBToken methodsFor: 'accessing'!removePositions	sourcePointer := nil! !!RBToken methodsFor: 'accessing'!start	^sourcePointer! !!RBToken methodsFor: 'accessing'!stop	^self start + self length - 1! !!RBToken methodsFor: 'printing'!printOn: aStream 	aStream		nextPut: $ ;		nextPutAll: self class name! !!RBToken methodsFor: 'initialize-release'!start: anInteger 	sourcePointer := anInteger! !!RBToken commentStamp: 'md 8/9/2005 14:53' prior: 0!RBToken is the abstract superclass of all of the RB tokens. These tokens (unlike the standard parser's) remember where they came from in the original source code.Subclasses must implement the following messages:	accessing		lengthInstance Variables:	sourcePointer	<Integer>	The position in the original source code where this token began.!!RBToken class methodsFor: 'instance creation'!start: anInterval 	^self new start: anInterval! !!RBValueNode methodsFor: 'accessing' stamp: 'md 4/2/2007 08:10'!addParenthesis: anInterval 	self propertyAt: #parenthesis ifAbsentPut: [OrderedCollection new: 1].	(self propertyAt: #parenthesis) add: anInterval! !!RBValueNode methodsFor: 'accessing' stamp: 'md 4/2/2007 08:10'!parentheses	^self propertyAt: #parenthesis ifAbsent: [#()].! !!RBValueNode methodsFor: 'accessing' stamp: 'md 4/6/2007 14:05'!start	^(self hasProperty: #parenthesis)		ifFalse: [self startWithoutParentheses]		ifTrue: [self parentheses last first]! !!RBValueNode methodsFor: 'accessing'!startWithoutParentheses	^self subclassResponsibility! !!RBValueNode methodsFor: 'accessing' stamp: 'md 4/6/2007 14:05'!stop	^(self hasProperty: #parenthesis)		ifFalse: [self stopWithoutParentheses]		ifTrue: [self parentheses last last]! !!RBValueNode methodsFor: 'accessing'!stopWithoutParentheses	^self subclassResponsibility! !!RBValueNode methodsFor: 'testing'!containedBy: anInterval 	^anInterval first <= self startWithoutParentheses 		and: [anInterval last >= self stopWithoutParentheses]! !!RBValueNode methodsFor: 'testing'!hasParentheses	^self parentheses isEmpty not! !!RBValueNode methodsFor: 'testing'!isValue	^true! !!RBValueNode commentStamp: 'md 7/6/2007 14:22' prior: 0!RBValueNode is an abstract class that represents a node that returns some value.Subclasses must implement the following messages:	accessing		startWithoutParentheses		stopWithoutParentheses	testing		needsParenthesisProperties:	#parentheses	<SequenceableCollection of: Inteval>	the positions of the parethesis around this node. We need a collection of intervals for stupid code such as "((3 + 4))" that has multiple parethesis around the same expression.!!RBValueToken methodsFor: 'private'!length	^value size! !!RBValueToken methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	value printOn: aStream.	aStream nextPutAll: ')'! !!RBValueToken methodsFor: 'accessing' stamp: 'pmm 7/31/2006 11:32'!realValue	^value class == Array		ifTrue: [value collect: [:each | each realValue]]		ifFalse: [value]! !!RBValueToken methodsFor: 'accessing'!value	^value! !!RBValueToken methodsFor: 'accessing'!value: anObject	value := anObject! !!RBValueToken methodsFor: 'initialize-release'!value: aString start: anInteger 	value := aString.	sourcePointer := anInteger! !!RBValueToken commentStamp: 'md 8/9/2005 14:53' prior: 0!RBValueToken is the abstract superclass of all tokens that have additional information attached. For example, the BinarySelector token holds onto the actual character (e.g. $+).Instance Variables:	value	<String>	The value of this token!!RBValueToken class methodsFor: 'instance creation'!value: aString start: anInteger 	^self new value: aString start: anInteger! !!RBVariableNode methodsFor: 'comparing'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self name = anObject name! !!RBVariableNode methodsFor: 'comparing'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	^(aDictionary at: self name ifAbsentPut: [anObject name]) = anObject name! !!RBVariableNode methodsFor: 'comparing'!hash	^self name hash! !!RBVariableNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptVariableNode: self! !!RBVariableNode methodsFor: 'replacing' stamp: 'ajh 3/13/2003 16:13'!adjustPositionsAfter: sourcePos by: delta	"Slide token positions after sourcePos by delta"	token start > sourcePos ifTrue: [		token start: token start + delta]! !!RBVariableNode methodsFor: 'replacing' stamp: 'ajh 3/17/2003 13:12'!changeToken: newToken	self root adjustPositionsAfter: token stop by: newToken stop - token stop.	token := newToken.! !!RBVariableNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:44'!basicFirstToken		^self token! !!RBVariableNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:45'!basicLastToken		^self token! !!RBVariableNode methodsFor: 'semantics' stamp: 'md 4/2/2007 08:07'!binding	^ self propertyAt: #binding ifAbsent: [nil].! !!RBVariableNode methodsFor: 'semantics' stamp: 'md 4/2/2007 08:07'!binding: aSemVar	aSemVar ifNil: [^self removeProperty: #binding ifAbsent: []].	self propertyAt: #binding put: aSemVar.! !!RBVariableNode methodsFor: 'matching'!copyInContext: aDictionary 	^self class identifierToken: token removePositions! !!RBVariableNode methodsFor: 'initialize-release' stamp: 'md 4/13/2007 22:39'!identifierToken: anIdentifierToken 	token := anIdentifierToken.	name := anIdentifierToken value.! !!RBVariableNode methodsFor: 'testing' stamp: 'pmm 10/8/2005 11:21'!isGlobal	^self binding isGlobal! !!RBVariableNode methodsFor: 'testing'!isImmediate	^true! !!RBVariableNode methodsFor: 'testing' stamp: 'pmm 10/8/2005 11:57'!isInstance	^self binding isInstance! !!RBVariableNode methodsFor: 'testing' stamp: 'pmm 2/6/2006 12:31'!isRead	^self isWrite not! !!RBVariableNode methodsFor: 'testing' stamp: 'pmm 10/8/2005 11:21'!isTemp	^self binding isTemp! !!RBVariableNode methodsFor: 'testing'!isVariable	^true! !!RBVariableNode methodsFor: 'testing' stamp: 'pmm 2/6/2006 12:31'!isWrite	^self parent isAssignment		and: [ self parent variable == self ]! !!RBVariableNode methodsFor: 'testing'!references: aVariableName 	^self name = aVariableName! !!RBVariableNode methodsFor: 'accessing' stamp: 'md 4/13/2007 22:42'!name	^name! !!RBVariableNode methodsFor: 'accessing'!precedence	^0! !!RBVariableNode methodsFor: 'accessing'!startWithoutParentheses	^token start! !!RBVariableNode methodsFor: 'accessing'!stopWithoutParentheses	^token stop! !!RBVariableNode methodsFor: 'accessing' stamp: 'ajh 3/13/2003 15:17'!token	^ token! !!RBVariableNode methodsFor: '*newcompiler' stamp: 'ms 5/28/2007 13:47'!peekBeforeComment	| tokenStream tok countNewLine |	self parent isMethod 		ifFalse: [^ super peekBeforeComment]		ifTrue: 			[self beforeComment ifNil: 					[self beforeComment: OrderedCollection new.					tokenStream := SqueakTokenStream backwardOn: self firstToken previous.					countNewLine:= 0.					[tokenStream atEnd 						ifFalse: [							tok := tokenStream next.														tok isNewLine ifTrue: [countNewLine := countNewLine + 1].							(countNewLine > 0 and: [tok value = '|']) or: [tok isSignificant]]						ifTrue:[true]] 							whileFalse: [tok isComment ifTrue: [self beforeComment add: tok eatToken]].					self beforeComment do: [:each | self comments add: (each start to: each stop)]].			^ self beforeComment]! !!RBVariableNode methodsFor: '*persephone' stamp: 'pmm 6/12/2006 20:23'!ifTemp: aTempBlock ifInstance: anInstanceBlock ifGlobal: aGlobalBlock	^self isTemp		ifTrue: aTempBlock		ifFalse: [			self isInstance				ifTrue: anInstanceBlock				ifFalse: aGlobalBlock ]! !!RBVariableNode methodsFor: '*persephone' stamp: 'md 11/21/2007 13:30'!isArg	^(self enclosingBlockOrMethod arguments identityIncludes: self) or: [self binding isArg].! !!RBVariableNode methodsFor: '*persephone' stamp: 'md 11/11/2007 13:57'!isVariableDefinition	"Variables are defined as arguments or in the | |"		^ self enclosingBlockOrMethod definitions identityIncludes: self.! !!RBVariableNode commentStamp: 'md 8/9/2005 15:00' prior: 0!RBVariableNode is an AST node that represent a variable (global, inst var, temp, etc.).Instance Variables:	token	<RBValueToken>	the token that contains our name and position!!RBVariableNode class methodsFor: 'instance creation'!identifierToken: anIdentifierToken 	^(anIdentifierToken isPatternVariable 		ifTrue: [RBPatternVariableNode]		ifFalse: [RBVariableNode]) new 		identifierToken: anIdentifierToken! !!RBVariableNode class methodsFor: 'instance creation'!named: aString 	^self identifierToken: (RBIdentifierToken value: aString start: 0)! !!RBVariableNodeTest methodsFor: 'method - tested' stamp: 'ms 3/31/2007 20:51'!expectedFailures	Smalltalk at: #SqueakParser ifAbsent:[^#(#testFirstLastToken)].	^#()! !!RBVariableNodeTest methodsFor: 'testing' stamp: 'ms 9/18/2006 17:26'!testFirstLastToken		| rbNode |	rbNode := RBVariableNode named: 'foo'.	self assert: (rbNode firstToken value = 'foo').	self assert: (rbNode lastToken value = 'foo').		rbNode := (self defaultParser parseMethod: 'test  (foo)') body statements first.	self assert: (rbNode firstToken value  = '(').	self assert: (rbNode lastToken value = ')').! !!RBVariableNodeTest methodsFor: 'testing' stamp: 'ms 3/31/2007 19:00'!testPosition		| rbNode |	rbNode := (self defaultParser parseMethod: 'test (foo)') body statements first.	self assertPosition: rbNode start: 6 stop: 10! !!ReceiverAndSelector methodsFor: 'as yet unclassified' stamp: 'bh 11/5/2000 00:00'!initializeReceiver:anObject andSelector:aSymbol	receiver := anObject.	selector := aSymbol.! !!ReceiverAndSelector methodsFor: 'as yet unclassified' stamp: 'bh 11/5/2000 00:01'!value	^receiver perform: selector.! !!ReceiverAndSelector methodsFor: 'as yet unclassified' stamp: 'bh 11/5/2000 00:01'!value: firstArgument	^receiver perform: selector with: firstArgument.! !!ReceiverAndSelector methodsFor: 'as yet unclassified' stamp: 'bh 11/5/2000 00:01'!value: firstArgument value: secondArgument	^receiver perform: selector with: firstArgument with: secondArgument.! !!ReceiverAndSelector class methodsFor: 'as yet unclassified' stamp: 'bh 11/4/2000 23:59'!forReceiver:anObject andSelector:aSymbol	^self new initializeReceiver:anObject andSelector:aSymbol.! !!Recompiler methodsFor: 'recompile' stamp: 'ms 8/6/2007 08:28'!decompileAndRecompile: selector in: class	"Recompile method in class. If method can't be recompiled (because of compile error) add it to problemMethods with general reason"	| trailer methodNode newMethod oldMethod |	oldMethod := class compiledMethodAt: selector.	trailer := oldMethod trailer.	methodNode := self decompiler decompile: selector in: class.	selector == methodNode selector ifFalse: [		^ self problem: 'selector changed' sel: selector in: class].	newMethod := methodNode generate: trailer.	newMethod = oldMethod ifFalse:[self error: 'Method are not the same'].	class addSelectorSilently: selector withMethod: newMethod.! !!Recompiler methodsFor: 'recompile' stamp: 'ms 7/11/2007 23:45'!decompileAndRecompileClass: class	class compileAll.	{class. class class} do: [:behavior |		behavior selectorsDo: [:selector |			[self decompileAndRecompile: selector in: behavior]				on: Error				do: [:ex | self problem: ex description sel: selector in: behavior]]]! !!Recompiler methodsFor: 'recompile' stamp: 'ms 7/10/2007 16:23'!decompileAndRecompileImage	"Recomiles all class/instance methods in image. Methods that can't be recompiled (because of compile error) are added to problemMethods and are not recompiled"	"ProtoObject allSubclasses includes metaclasses"	| m |	m := 0.	Smalltalk allClassesAndTraitsDo: [:class | m := m + 1].	'Recompiling ', m printString, ' classes and traits'		displayProgressAt: Sensor cursorPoint from: 0 to: m		during: [:bar | | n |			n _ 0.			Smalltalk allClassesDo: [:class |				self decompileAndRecompileClass: class.				bar value: (n _ n + 1)].			self decompileAndRecompileClass: ProtoObject.		].! !!Recompiler methodsFor: 'recompile' stamp: 'md 7/24/2007 16:11'!recompile: selector in: class	"Recompile method in class. If method can't be recompiled (because of compile error) add it to problemMethods with general reason"	| source oldMethod trailer methodNode newMethod |		"do not recompile Traits methods here, they are recompiled 	and reinstalled when the trait is recompiled"		(class includesLocalSelector: selector) ifFalse: [^self].			oldMethod _ class compiledMethodAt: selector.	"oldMethod isClosureCompiled ifTrue: [^ self]."	source _ class sourceCodeAt: selector.	source ifNil: [^ self problem: 'no source' sel: selector in: class].	trailer _ oldMethod trailer.	methodNode _ Compiler new		compile: source in: class notifying: self		ifFail: [^ self problem: 'syntax error' sel: selector in: class].	selector == methodNode selector ifFalse: [		^ self problem: 'selector changed' sel: selector in: class].	newMethod _ methodNode generate: trailer.	class addSelectorSilently: selector withMethod: newMethod.! !!Recompiler methodsFor: 'recompile' stamp: 'md 7/24/2007 16:23'!recompile: selector inTrait: trait	"Recompile method in class. If method can't be recompiled (because of compile error) add it to problemMethods with general reason"	| source oldMethod trailer methodNode newMethod |		"do not recompile Traits methods here, they are recompiled 	and reinstalled when the trait is recompiled"		(trait includesLocalSelector: selector) ifFalse: [^self].			oldMethod _ trait compiledMethodAt: selector.	source _ trait sourceCodeAt: selector.	source ifNil: [^ self problem: 'no source' sel: selector in: trait].	trailer _ oldMethod trailer.	methodNode _ Compiler new		compile: source in: trait notifying: self		ifFail: [^ self problem: 'syntax error' sel: selector in: trait].	selector == methodNode selector ifFalse: [		^ self problem: 'selector changed' sel: selector in: trait].	newMethod _ methodNode generate: trailer.	trait addSelectorSilently: selector withMethod: newMethod.		"now update all the classes that have this trait imported"	trait updateMethodDictionarySelector: selector.! !!Recompiler methodsFor: 'recompile' stamp: 'ajh 5/19/2004 23:29'!recompileClass: class	{class. class class} do: [:behavior |		behavior selectorsDo: [:selector |			[self recompile: selector in: behavior]				on: Error				do: [:ex | self problem: ex description sel: selector in: behavior]]]! !!Recompiler methodsFor: 'recompile' stamp: 'md 7/24/2007 16:16'!recompileImage	"Recomiles all class/instance methods in image. Methods that can't be recompiled (because of compile error) are added to problemMethods and are not recompiled"	"ProtoObject allSubclasses includes metaclasses"	| m |	m _ 0.	Smalltalk allClassesDo: [:class | m _ m + 1].	'Recompiling ', m printString, ' classes'		displayProgressAt: Sensor cursorPoint from: 0 to: m		during: [:bar | | n |			n _ 0.			Smalltalk allClassesDo: [:class |				self recompileClass: class.				bar value: (n _ n + 1)].			self recompileClass: ProtoObject.		].	m _ 0.	Smalltalk allTraitsDo: [:class | m _ m + 1].	'Recompiling ', m printString, ' traits'		displayProgressAt: Sensor cursorPoint from: 0 to: m		during: [:bar | | n |			n _ 0.			Smalltalk allTraitsDo: [:trait |				self recompileTrait: trait.				bar value: (n _ n + 1)].		].	! !!Recompiler methodsFor: 'recompile' stamp: 'md 7/24/2007 16:18'!recompileTrait: trait	{trait. trait classTrait} do: [:behavior |		behavior selectorsDo: [:selector |			[self recompile: selector inTrait: behavior]				on: Error				do: [:ex | self problem: ex description sel: selector in: behavior]]]! !!Recompiler methodsFor: 'accessing' stamp: 'ms 7/10/2007 16:15'!decompiler	^ decompiler ifNil: [decompiler := Decompiler2 new]! !!Recompiler methodsFor: 'accessing' stamp: 'ms 7/10/2007 16:14'!decompiler: anObject	decompiler := anObject! !!Recompiler methodsFor: 'problem methods' stamp: 'ms 7/10/2007 16:25'!initialize	problemMethods := OrderedCollection new.! !!Recompiler methodsFor: 'problem methods' stamp: 'ajh 5/19/2004 18:16'!problem: reason sel: selector in: class	problemMethods add: {class. selector. reason}! !!Recompiler methodsFor: 'requestor interface' stamp: 'ajh 5/19/2004 17:32'!interactive	"Batch compiling, not interactive"	^ false! !!Recompiler methodsFor: 'requestor interface' stamp: 'ajh 5/19/2004 17:32'!notify: aString at: anInteger in: aStream	"Called from Parser2 on syntax error. Do nothing and let fail block handle it"! !!Recompiler commentStamp: 'ms 7/11/2007 23:46' prior: 0![Recompiler new inspect; recompileImage] forkAt: 30[Recompiler new inspect; decompileAndRecompileImage] forkAt: 30!!Refactoring methodsFor: 'utilities'!associationForClassVariable: aName in: aClass ifAbsent: aBlock 	^aClass realClass classPool associationAt: aName asSymbol		ifAbsent: [aClass realClass classPool associationAt: aName asString ifAbsent: aBlock]! !!Refactoring methodsFor: 'utilities'!checkInstanceVariableName: aName in: aClass 	^RBCondition checkInstanceVariableName: aName in: aClass! !!Refactoring methodsFor: 'utilities'!checkMethodName: aName in: aClass 	^RBCondition checkMethodName: aName in: aClass! !!Refactoring methodsFor: 'utilities'!poolVariableNamesFor: aClass 	| pools |	pools := Set new.	aClass withAllSuperclasses do: 			[:each | 			each allPoolDictionaryNames do: 					[:pool | 					pools addAll: ((Smalltalk at: pool asSymbol) keys 								collect: [:name | name asString])]].	^pools! !!Refactoring methodsFor: 'utilities'!safeMethodNameFor: aClass basedOn: aString 	"Creates an unused method name containing aString"	| baseString newString hasParam i |	baseString := aString copy.	baseString at: 1 put: baseString first asLowercase.	newString := baseString.	hasParam := newString last = $:.	hasParam 		ifTrue: [baseString := newString copyFrom: 1 to: newString size - 1].	i := 0.	[aClass hierarchyDefinesMethod: newString asSymbol] whileTrue: 			[i := i + 1.			newString := baseString , i printString 						, (hasParam ifTrue: [':'] ifFalse: [''])].	^newString asSymbol! !!Refactoring methodsFor: 'utilities'!whichVariableNode: aParseTree inInterval: anInterval name: aName 	| matcher block |	matcher := ParseTreeSearcher new.	block := 			[:aNode :answer | 			(aNode intersectsInterval: anInterval) ifTrue: [aNode] ifFalse: [answer]].	matcher		matches: aName do: block;		matchesArgument: aName do: block.	^matcher executeTree: aParseTree initialAnswer: nil! !!Refactoring methodsFor: 'testing'!canReferenceVariable: aString in: aClass 	(aClass definesVariable: aString) ifTrue: [^true].	(self model includesGlobal: aString asSymbol) ifTrue: [^true].	^(self poolVariableNamesFor: aClass) includes: aString! !!Refactoring methodsFor: 'accessing'!changes	^self model changes! !!Refactoring methodsFor: 'accessing'!copyOptionsFrom: aDictionary 	| dict |	dict := self options.	dict == self class refactoringOptions 		ifTrue: [^self options: aDictionary copy].	dict keysAndValuesDo: 			[:key :value | 			value == (self class refactoringOptions at: key) 				ifTrue: [dict at: key put: (aDictionary at: key)]].	self options: dict! !!Refactoring methodsFor: 'accessing'!options	^options isNil ifTrue: [self class refactoringOptions] ifFalse: [options]! !!Refactoring methodsFor: 'accessing'!options: aDictionary 	options := aDictionary! !!Refactoring methodsFor: 'accessing'!setOption: aSymbol toUse: aBlock 	| dict |	dict := self options.	dict == self class refactoringOptions ifTrue: [dict := dict copy].	dict at: aSymbol put: aBlock.	self options: dict! !!Refactoring methodsFor: 'support'!checkClass: aRBClass selector: aSelector using: aMatcher 	| parseTree |	parseTree := aRBClass parseTreeFor: aSelector.	parseTree notNil ifTrue: [aMatcher executeTree: parseTree].	^aMatcher answer! !!Refactoring methodsFor: 'support'!convertAllReferencesTo: aSymbol using: searchReplacer 	self model allReferencesTo: aSymbol		do: 			[:method | 			self 				convertMethod: method selector				for: method modelClass				using: searchReplacer]! !!Refactoring methodsFor: 'support'!convertAllReferencesToClass: aRBClass using: searchReplacer 	self model allReferencesToClass: aRBClass		do: 			[:method | 			self 				convertMethod: method selector				for: method modelClass				using: searchReplacer]! !!Refactoring methodsFor: 'support'!convertClasses: classSet select: aBlock using: searchReplacer 	classSet do: 			[:aClass | 			(aBlock value: aClass) do: 					[:selector | 					self 						convertMethod: selector						for: aClass						using: searchReplacer]]! !!Refactoring methodsFor: 'support'!convertMethod: selector for: aClass using: searchReplacer 	"Convert the parse tree for selector using the searchReplacer. If a	change is made then compile it into the changeBuilder."	| parseTree |	parseTree := aClass parseTreeFor: selector.	parseTree isNil ifTrue: [^self].	(searchReplacer executeTree: parseTree) 		ifTrue: [aClass compileTree: searchReplacer tree]! !!Refactoring methodsFor: 'preconditions'!checkPreconditions	| conditions block |	conditions := self preconditions.	conditions check 		ifFalse: 			[block := conditions errorBlock.			block notNil 				ifTrue: [self refactoringError: conditions errorString with: block]				ifFalse: [self refactoringError: conditions errorString]]! !!Refactoring methodsFor: 'preconditions'!preconditions	self subclassResponsibility! !!Refactoring methodsFor: 'private' stamp: 'dc 5/8/2007 12:05'!classObjectFor: anObject 	(anObject isBehavior or: [anObject isTrait]) ifTrue: [^self model classFor: anObject].	anObject isSymbol ifTrue: [^self model classNamed: anObject].	^anObject! !!Refactoring methodsFor: 'private'!onError: aBlock do: errorBlock 	^aBlock on: self class preconditionSignal		do: 			[:ex | 			errorBlock value.			ex return: nil]! !!Refactoring methodsFor: 'private'!primitiveExecute	self checkPreconditions.	self transform! !!Refactoring methodsFor: 'private' stamp: 'md 8/2/2005 23:35'!refactoringError: aString 	RefactoringError signal: aString! !!Refactoring methodsFor: 'private'!refactoringError: aString with: aBlock 	RefactoringError raiseSignal: aString with: aBlock! !!Refactoring methodsFor: 'private' stamp: 'md 8/2/2005 23:35'!refactoringWarning: aString 	RefactoringWarning signal: aString! !!Refactoring methodsFor: 'private'!uniqueMethodNameFor: anInteger 	| before after index name |	before := 'a'.	after := ''.	anInteger timesRepeat: [after := after , 'z:'].	index := 0.		[name := before , index printString , after.	(Symbol findInterned: name) notNil] 			whileTrue: [index := index + 1].	^name asSymbol! !!Refactoring methodsFor: 'transforming'!defaultEnvironment	^BrowserEnvironment new! !!Refactoring methodsFor: 'transforming'!execute	self primitiveExecute.	RefactoringManager instance addRefactoring: self! !!Refactoring methodsFor: 'transforming'!model	^model isNil 		ifTrue: 			[model := (RBNamespace onEnvironment: self defaultEnvironment)						name: self printString;						yourself]		ifFalse: [model]! !!Refactoring methodsFor: 'transforming'!performComponentRefactoring: aRefactoring 	aRefactoring copyOptionsFrom: self options.	aRefactoring primitiveExecute! !!Refactoring methodsFor: 'transforming'!transform	self subclassResponsibility! !!Refactoring methodsFor: 'initialize-release'!initialize! !!Refactoring methodsFor: 'initialize-release'!model: aRBNamespace 	model := aRBNamespace! !!Refactoring methodsFor: 'requests'!openBrowserOn: anEnvironment 	^(self options at: #openBrowser) value: self value: anEnvironment! !!Refactoring methodsFor: 'requests' stamp: 'rr 3/26/2004 10:16'!request: aString	^FillInTheBlank request: aString! !!Refactoring methodsFor: 'requests'!requestImplementorToInline: implementorsCollection 	^(self options at: #implementorToInline) value: self		value: implementorsCollection! !!Refactoring methodsFor: 'requests' stamp: 'dvf 9/8/2001 19:32'!requestMethodNameFor: aMethodName 	^(self options at: #methodName) value: self value: aMethodName! !!Refactoring methodsFor: 'requests'!requestSelfArgumentName	^(self options at: #selfArgumentName) value: self! !!Refactoring methodsFor: 'requests'!selectVariableToMoveMethodTo: aSelector class: aClass 	^(self options at: #selectVariableToMoveTo) 		value: self		value: aClass		value: aSelector! !!Refactoring methodsFor: 'requests' stamp: 'rr 3/15/2004 11:48'!selectVariableTypesFrom: initialTypeCollection selected: selectedTypeCollection 	"Temporary workaround to get something usable here,	which will avoid entering the emergency evaluator too..."		"^(self options at: #variableTypes) 		value: self		value: initialTypeCollection		value: selectedTypeCollection"	| init classes |	init := ''.	initialTypeCollection do: [:each | init := init, each asString, Character space asString].	classes := FillInTheBlank request: 'Here are the types found by the RefactoryTyper.	Since you are smarter than it, you can edit the list to add or remove 	relevant classes at your will' initialAnswer: init.	^ (classes findTokens: Character space asString) collect: 		[:each | self model classFor: (Smalltalk at: each withBlanksTrimmed asSymbol)].	! !!Refactoring methodsFor: 'requests'!shouldExtractAssignmentTo: aString 	^(self options at: #extractAssignment) value: self value: aString! !!Refactoring methodsFor: 'requests'!shouldInlineExpression: aString 	^(self options at: #inlineExpression) value: self value: aString! !!Refactoring methodsFor: 'requests'!shouldOverride: aSelector in: aClass 	^(self options at: #alreadyDefined) 		value: self		value: aClass		value: aSelector! !!Refactoring methodsFor: 'requests'!shouldUseExistingMethod: aSelector 	^(self options at: #useExistingMethod) value: self value: aSelector! !!Refactoring class methodsFor: '-- all --' stamp: 'nk 2/23/2005 14:34'!initializeRefactoringOptions	"self initializeRefactoringOptions"	RefactoringOptions := IdentityDictionary new.	RefactoringOptions		at: #implementorToInline		put: [:ref :imps | ChooserMorph				choose: 'Which implementation should be inlined?'				multipleSelect: false				fromList: imps				values: imps				cancel: []];				at: #methodName		put: [:ref :methodName | MethodNameEditor modalEditorForMethodName: methodName];				at: #selfArgumentName		put: [:ref | ref request: 'Enter name for argument to refer to "self" in extracted method'];				at: #selectVariableToMoveTo		put: [:ref :class :selector | 			| parseTree nameList ignoreList | 			parseTree := class parseTreeFor: selector.			parseTree isNil				ifTrue: [parseTree := RBMethodNode								selector: #value								body: (RBSequenceNode statements: #())].			nameList := OrderedCollection new.			nameList add: '---- Arguments ----';				 addAll: parseTree argumentNames asSortedCollection;				 add: '---- Instance Variables ----'.			ignoreList := OrderedCollection with: 1 with: nameList size.			nameList addAll: class allInstanceVariableNames asSortedCollection.			nameList at: (PopUpMenu labelArray: nameList lines: #()) startUp];				at: #variableTypes		put: [:ref :types :selected | ChooserMorph				choose: 'Choose types'				multipleSelect: true				fromList: types				values: types				cancel: []				initialSelections: selected];				at: #extractAssignment		put: [:ref :varName | ref				confirm: ('Do you want to extract the assignment of <1s><n>at the end of selection?' expandMacrosWith: varName)];				at: #inlineExpression		put: [:ref :string | ref				confirm: ('Do you want to inline "<1s>"? If not, it will be assigned as a temporary.' expandMacrosWith: string)];				at: #alreadyDefined		put: [:ref :cls :selector | ref				confirm: ('<1s> is already defined in the <2p> hierarchy.<n>Extracting it to an existing selector may change behavior.<n>Do you wish to use <1s> anyway?' expandMacrosWith: selector with: cls)];				at: #useExistingMethod		put: [:ref :selector | ref confirm: 'Use existing method ' , selector , ' instead of creating new method?'];				at: #openBrowser		put: [:ref :env | env openEditor]! !!Refactoring class methodsFor: 'accessing signal'!preconditionSignal	^RefactoringError , RefactoringWarning! !!Refactoring class methodsFor: 'accessing'!refactoringOptions	RefactoringOptions isNil ifTrue: [self initializeRefactoringOptions].	^RefactoringOptions! !!Refactoring class methodsFor: 'accessing'!setDefaultOption: aSymbol to: aBlock 	self refactoringOptions at: aSymbol put: aBlock! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:40'!abstractClassVar	| name |	name := self selectClassVar.	name isEmpty ifTrue: [^self].	self abstractClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/19/2000 23:52'!abstractClassVar: aString 	self performRefactoring: (AbstractClassVariableRefactoring 				variable: aString asSymbol				class: (self nonMetaClass whichClassDefinesClassVar: aString))! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:39'!abstractInstVar	| name |	name := self selectInstVar.	name isEmpty ifTrue: [^self].	self abstractInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:02'!abstractInstVar: aString 	self 		performRefactoring: (AbstractInstanceVariableRefactoring variable: aString				class: (self selectedClassOrMetaClass whichClassDefinesInstVar: aString))! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 01:00'!abstractSelectedInstVar	| name |	name := self selectedVariableName.	name isEmpty ifTrue: [^self].	self abstractInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 10:17'!addClassVar	self changeRequest ifFalse: [^self].	self addClassVarIn: self nonMetaClass.	self changedClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 10:19'!addClassVarIn: aClass 	| newName |	newName := self requestClassVarName: ''.	newName isNil ifTrue: [^self].	self handleError: 			[(AddClassVariableRefactoring variable: newName class: aClass) execute]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:02'!addInstVar	self changeRequest ifFalse: [^self].	self addInstVarIn: self selectedClassOrMetaClass.	self changedClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 10:21'!addInstVarIn: aClass 	| newName |	newName := self requestInstVarName: ''.	newName isNil ifTrue: [^self].	self handleError: 			[(AddInstanceVariableRefactoring variable: newName class: aClass) execute]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:02'!bindTight	self performRefactoring: (MoveVariableDefinitionRefactoring 				bindTight: (self convertToSourceInterval: self selectedInterval)				in: self selectedClassOrMetaClass				selector: self selector)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dc 10/19/2007 08:24'!browseClassRefs	| cls |	(cls := self selectedClass) ifNotNil: [	self systemNavigation browseAllCallsOnClass: cls theNonMetaClass ].! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 10:28'!changeClassCategory	| state |	self changeRequest ifFalse: [^self].	state := self getState.	self changeClassCategoryFor: self nonMetaClasses.	self setState: state updateClasses: true.	self changed: #category with: self category! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 10:33'!changeClassCategoryFor: classCollection 	self needsWork.	self error:'not yet implemented.'.	"| dialog newCategory oldCategory changeClasses |	classCollection isEmpty ifTrue: [^self].	oldCategory := self environment whichCategoryIncludes: classCollection first name.	dialog := CategoryDialog new.	dialog organizer: Smalltalk organization.	dialog currentCategory: oldCategory.	dialog open ifFalse: [^self].	newCategory := dialog categoryName asSymbol.	changeClasses := classCollection				select: [:each | (self environment whichCategoryIncludes: each name) ~= newCategory].	changeClasses isEmpty ifTrue: [^self].	changeClasses do: 			[:each | 			Smalltalk organization classify: each name under: newCategory.			ChangeSet current changeClass: each]"! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 11/8/2000 11:21'!convertToSibling	| name subclasses |self needsWork.  "Still not right."	name := self request: 'Enter name for new parent class'.	name isEmpty ifTrue: [^self].	subclasses := self selectSubclassesOf: self nonMetaClass.	subclasses isNil ifTrue: [^self].	self handleError: 			[(ChildrenToSiblingsRefactoring name: name				class: self nonMetaClass				subclasses: subclasses) execute.			self selectClasses: (Array with: name asSymbol)				meta: self isMeta				categories: self categories]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/19/2000 23:50'!createAccessorsForClassVar: aString 	self performRefactoring: (CreateAccessorsForVariableRefactoring 				variable: aString asSymbol				class: (self nonMetaClass whichClassDefinesClassVar: aString)				classVariable: true)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:03'!createAccessorsForInstVar: aString 	self performRefactoring: (CreateAccessorsForVariableRefactoring 				variable: aString				class: (self selectedClassOrMetaClass whichClassDefinesInstVar: aString)				classVariable: false)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 3/4/2005 13:27'!createClassVarAccessors	| name |	name := self selectClassVar.	name isEmptyOrNil ifTrue: [^self].	self createAccessorsForClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:03'!createInstVar	self performRefactoring: (TemporaryToInstanceVariableRefactoring 				class: self selectedClassOrMetaClass				selector: self selector				variable: self selectedText)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:56'!createInstVarAccessors	| name |	name := self selectInstVar.	name isNil ifTrue: [^self].	self createAccessorsForInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:57'!createSelectedClassVarAccessors	| name |	name := self selectedVariableName.	name isNil ifTrue: [^self].	self createAccessorsForClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:56'!createSelectedInstVarAccessors	| name |	name := self selectedVariableName.	name isNil ifTrue: [^self].	self createAccessorsForInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 7/30/2004 17:58'!extractMethod	| currentSelector |	messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	currentSelector := self selectedMessageName.	self performRefactoring: (ExtractMethodRefactoring 				extract: self selectedInterval				from: self selectedMessageName				in: self selectedClassOrMetaClass).	self messageListIndex: (self messageList indexOf: currentSelector).	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 7/30/2004 17:58'!extractMethodToComponent	messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	self performRefactoring: (ExtractMethodToComponentRefactoring 				extract: self selectedInterval				from: self selectedMessageName				in: self selectedClassOrMetaClass).	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/30/2001 02:18'!extractToTemp	| newName node |	self updateRequest ifFalse: [^self].	node := self findNode.	(node isNil or: [node isValue not]) 		ifTrue: [^self warn: 'Could not find the node'].	newName := self request: 'Enter name for Temporary:'.	newName isEmpty ifTrue: [^self].	self performRefactoring: (ExtractToTemporaryRefactoring 				extract: (self convertToSourceInterval: node sourceInterval)				to: newName				from: self selector				in: self selectedClassOrMetaClass)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'fc 12/2/2004 10:42'!findNode	| tree node interval |	interval := self selectedInterval.	interval isEmpty ifTrue: [^nil].	tree := RBParser parseMethod: self text				onError: [:str :err | ^self parseSelection].	node := tree whichNodeIsContainedBy: interval.	node isNil ifTrue: [node := tree bestNodeFor: interval].	^node! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/8/2001 19:57'!handleError: aBlock 	^[Cursor execute showWhile: aBlock] on: Refactoring preconditionSignal		do: 			[:ex | 			ex isResumable 				ifTrue: 					[(self confirm: (ex messageText last == $? 								ifTrue: [ex messageText]								ifFalse: [ex messageText , '\Do you want to proceed?' withCRs])) 						ifTrue: [ex resume]]				ifFalse: 					[ex parameter notNil 						ifTrue: [(self confirm: ex messageText) ifTrue: [ex parameter value]]						ifFalse: [self warn: ex messageText]].			ex return: nil]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:03'!inlineMethod	| node |	node := self findNode.	(node isNil or: [node isMessage not]) 		ifTrue: [^self warn: 'Could not find message send'].	(node receiver isVariable 		and: [#('self' 'super') includes: node receiver name]) 			ifTrue: 				[self performRefactoring: (InlineMethodRefactoring 							inline: (self convertToSourceInterval: node sourceInterval)							inMethod: self selector							forClass: self selectedClassOrMetaClass)]			ifFalse: 				[self performRefactoring: (InlineMethodFromComponentRefactoring 							inline: (self convertToSourceInterval: node sourceInterval)							inMethod: self selector							forClass: self selectedClassOrMetaClass)]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:03'!inlineParameter	self handleError: 			[| ref |			ref := InlineParameterRefactoring 						inlineParameter: self selectedText						in: self selectedClassOrMetaClass						selector: self selector.			ref execute.			"codeModel setSelector: ref newSelector"]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 7/30/2004 17:58'!inlineSelfSends	messageListIndex = 0 ifTrue: [^self].	self handleError: 			[| refactoring aCollection |			refactoring := InlineAllSendersRefactoring sendersOf: self selector						in: self selectedClassOrMetaClass.			refactoring execute.			refactoring messagesNotReplaced > 0 				ifTrue: 					[self warn: ('<1p> message sends were not replaced' 								expandMacrosWith: refactoring messagesNotReplaced)].			self changed: #messageList.			self changedSelector].	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:04'!inlineTemporary	| node |	self updateRequest ifFalse: [^self].	node := self findNode.	(node isNil or: [node isAssignment not]) 		ifTrue: [^self warn: 'Could not find the node'].	self performRefactoring: (InlineTemporaryRefactoring 				inline: (self convertToSourceInterval: node sourceInterval)				from: self selector				in: self selectedClassOrMetaClass)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/15/2000 22:12'!inspectAllInstances	(self nonMetaClass allInstances) inspect! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/29/2001 17:53'!navigateToClass	self navigateToClass: self selectedClassInCode! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/28/2001 23:46'!navigateToClass: foundClass 	self selectCategoryForClass: foundClass.	self selectClass: foundClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 7/31/2004 09:21'!navigateToClassNamed: className 	| foundClass |	foundClass := Smalltalk classNamed: className.	self navigateToClass: foundClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/29/2001 18:13'!openBrowserForClass	self class fullOnClass: self selectedClassInCode! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'fc 12/2/2004 10:45'!parseSelection	^RBParser parseExpression: self selectedText onError: [:str :pos | ^nil]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/1/2001 14:41'!performClassRefactoring: refactoring 	self handleError: 			[refactoring execute.			self changedClass]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/30/2001 01:15'!performRefactoring: aRefactoring 	aRefactoring isNil ifTrue: [^self].	self handleError: 			[aRefactoring execute.			self changed: #messageList.			self changed: #contents]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:43'!protectInstVar	| name |	name := self selectInstVar.	name isNil ifTrue: [^self].	self protectInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:04'!protectInstVar: aString 	self 		performRefactoring: (ProtectInstanceVariableRefactoring variable: aString				class: (self selectedClassOrMetaClass whichClassDefinesInstVar: aString))! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 01:01'!protectSelectedInstVar	| name |	name := self selectedVariableName.	name isNil ifTrue: [^self].	self protectInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/1/2001 14:45'!pullUpClassVar	| classVar |	self changeRequest ifFalse: [^self].	classVar := self selectSubclassClassVar.	classVar isNil ifTrue: [^self].	self pullUpClassVar: self nonMetaClass in: classVar.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/1/2001 14:44'!pullUpClassVar: class in: classVar 	| refactoring |	refactoring := PullUpClassVariableRefactoring variable: classVar				class: class.	self performClassRefactoring: refactoring! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 7/30/2004 17:58'!pullUpInstVar	| instVar |	self changeRequest ifFalse: [^self].	instVar := self selectSubclassInstVar.	instVar isNil ifTrue: [^self].	self handleError: 			[(PullUpInstanceVariableRefactoring variable: instVar				class: self selectedClassOrMetaClass) execute.			self changedClass].	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/30/2001 18:12'!pushDownClassVar	| classVar |	self changeRequest ifFalse: [^self].	classVar := self selectClassVarSupers: false subs: false.	classVar isNil ifTrue: [^self].	self handleError: 			[(PushDownClassVariableRefactoring variable: classVar				class: self nonMetaClass) execute.			self changedClass].self needsWork.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:05'!pushDownInstVar	| instVar |	self changeRequest ifFalse: [^self].	instVar := self selectInstVarSupers: false subs: false.	instVar isNil ifTrue: [^self].	self handleError: 			[(PushDownInstanceVariableRefactoring variable: instVar				class: self selectedClassOrMetaClass) execute.			self changedClass]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/19/2000 23:49'!pushUpClassVar: aString 	self performRefactoring: (PullUpClassVariableRefactoring 				variable: aString asSymbol				class: (self nonMetaClass whichClassDefinesClassVar: aString) superclass)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/1/2001 14:37'!pushUpSelectedClassVar	| name |	name := self selectClassVar.	name isNil ifTrue: [^self].	self pushUpClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'md 2/26/2006 16:53'!pushUpSelectedInstVar	| instVar |	self changeRequest ifFalse: [^self].	instVar := self selectedVariableName.	instVar isNil ifTrue: [^self].	self handleError: 			[(PullUpInstanceVariableRefactoring variable: instVar				class: self selectedClassOrMetaClass superclass) execute.			self changedClass].	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/12/2000 23:15'!removeClassSafe	classListIndex = 0 ifTrue: [^self].	self changeRequest ifFalse: [^self].	self removeClassesSafe: self nonMetaClasses.	self newClassList: self classNames.	self changedClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 11:09'!removeClassVar	| classVar |	self changeRequest ifFalse: [^self].	classVar := self selectClassVarSupers: false subs: false.	classVar isNil ifTrue: [^self].	self handleError: 			[(RemoveClassVariableRefactoring variable: classVar				class: self nonMetaClass) execute.			self changedClass]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/12/2000 23:05'!removeClassesSafe: classCollection 	self handleError: 			[(RemoveClassRefactoring 				classNames: (classCollection collect: [:each | each name])) execute]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:05'!removeInstVar	| instVar |	self changeRequest ifFalse: [^self].	instVar := self selectInstVarSupers: false subs: false.	instVar isNil ifTrue: [^self].	self removeInstVar: instVar fromClass: self selectedClassOrMetaClass.	self changedClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 11:10'!removeInstVar: instVar fromClass: cls 	self handleError: 			[(RemoveInstanceVariableRefactoring variable: instVar class: cls) execute]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 11/2/2002 18:54'!renameClass: aClass 	| aString newName |	aString := self request: 'Enter new ClassName' initialAnswer: aClass name.	aString isEmpty ifTrue: [^self].	newName := aString asSymbol.	self handleError: 			[(RenameClassRefactoring rename: aClass to: newName) execute.			self selectClasses: (Array with: aString asSymbol)				meta: self isMeta				categories: self categories.			self changedClass]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 01:11'!renameClassVar	| name |	name := self selectClassVar.	name isNil ifTrue: [^self].	self renameClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/19/2000 23:45'!renameClassVar: aString 	self navigator renameClassVar: aString asSymbol		in: (self nonMetaClass whichClassDefinesClassVar: aString).	self updateContents! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/19/2000 23:46'!renameClassVar: oldName in: aClass 	| newName |	newName := self requestClassVarName: oldName.	newName isNil ifTrue: [^self].	self handleError: 			[(RenameClassVariableRefactoring rename: oldName				to: newName				in: aClass) execute]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/26/2001 17:02'!renameInstVar	| name |	name := self selectInstVarSupers: false subs: false.	name isNil ifTrue: [^self].	self renameInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:07'!renameInstVar: aString 	self navigator renameInstVar: aString		in: (self selectedClassOrMetaClass whichClassDefinesInstVar: aString).	self updateContents! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/26/2001 17:02'!renameInstVar: oldName in: aClass 	| newName |	newName := self requestInstVarName: oldName.	newName isNil ifTrue: [^self].	self handleError: 			[(RenameInstanceVariableRefactoring rename: oldName				to: newName				in: aClass) execute]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'md 3/15/2006 17:28'!renameMethod: aSelector in: aClass 	| oldMethodName newMethodName oldArguments argumentPermutation |	oldArguments := (RBParser parseMethod: self selectedMessage) argumentNames.	oldMethodName := RBMethodName selector: aSelector arguments: oldArguments.	(newMethodName := MethodNameEditor forMethodName: oldMethodName) 		ifNil: [^nil].	argumentPermutation := newMethodName arguments 				collect: [:e | oldArguments indexOf: e].	^self handleError: 			[(RenameMethodRefactoring 				renameMethod: aSelector				in: aClass				to: newMethodName selector				permutation: argumentPermutation) execute.			newMethodName selector]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:55'!renameSelectedClassVar	| name |	name := self selectedVariableName.	name isNil ifTrue: [^self].	self renameClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/27/2003 14:25'!renameSelectedInstVar	| name |	name := self selectedVariableName.	name isNil ifTrue: [^self].	self renameInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:07'!renameTemporary	| newName node |	node := self findNode.	(node isNil or: [node isVariable not]) 		ifTrue: [^self warn: 'Could not find the node'].	newName := self request: 'Enter new name:' initialAnswer: node name.	newName isEmpty ifTrue: [^self].	self performRefactoring: (RenameTemporaryRefactoring 				renameTemporaryFrom: (self convertToSourceInterval: node sourceInterval)				to: newName				in: self selectedClassOrMetaClass				selector: self selector)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:07'!selectClassVar	self selectedClassOrMetaClass chooseClassVarThenDo:[:ivar| ^ivar].	^''.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:07'!selectClassVarSupers: supersBoolean subs: subsBoolean	(supersBoolean & subsBoolean) ifTrue:[^self error:'cannot select cvars from subs and supers yet. sorry.'].	(supersBoolean | subsBoolean) ifFalse:[self selectedClassOrMetaClass chooseThisClassClassVarThenDo:[:ivar| ^ivar]. ^''].	supersBoolean ifTrue:[^self selectClassVar].	subsBoolean ifTrue:[^self selectSubclassClassVar].! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/8/2001 21:03'!selectClassVariables	| variables |	variables := self nonMetaClass classVarNames asSortedCollection.	variables isEmpty ifTrue: [^#()].	^ChooserMorph 		choose: 'Choose variables:'		multipleSelect: true		fromList: variables		values: variables		cancel: [#()]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 11/8/2000 10:53'!selectClasses: classCollection meta: aBoolean categories: categoriesCollection	classCollection ifNotEmpty:		[ :col |		self selectClass: classCollection first ].! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:06'!selectInstVar	self selectedClassOrMetaClass chooseInstVarThenDo:[:ivar| ^ivar].	^''.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:06'!selectInstVarSupers: supersBoolean subs: subsBoolean	(supersBoolean & subsBoolean) ifTrue:[^self error:'cannot select ivars from subs and supers yet. sorry.'].	(supersBoolean | subsBoolean) ifFalse:[self selectedClassOrMetaClass chooseThisClassInstVarThenDo:[:ivar| ^ivar]. ^''].	supersBoolean ifTrue:[^self selectInstVar].	subsBoolean ifTrue:[^self selectSubclassInstVar].! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/8/2001 21:03'!selectInstanceVariables	| variables |	variables := self selectedClass instVarNames asSortedCollection.	variables isEmpty ifTrue: [^#()].	^ChooserMorph 		choose: 'Choose variables:'		multipleSelect: true		fromList: self selectedClass instVarNames		values: self selectedClass instVarNames		cancel: [#()]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:06'!selectSubclassClassVar	self selectedClassOrMetaClass chooseSubclassesClassVarThenDo:[:ivar| ^ivar].	^''.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:06'!selectSubclassInstVar	self selectedClassOrMetaClass chooseSubclassesInstVarThenDo:[:ivar| ^ivar].	^''.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 2/25/2005 08:32'!selectSubclassesOf: aClass 	| subclasses |	subclasses := aClass subclasses 				asSortedCollection: [:a :b | a name < b name].	subclasses isEmpty ifTrue: [^#()].	^ChooserMorph 		choose: ('Choose subclasses of {1}:' translated format: { aClass name })		multipleSelect: true		fromList: subclasses		values: subclasses		cancel: [nil]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:24'!addClassSubMenuTo: aMenu 	| findSubMenu rewriteSubMenu lintSubMenu lastBrowse pkg |	World ifNil: [^aMenu].	pkg := self packageForSelectedCategory.	findSubMenu := (MenuMorph new)				defaultTarget: self;				add: 'code in class...' translated action: #finderOnClass;				add: 'code in class hierarchy...' translated					action: #finderOnClassHierarchy;				add: 'code in class category...' translated action: #finderOnClassCategory;				yourself.	pkg ifNotNil: 			[findSubMenu add: 'code in package...' translated				action: #finderOnPackageWithClassCategory].	rewriteSubMenu := (MenuMorph new)				defaultTarget: self;				add: 'code in class...' translated action: #rewriteToolOnClass;				add: 'code in class hierarchy...' translated					action: #rewriteToolOnClassHierarchy;				add: 'code in class category...' translated					action: #rewriteToolOnClassCategory;				yourself.	pkg ifNotNil: 			[rewriteSubMenu add: 'code in package...' translated				action: #rewriteToolOnPackageWithClassCategory].	lintSubMenu := (MenuMorph new)				defaultTarget: self;				addLine;				add: 'on class...' translated action: #lintOnClass;				add: 'on class category...' translated action: #lintOnClassCategory;				add: 'on class hierarchy...' translated action: #lintOnClassHierarchy;				yourself.	pkg ifNotNil: 			[lintSubMenu add: 'on package...' translated				action: #lintOnPackageWithClassCategory].	aMenu defaultTarget: aMenu.	lastBrowse := 4.	pkg ifNotNil: 			[aMenu				add: 'browse package ' , pkg packageName					target: self					action: #browsePackageWithClassCategory;				addMorph: aMenu submorphs last asElementNumber: 4.			lastBrowse := 5].	aMenu		add: 'browse category' translated			target: self			action: #browseSelectedClassCategory;		addMorph: aMenu submorphs last asElementNumber: lastBrowse.	aMenu		add: 'find...' subMenu: findSubMenu;		add: 'rewrite...' subMenu: rewriteSubMenu;		add: 'lint...' subMenu: lintSubMenu;		addLine;		add: 'class'			subMenu: ((MenuMorph new)					defaultTarget: self;					addLine;					add: 'references...' translated action: #classRefs;					add: 'create subclass...' translated action: #createSubclass;					add: 'rename as...' translated action: #rbRenameClass;					add: 'remove...' translated action: #removeClass;					add: 'safe remove' translated action: #removeClassSafe;					add: 'convert to sibling' translated action: #convertToSibling;					add: 'inspect all instances...' translated action: #inspectAllInstances;					add: 'find reference path to an instance...' translated						action: #findReferencePathToInstance;					add: 'find all reference paths to an instance...' translated						action: #findAllReferencesToInstances;					add: 'check protocols...' translated action: #checkProtocols;					yourself)! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!addClassVariableSubMenuTo: aMenu 	World ifNotNil: 			[aMenu defaultTarget: aMenu.			aMenu add: 'class variables'				subMenu: ((MenuMorph new)						defaultTarget: self;						add: 'references...' translated action: #classVarRefs;						add: 'add...' translated action: #addClassVar;						add: 'rename as...' translated action: #renameClassVar;						add: 'remove...' translated action: #removeClassVar;						add: 'push down...' translated action: #pushDownClassVar;						add: 'pull up...' translated action: #pullUpClassVar;						add: 'create accessors...' translated action: #createClassVarAccessors;						add: 'abstract...' translated action: #abstractClassVar;						yourself)]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!addInstanceVariableSubMenuTo: aMenu 	World ifNotNil: 			[aMenu defaultTarget: aMenu.			aMenu add: 'instance variables'				subMenu: ((MenuMorph new)						defaultTarget: self;						add: 'references...' translated action: #instVarRefs;						add: 'readers...' translated action: #instVarReaders;						add: 'writers...' translated action: #instVarWriters;						add: 'add...' translated action: #addInstVar;						add: 'rename as...' translated action: #renameInstVar;						add: 'remove...' translated action: #removeInstVar;						add: 'push down...' translated action: #pushDownInstVar;						add: 'pull up...' translated action: #pullUpInstVar;						add: 'create accessors...' translated action: #createInstVarAccessors;						add: 'abstract...' translated action: #abstractInstVar;						add: 'protect/concrete...' translated action: #protectInstVar;						yourself)]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 12:24'!addSelectionSubMenuTo: aMenu	| title subMenu |	World ifNotNil: 		[aMenu defaultTarget: aMenu.		title := 'selection...'.		subMenu := self selectMenu. 		aMenu add: title subMenu: subMenu]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!assignmentMenuFor: aNode 	^(MenuMorph new)		defaultTarget: self;		add: 'inline temporary' translated action: #inlineTemporary;		yourself! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 12:36'!classListMenu: aMenu shifted: shifted 	| moreItem |	super classListMenu: aMenu shifted: shifted.	shifted 		ifFalse: 			[moreItem := aMenu submorphs last.			moreItem delete.			self addClassSubMenuTo: aMenu.			self addClassVariableSubMenuTo: aMenu.			self addInstanceVariableSubMenuTo: aMenu.			aMenu addLine.			aMenu addMorphBack: moreItem].	^aMenu! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!classVariableMenu	^(MenuMorph new)		defaultTarget: self;		add: 'references...' translated action: #browseClassVarRefs;		add: 'rename class variable...' translated action: #renameClassVar;		add: 'push up' translated action: #pushUpSelectedClassVar;		add: 'create accessors' translated action: #createClassVarAccessors;		add: 'abstract' translated action: #abstractClassVar;		yourself! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/5/2005 16:45'!codePaneMenu: aMenu shifted: shifted 	| moreItem |	super codePaneMenu: aMenu shifted: shifted.	moreItem := aMenu submorphs last.	moreItem delete.	aMenu add: 'extract method' translated action: #extractMethod.	aMenu add: 'extract method to component' translated		action: #extractMethodToComponent.	self addSelectionSubMenuTo: aMenu.	aMenu addLine; addMorphBack: moreItem.	^aMenu! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!globalVariableMenuFor: aNode 	^(MenuMorph new)		defaultTarget: self;		add: 'navigate to' translated action: #navigateToClass;		add: 'open browser on...' translated action: #openBrowserForClass;		add: 'browse references...' translated action: #browseReferencesToGlobal;		yourself! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!instanceVariableMenu	^(MenuMorph new)		defaultTarget: self;		add: 'references...' translated action: #browseSelectedInstVarRefs;		add: 'readers...' translated action: #browseSelectedInstVarReaders;		add: 'writers...' translated action: #browseSelectedInstVarWriters;		add: 'rename instance variable...' translated			action: #renameSelectedInstVar;		add: 'pull up' translated action: #pushUpSelectedInstVar;		add: 'create accessors' translated action: #createSelectedInstVarAccessors;		add: 'abstract' translated action: #abstractSelectedInstVar;		add: 'protect/concrete' translated action: #protectSelectedInstVar;		yourself! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 12:25'!messageListMenu: aMenu shifted: shifted 	^shifted ifFalse: [		super messageListMenu: aMenu shifted: shifted.		aMenu addStayUpItem.		aMenu submorphs last delete.		aMenu addTranslatedList: #(			#-			#('safe remove' #removeMethodSafe) 			#('add parameter' #addParameter) 			#('rename method' #renameMethod) 			#('inline all self sends' #inlineSelfSends) 			#('push up' #pushUpMethod) 			#('push down' #pushDownMethod) 			#-			#('more...' #shiftedYellowButtonActivity))]		ifTrue: [self shiftedMessageListMenu: aMenu]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!messageMenuFor: aNode 	"add: stuff action: bar"	^(MenuMorph new)		defaultTarget: self;		add: 'senders...' translated action: #browseSenders;		add: 'implementors...' translated action: #browseImplementors;		add: 'inline message' translated action: #inlineMethod;		add: 'extract to temporary...' translated action: #extractToTemp;		yourself! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!noMenu	^(MenuMorph new)		add: 'no selection' translated action: #printString;		yourself! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!parameterMenu	"MenuEditor new openOnClass: self andSelector: #temporaryMenu"	^(MenuMorph new)		defaultTarget: self;		add: 'remove parameter' translated action: #removeParameter;		add: 'inline parameter' translated action: #inlineParameter;		add: 'rename...' translated action: #renameTemporary;		yourself	"Things that used to be here -#(#MenuItem #rawLabel: 'con&vert to instance variable' #value: #createInstVar) #(#MenuItem #rawLabel: 'move to inner &scope' #value: #bindTight)) #(5) nil) 		decodeAsLiteralArray"! !!RefactoringBrowser methodsFor: 'menus' stamp: 'bh 5/17/2000 21:12'!selectMenu	| node |	node := self findNode.	node isNil ifTrue: [^self noMenu].	node isVariable ifTrue: [^self selectVariableMenuFor: node].	node isMessage ifTrue: [^self messageMenuFor: node].	node isAssignment ifTrue: [^self assignmentMenuFor: node].	node isValue ifTrue: [^self valueNodeMenuFor: node].	^self noMenu! !!RefactoringBrowser methodsFor: 'menus' stamp: 'bh 10/15/2000 21:06'!selectVariableMenuFor: aNode 	(aNode whoDefines: aNode name) notNil 		ifTrue: [^self temporaryMenuFor: aNode].	(self selectedClassOrMetaClass allInstVarNames includes: aNode name) 		ifTrue: [^self instanceVariableMenu].	(self nonMetaClass allClassVarNames 		detect: [:each | each asString = aNode name]		ifNone: [nil]) notNil 		ifTrue: [^self classVariableMenu].	^(Smalltalk includesKey: aNode name asSymbol) 		ifTrue: 			[self globalVariableMenuFor: (Smalltalk associationAt: aNode name asSymbol)]		ifFalse: [self noMenu]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:24'!systemCategoryMenu: aMenu 	| newMenu findSubMenu rewriteSubMenu lintSubMenu |	newMenu := super systemCategoryMenu: aMenu.	newMenu addLine.	findSubMenu := (MenuMorph new)				defaultTarget: self;				add: 'code in class category...' translated action: #finderOnClassCategory;				add: 'code in package...' translated					target: self					action: #finderOnPackageWithClassCategory;				yourself.	rewriteSubMenu := (MenuMorph new)				defaultTarget: self;				add: 'code in class category...' translated					action: #rewriteToolOnClassCategory;				add: 'code in package...' translated					target: self					action: #rewriteToolOnPackageWithClassCategory;				yourself.	lintSubMenu := (MenuMorph new)				defaultTarget: self;				addLine;				add: 'on class category...' translated action: #lintOnClassCategory;				add: 'on package...' translated action: #lintOnPackageWithClassCategory;				yourself.	newMenu		add: 'find...' subMenu: findSubMenu;		add: 'rewrite...' subMenu: rewriteSubMenu;		add: 'lint...' subMenu: lintSubMenu.	newMenu addLine.	self packageForSelectedCategory ifNotNilDo: 			[:pkg | 			newMenu 				add: 'browse package ' , pkg packageName				target: self				action: #browsePackageWithClassCategory].	newMenu 		add: 'browse category' translated		target: self		action: #browseSelectedClassCategory.	^newMenu! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!temporaryMenu	"MenuEditor new openOnClass: self andSelector: #temporaryMenu"	^(MenuMorph new)		defaultTarget: self;		add: 'convert to instance variable' translated action: #createInstVar;		add: 'rename...' translated action: #renameTemporary;		add: 'move to inner scope' translated action: #bindTight;		yourself! !!RefactoringBrowser methodsFor: 'menus' stamp: 'dvf 9/1/2001 19:07'!temporaryMenuFor: aNode 	aNode parent ifNil:[^self noMenu].	^aNode parent isMethod		ifTrue:[self parameterMenu]		ifFalse:[self temporaryMenu].! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!valueNodeMenuFor: aNode 	^(MenuMorph new)		defaultTarget: self;		add: 'extract to temporary...' translated action: #extractToTemp;		yourself! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'nk 7/30/2004 17:57'!addParameter	| newSelector aCollection |	messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	newSelector := self addParameterTo: self selector				in: self selectedClassOrMetaClass.	newSelector isNil ifTrue: [^self].	aCollection := Array with: newSelector.	self changed: #messageList.	self changedSelector.	Beeper  beep! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'dvf 9/30/2001 02:16'!addParameterTo: aSelector in: aClass 	| initializer newSelector initialAnswer |	initialAnswer := aSelector numArgs == 0 				ifTrue: [aSelector , ':']				ifFalse: [aSelector].	newSelector := self request: 'Enter new selector:'				initialAnswer: initialAnswer.	newSelector isEmpty ifTrue: [^nil].	initializer := self request: 'Enter default value for parameter:'				initialAnswer: 'nil'.	initializer isEmpty ifTrue: [^nil].	^self handleError: 			[(AddParameterRefactoring 				addParameterToMethod: aSelector				in: aClass				newSelector: newSelector asSymbol				initializer: initializer) execute.			newSelector]! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'nk 7/30/2004 17:58'!pushDownMethod	messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	self handleError: 			[(PushDownMethodRefactoring pushDown: { 						self selectedMessageName}				from: self selectedClassOrMetaClass) execute.			self changed: #messageList.			self changed: #contents].	Beeper  beep! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'nk 7/30/2004 17:58'!pushUpMethod	messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	self handleError: 			[(PushUpMethodRefactoring pushUp: { 						self selectedMessageName}				from: self selectedClassOrMetaClass) execute.			self changed: #messageList.			self changed: #contents].	Beeper  beep! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'nk 7/30/2004 17:58'!removeMethodSafe	messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	self removeMethodsSafe: self selectors from: self selectedClassOrMetaClass.	self changed: #messageList.	self changedSelector.	Beeper  beep! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'bh 5/12/2000 21:58'!removeMethodsSafe: sels from: cls 	self		handleError: [(RemoveMethodRefactoring removeMethods: sels from: cls) execute]! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'bh 10/15/2000 21:07'!removeParameter	self handleError: 			[| ref |			ref := RemoveParameterRefactoring 						removeParameter: self selectedText						in: self selectedClassOrMetaClass						selector: self selector.			ref execute.			"codeModel setSelector: ref newSelector"]! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'nk 7/30/2004 17:58'!renameMethod	| newSelector |	messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	newSelector := self renameMethod: self selector				in: self selectedClassOrMetaClass.	newSelector isNil ifTrue: [^self].	self changed: #messageList.	self messageListIndex: (self messageList indexOf: newSelector).	self changedSelector.	Beeper  beep! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:49'!browseAllCallsOn: aSymbol	((BrowserEnvironment new)			referencesTo: aSymbol) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:23'!browseAllCallsOn: aSymbol localTo: aClass 	| localClasses |	aClass ifNil: [ ^self inform: 'no class selected' ].	localClasses := OrderedCollection new.	aClass withAllSubAndSuperclassesDo: [ :cls | localClasses add: cls ].	((BrowserEnvironment new forClasses: localClasses)			referencesTo: aSymbol) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/28/2005 08:05'!browseAllImplementorsOf: aSymbol	((BrowserEnvironment new)			implementorsOf: aSymbol) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:23'!browseAllImplementorsOf: aSymbol localTo: aClass 	| localClasses |	aClass ifNil: [ ^self inform: 'no class selected' ].	localClasses := OrderedCollection new.	aClass withAllSubAndSuperclassesDo: [ :cls | localClasses add: cls ].	((BrowserEnvironment new forClasses: localClasses)			implementorsOf: aSymbol) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:40'!browseAllMessages	"Create and schedule a message set browser on all implementors of all the messages sent by the current method."	| aName method filteredList result |	(aName := self selectedMessageName) ifNotNil: 			[method := self selectedClassOrMetaClass compiledMethodAt: aName.			filteredList := method messages 						reject: [:each | #(#new #initialize #=) includes: each].			filteredList := filteredList inject: Set new						into: 							[:s :sel | 							s								addAll: (self systemNavigation allImplementorsOf: sel);								yourself].			result := SelectorEnvironment new.			filteredList 				do: [:mr | result addClass: mr actualClass selector: mr methodSymbol].			result openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/20/2000 11:15'!browseGlobalInstVarReadersTo: instVar in: aClass 	self showWaitCursorWhile: 			[(BrowserEnvironment new instVarReadersTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/20/2000 00:01'!browseGlobalInstVarRefsTo: instVar in: aClass 	self showWaitCursorWhile: 			[(BrowserEnvironment new instVarRefsTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/20/2000 11:15'!browseGlobalInstVarWritersTo: instVar in: aClass 	self showWaitCursorWhile: 			[(BrowserEnvironment new instVarWritersTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/19/2000 23:57'!browseGlobalReferencesTo: aLiteral 	self showWaitCursorWhile: 			[(BrowserEnvironment new referencesTo: aLiteral) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/19/2000 23:34'!browseGlobalReferencesTo: aLiteral in: aClass 	self showWaitCursorWhile: 			[(BrowserEnvironment new referencesTo: aLiteral in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/28/2005 08:06'!browseImplementors	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen in or below	the selected class.	Do nothing if no message is chosen."	self getSelectorAndSendQuery: #browseAllImplementorsOf:		to: self navigator! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:48'!browseImplementorsOf: aSymbol	(SelectorEnvironment implementorsOf: aSymbol in: BrowserEnvironment new) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 15:58'!browseInstVarDefs	self browseInstVarWriters! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 13:28'!browseInstVarReaders	| name |	name := self selectInstVar.	name isEmptyOrNil ifTrue: [^self].	self navigator browseGlobalInstVarReadersTo: name		in: self selectedClassOrMetaClass! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!browseInstVarReadersTo: instVar in: aClass 	self showWaitCursorWhile: 			[(self browserEnvironment instVarReadersTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'dc 10/19/2007 08:26'!browseInstVarRefs	"first handle situation where no class selected"	| name |	self selectedClass		ifNil: [^ self inform: 'Nothing selected.'].	name := self selectInstVar.	"then handle the situation where no ivar selected"	name isEmpty		ifFalse: [self systemNavigation browseAllAccessesTo: name from: self selectedClassOrMetaClass ]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!browseInstVarRefsTo: instVar in: aClass 	self showWaitCursorWhile: 			[(self browserEnvironment instVarRefsTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'dc 10/19/2007 08:26'!browseInstVarWriters	| name |	name := self selectInstVar.	name notNil ifTrue: 		[ self systemNavigation 			browseAllStoresInto: name			from: self selectedClassOrMetaClass ]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!browseInstVarWritersTo: instVar in: aClass 	self showWaitCursorWhile: 			[(self browserEnvironment instVarWritersTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:11'!browseLocalImplementors	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen in or below	the selected class.	Do nothing if no message is chosen."	self getSelectorAndSendQuery: #browseAllImplementorsOf:localTo:		to: self navigator		with: { self selectedClass }! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:23'!browseLocalSendersOfMessages	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen in or below	the selected class.	Do nothing if no message is chosen."	self getSelectorAndSendQuery: #browseAllCallsOn:localTo: 		to: self navigator		with: { self selectedClass }! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'hk 5/6/2006 15:59'!browseMessages	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen in or below	the selected class.	Do nothing if no message is chosen."	self getSelectorAndSendQuery: #browseAllImplementorsOf:		to: self systemNavigation! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 13:33'!browsePackageWithClassCategory	(self environmentForPackageWithClassCategory ifNil: [ ^nil ])	openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!browseReferencesTo: aLiteral 	self showWaitCursorWhile: 			[(self browserEnvironment referencesTo: aLiteral) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!browseReferencesTo: aLiteral in: aClass 	self showWaitCursorWhile: 			[(self browserEnvironment referencesTo: aLiteral in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/19/2000 23:57'!browseReferencesToGlobal	| name association |	name := self selectedVariableName.	name isNil ifTrue: [^self].	association := Smalltalk associationAt: name asSymbol ifAbsent: [^self].	self navigator browseGlobalReferencesTo: association! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 16:57'!browseSelectedClassCategory	(self environmentForSelectedClassCategory ifNil: [ ^nil ])	openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'dvf 8/29/2001 00:59'!browseSelectedClassVarRefs	| name association |	name := self selectedVariableName.	association := self navigator findAssociationForClassVariable: name.	self navigator browseGlobalReferencesTo: association in: self nonMetaClass! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'dvf 8/29/2001 00:59'!browseSelectedInstVarReaders	| name |	name := self selectedVariableName.	name notNil 		ifTrue: [self navigator browseGlobalInstVarReadersTo: name in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'dvf 8/29/2001 00:58'!browseSelectedInstVarRefs	| name |	name := self selectedVariableName.	name notNil 		ifTrue: [self navigator browseGlobalInstVarRefsTo: name in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'dvf 8/29/2001 00:58'!browseSelectedInstVarWriters	| name |	name := self selectedVariableName.	name notNil 		ifTrue: [self navigator browseGlobalInstVarWritersTo: name in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/17/2000 22:33'!browseSenders	| node |	node := self findNode.	(node isNil or: [node isMessage not]) ifTrue: [^self].	(BrowserEnvironment new referencesTo: node selector) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'hk 5/6/2006 15:58'!browseSendersOfMessages	"Present a menu of the currently selected message, as well as all messages sent by it.  Open a message set browser of all senders of the selector chosen."	self getSelectorAndSendQuery: #browseAllCallsOn: to: self systemNavigation! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!classRefs	self 		browseReferencesTo: (self browserEnvironment associationAt: self className)! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 6/14/2000 10:49'!classVarRefs	| classVar association |	classVar := self selectClassVarSupers: true subs: false.	classVar isNil ifTrue: [^self].	association := self findAssociationForClassVariable: classVar.	self browseReferencesTo: association in: self nonMetaClass! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 13:28'!instVarReaders	| instVar |	instVar := self selectInstVarSupers: true subs: false.	instVar isEmptyOrNil ifTrue: [^self].	self browseInstVarReadersTo: instVar in: self selectedClassOrMetaClass! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/5/2005 16:18'!instVarRefs	| instVar |	instVar := self selectInstVarSupers: true subs: false.	instVar isEmptyOrNil ifFalse: 		 [self browseInstVarRefsTo: instVar in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 10/15/2000 21:04'!instVarWriters	| instVar |	instVar := self selectInstVarSupers: true subs: false.	instVar notNil		ifTrue: [self browseInstVarWritersTo: instVar in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'cmm 3/24/2006 15:25'!methodHierarchy	self systemNavigation 			methodHierarchyBrowserForClass: (self selectedClassOrMetaClass ifNil: [ ^ self ])			selector: (self selectedMessageName ifNil: [ ^ self ])! !!RefactoringBrowser methodsFor: 'message list menu' stamp: 'nk 2/27/2005 15:52'!browseClassVarRefs	| name association |	name := self selectClassVar.	name isEmptyOrNil ifTrue: [^self].	association := self navigator findAssociationForClassVariable: name.	self navigator browseGlobalReferencesTo: association in: self nonMetaClass! !!RefactoringBrowser methodsFor: 'message list menu' stamp: 'nk 2/27/2005 16:00'!browseClassVariables	self browseClassVarRefs! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'nk 3/4/2005 13:00'!browserEnvironment	^BrowserEnvironment new! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'bh 11/8/2000 15:26'!categories	^#().! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'dvf 10/3/2001 18:18'!checkProtocolFor: aSelector in: aClass 	| exp1 exp2 exp3 exp4 |	self needsWork.	self error:'not yet implemented'. {exp1. [exp2]. exp3. [exp4]} allTrue"	| protocol |	protocol := aClass organization categoryOfElement: aSelector.	^protocol isNil 		ifTrue: 			[(Dialog confirm: aSelector asString 						, ' is not classified under a protocol.\Do you want to classify it?' 								withCRs) 				ifTrue: 					[protocol := Dialog 								request: 'Enter a protocol name for ' asText 										, (aSelector asText emphasizeAllWith: #(#italic)) , ':'.					protocol isEmpty 						ifFalse: 							[self 								moveMethods: (Array with: aSelector)								to: protocol								in: aClass]].			true]		ifFalse: [false]"! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'dvf 9/8/2001 19:58'!checkProtocolMatchFor: aSelector in: aClass 	self needsWork.	self error:'not yet implemented'.[ "comment block"	| protocol superClass superProtocol patchClass |	protocol := aClass organization categoryOfElement: aSelector.	protocol isNil ifTrue: [^false].	superClass := aClass superclass whichClassIncludesSelector: aSelector.	superClass isNil ifTrue: [^false].	superProtocol := superClass organization categoryOfElement: aSelector.	superProtocol == protocol ifTrue: [^false].	superProtocol isNil ifTrue: [^false].	patchClass := self 				choose: (aSelector printString , ' is classified under "' , protocol 						, '" in ' , aClass name 						, '\and under "' , superProtocol 						, '" in ' , superClass name 						, '. Patch?') withCRs				labels: (Array 						with: aClass name asString						with: superClass name asString						with: 'neither')				values: (Array 						with: aClass						with: superClass						with: nil)				default: aClass.	patchClass isNil ifTrue: [^false].	patchClass == aClass 		ifTrue: 			[self 				moveMethods: (Array with: aSelector)				to: superProtocol				in: aClass]		ifFalse: 			[self 				moveMethods: (Array with: aSelector)				to: protocol				in: superClass].	^true].! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'dvf 9/8/2001 19:58'!checkProtocols	self changeRequest ifFalse: [^self].	Cursor wait showWhile: 			[(self nonMetaClasses inject: false				into: 					[:changed :class | 					changed | (self checkProtocolsFor: class)						| (self checkProtocolsFor: class class)])					ifTrue: [self setState: self getState updateClasses: true]					ifFalse: [self warn: 'No changes made.']]! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'nk 3/4/2005 12:53'!checkProtocolsFor: aClass 	^(self browserEnvironment selectorsForClass: aClass) inject: false		into: 			[:bool :each | 			bool | (self checkProtocolFor: each in: aClass) 				| (self checkProtocolMatchFor: each in: aClass)]! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'hboon 11/30/2004 14:23'!createSubclass	| class |	self changeRequest		ifFalse: [^ self].	class := self createSubclassOf: self nonMetaClass.	class isNil		ifTrue: [^ self].			self changedClass.	self selectClass: class! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'hboon 11/30/2004 14:20'!createSubclassOf: aClass 	| name subclasses aCategory categoryChoices |	name := self requestClassName.	name isNil		ifTrue: [^ nil].	subclasses := self selectSubclassesOf: aClass.	subclasses isNil		ifTrue: [^ nil].	categoryChoices := (OrderedCollection with: aClass category) addAll: Smalltalk organization categories;				 yourself.	aCategory := (SelectionMenu selections: categoryChoices lines: #(1 ))				startUpWithCaption: 'Choose a class category:'.	aCategory		ifNil: [^ nil].	^ self		handleError: [(AddClassRefactoring				addClass: name				superclass: aClass				subclasses: subclasses				category: aCategory) execute.			Smalltalk				at: name asSymbol				ifAbsent: []]! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'nk 3/4/2005 12:15'!environmentForPackageWithClassCategory	self selectedEnvironment ifNil: [^nil].	^BrowserEnvironment new 		forPackageContainingClassCategory: self selectedSystemCategoryName! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'nk 3/4/2005 12:21'!environmentForSelectedClassCategory	self selectedEnvironment ifNil: [^nil].	^BrowserEnvironment new forCategories: {self selectedSystemCategoryName}! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'nk 3/4/2005 12:17'!environmentForSelectedClassHierarchy	| classes |	self selectedClass ifNil: [^nil].	classes := Set new.	self selectedClass withAllSubAndSuperclassesDo: [:cls | classes add: cls].	^BrowserEnvironment new forClasses: classes! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'bh 6/14/2000 10:54'!findAllReferencesToInstances	self needsWork.	self error:'ReferenceFinder does not work yet. Sorry.'.	"self showWaitCursorWhile: 			[| paths |			paths := ReferenceFinder findAllPathsToInstanceOf: self selectedClass.			paths isEmpty 				ifTrue: [self warn: 'No reference paths exist']				ifFalse: [paths inspect]]"! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'bh 6/14/2000 11:03'!findReferencePathToInstance	self needsWork.	self error:'ReferenceFinder does not work yet, sorry.'.	"self showWaitCursorWhile: 			[| path |			path := ReferenceFinder findPathToInstanceOf: self selectedClass.			path notNil 				ifTrue: [path inspect]				ifFalse: [self warn: 'No reference paths exist']]"! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'md 7/18/2006 14:23'!packageForSelectedCategory		self selectedSystemCategoryName isNil ifTrue:[ ^ nil].	^PackageInfo allPackages 		detect: [:p | p includesSystemCategory: self selectedSystemCategoryName]		ifNone: []! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'bh 6/14/2000 11:07'!rbRenameClass	self changeRequest ifFalse: [^self].	self renameClass: self nonMetaClass! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'bh 11/7/2000 23:01'!requestClassName	| name |	name := self request: 'Enter a class name:'.	^name isEmpty ifTrue: [nil] ifFalse: [name]! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'dvf 9/29/2001 18:13'!selectedClassInCode	^Smalltalk classNamed: self findNode name asSymbol! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'fc 12/2/2004 10:44'!selectedInterval	^self codeTextMorph selectionInterval! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'fc 12/2/2004 10:46'!selectedText	| interval |	interval := self selectedInterval.	interval isEmpty ifTrue: [^''].	^self codeTextMorph text asString copyFrom: interval first		to: interval last! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'fc 12/2/2004 10:44'!text	^self contents! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 22:29'!changeRequest	^self okToChange.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 6/14/2000 10:30'!changed: aSymbol with:anObject	"Temporary"	aSymbol == #category ifTrue: [ self changed: #categoryList ].	! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'hboon 11/12/2004 15:29'!changedClass	self changed: #categoryList.	self changed: #messageList.	self changed: #classList.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 22:14'!changedSelector	self changed: #contents.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 11/5/2000 22:06'!className	^self selectedClassName.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 23:14'!classNames	^{self selectedClassName}! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:13'!convertToSourceInterval: anInterval 	"Convert the selected interval from our text widget, to the interval in the stored source code.	For this widget, we don't need to do anything."	^anInterval! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:33'!findAssociationForClassVariable: classVar 	| association definingClass name |self needsWork. "well, maybe not work, but needs testing."	definingClass := self nonMetaClass.	association := nil.		[definingClass notNil and: 			[name := definingClass classPool keys 						detect: [:each | each asString = classVar asString]						ifNone: [nil].			association := definingClass classPool associationAt: name ifAbsent: [nil].			association isNil]] 			whileTrue: [definingClass := definingClass superclass].	^association! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 6/14/2000 10:26'!getState	"do nothing, this is temporary"! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 11/8/2000 10:47'!isMeta	^self metaClassIndicated.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:31'!navigator	^self.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 23:13'!newClassList:aCollection	self changed: #classList.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 10/15/2000 21:04'!nonMetaClass	^self selectedClassOrMetaClass.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 10/15/2000 21:04'!nonMetaClasses	^{self selectedClassOrMetaClass}.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'dvf 9/8/2001 20:06'!request: aString	^FillInTheBlank request: aString! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:47'!requestClassVarName: oldName 	| name |	name := self request: 'Enter a class variable name:' initialAnswer: oldName.	(name isEmpty or: [oldName = name]) ifTrue: [^nil].	^name! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/16/2000 23:22'!requestInstVarName: oldName 	| name |	name := self request: 'Enter a instance variable name:' initialAnswer: oldName.	(name isEmpty or: [oldName = name]) ifTrue: [^nil].	^name! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:18'!selectedVariableName	| node |	node := self findNode.	^(node notNil and: [node isVariable]) ifTrue: [node name] ifFalse: [nil]! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 22:10'!selector	^self selectedMessageName.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 22:35'!selectors	^{self selectedMessageName}! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 6/14/2000 10:26'!setState: aNavigatorState updateClasses: aBoolean 	self changedClass.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:37'!showWaitCursorWhile: aBlock	^Cursor execute showWhile:aBlock.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'dvf 8/26/2001 16:33'!updateContents	self changedClass.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:12'!updateRequest	^true.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'dvf 9/8/2001 19:57'!warn: aString	^PopUpMenu notify:aString.! !!RefactoringBrowser methodsFor: 'initialize-release' stamp: 'jf 7/24/2005 01:02'!defaultBrowserTitle	^ 'RB'! !!RefactoringBrowser methodsFor: 'tools' stamp: 'dvf 9/29/2001 00:04'!finderOnClass	self selectedClass ifNil: [^self finderOnClassCategory].	(FinderTool onClass: self selectedClass) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 9/17/2003 12:32'!finderOnClassCategory	(self selectedEnvironment 		ifNil: [FinderTool new] 		ifNotNil: [(FinderTool onClassCategory: self selectedSystemCategoryName)]) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 2/25/2005 07:44'!finderOnClassHierarchy	self selectedClass ifNil: [^self finderOnClassCategory].	(FinderTool onClassHierarchyIncluding: self selectedClass) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 9/17/2003 14:26'!finderOnPackageWithClassCategory	| tool |	tool := (self selectedEnvironment 		ifNil: [FinderTool new] 		ifNotNil: [ FinderTool onPackageWithClassCategory: self selectedSystemCategoryName ]).	tool ifNotNil: [ tool openAsMorph ]! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 3/4/2005 11:11'!lintOnClass	self selectedClass ifNil: [^nil].	LintDialog onEnvironment: (BrowserEnvironment new forClasses: {self selectedClass}).! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 3/4/2005 12:21'!lintOnClassCategory	^LintDialog onEnvironment: (self environmentForSelectedClassCategory ifNil: [ ^nil ]).! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 3/4/2005 12:19'!lintOnClassHierarchy	^LintDialog onEnvironment: (self environmentForSelectedClassHierarchy ifNil: [ ^nil ]).! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 3/4/2005 12:16'!lintOnPackageWithClassCategory	^LintDialog onEnvironment: (self environmentForPackageWithClassCategory ifNil: [ ^nil ])! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 11/3/2004 09:42'!rewriteToolOnClass	self selectedClass ifNil: [^self rewriteToolOnClassCategory].	(RewriteTool onClass: self selectedClass) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 11/3/2004 09:42'!rewriteToolOnClassCategory	(self selectedEnvironment 		ifNil: [RewriteTool new] 		ifNotNil: [(RewriteTool onClassCategory: self selectedSystemCategoryName)]) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 2/25/2005 07:52'!rewriteToolOnClassHierarchy	self selectedClass ifNil: [^self rewriteToolOnClassCategory].	(RewriteTool onClassHierarchyIncluding: self selectedClass) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 11/3/2004 09:42'!rewriteToolOnPackageWithClassCategory	| tool |	tool := (self selectedEnvironment 		ifNil: [RewriteTool new] 		ifNotNil: [ RewriteTool onPackageWithClassCategory: self selectedSystemCategoryName ]).	tool ifNotNil: [ tool openAsMorph ]! !!RefactoringBrowser class methodsFor: 'class initialization' stamp: 'nk 3/4/2005 12:46'!hierarchyBrowserIsRBPreferenceChanged	(Preferences valueOfPreference: #hierarchyBrowserIsRB)		ifTrue: [ HierarchyBrowser superclass == self			ifFalse: [ HierarchyBrowser superclass: self ]]		ifFalse: [ HierarchyBrowser superclass == self			ifTrue: [  HierarchyBrowser superclass: Browser  ]]! !!RefactoringBrowser class methodsFor: 'class initialization' stamp: 'nk 3/4/2005 07:56'!initialize	"self initialize"	TheWorldMenu registerOpenCommand: {'Refactoring Browser'. {self. #openBrowser}}.	self registerInAppRegistry.	Preferences addPreference: #hierarchyBrowserIsRB		categories: #(browsing)		default: true		balloonHelp: 'if true, the HierarchyBrowser will be a kind of RefactoringBrowser'		projectLocal: false		changeInformee: self		changeSelector: #hierarchyBrowserIsRBPreferenceChanged.	self hierarchyBrowserIsRBPreferenceChanged ! !!RefactoringBrowser class methodsFor: 'class initialization' stamp: 'nk 3/4/2005 12:46'!unload	"Called when the class is being removed"	TheWorldMenu unregisterOpenCommandWithReceiver: self.	Preferences removePreference: #hierarchyBrowserIsRB.	HierarchyBrowser superclass == self		ifTrue: [  HierarchyBrowser superclass: Browser  ].! !!RefactoringBrowser class methodsFor: 'instance creation' stamp: 'nk 7/30/2004 16:13'!newOnEnvironment: aBrowserEnvironment	^self new initializeOnEnvironment: aBrowserEnvironment.! !!RefactoringBrowser class methodsFor: 'instance creation' stamp: 'jf 7/24/2005 00:55'!openBrowser	"Create and schedule a BrowserView with label 'RB'. The 	view consists of five subviews, starting with the list view of system 	categories of SystemOrganization. The initial text view part is empty."	self openBrowserView: (self new openEditString: nil)			label: 'RB'! !!RefactoringBrowser class methodsFor: 'instance creation' stamp: 'nk 7/30/2004 16:09'!openOnEnvironment: aBrowserEnvironment		^(self newOnEnvironment: aBrowserEnvironment) open.! !!RefactoringBrowserTest methodsFor: 'private'!convertInterval: anInterval for: aString 	"Convert the interval to ignore differences in end of line conventions."	^anInterval! !!RefactoringBrowserTest methodsFor: 'private'!executeRefactoring: aRefactoring 	aRefactoring primitiveExecute.	RBParser parseExpression: aRefactoring storeString! !!RefactoringBrowserTest methodsFor: 'private'!objectClassVariable	^Object classPool keys detect: [:each | true]! !!RefactoringBrowserTest methodsFor: 'private' stamp: 'md 8/2/2005 23:36'!proceedThroughWarning: aBlock 	aBlock on: RefactoringWarning do: [:ex | ex resume]! !!RefactoringBrowserTest class methodsFor: 'as yet unclassified' stamp: 'nk 2/23/2005 15:36'!runAllTests	"	RefactoringBrowserTest runAllTests	"	| package runner |	package := PackageInfo named: 'Refactory'.	runner := TestRunner new.	runner openAsMorph.	runner selectTestsSuchThat: [ :t | package includesClass: (Smalltalk classNamed: t) ].! !!RefactoringError methodsFor: 'as yet unclassified' stamp: 'dvf 9/15/2001 16:28'!parameter 	self needsWork."what should we do?"	^parameter.	! !!RefactoringError methodsFor: 'as yet unclassified' stamp: 'dvf 9/15/2001 16:28'!parameter: anObject 	self needsWork."what should we do?"	parameter := anObject.	! !!RefactoringError class methodsFor: 'signalling' stamp: 'md 8/2/2005 23:35'!raiseSignal: aString with: anObject 	"Raise an an exception."	^(self new)		searchFrom: thisContext sender;		messageText: aString;		parameter: anObject;		signal.! !!RefactoringManager methodsFor: 'public access'!addRefactoring: aRefactoring 	RefactoryChangeManager instance performChange: aRefactoring changes.	refactorings add: aRefactoring class name! !!RefactoringManager methodsFor: 'initialize-release'!initialize	refactorings := Bag new! !!RefactoringManager methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: '#		Refactoring';		cr;		nextPutAll: '---		-----------------------------------------------';		cr.	refactorings asSet asSortedCollection do: 			[:name | 			aStream nextPutAll: (refactorings occurrencesOf: name) printString;				nextPutAll: '		';				nextPutAll: name;				cr]! !!RefactoringManager class methodsFor: 'instance creation'!instance	Instance isNil		ifTrue:			[Instance := self basicNew.			Instance initialize].	^Instance! !!RefactoringManager class methodsFor: 'instance creation'!new	^self shouldNotImplement! !!RefactoringManager class methodsFor: 'public access'!nuke	Instance notNil ifTrue: [Instance release].	Instance := nil! !!RefactoringManager class methodsFor: 'parcel load/unload/save'!preUnloadActionFor: aParcel	^RefactoringManager nuke! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:28'!abstractClassVariable	^ ServiceAction		text: 'Abstract class variable'		button: 'abstract'		description: 'Replaces all direct accesses to the class variable by	message sends to the class'		action: [:r | (AbstractClassVariableRefactoring variable: r getClassVariable class: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:14'!abstractInstanceVariable	^ ServiceAction		text: 'Abstract instance variable'		button: 'Abstract iv'		description: 'Creates accessors and selectors for the selected instance variable,	and replaces all references and assignments to the iv in the code	with call to the accessors'		action: [:r | (AbstractInstanceVariableRefactoring variable: r getInstanceVariableName class: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:36'!accessorsForClassVariable	^ ServiceAction		text: 'Create accessors for class variable'		button: 'accessors'		description: 'Creates getters and setters for the selected class variable'		action: [:r | (CreateAccessorsForClassVariableRefactoring				variable: r getClassVariable				class: r getClass				classVariable: true) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:34'!accessorsForInstanceVariable	^ ServiceAction		text: 'Create accessors for instance variable'		button: 'iv accessors'		description: 'Creates getters and setters for the selected instance variable'		action: [:r | (CreateAccessorsForInstanceVariableRefactoring				variable: r getInstanceVariable				class: r getClass				classVariable: false) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:13'!addClass	^ ServiceAction		text: 'New class'		description: 'Create a new subclass of a class. You can also name	some of the class''s subclasses to become subclasses	of the newly created class'		action: [:r | (AddClassRefactoring				addClass: r getNewClassName				superclass: r getClass				subclasses: r getSubclasses				category: r getCategoryName) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:29'!addClassVariable	^ ServiceAction		text: 'Add class variable'		button: 'add'		description: 'Adds a class variable to the class'		action: [:r | (AddClassVariableRefactoring variable: r getNewVariableName class: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:28'!addInstanceVariable	^ ServiceAction		text: 'Add instance variable'		button: 'add iv'		description: 'Adds an instance variable to the selected class'		action: [:r | (AddInstanceVariableRefactoring variable: (r caption: 'enter new instance variable name';					 getSymbol) class: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:28'!addMethod	^ ServiceAction		text: 'Add method'		description: 'Enter the method name and body, 		the class to implement it in, and		the method category to classify		the new method'		action: [:r | (AddMethodRefactoring				addMethod: r getMethodBody				toClass: r getClass				inProtocols: r getMethodCategoryName) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:14'!addParameter	^ ServiceAction		text: 'Add parameter'		description: 'Adds a parameter to the method.	Requests the new message name,	and an initialization expression for	the new parameter to insert in all	senders of the message'		action: [:r | (AddParameterRefactoring				addParameterToMethod: r getSelector				in: r getClass				newSelector: r getNewSelectorName				initializer: r getInitializingExpressionForTheNewParameter) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:36'!childrenToSiblings	^ ServiceAction		text: 'Convert subclasses to sibling classes'		button: 'sibling'		description: 'Creates a new class which will the selected	class'' superclass. You will then be prompted 	to choose some of the subclasses of this class.	Those classes will become subclasses of the	new class (they''re pushed up). 		Warning : this refactoring involves quite 	a lot of recompilation, so be patient'		action: [:r | (ChildrenToSiblingsRefactoring				name: r getNewSuperClassName				class: r getClass				subclassesNames: r getSubclassesToMoveCollection) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 1/9/2006 19:04'!classRefactorings	^ ServiceCategory 		 text:'Class Refactorings'		 button:''		 description:''! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 1/9/2006 19:04'!classVariableRefactorings	^ ServiceCategory 		 text:'Class Variable'		 button:''		 description:''! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 1/9/2006 19:05'!codeSelectionRefactorings	^ ServiceCategory 		 text:'Selection'		 button:''		 description:''! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 9/13/2006 17:11'!extractMethod	^ ServiceAction 		text: 'Extract Method'		button: 'Extract'		description: 'Select a piece of text in a method.	You will be prompted to enter a new method	name. The new method will be created, and 	a call will be inserted. If the selected code	exists in another method, you will be asked	whether to use the other method'		action: 			[:r | 			(ExtractMethodRefactoring 				extract: r getSelection				from: r getSelector				in: r getClass) execute]		condition: self blockExtractableCodeSelected! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 9/13/2006 17:11'!extractMethodToComponent	^ ServiceAction 		text: 'Extract method to component'		button: 'Extract'		description: 'Select a piece of code and an instance or temporary variable.You will then have to choose in this iv''s possible types which one you want to select.The code will be compiled in those classes, and the code will be replaced by a method call on the selected iv.'		action: 			[:r | 			(ExtractMethodToComponentRefactoring 				extract: r getSelection				from: r getSelector				in: r getClass) execute]		condition: self blockExtractableCodeSelected! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 9/13/2006 17:11'!extractToTemporary	^ ServiceAction 		text: 'Extract to temporary variable'		button: 'Extract temp'		description: 'Converts the selected expression in the code to an	assignment in a temporary variable.'		action: 			[:r | 			(ExtractToTemporaryRefactoring 				extract: r getNode interval				to: (r						caption: 'enter a new variable name';						getString)				from: r getSelector				in: r getClass) execute]		condition: self blockExtractableCodeSelected! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/9/2006 22:00'!finderTool	^ ServiceAction		text: 'Find Code'		button: 'find'		description: 'Find some code matching a given pattern'		action: [:r | (FinderTool new searchEnvironment: r getRBEnv environment) openAsMorph]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:34'!inlineAllSenders	^ ServiceAction		text: 'Inline all self sends'		button: 'inline'		description: 'Inlines all the call to the selected message sent by self.	If the message is not called anywhere else, it is removed '		action: [:r | (InlineAllSendersRefactoring sendersOf: r getSelector in: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 9/13/2006 17:12'!inlineMethod	^ ServiceAction 		text: 'Inline method'		button: 'inline'		description: 'select a self message send in the method.	The body of this message will be inserted in	the method'		action: 			[:r | 			(InlineMethodRefactoring 				inline: r getMessageNode interval				inMethod: r getSelector				forClass: r getClass) execute]		condition: self blockSelfMessageSendSelected! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 9/13/2006 17:11'!inlineMethodFromComponent	^ ServiceAction 		text: 'Inline method from component'		button: 'inline comp'		description: 'Select a message send to an iv or temp.	You will be prompted to choose one implementation 	of the message, this implementation will be inlined	in place of the call'		action: 			[:r | 			(InlineMethodFromComponentRefactoring 				inline: r getMessageNode interval				inMethod: r getSelector				forClass: r getClass) execute]		condition: self blockNonSelfMessageSendSelected! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:28'!inlineParameter	^ ServiceAction		text: 'Inline parameter'		button: 'inline param'		description: 'Converts the parameter to a temporary variable.	Works if all the calls to the message gives the	same literal value to the parameter.	The parameter is then removed from the message'		action: [:r | (InlineParameterRefactoring				inlineParameter: r getParameterName				in: r getClass				selector: r getSelector) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:33'!inlineTemporary	^ ServiceAction		text: 'Inline temporary'		button: 'inline'		description: 'Select an assignment to a temp.	All references to the temp will be replaced	by the right part of the assignment.'		action: [:r | (InlineTemporaryRefactoring				inline: r getAssignmentNode interval				from: r getSelector				in: r getClass) execute]		condition: [:r | r getAssignmentNode notNil]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 1/9/2006 19:04'!instanceVariableRefactorings	^ ServiceCategory 		 text:'Instance Variable'		 button:''		 description:''! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/9/2006 22:11'!lintTool	^ ServiceAction		text: 'Code Critic'		button: 'critic'		description: 'Analyse the code for some common defects'		action: [:r | LintDialog onEnvironment: r getRBEnv environment]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 1/9/2006 19:05'!methodRefactorings	^ ServiceCategory 		 text:'Method'		 button:''		 description:''! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:34'!moveMethod	^ ServiceAction		text: 'Move method to variable'		button: 'move'		description: 'Moves the definition of the method to an instance variable	of the class. The message definition is then forwarded to the iv'		action: [:r | (MoveMethodRefactoring				selector: r getSelector				class: r getClass				variable: r getAnyVariable) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 9/13/2006 17:12'!moveVariableDefinition	^ ServiceAction 		text: 'Move variable definition to innermost scope'		button: 'bindTight'		description: 'moves a variable declaration as close to its use as possible.	I.e. if a variable is only used in a block, it''s declaration will	be moved to the beginning of the block.'		action: 			[:r | 			(MoveVariableDefinitionRefactoring 				bindTight: r getSelection				in: r getClass				selector: r getSelector) execute]		condition: self blockVariableSelected! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:13'!protectInstanceVariable	^ ServiceAction		text: 'Protect instance variable'		button: 'protect iv'		description: 'Replaces all accessor by direct accesses to the ivar.	If the accessor are not sent, they are removed as well'		action: [:r | (ProtectInstanceVariableRefactoring variable: r getInstanceVariable class: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:34'!pullUpClassVariable	^ ServiceAction		text: 'Pull up class variable'		button: 'pull up'		description: 'Select a class and a class variable.		 The definition will be moved in the superclass'		action: [:r | (PullUpClassVariableRefactoring variable: r getClassVariable class: r getClass superclass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:33'!pullUpInstanceVariable	^ ServiceAction		text: 'Pull up instance variable'		button: 'pull up iv'		description: 'Select a class and an instance variable 	defined in one of it''s subclasses. 	The definition will be moved in the class'		action: [:r | (PullUpInstanceVariableRefactoring variable: r getInstanceVariable class: r getClass superclass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:32'!pushDownClassVariable	^ ServiceAction		text: 'Push down class variable'		button: 'Push  down'		description: 'Push the definition of the selected class variable	in ONE of the subclasses (duplicating it may break	the code)'		action: [:r | (PushDownClassVariableRefactoring variable: r getClassVariable class: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:36'!pushDownInstanceVariable	^ ServiceAction		text: 'Push down instance variable'		button: 'push down iv'		description: 'Pushes the selected instance variable in	the subclasse of the class. It will only be defined	where it is really used'		action: [:r | (PushDownInstanceVariableRefactoring variable: r getInstanceVariable class: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:35'!pushDownMethod	^ ServiceAction		text: 'push down methods'		button: 'push down'		description: 'Move a method in all of the subclasses of a class.	It''s definition can be duplicated if there are several	subclasses.'		action: [:r | (PushDownMethodRefactoring pushDown: r getSelectorCollection from: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:34'!pushUpMethod	^ ServiceAction		text: 'Push up methods'		button: 'push up'		description: 'Moves the selector to this class'' superclass'		action: [:r | (PushUpMethodRefactoring				pushUp: (Array with: r getMessage)				from: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/10/2006 14:47'!refactoringMenu	^ ServiceCategory		text: 'Refactorings'		button: 'R'		description: 'Accesses all refactoring tools'! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:14'!removeClass	^ ServiceAction		text: 'Remove classes'		description: 'Safely removes the selected class'		action: [:r | (RemoveClassRefactoring				classNames: (Array with: r getClass name)) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:32'!removeClassVariable	^ ServiceAction		text: 'Remove class variable'		button: 'remove'		description: 'Removes the selected class variable'		action: [:r | (RemoveClassVariableRefactoring variable: r getClassVariable class: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:36'!removeInstanceVariable	^ ServiceAction		text: 'Remove instance variable'		button: 'Remove iv'		description: 'Safely removes an instance variable'		action: [:r | (RemoveInstanceVariableRefactoring remove: r getInstanceVariableName from: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:35'!removeMethods	^ ServiceAction		text: 'Remove methods'		description: 'Safely removes the selected methods'		action: [:r | (RemoveMethodRefactoring removeMethods: r getSelectorCollection from: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:32'!removeParameter	^ ServiceAction		text: 'Remove parameter'		button: 'Rm param'		description: 'If a parameter is no more used in a method, you can remove	it, and all senders will be updated'		action: [:r | (RemoveParameterRefactoring				removeParameter: r getParameterName				in: r getClass				selector: r getSelector) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:36'!renameClass	^ ServiceAction		text: 'Rename class'		description: 'Renames a class, changing all references to it'		action: [:r | (RenameClassRefactoring rename: r getClass to: (r caption: 'enter new name';					 getSymbol)) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:33'!renameClassVariable	^ ServiceAction		text: 'Rename class variable'		button: 'Rename'		description: 'Renames a class variable, and update	all references to it.'		action: [:r | (RenameClassVariableRefactoring				rename: r getClassVariableName				to: r getNewVariableName				in: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:35'!renameInstanceVariable	^ ServiceAction		text: 'Rename instance variable'		button: 'rename iv'		description: 'Renames an instance variable,	and update all references to it'		action: [:r | (RenameInstanceVariableRefactoring				rename: r getInstanceVariable				to: r getNewVariableName				in: r getClass) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 9/13/2006 17:08'!renameMethod	^ ServiceAction		text: 'Rename method'		button: 'Rename'		description: 'Renames a method, and fixes all senders.	You can if you want change the orders in	which the arguments are passed to the	new method'		action: [:r | (RenameMethodRefactoring				renameMethod: r getSelector				in: r getClass				to: r getNewSelectorName				permutation: r getArgumentPermutation) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:34'!renameTemporary	^ ServiceAction		text: 'rename local variable'		button: 'Rename'		description: 'Renames a temporary variable !!'		action: [:r | (RenameTemporaryRefactoring				renameTemporaryFrom: r getArgOrTempNode interval				to: r getNewVariableName				in: r getClass				selector: r getSelector) execute]		condition: [:r | r getArgOrTempNode notNil]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/9/2006 22:10'!rewriteTool	^ ServiceAction		text: 'Rewrite Code'		button: 'rewrite'		description: 'Rewrite some code matching a given pattern to another form'		action: [:r | (RewriteTool new searchEnvironment: r getRBEnv environment) openAsMorph]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:36'!splitClass	^ ServiceAction		text: 'Split class in two components'		button: 'split'		description: 'Create a new class at the same level than the old class,	with the list of instance variable selected from the old class.	These ivs are then removed from the old class.	A new iv will be added, on which the request to the	removed iv will be forwarded. Thus the new class	will become a component of the old class.'		action: [:r | (SplitClassRefactoring				class: r getClass				instanceVariables: r getInstanceVariablesToMoveInTheNewClassCollection				newClassName: r getNewClassName				referenceVariableName: r getNewVariableWhereRequestsWillBeForwarded) execute]! !!RefactoringServiceProvider methodsFor: 'services' stamp: 'rr 3/20/2006 13:34'!temporaryToInstanceVariable	^ ServiceAction		text: 'Convert temporary to instance variable'		button: 'convert'		description: 'Converts a temporary variable in a method	to an instance variable of the class'		action: [:r | (TemporaryToInstanceVariableRefactoring				class: r getClass				selector: r getSelector				variable: r getTempNode name) execute]		condition: [:r | r getTempNode notNil]! !!RefactoringServiceProvider methodsFor: 'conditions' stamp: 'rr 9/13/2006 17:11'!blockExtractableCodeSelected	^ 	[:r | 	| n |	n := r getNode.	n parent notNil and: [n parent isMethod not or: [n isVariable not]]		and: [n parent isSequence not or: [n isVariable not]]]! !!RefactoringServiceProvider methodsFor: 'conditions' stamp: 'rr 9/13/2006 17:11'!blockNonSelfMessageSendSelected	^ [:r | r getMessageNode notNil & (self isSelfMessageSend: r getMessageNode) not]! !!RefactoringServiceProvider methodsFor: 'conditions' stamp: 'rr 9/13/2006 17:12'!blockSelfMessageSendSelected	^ [:r | self isSelfMessageSend: r getMessageNode]! !!RefactoringServiceProvider methodsFor: 'conditions' stamp: 'rr 9/13/2006 17:12'!blockVariableSelected	^ [:r | r getSelectionNode isVariable]! !!RefactoringServiceProvider methodsFor: 'conditions' stamp: 'rr 1/9/2006 17:41'!isSelfMessageSend: messageNode 	^messageNode notNil and: [messageNode receiver isVariable]		and: [messageNode receiver name = 'self']! !!RefactoringServiceProvider methodsFor: 'saved preferences'!browserButtonBarrefactoringMenu	^ #(#'Items in browserButtonBar:' #refactoringMenu 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!browserClassMenuclassRefactorings	^ #(#'Items in browserClassMenu:' #classRefactorings 1 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!browserClassMenuclassVariableRefactorings	^ #(#'Items in browserClassMenu:' #classVariableRefactorings 3 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!browserClassMenuinstanceVariableRefactorings	^ #(#'Items in browserClassMenu:' #instanceVariableRefactorings 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!browserCodePaneMenucodeSelectionRefactorings	^ #(#'Items in browserCodePaneMenu:' #codeSelectionRefactorings 1 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!browserMethodMenumethodRefactorings	^ #(#'Items in browserMethodMenu:' #methodRefactorings 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classRefactoringsaddClass	^ #(#'Items in classRefactorings:' #addClass 1 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classRefactoringschildrenToSiblings	^ #(#'Items in classRefactorings:' #childrenToSiblings 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classRefactoringsremoveClass	^ #(#'Items in classRefactorings:' #removeClass 3 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classRefactoringsrenameClass	^ #(#'Items in classRefactorings:' #renameClass 4 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classRefactoringssplitClass	^ #(#'Items in classRefactorings:' #splitClass 5 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classVariableRefactoringsabstractClassVariable	^ #(#'Items in classVariableRefactorings:' #abstractClassVariable 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classVariableRefactoringsaccessorsForClassVariable	^ #(#'Items in classVariableRefactorings:' #accessorsForClassVariable 3 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classVariableRefactoringsaddClassVariable	^ #(#'Items in classVariableRefactorings:' #addClassVariable 1 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classVariableRefactoringspullUpClassVariable	^ #(#'Items in classVariableRefactorings:' #pullUpClassVariable 4 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classVariableRefactoringspushDownClassVariable	^ #(#'Items in classVariableRefactorings:' #pushDownClassVariable 5 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classVariableRefactoringsremoveClassVariable	^ #(#'Items in classVariableRefactorings:' #removeClassVariable 6 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!classVariableRefactoringsrenameClassVariable	^ #(#'Items in classVariableRefactorings:' #renameClassVariable 7 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringsextractMethod	^ #(#'Items in codeSelectionRefactorings:' #extractMethod 1 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringsextractMethodToComponent	^ #(#'Items in codeSelectionRefactorings:' #extractMethodToComponent 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringsextractToTemporary	^ #(#'Items in codeSelectionRefactorings:' #extractToTemporary 3 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringsinlineMethod	^ #(#'Items in codeSelectionRefactorings:' #inlineMethod 4 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringsinlineMethodFromComponent	^ #(#'Items in codeSelectionRefactorings:' #inlineMethodFromComponent 5 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringsinlineTemporary	^ #(#'Items in codeSelectionRefactorings:' #inlineTemporary 6 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringsmoveVariableDefinition	^ #(#'Items in codeSelectionRefactorings:' #moveVariableDefinition 7 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringsrenameTemporary	^ #(#'Items in codeSelectionRefactorings:' #renameTemporary 8 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!codeSelectionRefactoringstemporaryToInstanceVariable	^ #(#'Items in codeSelectionRefactorings:' #temporaryToInstanceVariable 9 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!instanceVariableRefactoringsabstractInstanceVariable	^ #(#'Items in instanceVariableRefactorings:' #abstractInstanceVariable 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!instanceVariableRefactoringsaccessorsForInstanceVariable	^ #(#'Items in instanceVariableRefactorings:' #accessorsForInstanceVariable 3 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!instanceVariableRefactoringsaddInstanceVariable	^ #(#'Items in instanceVariableRefactorings:' #addInstanceVariable 1 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!instanceVariableRefactoringsprotectInstanceVariable	^ #(#'Items in instanceVariableRefactorings:' #protectInstanceVariable 4 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!instanceVariableRefactoringspullUpInstanceVariable	^ #(#'Items in instanceVariableRefactorings:' #pullUpInstanceVariable 5 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!instanceVariableRefactoringspushDownInstanceVariable	^ #(#'Items in instanceVariableRefactorings:' #pushDownInstanceVariable 6 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!instanceVariableRefactoringsremoveInstanceVariable	^ #(#'Items in instanceVariableRefactorings:' #removeInstanceVariable 7 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!instanceVariableRefactoringsrenameInstanceVariable	^ #(#'Items in instanceVariableRefactorings:' #renameInstanceVariable 8 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringsaddMethod	^ #(#'Items in methodRefactorings:' #addMethod 1 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringsaddParameter	^ #(#'Items in methodRefactorings:' #addParameter 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringsinlineAllSenders	^ #(#'Items in methodRefactorings:' #inlineAllSenders 3 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringsinlineParameter	^ #(#'Items in methodRefactorings:' #inlineParameter 4 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringsmoveMethod	^ #(#'Items in methodRefactorings:' #moveMethod 5 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringspushDownMethod	^ #(#'Items in methodRefactorings:' #pushDownMethod 7 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringspushUpMethod	^ #(#'Items in methodRefactorings:' #pushUpMethod 6 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringsremoveMethods	^ #(#'Items in methodRefactorings:' #removeMethods 8 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringsremoveParameter	^ #(#'Items in methodRefactorings:' #removeParameter 9 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!methodRefactoringsrenameMethod	^ #(#'Items in methodRefactorings:' #renameMethod 10 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!refactoringMenuclassRefactorings	^ #(#'Items in refactoringMenu:' #classRefactorings 1 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!refactoringMenuclassVariableRefactorings	^ #(#'Items in refactoringMenu:' #classVariableRefactorings 2 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!refactoringMenucodeSelectionRefactorings	^ #(#'Items in refactoringMenu:' #codeSelectionRefactorings 5 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!refactoringMenufinderTool	^ #(#'Items in refactoringMenu:' #finderTool 6 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!refactoringMenuinstanceVariableRefactorings	^ #(#'Items in refactoringMenu:' #instanceVariableRefactorings 3 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!refactoringMenulintTool	^ #(#'Items in refactoringMenu:' #lintTool 8 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!refactoringMenumethodRefactorings	^ #(#'Items in refactoringMenu:' #methodRefactorings 4 )! !!RefactoringServiceProvider methodsFor: 'saved preferences'!refactoringMenurewriteTool	^ #(#'Items in refactoringMenu:' #rewriteTool 7 )! !!RefactoringServiceProvider class methodsFor: 'initialize-release' stamp: 'rr 2/20/2007 18:09'!initialize	super initialize.	ServiceRegistry current buildProvider: self new! !!RefactoringTest methodsFor: 'private' stamp: 'md 7/25/2005 15:15'!abstractVariableTestData^'| model |(model := RBNamespace 			onEnvironment: ((ClassEnvironment onEnvironment: BrowserEnvironment new) 					classes: (#(#Bar #Foo) inject: OrderedCollection new							into: 								[:sum :each | 								| class |								class := Smalltalk at: each ifAbsent: [nil].								class notNil ifTrue: [sum add: class].								sum]) 								, (#(#Bar #Foo) inject: OrderedCollection new										into: 											[:sum :each | 											| class |											class := Smalltalk at: each ifAbsent: [nil].											class notNil ifTrue: [sum add: class class].											sum])) 						not) 		name: ''Test''.#(''Object subclass: #Foo	instanceVariableNames: ''''instVarName1 instVarName2 ''''	classVariableNames: ''''ClassVarName1 ClassVarName2 ''''	poolDictionaries: ''''''''	category: ''''Testing'''''' ''Foo subclass: #Bar	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Testing'''''') 	do: [:each | model defineClass: each].#(#(#Bar #(#(''instVarName1	^1242321'' #tests) #(''foo	instVarName1 := instVarName1 + instVarName2 + ClassVarName1'' #tests))) #(#Foo #(#(''foo	^instVarName2 := 3'' #tests) #(''bar	"Add one to instVarName1"	instVarName1 := instVarName1 + 1'' #tests) #(''classVarName1	^ClassVarName1'' #tests) #(''instVarName1: anObject	^anObject'' #tests) #(''asdf	^self classVarName1: (ClassVarName1 := ClassVarName1 + 1)'' #tests) #(''instVarName2	^instVarName2'' #tests) #(''instVarName2: anObject	instVarName2 := anObject'' #tests) #(''classVarName1: anObject	^ClassVarName1 := anObject'' #tests))) #(''Bar class'' #(#(''classVarName2: anObject	ClassVarName2 := anObject'' #tests) #(''classVarName2	^ClassVarName2'' #tests))) #(''Foo class'' #(#(''foo	^ClassVarName1 := ClassVarName1 * ClassVarName1 * ClassVarName1'' #tests)))) 	do: 		[:each | 		| class |		class := model classNamed: each first.		each last do: [:meth | class compile: meth first classified: meth last]].model'! !!RefactoringTest methodsFor: 'private' stamp: 'md 7/25/2005 18:12'!childrenToSiblingTestData^'| m |(m:= RBNamespace 			onEnvironment: ((ClassEnvironment onEnvironment: BrowserEnvironment new) 					classes: (#(#ConcreteSubclass #ConcreteSuperclass #NoMoveSubclass) 							inject: OrderedCollection new							into: 								[:sum :each | 								| class |								class := Smalltalk at: each ifAbsent: [nil].								class notNil ifTrue: [sum add: class].								sum]) 								, (#(#ConcreteSubclass #ConcreteSuperclass #NoMoveSubclass) 										inject: OrderedCollection new										into: 											[:sum :each | 											| class |											class := Smalltalk at: each ifAbsent: [nil].											class notNil ifTrue: [sum add: class class].											sum])) 						not) 		name: ''Test''.#(''ConcreteSuperclass subclass: #NoMoveSubclass	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Testing'''''' ''Object subclass: #ConcreteSuperclass	instanceVariableNames: ''''instVarName1 instVarName2 ''''	classVariableNames: ''''ClassVarName1 ClassVarName2 ''''	poolDictionaries: ''''''''	category: ''Testing'''''' ''ConcreteSuperclass subclass: #ConcreteSubclass	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Testing'''''') 	do: [:each | m defineClass: each].(m metaclassNamed: #ConcreteSuperclass) 	addInstanceVariable: ''classInstVarName1''.#(#(#ConcreteSubclass #(#(''initialize	super initialize.	instVarName1 := nil'' #everyone) #(''different	^0'' #everyone))) #(#ConcreteSuperclass #(#(''same	^self initialize isKindOf: ConcreteSuperclass'' #''one def'') #(''different	^instVarName1 + instVarName2'' #everyone) #(''initialize	instVarName1 := instVarName2 := ClassVarName1 := ClassVarName2 := 0'' #everyone))) #(#NoMoveSubclass #(#(''same	^123'' #''one def''))) #(''ConcreteSubclass class'' #(#(''bar	^self storeString'' #testing))) #(''ConcreteSuperclass class'' #(#(''foo	^classInstVarName1 + ClassVarName1 + ClassVarName2'' #testing) #(''new	^super new initialize'' #testing) #(''bar	^self printString'' #testing))) #(''NoMoveSubclass class'' #())) 	do: 		[:each | 		| class |		class := m classNamed: each first.		each last do: [:meth | class compile: meth first classified: meth last]].m'! !!RefactoringTest methodsFor: 'private' stamp: 'md 7/25/2005 18:45'!inlineMethodTestData^ '| m |(m := RBNamespace 			onEnvironment: ((ClassEnvironment onEnvironment: BrowserEnvironment new) 					classes: (#(#RenameClassVariableChange #VariableCompositeRefactoryChange #RenameInstanceVariableChange #CompositeRefactoryChange #RenameVariableChange #RefactoryChange) 							inject: OrderedCollection new							into: 								[:sum :each | 								| class |								class := Smalltalk at: each ifAbsent: [nil].								class notNil ifTrue: [sum add: class].								sum]) 								, (#() inject: OrderedCollection new										into: 											[:sum :each | 											| class |											class := Smalltalk at: each ifAbsent: [nil].											class notNil ifTrue: [sum add: class class].											sum])) 						not) 		name: ''Test''.#(''Object subclass: #RefactoryChange	instanceVariableNames: ''''name ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RefactoryChange subclass: #CompositeRefactoryChange	instanceVariableNames: ''''changes ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''CompositeRefactoryChange subclass: #VariableCompositeRefactoryChange	instanceVariableNames: ''''className isMeta ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''VariableCompositeRefactoryChange subclass: #RenameVariableChange	instanceVariableNames: ''''oldName newName ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RenameVariableChange subclass: #RenameClassVariableChange	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RenameVariableChange subclass: #RenameInstanceVariableChange	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''') 	do: [:each | m defineClass: each].#(#(#RenameClassVariableChange #(#(''removeOldVariable	(RemoveClassVariableChange remove: oldName from: self changeClass) execute'' #private) #(''addNewVariable	(AddClassVariableChange add: newName to: self changeClass) execute'' #private) #(''executeNotifying: aBlock 	| undo |	self addNewVariable.	self copyOldValuesToNewVariable.	undo := super executeNotifying: aBlock.	self removeOldVariable.	^undo'' #private) #(''copyOldValuesToNewVariable	| oldValue |	oldValue := self changeClass classPool at: oldName ifAbsent: [].	self changeClass at: newName asSymbol put: oldValue'' #private))) #(#VariableCompositeRefactoryChange #(#(''displayClassName	^isMeta 		ifTrue: [self changeClassName , '''' class'''']		ifFalse: [self changeClassName asString]'' #printing) #(''isMeta	^isMeta'' #private) #(''changeClass: aBehavior 	isMeta := aBehavior isMeta.	className := isMeta 				ifTrue: [aBehavior soleInstance name]				ifFalse: [aBehavior name]'' #accessing) #(''hash	^self changeClassName hash'' #comparing) #(''changeClassName: aSymbol 	className := aSymbol.	isMeta isNil ifTrue: [isMeta := false]'' #accessing) #(''changeClass	| class |	class := Smalltalk at: self changeClassName ifAbsent: [^nil].	^isMeta ifTrue: [class class] ifFalse: [class]'' #accessing) #(''printOn: aStream	aStream nextPutAll: self displayString'' #printing) #(''changeClassName	^className'' #accessing) #(''= aRefactoryClassChange 	self class = aRefactoryClassChange class ifFalse: [^false].	^className = aRefactoryClassChange changeClassName 		and: [isMeta = aRefactoryClassChange isMeta]'' #comparing))) #(#RenameInstanceVariableChange #(#(''removeOldVariable	(RemoveInstanceVariableChange remove: oldName from: self changeClass) 		execute'' #private) #(''addNewVariable	(AddInstanceVariableChange add: newName to: self changeClass) execute'' #private) #(''executeNotifying: aBlock 	| undo |	self addNewVariable.	self copyOldValuesToNewVariable.	undo := super executeNotifying: aBlock.	self removeOldVariable.	^undo'' #private) #(''copyOldValuesToNewVariable	| newIndex oldIndex |	oldIndex := self changeClass allInstVarNames indexOf: oldName asString.	newIndex := self changeClass allInstVarNames indexOf: newName asString.	self changeClass withAllSubclasses do: 			[:each | 			each allInstances 				do: [:inst | each instVarAt: newIndex put: (each instVarAt: oldIndex)]]'' #private))) #(#CompositeRefactoryChange #(#(''compile: source in: class 	^self addChange: (AddMethodChange compile: source in: class)'' #''refactory-changes'') #(''addClassVariable: variableName to: aClass 	^self addChange: (AddClassVariableChange add: variableName to: aClass)'' #''refactory-changes'') #(''addChangeFirst: aRefactoryChange 	changes addFirst: aRefactoryChange.	^aRefactoryChange'' #accessing) #(''removeChange: aChange 	changes remove: aChange ifAbsent: []'' #''private-inspector accessing'') #(''addPool: aPoolVariable to: aClass 	^self addChange: (AddPoolVariableChange add: aPoolVariable to: aClass)'' #''refactory-changes'') #(''initialize	super initialize.	changes := OrderedCollection new'' #''initialize-release'') #(''defineClass: aString 	^self addChange: (AddClassChange definition: aString)'' #''refactory-changes'') #(''changeForClass: aRBClass selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForClass: aRBClass selector: aSelector.			change notNil ifTrue: [^change]].	^nil'' #accessing) #(''removeInstanceVariable: variableName from: aClass 	^self 		addChange: (RemoveInstanceVariableChange remove: variableName from: aClass)'' #''refactory-changes'') #(''printOn: aStream 	aStream nextPutAll: name'' #printing) #(''inspect	RefactoryBuilderInspector openOn: self'' #''user interface'') #(''flattenOnto: aCollection 	changes do: [:each | each flattenOnto: aCollection]'' #private) #(''hash	^changes size'' #comparing) #(''= aRefactoryBuilder 	self class = aRefactoryBuilder class ifFalse: [^false].	changes size = aRefactoryBuilder changes size ifFalse: [^false].	changes with: aRefactoryBuilder changes		do: [:each :change | each = change ifFalse: [^false]].	^true'' #comparing) #(''renameClass: class to: newName 	^self addChange: (RenameClassChange rename: class name to: newName)'' #''refactory-changes'') #(''renameChangesForClass: aClassName to: newClassName 	^(self copy)		changes: (self changes 					collect: [:each | each renameChangesForClass: aClassName to: newClassName]);		yourself'' #accessing) #(''postCopy	super postCopy.	changes := changes collect: [:each | each copy]'' #copying) #(''changes: aCollection 	changes := aCollection'' #''private-inspector accessing'') #(''addInstanceVariable: variableName to: aClass 	^self addChange: (AddInstanceVariableChange add: variableName to: aClass)'' #''refactory-changes'') #(''compile: source in: class classified: aProtocol 	^self addChange: (AddMethodChange 				compile: source				in: class				classified: aProtocol)'' #''refactory-changes'') #(''changeForMetaclass: aSymbol selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForMetaclass: aSymbol selector: aSelector.			change notNil ifTrue: [^change]].	^nil'' #accessing) #(''removeClassVariable: variableName from: aClass 	^self 		addChange: (RemoveClassVariableChange remove: variableName from: aClass)'' #''refactory-changes'') #(''executeNotifying: aBlock 	| undos undo |	undos := changes collect: [:each | each executeNotifying: aBlock].	undo := self copy.	undo changes: undos reverse.	^undo'' #private) #(''changes	^changes'' #''private-inspector accessing'') #(''removeMethod: aSelector from: aClass 	^self addChange: (RemoveMethodChange remove: aSelector from: aClass)'' #''refactory-changes'') #(''removeClass: aClass 	^self addChange: (RemoveClassChange removeClassName: aClass)'' #''refactory-changes'') #(''addChange: aRefactoryChange 	changes add: aRefactoryChange.	^aRefactoryChange'' #accessing) #(''changesSize	^changes inject: 0 into: [:sum :each | sum + each changesSize]'' #accessing) #(''displayString	^super displayString asText allBold'' #printing) #(''problemCount	^self changesSize'' #accessing))) #(#RenameVariableChange #(#(''oldName: aString	oldName := aString'' #private) #(''executeNotifying: aBlock 	| undo |	undo := super executeNotifying: aBlock.	undo		oldName: newName;		newName: oldName.	^undo'' #private) #(''newName: aString 	newName := aString'' #private) #(''changeString	^''''Rename '''' , oldName , '''' to '''' , newName'' #printing))) #(#RefactoryChange #(#(''flattenedChanges	| changes |	changes := OrderedCollection new.	self flattenOnto: changes.	^changes'' #private) #(''name: aString	name := aString'' #''initialize-release'') #(''initialize'' #''initialize-release'') #(''changeForMetaclass: aSymbol selector: aSelector 	^nil'' #accessing) #(''changeString	^self class name'' #printing) #(''changeForClass: aRBClass selector: aSelector 	^nil'' #accessing) #(''executeWithMessage: aString 	| tally controller m done |	m := 0 asValue.	done := 0.	tally := self changesSize.	controller := aString isNil 				ifTrue: [nil]				ifFalse: [ProgressWidgetView progressOpenOn: m label: aString].	m value: 0.	^	[self executeNotifying: 			[done := done + 1.			m value: done asFloat / tally]] 			ensure: [controller notNil ifTrue: [controller closeAndUnschedule]]'' #''performing-changes'') #(''executeNotifying: aBlock 	self subclassResponsibility'' #private) #(''changes	^Array with: self'' #accessing) #(''execute	^self executeNotifying: []'' #''performing-changes'') #(''inspect	^((CompositeRefactoryChange new)		changes: (Array with: self);		yourself) inspect'' #''user interface'') #(''flattenOnto: aCollection 	aCollection add: self'' #private) #(''name	^name isNil ifTrue: [self changeString] ifFalse: [name]'' #accessing) #(''changesSize	^1'' #accessing) #(''displayString	^name isNil ifTrue: [self changeString] ifFalse: [name]'' #printing) #(''renameChangesForClass: aClassName to: newClassName 	"We are in the middle of performing a rename operation. If we stored 	the class name, we need to change the class name to the new 	name to perform the compiles."	self subclassResponsibility'' #accessing)))) 	do: 		[:each | 		| class |		class := m classNamed: each first.		each last do: [:meth | class compile: meth first classified: meth last]].m'! !!RefactoringTest methodsFor: 'private'!shouldFail: aRefactoring 	self proceedThroughWarning: 			[self should: [self executeRefactoring: aRefactoring]				raise: RefactoringError]! !!RefactoringTest methodsFor: 'private'!shouldWarn: aRefactoring 	self should: [self executeRefactoring: aRefactoring]		raise: RefactoringWarning! !!RefactoringTest methodsFor: 'set up'!setUp	| assoc |	super setUp.	assoc := RefactoringManager classPool associationAt: #Instance				ifAbsent: [RefactoringManager classPool associationAt: 'Instance'].	manager := assoc value.	assoc value: nil.	model := RBNamespace new! !!RefactoringTest methodsFor: 'set up'!setupImplementorToInlineFor: aRefactoring toReturn: anObject 	| options |	options := aRefactoring options copy.	options at: #implementorToInline put: [:ref :imps | anObject].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupInlineExpressionFor: aRefactoring toReturn: aBoolean 	| options |	options := aRefactoring options copy.	options at: #inlineExpression put: [:ref :string | aBoolean].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupMethodNameFor: aRefactoring toReturn: aSelector 	| options |	options := aRefactoring options copy.	options at: #methodName		put: 			[:ref :aMethodName | 			aMethodName				selector: aSelector;				yourself].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupMethodNameFor: aRefactoring toReturn: aSelector withArguments: stringCollection 	| options |	options := aRefactoring options copy.	options at: #methodName		put: 			[:ref :aMethodName | 			aMethodName				selector: aSelector;				arguments: stringCollection;				yourself].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupSelfArgumentNameFor: aRefactoring toReturn: aString 	| options |	options := aRefactoring options copy.	options at: #selfArgumentName put: [:ref | aString].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupVariableToMoveToFor: aRefactoring toReturn: aString 	| options |	options := aRefactoring options copy.	options at: #selectVariableToMoveTo put: [:ref :class :selector | aString].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupVariableTypesFor: aRefactoring toReturn: anObject 	| options |	options := aRefactoring options copy.	options at: #variableTypes put: [:ref :ignore1 :ignore2 | anObject].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!tearDown	super tearDown.	RefactoringManager instance release.	(RefactoringManager classPool associationAt: #Instance		ifAbsent: [RefactoringManager classPool associationAt: 'Instance']) 			value: manager! !!RefactoringTest methodsFor: 'tests' stamp: 'bh 4/2/2000 22:28'!testConditions	| condition newCondition |	condition := RBCondition new 				type: #false				block: [false]				errorString: 'false'.	condition errorMacro: '<1?true:false>'.	self deny: condition check.	self assert: condition errorString = 'false'.	self assert: condition not check.	self assert: condition printString = 'false'.	self assert: condition not printString = 'NOT false'.	self deny: (condition not & condition) check.	self 		assert: (condition not & condition) printString = 'NOT false & false'.	self assert: (condition & condition) not check.	self assert: (condition | condition not) check.	self deny: (newCondition := condition | condition) check.	self assert: newCondition errorString = 'false AND false'.	self assert: (condition not | condition not) check.	self deny: (newCondition := condition & condition) check.	self assert: newCondition errorString = 'false'.	self assert: (condition not & condition not) check.	self assert: (condition & condition) errorString = 'false OR false'! !!RefactoringTest methodsFor: 'tests' stamp: 'md 8/2/2005 22:19'!testPrintRefactoringManager	Transcript		show: RefactoringManager instance printString;		cr.! !!RefactoringWarning methodsFor: 'private - actions'!defaultAction	"Proceed through warnings"	^nil! !!RefactoringWarning methodsFor: 'description' stamp: 'dvf 11/12/2002 00:47'!isResumable	^true.! !!RefactoryChange methodsFor: 'accessing'!changeForClass: aRBClass selector: aSelector 	^nil! !!RefactoryChange methodsFor: 'accessing'!changeForMetaclass: aSymbol selector: aSelector 	^nil! !!RefactoryChange methodsFor: 'accessing'!changes	^Array with: self! !!RefactoryChange methodsFor: 'accessing'!changesSize	^1! !!RefactoryChange methodsFor: 'accessing'!name	^name isNil ifTrue: [self changeString] ifFalse: [name]! !!RefactoryChange methodsFor: 'accessing'!renameChangesForClass: aClassName to: newClassName 	"We're in the middle of performing a rename operation. If we stored 	the class name, we need to change the class name to the new 	name to perform the compiles."	self subclassResponsibility! !!RefactoryChange methodsFor: 'printing'!changeString	^self class name! !!RefactoryChange methodsFor: 'printing'!displayString	^name isNil ifTrue: [self changeString] ifFalse: [name]! !!RefactoryChange methodsFor: 'copying' stamp: 'bh 3/16/2000 23:27'!copy	^(super copy)		postCopy;		yourself! !!RefactoryChange methodsFor: 'copying' stamp: 'dvf 9/21/2003 16:35'!postCopy	^self! !!RefactoryChange methodsFor: 'performing-changes'!execute	^self executeNotifying: []! !!RefactoryChange methodsFor: 'private'!executeNotifying: aBlock 	self subclassResponsibility! !!RefactoryChange methodsFor: 'private' stamp: 'dvf 9/21/2003 16:35'!flattenOnto: aCollection 	aCollection add: self! !!RefactoryChange methodsFor: 'private'!flattenedChanges	| changes |	changes := OrderedCollection new.	self flattenOnto: changes.	^changes! !!RefactoryChange methodsFor: 'initialize-release'!initialize! !!RefactoryChange methodsFor: 'initialize-release'!name: aString	name := aString! !!RefactoryChange methodsFor: 'user interface' stamp: 'bh 5/8/2000 21:13'!inspect	^((CompositeRefactoryChange new)		changes: (Array with: self);		yourself) inspect! !!RefactoryChangeManager methodsFor: 'public access'!addUndo: aRefactoringChange 	undo addLast: aRefactoringChange.	undo size > UndoSize ifTrue: [undo removeFirst].	redo := OrderedCollection new! !!RefactoryChangeManager methodsFor: 'public access'!ignoreChangesWhile: aBlock 	isPerformingRefactoring ifTrue: [^aBlock value].	isPerformingRefactoring := true.	aBlock ensure: [isPerformingRefactoring := false]! !!RefactoryChangeManager methodsFor: 'public access'!performChange: aRefactoringChange 	self ignoreChangesWhile: [self addUndo: aRefactoringChange execute]! !!RefactoryChangeManager methodsFor: 'public access'!redoChange	^redo last! !!RefactoryChangeManager methodsFor: 'public access'!redoOperation	redo isEmpty ifTrue: [^self].	self ignoreChangesWhile: 			[| change |			change := redo removeLast.			undo add: change execute]! !!RefactoryChangeManager methodsFor: 'public access'!undoChange	^undo last! !!RefactoryChangeManager methodsFor: 'public access'!undoOperation	undo isEmpty ifTrue: [^self].	self ignoreChangesWhile: 			[| change |			change := undo removeLast.			redo add: change execute]! !!RefactoryChangeManager methodsFor: 'private'!clearUndoRedoList	undo := OrderedCollection new.	redo := OrderedCollection new! !!RefactoryChangeManager methodsFor: 'initialize-release'!connectToChanges	ChangeSet addDependent: self! !!RefactoryChangeManager methodsFor: 'initialize-release'!disconnectFromChanges	ChangeSet removeDependent: self! !!RefactoryChangeManager methodsFor: 'initialize-release'!initialize	undo := OrderedCollection new.	redo := OrderedCollection new.	isPerformingRefactoring := false.	self connectToChanges! !!RefactoryChangeManager methodsFor: 'initialize-release'!release	super release.	self disconnectFromChanges! !!RefactoryChangeManager methodsFor: 'testing'!hasRedoableOperations	^redo isEmpty not! !!RefactoryChangeManager methodsFor: 'testing'!hasUndoableOperations	^undo isEmpty not! !!RefactoryChangeManager methodsFor: 'updating'!update: anAspectSymbol with: aParameter from: aSender 	| changeType |	(aSender == ChangeSet and: [isPerformingRefactoring not]) ifFalse: [^self].	anAspectSymbol == #reorganizeClass: ifTrue: [^self].	changeType := (anAspectSymbol isString 				ifTrue: [anAspectSymbol asString]				ifFalse: ['class']) asLowercase.	(changeType indexOfSubCollection: 'class' startingAt: 1) 		+ (changeType indexOfSubCollection: 'selector' startingAt: 1) > 0 		ifTrue: [self clearUndoRedoList]! !!RefactoryChangeManager class methodsFor: 'class initialization'!initialize	self nuke.	UndoSize := 5! !!RefactoryChangeManager class methodsFor: 'class initialization'!undoSize	^UndoSize! !!RefactoryChangeManager class methodsFor: 'class initialization'!undoSize: anInteger 	UndoSize := anInteger max: 0! !!RefactoryChangeManager class methodsFor: 'instance creation'!instance	Instance isNil 		ifTrue: 			[Instance := self basicNew.			Instance initialize].	^Instance! !!RefactoryChangeManager class methodsFor: 'instance creation'!new	^self shouldNotImplement! !!RefactoryChangeManager class methodsFor: 'public access'!nuke	Instance notNil ifTrue: [Instance release].	Instance := nil! !!RefactoryClassChange methodsFor: 'comparing'!= aRefactoryClassChange 	self class = aRefactoryClassChange class ifFalse: [^false].	^className = aRefactoryClassChange changeClassName 		and: [isMeta = aRefactoryClassChange isMeta]! !!RefactoryClassChange methodsFor: 'comparing'!hash	^self changeClassName hash! !!RefactoryClassChange methodsFor: 'converting'!asUndoOperation	^self subclassResponsibility! !!RefactoryClassChange methodsFor: 'accessing' stamp: 'dc 5/8/2007 13:19'!changeClass	| class |	class := Smalltalk at: self changeClassName ifAbsent: [^nil].	^isMeta ifTrue: [class classSide] ifFalse: [class]! !!RefactoryClassChange methodsFor: 'accessing'!changeClass: aBehavior 	isMeta := aBehavior isMeta.	className := isMeta 				ifTrue: [aBehavior soleInstance name]				ifFalse: [aBehavior name]! !!RefactoryClassChange methodsFor: 'accessing'!changeClassName	^className! !!RefactoryClassChange methodsFor: 'accessing'!changeClassName: aSymbol 	className := aSymbol.	isMeta isNil ifTrue: [isMeta := false]! !!RefactoryClassChange methodsFor: 'accessing'!methodSourceFor: aSymbol 	(self changeClass includesSelector: aSymbol) ifFalse: [^nil].	^self changeClass sourceCodeAt: aSymbol! !!RefactoryClassChange methodsFor: 'accessing'!renameChangesForClass: aClassName to: newClassName 	self changeClassName == aClassName 		ifTrue: 			[^(self copy)				changeClassName: newClassName;				yourself].	^self! !!RefactoryClassChange methodsFor: 'printing'!changeString	^self displayClassName! !!RefactoryClassChange methodsFor: 'printing'!displayClassName	^isMeta 		ifTrue: [self changeClassName , ' class']		ifFalse: [self changeClassName asString]! !!RefactoryClassChange methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self displayString! !!RefactoryClassChange methodsFor: 'private'!executeNotifying: aBlock 	| undo |	undo := self asUndoOperation.	undo name: self name.	self primitiveExecute.	aBlock value.	^undo! !!RefactoryClassChange methodsFor: 'private'!isMeta	^isMeta! !!RefactoryClassChange methodsFor: 'private'!primitiveExecute	^self subclassResponsibility! !!RefactoryTestDataApp methodsFor: 'lint'!asOrderedCollectionNotNeeded	self foo addAll: (1 to: 10) asOrderedCollection! !!RefactoryTestDataApp methodsFor: 'lint'!assignmentInBlock	[^self printString] ensure: [self close]! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 15:28'!assignmentInIfTrue	| variable |	self isVariable 		ifTrue: [variable := self]		ifFalse: [variable := self printString].	^variable! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'md 3/14/2006 16:47'!atIfAbsent	^ Smalltalk at: #MyTest		ifAbsent: 			[| collection |			collection := #().			Smalltalk at: #MyTest put: collection]! !!RefactoryTestDataApp methodsFor: 'lint'!badMessage	self become: String new! !!RefactoryTestDataApp methodsFor: 'lint'!booleanPrecedence	^true & 4 = 45! !!RefactoryTestDataApp methodsFor: 'lint'!collectSelectNotUsed	(1 to: 10) select: [:each | each = 4]! !!RefactoryTestDataApp methodsFor: 'lint'!collectionMessagesToExternalObject	self someObject collection remove: 10! !!RefactoryTestDataApp methodsFor: 'lint'!collectionProtocol	| newCollection |	newCollection := OrderedCollection new.	(1 to: 10) asOrderedCollection do: 			[:each | 			| new |			new := each * 2.			newCollection add: new].	^newCollection! !!RefactoryTestDataApp methodsFor: 'lint'!consistencyCheck	^(1 to: 10) at: 1! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 15:28'!contains	^((1 to: 10) detect: [:each | each > 2] ifNone: [nil]) isNil! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 16:49'!cruft	self halt! !!RefactoryTestDataApp methodsFor: 'lint'!detectContains	^(1 to: 10) do: [:each | each > 2 ifTrue: [^each]]! !!RefactoryTestDataApp methodsFor: 'lint'!endTrueFalse	self isVariable 		ifTrue: 			[self printString.			self isVariable printString]		ifFalse: 			[self printString.			^4]! !!RefactoryTestDataApp methodsFor: 'lint'!equalNotUsed	| string |	string = '' yourself.	(1 to: 10) do: [:i | string := i printString].	^string! !!RefactoryTestDataApp methodsFor: 'lint'!equalsTrue	^true == self! !!RefactoryTestDataApp methodsFor: 'lint'!extraBlock	^[:arg | arg + 43] value: 45! !!RefactoryTestDataApp methodsFor: 'lint'!fileBlocks	| file |	^	[file := 'asdf' asFilename readStream.	file contents] ensure: [file close]! !!RefactoryTestDataApp methodsFor: 'lint'!fullBlocks	^[thisContext]! !!RefactoryTestDataApp methodsFor: 'lint'!guardingClause	self isSymbol 		ifFalse: 			[self printString.			self isSymbol printString]! !!RefactoryTestDataApp methodsFor: 'lint'!ifTrueReturns	self isSymbol ifFalse: [^true].	^false! !!RefactoryTestDataApp methodsFor: 'lint'!isLiteral	^false! !!RefactoryTestDataApp methodsFor: 'lint'!justSendsSuper	super justSendsSuper! !!RefactoryTestDataApp methodsFor: 'lint'!literalArrayCharacters	^#($a $b $c) includes: $a! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/4/2005 14:52'!literalArrayWithTrueFalseOrNil	| a b c |	a := #(true false nil).	b := #(#true #false #nil).	c := {true. false. nil}.	^{a. b. c}! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/4/2005 16:40'!literalArrayWithTrueFalseOrNil2	| b c |	b := #(#true #false #nil).	c := #(#true (#true #false #nil) #false #nil).^b! !!RefactoryTestDataApp methodsFor: 'lint'!longMethods	self printString.	self printString.	self isVariable ifTrue: [self printString].	self isVariable ifTrue: [self printString].	self isVariable ifTrue: [self printString].	self isVariable ifTrue: [self printString]! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 15:28'!minMax	"Bug in 3<5 ifTrue: [3]  ifFalse: [5]"^3<5 ifTrue: [3]  ifFalse: [5]"	| var |	var := 4.	var < 5 ifTrue: [var := 5].	^var"! !!RefactoryTestDataApp methodsFor: 'lint'!missingYourself	^(OrderedCollection new)		add: 1;		add: 2;		removeFirst! !!RefactoryTestDataApp methodsFor: 'lint'!modifiesCollection	| collection |	collection := (1 to: 10) asOrderedCollection.	collection do: [:each | each > 5 ifTrue: [collection remove: each]].	^collection! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 14:51'!noIsNil: arg	^arg = nil or: [ arg ~= nil ]! !!RefactoryTestDataApp methodsFor: 'lint'!precedence	^self isArray ifFalse: [self block + 5 * 34] ifTrue: [self printString = 10]! !!RefactoryTestDataApp methodsFor: 'lint'!refersToClass	^RefactoryTestDataApp! !!RefactoryTestDataApp methodsFor: 'lint'!release	self printString! !!RefactoryTestDataApp methodsFor: 'lint'!returnInEnsure	[self error: 'asdf'] ensure: [^4]! !!RefactoryTestDataApp methodsFor: 'lint'!returnsBooleanAndOther	self isVariable ifTrue: [^false].	self printString! !!RefactoryTestDataApp methodsFor: 'lint'!returnsIfTrue	^self isNil ifTrue: [4]! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'bh 4/2/2000 22:25'!searchingLiteral	^self printString = #a or: [#() = self printString | ( #() == self printString)]! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 15:28'!sendsDifferentSuper	super printString! !!RefactoryTestDataApp methodsFor: 'lint'!sizeCheck	self isEmpty		ifFalse: [self do: 					[:each | 					Transcript						show: each;						cr]]! !!RefactoryTestDataApp methodsFor: 'lint'!stringConcatenation	| string |	string := '' yourself.	(1 to: 10) do: [:i | string := string , i printString].	^string! !!RefactoryTestDataApp methodsFor: 'lint'!tempVarOverridesInstVar	| temporaryVariable |	temporaryVariable := 4.	^temporaryVariable! !!RefactoryTestDataApp methodsFor: 'lint'!tempsReadBeforeWritten	| temp |	self isVariable ifTrue: [temp := 4].	^temp! !!RefactoryTestDataApp methodsFor: 'lint'!threeElementPoint	^5 @ 5 + 6 @ 6! !!RefactoryTestDataApp methodsFor: 'lint'!toDo	1 to: self size do: [:i | (self at: i) printString]! !!RefactoryTestDataApp methodsFor: 'lint'!toDoCollect	| array |	array := Array new: 10.	1 to: 10 do: [:i | array at: i put: i * i].	^array! !!RefactoryTestDataApp methodsFor: 'lint'!toDoWithIncrement	| counter |	counter := 0.	1 to: 10		by: 2		do: [:i | counter := counter + 2].	^counter! !!RefactoryTestDataApp methodsFor: 'lint'!usesAdd	^(1 to: 10) asOrderedCollection addAll: (11 to: 20)! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 2/25/2005 16:50'!variableAssignedLiteral	temporaryVariable := #() ! !!RefactoryTestDataApp methodsFor: 'lint'!whileTrue	| i |	i := 1.	[i < self size] whileTrue: 			[(self at: i) printString.			i := i + 1]! !!RefactoryTestDataApp methodsFor: 'lint'!yourselfNotUsed	self		printString;		printString;		yourself! !!RefactoryTestDataApp methodsFor: 'test'!callFoo	^self testFoo: 5! !!RefactoryTestDataApp methodsFor: 'test'!callMethod	^self renameThisMethod: 5! !!RefactoryTestDataApp methodsFor: 'test'!exampleCall	^self rename: 1 two: 2! !!RefactoryTestDataApp methodsFor: 'test'!inlineFoo: aBlock 	| bar baz asdf |	bar := aBlock value: self.	baz := bar + bar.	asdf := baz + bar.	^asdf! !!RefactoryTestDataApp methodsFor: 'test'!inlineJunk	| asdf |	asdf := self inlineFoo: 					[:each | 					| temp |					temp := each.					temp , temp].	^asdf foo: 			[:bar | 			| baz |			baz := bar.			baz * baz]! !!RefactoryTestDataApp methodsFor: 'test'!inlineMethod	| temp |	temp := self				foo;				inlineMethod;				bar.	^temp! !!RefactoryTestDataApp methodsFor: 'test'!inlineParameterMethod: aSymbol	^aSymbol isSymbol! !!RefactoryTestDataApp methodsFor: 'test'!moveDefinition	| temp |	^(self collect: 			[:each | 			temp := each printString.			temp , temp]) 		select: 			[:each | 			temp := each size.			temp odd]! !!RefactoryTestDataApp methodsFor: 'test'!noMoveDefinition	| temp |	^(self collect: 			[:each | 			temp := each printString.			temp , temp]) 		select: [:each | temp := each size + temp]! !!RefactoryTestDataApp methodsFor: 'test'!rename: this two: argumentMethod	^self printString , this , argumentMethod! !!RefactoryTestDataApp methodsFor: 'test'!renameThisMethod: anArg	^self! !!RefactoryTestDataApp methodsFor: 'test'!selectorNotReferenced	^self selectorNotReferenced + 4! !!RefactoryTestDataApp methodsFor: 'test'!sendInlineParameterMethod	^self inlineParameterMethod: #(#asdf)! !!RefactoryTestDataApp methodsFor: 'test'!symbolReference	^#(#renameThisMethod: #(4 #renameThisMethod:))! !!RefactoryTestDataApp methodsFor: 'test'!testFoo: anObject	^self class + anObject! !!RefactoryTestDataApp methodsFor: 'test'!testMethod	^self class! !!RefactoryTestDataApp methodsFor: 'test'!testMethod1	^self testMethod1 		, ([:each | each testMethod1] value: #(#(#testMethod1) 2 #testMethod1))! !!RefactoryTestDataApp methodsFor: 'inline'!called: anObject on1: aBlock 	| each |	each := anObject printString.	Transcript		show: each;		cr.	aBlock value: each! !!RefactoryTestDataApp methodsFor: 'inline'!called: anObject on: aBlock 	Transcript		show: anObject printString;		cr.	aBlock value! !!RefactoryTestDataApp methodsFor: 'inline'!caller	| anObject |	anObject := 5.	self 		called: anObject + 1		on: [^anObject]! !!RefactoryTestDataApp methodsFor: 'inline'!caller1	| anObject |	anObject := 5.	self called: anObject + 1		on1: 			[:each | 			each printString.			^anObject]! !!RefactoryTestDataApp methodsFor: 'inline'!caller2	^(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)]! !!RefactoryTestDataApp methodsFor: 'inline'!foo: aValue	^(1 to: 10) inject: aValue into: [:sum :each | sum + each]! !!RefactoryTestDataApp methodsFor: 'inline'!inlineComponent	| a |	a := 5.	^a class		superclass;		hasImmediateInstances;		yourself! !!RefactoryTestDataApp methodsFor: 'inline'!inlineFailed	| x y q |	x := 5.	y := 10.	q := x + 1 fooMax: y.	^q! !!RefactoryTestDataApp methodsFor: 'inline'!inlineLast	5 = 3 ifTrue: [^self caller] ifFalse: [^self caller2]! !!RefactoryTestDataApp methodsFor: 'inline'!inlineMax	| x y q |	x := 5.	y := 10.	q := x + 1 max: y.	^q! !!RefactoryTestDataApp methodsFor: 'inline'!inlineTemporary	| temp |	self isNil ifTrue: [temp := 4].	^temp! !!RefactoryTestDataApp methodsFor: 'inline'!multipleCalls	self caller2.	self caller2! !!RefactoryTestDataApp methodsFor: 'accessing'!referencesConditionFor: aClass 	| environment association |	^(RBCondition withBlock: 			[association := Smalltalk associationAt: aClass name						ifAbsent: [self refactoringError: 'Could not find class'].			environment := (self environment referencesTo: association) 						| (self environment referencesTo: aClass name).			environment isEmpty])		errorMacro: aClass , ' is referenced.<n>Browse references?';		errorBlock: [environment openEditor];		yourself! !!RefactoryTyper methodsFor: 'printing'!collectionNameFor: aString 	^'-<1s>-' expandMacrosWith: aString! !!RefactoryTyper methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: class name;		cr.	class instanceVariableNames do: 			[:each | 			aStream				tab;				nextPutAll: each;				tab;				nextPut: $<.			self printTypeFor: each on: aStream.			aStream				nextPut: $>;				cr]! !!RefactoryTyper methodsFor: 'printing'!printType: aClass for: aString on: aStream 	| name colTypes |	colTypes := #().	name := self collectionNameFor: aString.	(aClass includesClass: (model classFor: Collection))		ifTrue: [colTypes := self guessTypesFor: name].	colTypes isEmpty ifFalse: [aStream nextPut: $(].	aClass printOn: aStream.	colTypes isEmpty		ifFalse: 			[aStream nextPutAll: ' of: '.			colTypes size > 1 ifTrue: [aStream nextPut: $(].			self printTypeFor: name on: aStream.			colTypes size > 1 ifTrue: [aStream nextPut: $)]].	colTypes isEmpty ifFalse: [aStream nextPut: $)]! !!RefactoryTyper methodsFor: 'printing'!printTypeFor: aString on: aStream 	| types |	types := (self guessTypesFor: aString) 				asSortedCollection: [:a :b | a name < b name].	1 to: types size		do: 			[:i | 			i == 1 ifFalse: [aStream nextPutAll: ' | '].			self 				printType: (types at: i)				for: aString				on: aStream]! !!RefactoryTyper methodsFor: 'equivalence classes'!computeEquivalenceClassesForMethodsAndVars	| searcher |	bindings := Set new.	backpointers := Dictionary new.	class instanceVariableNames 		do: [:each | backpointers at: each put: (bindings add: (Set with: each))].	class withAllSubclasses do: 			[:sub | 			sub selectors 				do: [:each | backpointers at: each put: (bindings add: (Set with: each))]].	searcher := ParseTreeSearcher new.	searcher matches: '^``@object'		do: [:aNode :answer | self processNode: aNode value].	self executeSearch: searcher! !!RefactoryTyper methodsFor: 'equivalence classes' stamp: 'rr 3/15/2004 14:06'!merge: aName 	"rr 3/15/2004 14:05 add: the ifAbsent: keyword in the last line, as I encountered a failing case"	| set1 set2 |	set1 := backpointers at: methodName ifAbsent: [nil].	set2 := backpointers at: aName ifAbsent: [nil].	(set1 isNil or: [set2 isNil or: [set1 == set2]]) ifTrue: [^self].	set1 addAll: set2.	set2 do: [:each | backpointers at: each put: set1].	bindings remove: set2 ifAbsent: [] ! !!RefactoryTyper methodsFor: 'equivalence classes'!processNode: aNode 	(aNode isVariable and: [class instanceVariableNames includes: aNode name]) 		ifTrue: [^self merge: aNode name].	(aNode isMessage 		and: [aNode receiver isVariable and: [aNode receiver name = 'self']]) 			ifTrue: [^self merge: aNode selector].	aNode isAssignment 		ifTrue: 			[self				processNode: aNode value;				processNode: aNode variable].	(aNode isMessage and: 			[#(#ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue:) 				includes: aNode selector]) 		ifTrue: 			[aNode arguments do: 					[:each | 					each isBlock 						ifTrue: 							[each body statements isEmpty 								ifFalse: [self processNode: each body statements last]]]]! !!RefactoryTyper methodsFor: 'selectors'!computeMessagesSentToVariables	| searcher |	variableMessages := Dictionary new.	class instanceVariableNames 		do: [:each | variableMessages at: each put: Set new].	searcher := ParseTreeSearcher new.	class instanceVariableNames do: 			[:each | 			| block |			block := 					[:aNode :answer | 					(variableMessages at: each ifAbsentPut: [Set new]) add: aNode selector.					self processCollectionMessagesFor: each in: aNode].			searcher matches: each , ' `@messageName: ``@args' do: block.			(backpointers at: each) do: 					[:sel | 					sel isSymbol 						ifTrue: 							[searcher 								matches: ('(self <1s>) `@messageName: ``@args' 										expandMacrosWith: (ParseTreeSearcher buildSelectorString: sel)) asString								do: block]]].	searcher answer: variableMessages.	self executeSearch: searcher! !!RefactoryTyper methodsFor: 'computing types'!computeTypes	variableMessages		keysAndValuesDo: [:key :value | variableTypes at: key put: (self findTypeFor: value)]! !!RefactoryTyper methodsFor: 'computing types'!findTypeFor: selectorCollection 	^selectorCollection inject: model rootClasses		into: 			[:classes :each | 			self refineTypes: classes				with: (selectorLookup at: each ifAbsentPut: [self implementorsOf: each])]! !!RefactoryTyper methodsFor: 'computing types'!implementorsOf: aSelector 	| classes |	classes := OrderedCollection new.	model rootClasses do: 			[:each | 			self 				implementorsOf: aSelector				in: each				storeIn: classes].	^classes! !!RefactoryTyper methodsFor: 'computing types'!implementorsOf: aSelector in: aClass storeIn: classes 	(aClass directlyDefinesMethod: aSelector) 		ifTrue: 			[classes add: aClass.			^self].	aClass subclasses do: 			[:each | 			self 				implementorsOf: aSelector				in: each				storeIn: classes]! !!RefactoryTyper methodsFor: 'computing types'!refineTypes: aClassCollection with: anotherClassCollection 	| classSet |	classSet := Set new.	aClassCollection do: 			[:each | 			anotherClassCollection do: 					[:cls | 					(cls includesClass: each) 						ifTrue: [classSet add: cls]						ifFalse: [(each includesClass: cls) ifTrue: [classSet add: each]]]].	^classSet! !!RefactoryTyper methodsFor: 'private'!executeSearch: searcher 	class withAllSubclasses do: 			[:each | 			each selectors do: 					[:sel | 					| parseTree |					methodName := sel.					parseTree := each parseTreeFor: sel.					parseTree notNil ifTrue: [searcher executeTree: parseTree]]]! !!RefactoryTyper methodsFor: 'private'!model	^model! !!RefactoryTyper methodsFor: 'private'!model: aRBSmalltalk	model := aRBSmalltalk! !!RefactoryTyper methodsFor: 'private'!rootClasses	^Class rootsOfTheWorld! !!RefactoryTyper methodsFor: 'assignments'!guessTypeFromAssignment: aNode 	| type set newType |	type := nil.	aNode value isAssignment 		ifTrue: 			[^self guessTypeFromAssignment: (RBAssignmentNode variable: aNode variable						value: aNode value value)].	aNode value isBlock ifTrue: [type := model classFor: [] class].	aNode value isLiteral 		ifTrue: 			[aNode value value isNil ifTrue: [^self].			type := model classFor: (self typeFor: aNode value value)].	aNode value isMessage 		ifTrue: 			[aNode value receiver isVariable 				ifTrue: [type := model classNamed: aNode value receiver name asSymbol].			aNode value selector == #asValue 				ifTrue: [type := model classNamed: #ValueHolder].			(#(#and: #or: #= #== #~= #~~ #<= #< #~~ #> #>=) 				includes: aNode value selector) ifTrue: [type := model classFor: Boolean]].	type isNil ifTrue: [^self].	set := variableTypes at: aNode variable name.	newType := set detect: [:each | type includesClass: each] ifNone: [nil].	newType isNil ifTrue: [^self].	newType = (model classFor: Object) ifTrue: [newType := type].	(bestGuesses at: aNode variable name ifAbsentPut: [Set new]) add: newType! !!RefactoryTyper methodsFor: 'assignments'!refineTypesByLookingAtAssignments	| searcher needsSearch |	needsSearch := false.	searcher := ParseTreeSearcher new.	variableTypes keysAndValuesDo: 			[:key :value | 			(key first == $-) 				ifFalse: 					[needsSearch := true.					searcher matches: key , ' := ``@object'						do: [:aNode :answer | self guessTypeFromAssignment: aNode]]].	needsSearch ifTrue: [self executeSearch: searcher]! !!RefactoryTyper methodsFor: 'assignments' stamp: 'bh 4/3/2000 11:52'!typeFor: anObject 	'' class == anObject class ifTrue: [^String].	^( {true. false} includes: anObject) 		ifTrue: [Boolean]		ifFalse: [anObject class]! !!RefactoryTyper methodsFor: 'accessing'!guessTypesFor: anInstVarName 	^bestGuesses at: anInstVarName ifAbsent: [self typesFor: anInstVarName]! !!RefactoryTyper methodsFor: 'accessing'!guessTypesFor: anInstVarName in: aClass 	class = aClass ifFalse: [self runOn: aClass].	^bestGuesses at: anInstVarName		ifAbsent: [self typesFor: anInstVarName in: aClass]! !!RefactoryTyper methodsFor: 'accessing'!runOn: aClass 	variableTypes := Dictionary new.	variableMessages := Dictionary new.	bestGuesses := Dictionary new.	class := model classFor: aClass.	class instanceVariableNames isEmpty ifTrue: [^self].	self		selectedClass: aClass;		computeEquivalenceClassesForMethodsAndVars;		computeMessagesSentToVariables;		computeTypes;		refineTypesByLookingAtAssignments! !!RefactoryTyper methodsFor: 'accessing'!selectedClass: aClass 	class := model classFor: aClass! !!RefactoryTyper methodsFor: 'accessing'!typesFor: anInstVarName 	^variableTypes at: anInstVarName ifAbsent: [Set new]! !!RefactoryTyper methodsFor: 'accessing'!typesFor: anInstVarName in: aClass 	class = aClass ifFalse: [self runOn: aClass].	^variableTypes at: anInstVarName ifAbsent: [Set new]! !!RefactoryTyper methodsFor: 'initialize-release'!initialize	model := RBNamespace new.	class := model classFor: Object.	variableTypes := Dictionary new.	variableMessages := Dictionary new.	selectorLookup := IdentityDictionary new.	bestGuesses := Dictionary new! !!RefactoryTyper methodsFor: 'selectors-collections'!processCollectionFor: key messagesTo: aName in: aBlock 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: aName , ' `@message: ``@args'		do: 			[:aNode :answer | 			self processCollectionMessagesFor: key in: aNode.			answer				add: aNode selector;				yourself].	searcher executeTree: aBlock		initialAnswer: (variableMessages at: (self collectionNameFor: key)				ifAbsentPut: [Set new])! !!RefactoryTyper methodsFor: 'selectors-collections'!processCollectionMessagesFor: variableName in: aParseTree 	| parent block |	aParseTree isMessage ifFalse: [^self].	(#(#first #at: #last) includes: aParseTree selector) 		ifTrue: 			[parent := aParseTree parent.			(parent notNil and: [parent isMessage]) ifFalse: [^self].			aParseTree == parent receiver ifFalse: [^self].			(variableMessages at: (self collectionNameFor: variableName)				ifAbsentPut: [Set new]) add: parent selector.			self processCollectionMessagesFor: (self collectionNameFor: variableName)				in: parent].	(#(#do: #do:separatedBy: #collect: #reject: #select: #detect: #detect:ifNone:) 		includes: aParseTree selector) 			ifTrue: 				[block := aParseTree arguments first.				block isBlock ifFalse: [^self].				self 					processCollectionFor: variableName					messagesTo: block arguments first name					in: block].	#inject:into: == aParseTree selector 		ifTrue: 			[block := aParseTree arguments last.			block isBlock ifFalse: [^self].			self 				processCollectionFor: variableName				messagesTo: block arguments last name				in: block]! !!RefactoryTyper class methodsFor: 'instance creation'!newFor: aRBNamespace 	^(self new)		model: aRBNamespace;		yourself! !!RefactoryTyper class methodsFor: 'accessing'!typesFor: variableName in: aParseTree model: aRBSmalltalk 	| searcher messages |	searcher := ParseTreeSearcher new.	searcher matches: variableName , ' `@message: ``@args'		do: 			[:aNode :answer | 			answer				add: aNode selector;				yourself].	messages := searcher executeTree: aParseTree initialAnswer: Set new.	^(self new)		model: aRBSmalltalk;		findTypeFor: messages! !!RefactoryVariableChange methodsFor: 'comparing'!= aRefactoryVariableChange 	^super = aRefactoryVariableChange 		and: [variable = aRefactoryVariableChange variable]! !!RefactoryVariableChange methodsFor: 'comparing'!hash	^self class hash bitXor: variable hash! !!RefactoryVariableChange methodsFor: 'private'!changeObject	^self variable! !!RefactoryVariableChange methodsFor: 'private'!changeSymbol	self subclassResponsibility! !!RefactoryVariableChange methodsFor: 'private'!changesFileTemplate	^'<1p> <2s> <3p>'! !!RefactoryVariableChange methodsFor: 'private' stamp: 'bh 4/29/2000 18:16'!primitiveExecute	| changeSymbol |	changeSymbol := self changeSymbol.	self changeClass perform: changeSymbol with: self changeObject.	self needsWork. "the following is to handle a VW bug.  Is it also a problem for Squeak?"	"ChangeSet current changeClass: self changeClass.	SourceFileManager default logChange: (self changesFileTemplate			expandMacrosWith: self changeClass			with: changeSymbol			with: self variable)"! !!RefactoryVariableChange methodsFor: 'private'!variable	^variable! !!RefactoryVariableChange methodsFor: 'initialize-release'!class: aBehavior variable: aString 	self changeClass: aBehavior.	variable := aString! !!RefactoryVariableChange class methodsFor: 'instance creation'!add: aVariable to: aBehavior 	"This should only be called on the Add*Change subclasses, 	but is here so we don't need to copy it to all subclasses"	^self new class: aBehavior variable: aVariable! !!RefactoryVariableChange class methodsFor: 'instance creation'!remove: aVariable from: aBehavior 	"This should only be called on the Remove*Change subclasses, 	but is here so we don't need to copy it to all subclasses"	^self new class: aBehavior variable: aVariable! !!ReferenceFinderTest methodsFor: 'tests' stamp: 'bh 4/29/2000 18:16'!testAllPaths	self needsWork. "slows, then hangs (100% CPU) on or after level 5 - 4551 objects to search.		is this because Squeak can't handle large collections efficiently?""	| paths |	paths := ReferenceFinder findAllPathsTo: RefactoringManager instance.	self deny: paths isEmpty.	paths do: 		[:each | 		self assert: each last == RefactoringManager instance.		self assert: each first == Smalltalk]"! !!ReferenceFinderTest methodsFor: 'tests' stamp: 'bh 4/29/2000 18:16'!testAllPathsToInstance	self needsWork. "slows, then hangs (100% CPU) on or after level 5 - 4551 objects to search.		is this because Squeak can't handle large collections efficiently?""	| paths |     	paths := ReferenceFinder findAllPathsToInstanceOf: RefactoringManager. 	    self deny: paths isEmpty.     	paths do:      	[:each |      	self assert: each last class == RefactoringManager.     	self assert: each first == Smalltalk]"! !!ReferenceFinderTest methodsFor: 'tests' stamp: 'bh 4/29/2000 18:17'!testFound	self needsWork. "slows, then hangs (100% CPU) on or after level 5 - 4551 objects to search.		is this because Squeak can't handle large collections efficiently?""	| path |	path := ReferenceFinder findPathTo: RefactoringManager instance.	self assert: path last == RefactoringManager instance.	self assert: (path at: path size - 1) isVariableBinding.	self assert: (path at: path size - 1) key == #Instance.	self assert: path first == Smalltalk"! !!ReferenceFinderTest methodsFor: 'tests' stamp: 'bh 4/29/2000 18:17'!testNotFound	self needsWork. "slows, then hangs (100% CPU) on or after level 5 - 4551 objects to search.		is this because Squeak can't handle large collections efficiently?""	| path |	path := ReferenceFinder findPathTo: Object new.	self assert: path isNil"! !!ReferenceFinderTest methodsFor: 'tests' stamp: 'bh 4/29/2000 18:17'!testPathToInstance	self needsWork. "slows, then hangs (100% CPU) on or after level 5 - 4551 objects to search.		is this because Squeak can't handle large collections efficiently?""	| path |	path := ReferenceFinder findPathToInstanceOf: RefactoringManager.	self assert: path last class == RefactoringManager.	self assert: path first == Smalltalk"! !!ReflectiveMethod methodsFor: 'refactoring browser' stamp: 'pmm 7/15/2005 13:49'!allLiterals	^ self compiledMethod allLiterals! !!ReflectiveMethod methodsFor: 'refactoring browser' stamp: 'pmm 4/27/2006 21:41'!ast	^self parseTree! !!ReflectiveMethod methodsFor: 'refactoring browser' stamp: 'pmm 7/15/2005 13:49'!literalsDo: aOneArgumentBlock	^self compiledMethod literalsDo: aOneArgumentBlock! !!ReflectiveMethod methodsFor: 'refactoring browser' stamp: 'pmm 7/15/2005 13:49'!needsHybridFrame	^self compiledMethod needsHybridFrame! !!ReflectiveMethod methodsFor: 'refactoring browser' stamp: 'pmm 7/13/2005 20:10'!parseTree	^self methodNode! !!ReflectiveMethod methodsFor: 'refactoring browser' stamp: 'pmm 7/15/2005 13:50'!refersToLiteral:aLiteral	^self compiledMethod refersToLiteral:aLiteral! !!ReflectiveMethod methodsFor: 'refactoring browser' stamp: 'md 3/31/2007 19:06'!sendsSelector: aSymbol	| visitor |	visitor := PEMessageSendSearcher selector: aSymbol.	visitor visitNode: self methodNode.	^visitor found! !!ReflectiveMethod methodsFor: 'refactoring browser' stamp: 'pmm 7/15/2005 13:50'!withAllBlockMethods	^self compiledMethod withAllBlockMethods! !!ReflectiveMethod methodsFor: 'refactoring browser' stamp: 'pmm 7/15/2005 13:50'!withAllBlockMethodsDo: aOneArgumentBlock 	self compiledMethod withAllBlockMethodsDo: aOneArgumentBlock ! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'pmm 8/3/2005 20:19'!argumentNames	^self methodNode argumentNames! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 3/31/2007 19:43'!classBinding	^classBinding! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 3/31/2007 19:43'!classBinding: aBinding	classBinding := aBinding! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 4/13/2007 13:57'!compiledMethod	compiledMethod ifNil: [		compiledMethod := self generateCompiledMethod.		self hasMethodClass ifTrue: [			compiledMethod methodClass: self methodClass ] ].	^compiledMethod! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 4/13/2007 13:58'!compiledMethod: aCompiledMethod 	compiledMethod := aCompiledMethod.	"(aCompiledMethod notNil		and: [ self hasMethodClass not ]		and: [ compiledMethod methodClass notNil ])			ifTrue: [ Beeper beep. self setMethodClass: compiledMethod methodClass  ]."	(aCompiledMethod notNil and: [ aCompiledMethod sourcePointer isZero not ])		ifTrue: [ sourcePointer := aCompiledMethod sourcePointer ]! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'pmm 7/22/2005 13:24'!formattedCode	^self methodNode formattedCode! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'pmm 7/12/2005 23:03'!ir	^self methodNode ir! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 4/15/2007 15:09'!literals	^literals ifNil: [#()].! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 4/15/2007 14:37'!literals: anArray	^literals := anArray.! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 4/21/2007 09:06'!methodClass	^classBinding value! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'pmm 7/26/2006 20:09'!methodClass: aClass	self setMethodClass: aClass.	self modifyMethodNode: [ :node | node methodClass: aClass ].	compiledMethod isNil ifFalse: [		compiledMethod methodClass: aClass ]! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 3/31/2007 18:57'!methodNode		| source |		^methodNode ifNil: [			compiledMethod ifNotNil: [				self methodNode: ((source := self getSourceFromFile)					ifNil: [compiledMethod decompile]					ifNotNil: [PEParser new						parse: source 						class: (self methodClass ifNil: [self sourceClass])])].		methodNode parent: self].	! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 3/29/2007 16:12'!methodNode: aMethodNode 	methodNode := aMethodNode.	aMethodNode ifNotNil: [aMethodNode parent: self].! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 9/29/2007 10:37'!methodNodeFromSource	"Return the parse tree that represents self"	| source |		^ (source := self getSourceFromFile)		ifNil: [self decompile]		ifNotNil: [			self selector isDoIt ifTrue: [self parserClass new parseDoit: source]					   ifFalse: [PEParser new 										parse: source 										class: (self methodClass ifNil: [self sourceClass])]]! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'pmm 9/24/2006 11:54'!methodReference	^MethodReference class: self methodClass selector: self selector! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 4/20/2007 11:14'!monitor 	^monitor ifNil: [monitor := Monitor new].! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 9/29/2007 10:36'!parserClass	^self compilerClass parserClass! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'SR 9/2/2006 17:32'!pragmas	^ self compiledMethod pragmas! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 4/14/2007 10:11'!properties	^properties ifNil: [properties := MethodProperties new]! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'pmm 7/16/2005 11:00'!properties: aDictionary 	properties := aDictionary! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 3/1/2007 20:27'!reflectiveMethod	^self! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 3/20/2007 17:32'!reflectiveMethodOrNil	^self! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 4/14/2007 10:06'!selector	^self properties selector! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'md 4/14/2007 10:07'!selector: aSymbol	self properties selector: aSymbol.	self modifyMethodNode: [ :node | node selector: aSymbol ].! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'pmm 7/19/2005 07:05'!sourceCode	^self methodNode source! !!ReflectiveMethod methodsFor: 'accessing' stamp: 'pmm 7/11/2005 15:48'!tempNames	^self methodNode tempNames! !!ReflectiveMethod methodsFor: 'accessing-legacy' stamp: 'pmm 6/21/2006 11:10'!at: anInteger	^self compiledMethod at: anInteger! !!ReflectiveMethod methodsFor: 'accessing-legacy' stamp: 'pmm 8/23/2006 14:21'!bytecodes	^self compiledMethod bytecodes! !!ReflectiveMethod methodsFor: 'accessing-legacy' stamp: 'pmm 6/19/2006 19:17'!endPC	"Answer the index of the last bytecode."	^ self compiledMethod endPC! !!ReflectiveMethod methodsFor: 'accessing-legacy' stamp: 'pmm 7/15/2005 13:43'!frameSize	"Answer the size of temporary frame needed to run the receiver."	"NOTE:  Versions 2.7 and later use two sizes of contexts."	^self compiledMethod frameSize! !!ReflectiveMethod methodsFor: 'accessing-legacy' stamp: 'pmm 8/23/2006 14:25'!getSource	^ self compiledMethod getSource! !!ReflectiveMethod methodsFor: 'accessing-legacy' stamp: 'pmm 7/15/2005 13:43'!header	^self compiledMethod header! !!ReflectiveMethod methodsFor: 'accessing-legacy' stamp: 'pmm 7/15/2005 13:43'!initialPC	"Answer the program counter for the receiver's first bytecode."	^ self compiledMethod initialPC! !!ReflectiveMethod methodsFor: 'accessing-legacy' stamp: 'pmm 7/15/2005 13:44'!last	^self compiledMethod last! !!ReflectiveMethod methodsFor: 'accessing-legacy' stamp: 'pmm 7/15/2005 13:44'!literalAt: anInteger	^self compiledMethod literalAt: anInteger! !!ReflectiveMethod methodsFor: 'accessing-legacy' stamp: 'md 10/2/2007 15:46'!messages	^self sends collect: #selector.   ! !!ReflectiveMethod methodsFor: 'accessing-legacy' stamp: 'pmm 7/15/2005 13:45'!nStack	^self compiledMethod nStack! !!ReflectiveMethod methodsFor: 'accessing-legacy' stamp: 'pmm 7/15/2005 13:45'!numArgs	"Answer the number of arguments the receiver takes."	^ self compiledMethod numArgs! !!ReflectiveMethod methodsFor: 'accessing-legacy' stamp: 'md 4/15/2007 14:46'!numLiterals	"Answer the number of literals used by the receiver."		^ self literals size! !!ReflectiveMethod methodsFor: 'accessing-legacy' stamp: 'pmm 7/15/2005 13:46'!numTemps	"Answer the number of temporary variables used by the receiver."		^ self compiledMethod numTemps! !!ReflectiveMethod methodsFor: 'accessing-legacy' stamp: 'pmm 7/15/2005 13:46'!primitive	"Answer the primitive index associated with the receiver.	Zero indicates that this is not a primitive method.	We currently allow 11 bits of primitive index, but they are in two places	for  backward compatibility.  The time to unpack is negligible,	since the reconstituted full index is stored in the method cache."		^self compiledMethod primitive! !!ReflectiveMethod methodsFor: 'accessing-legacy' stamp: 'pmm 7/15/2005 13:46'!trailer	^self compiledMethod trailer! !!ReflectiveMethod methodsFor: 'interpretation' stamp: 'md 4/18/2007 12:36'!beInterpreted	self primitiveChangeClassTo: InterpretedReflectiveMethod new.! !!ReflectiveMethod methodsFor: 'interpretation' stamp: 'md 4/18/2007 12:37'!beNative	"ignore"! !!ReflectiveMethod methodsFor: 'interpretation' stamp: 'pmm 4/28/2006 19:47'!interpret: oldSelector with: arguments in: aReceiver    	^self interpreterClass		run: (self methodNode scope; yourself)		with: arguments		in: aReceiver! !!ReflectiveMethod methodsFor: 'interpretation' stamp: 'md 4/14/2007 10:19'!interpreterClass	^self properties at: #interpreterClass ifAbsent: [ PEMethodInterpreter ]! !!ReflectiveMethod methodsFor: 'interpretation' stamp: 'md 4/14/2007 10:19'!interpreterClass: aClass	self properties at: #interpreterClass put: aClass! !!ReflectiveMethod methodsFor: 'interpretation' stamp: 'md 4/18/2007 12:31'!isInterpreted	^false! !!ReflectiveMethod methodsFor: 'interpretation' stamp: 'pmm 11/27/2006 18:50'!resetInterpreterClass	^self properties removeKey: #interpreterClass ifAbsent: [ "ignore" ]! !!ReflectiveMethod methodsFor: 'source code management-legacy' stamp: 'pmm 7/15/2005 13:51'!checkOKToAdd: size at: filePosition	"Issue several warnings as the end of the changes file approaches its limit,	and finally halt with an error when the end is reached."	^self compiledMethod checkOKToAdd: size at: filePosition! !!ReflectiveMethod methodsFor: 'source code management-legacy' stamp: 'pmm 7/15/2005 13:51'!fileIndex	^self compiledMethod fileIndex! !!ReflectiveMethod methodsFor: 'source code management-legacy' stamp: 'pmm 7/15/2005 13:51'!filePosition	^self compiledMethod filePosition! !!ReflectiveMethod methodsFor: 'source code management-legacy' stamp: 'pmm 7/29/2005 16:57'!getPreambleFrom: aFileStream at: position	^self compiledMethod getPreambleFrom: aFileStream at: position! !!ReflectiveMethod methodsFor: 'source code management-legacy' stamp: 'pmm 7/31/2006 15:31'!getSourceFor: aSelector in: aClass	"Retrieve or reconstruct the source code for this method."	^self compiledMethod getSourceFor: aSelector in: aClass! !!ReflectiveMethod methodsFor: 'source code management-legacy' stamp: 'pmm 7/15/2005 13:52'!getSourceFromFile	"Read the source code from file, determining source file index and	file position from the last 3 bytes of this method."	^self compiledMethod getSourceFromFile! !!ReflectiveMethod methodsFor: 'source code management-legacy' stamp: 'pmm 1/28/2007 15:21'!linesOfCode	^self compiledMethod linesOfCode! !!ReflectiveMethod methodsFor: 'source code management-legacy' stamp: 'md 3/20/2007 11:56'!putSource: sourceStr fromParseNode: aMethodNode class: class category: catName	withStamp: changeStamp inFile: fileIndex priorMethod: priorMethod	| t |	t := self compiledMethod		putSource: sourceStr		fromParseNode: aMethodNode		class: class		category: catName		withStamp: changeStamp		inFile: fileIndex		priorMethod: priorMethod.		self setSourcePointer: self compiledMethod sourcePointer.		^t.! !!ReflectiveMethod methodsFor: 'source code management-legacy' stamp: 'pmm 7/15/2005 13:53'!putSource: sourceStr fromParseNode: aMethodNode inFile: fileIndex withPreamble: preambleBlock	"Store the source code for the receiver on an external file.	If no sources are available, i.e., SourceFile is nil, then store	temp names for decompilation at the end of the method.	If the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes,	in each case, storing a 4-byte source code pointer at the method end."	^self compiledMethod putSource: sourceStr fromParseNode: aMethodNode inFile: fileIndex withPreamble: preambleBlock! !!ReflectiveMethod methodsFor: 'source code management-legacy' stamp: 'pmm 3/23/2006 09:45'!putSourceInChangesCategory: catName priorMethod: priorMethod	^ self compiledMethod		putSource: self formattedCode		fromParseNode: self methodNode		class: self methodClass 		category: catName		withStamp: Utilities changeStamp		inFile: 2 "2 means changes file"		priorMethod: priorMethod! !!ReflectiveMethod methodsFor: 'source code management-legacy' stamp: 'md 3/29/2007 13:47'!setSourcePointer: srcPointer	self hasCompiledMethod		ifTrue: [ self compiledMethod setSourcePointer: srcPointer ].	sourcePointer := srcPointer! !!ReflectiveMethod methodsFor: 'source code management-legacy' stamp: 'md 3/29/2007 13:48'!setSourcePosition: position inFile: fileIndex 	self hasCompiledMethod		ifTrue: [ self compiledMethod setSourcePosition: position inFile: fileIndex  ].	sourcePointer := position! !!ReflectiveMethod methodsFor: 'source code management-legacy' stamp: 'md 3/29/2007 13:46'!sourcePointer	^ sourcePointer.! !!ReflectiveMethod methodsFor: 'source code management-legacy' stamp: 'pmm 7/15/2005 13:54'!timeStamp	"Answer the authoring time-stamp for the given method, retrieved from the sources or changes file. Answer the empty string if no time stamp is available."	"(CompiledMethod compiledMethodAt: #timeStamp) timeStamp"	^self compiledMethod timeStamp! !!ReflectiveMethod methodsFor: 'compression' stamp: 'md 4/15/2007 22:03'!compress       | compressed serialized rwstream |       rwstream := RWBinaryOrTextStream on: (ByteArray new: 500).       serialized := (ReferenceStream on: rwstream) nextPut: methodNode; contents.       compressed := ByteArray streamContents: [:strm |               (GZipWriteStream on: strm) nextPutAll: serialized; close].       ^compressed contents! !!ReflectiveMethod methodsFor: 'compression' stamp: 'md 4/17/2007 17:17'!uncompress	| zipped |	zipped := GZipReadStream on: methodNode.	^ (ReferenceStream on: zipped) next.! !!ReflectiveMethod methodsFor: 'compilation' stamp: 'md 3/31/2007 19:16'!defaultCompilationStrategy	self methodNode isPrimitive ifTrue: [^PEWrapperCompilationStrategy]. 	^PEInlineCompilationStrategy! !!ReflectiveMethod methodsFor: 'compilation' stamp: 'md 10/21/2007 20:48'!generateCompiledMethod	| method ms selector |		ms := compiledMethod sourcePointer.	selector := self selector.	method := self defaultCompilationStrategy new compile: self.	method compiledMethod setSourcePointer: ms.	method selector: selector.	classBinding ifNotNil: [method methodClass: classBinding value].	self methodNode prepareForStorage.	method reflectiveMethod: self.	^method! !!ReflectiveMethod methodsFor: 'private' stamp: 'pmm 9/1/2005 08:37'!defaultTrailer	"this is needed for the source pointer	the default #(0) will result in the VM setfaulting	because #setSourcePointer: writes into the CompiledMethod	*we think*"	^ #(0 0 0 0). ! !!ReflectiveMethod methodsFor: 'private' stamp: 'md 3/29/2007 14:03'!getMethodClass	^classBinding value! !!ReflectiveMethod methodsFor: 'private' stamp: 'pmm 9/25/2005 11:44'!interpretSender: aSender receiver: aReceiver arguments: anArray	| context result |	context := MethodContext 		sender: aSender		receiver: aReceiver		method: self		arguments: anArray.	result := context runUntilErrorOrReturnFrom: aSender.! !!ReflectiveMethod methodsFor: 'private' stamp: 'pmm 11/3/2005 12:47'!modifyMethodNode: aBlock	aBlock value: self methodNode! !!ReflectiveMethod methodsFor: 'private' stamp: 'pmm 10/4/2006 12:41'!nameForInstVarAt: anInteger	^self methodClass allInstVarNames at: anInteger! !!ReflectiveMethod methodsFor: 'private' stamp: 'md 3/29/2007 14:03'!setMethodClass: aClass	classBinding := aClass binding.! !!ReflectiveMethod methodsFor: 'actions' stamp: 'md 4/20/2007 19:14'!flushCache	"Tell the interpreter to remove all references to this method from its method lookup cache, if it has one.  This primitive must be called whenever a method is defined or removed.	NOTE:  Only one of two selective flush methods needs to be used.	Squeak 2.2 and earlier uses 119 (See Symbol flushCache).	Squeak 2.3 and later uses 116 (See CompiledMethod flushCache)."	<primitive: 116>! !!ReflectiveMethod methodsFor: 'actions' stamp: 'pmm 3/23/2006 09:46'!recompile	self methodClass		recompile: self methodNode selector		from: self methodClass! !!ReflectiveMethod methodsFor: 'actions' stamp: 'pmm 8/7/2005 14:12'!renameArgument: oldName to: newName	self renameTemporary: oldName to: newName! !!ReflectiveMethod methodsFor: 'actions' stamp: 'md 3/29/2007 13:45'!renameTemporary: oldName to: newName	| oldCategory oldMethod |	oldCategory := self methodClass organization categoryOfElement: self selector.	oldMethod := self compiledMethod.	self modifyMethodNode: [ :node |		(RenameTemporaryRefactoring new			oldName: oldName;			newName: newName;			yourself) renameNode: node. 		node methodNode scope: nil ].	self invalidate.		self		putSourceInChangesCategory: oldCategory			priorMethod: oldMethod.	SystemChangeNotifier uniqueInstance		methodChangedFrom: oldMethod		to: self compiledMethod		selector: self selector		inClass: self methodClass	! !!ReflectiveMethod methodsFor: 'actions' stamp: 'md 3/29/2007 13:45'!renameTo: aSymbol	| oldSelector oldCategory oldMethod |	"self halt"	oldSelector := self methodNode selector.	oldCategory := self methodClass organization categoryOfElement: oldSelector.	oldMethod := self compiledMethod.	self modifyMethodNode: [ :node | node selector: aSymbol ].	self methodClass addSelector: aSymbol withMethod: self.	self methodClass organization classify: aSymbol under: oldCategory.	self invalidate.	self		putSourceInChangesCategory: oldCategory			priorMethod: oldMethod.	self methodClass removeSelector: oldSelector.		SystemChangeNotifier uniqueInstance		methodChangedFrom: oldMethod		to: self compiledMethod		selector: aSymbol		inClass: self methodClass 	! !!ReflectiveMethod methodsFor: 'actions' stamp: 'md 3/5/2007 10:46'!updateSource: oldCompiledMethod	| selector category |	selector := self methodNode selector.	category := self methodClass organization categoryOfElement: selector.		self		putSourceInChangesCategory: category			priorMethod: oldCompiledMethod.			SystemChangeNotifier uniqueInstance		methodChangedFrom: oldCompiledMethod		to: self compiledMethod		selector: selector		inClass: self methodClass.		self methodClass addSelectorSilently: self selector withMethod: self compiledMethod.! !!ReflectiveMethod methodsFor: 'testing-legacy' stamp: 'md 4/3/2007 11:07'!hasBreakpoint	^false! !!ReflectiveMethod methodsFor: 'testing-legacy' stamp: 'md 3/27/2007 23:48'!isBlockMethod	^false! !!ReflectiveMethod methodsFor: 'testing-legacy' stamp: 'pmm 6/19/2006 19:12'!isProvided	^self compiledMethod isProvided! !!ReflectiveMethod methodsFor: 'testing-legacy' stamp: 'pmm 7/15/2005 13:55'!isQuick	"Answer whether the receiver is a quick return (of self or of an instance 	variable)."	^ self compiledMethod isQuick! !!ReflectiveMethod methodsFor: 'testing-legacy' stamp: 'pmm 7/15/2005 13:55'!isReturnField	"Answer whether the receiver is a quick return of an instance variable."	^self compiledMethod isReturnField! !!ReflectiveMethod methodsFor: 'testing-legacy' stamp: 'pmm 7/15/2005 13:55'!isReturnSelf	"Answer whether the receiver is a quick return of self."	^ self compiledMethod isReturnSelf! !!ReflectiveMethod methodsFor: 'testing-legacy' stamp: 'pmm 7/15/2005 13:55'!isReturnSpecial	"Answer whether the receiver is a quick return of self or constant."	^ self compiledMethod isReturnSpecial! !!ReflectiveMethod methodsFor: 'testing-legacy' stamp: 'pmm 10/4/2006 12:52'!readsField: varIndex	| variableName |	variableName := self nameForInstVarAt: varIndex.	self nodesDo: [ :each |		(each isVariable			and: [ each name = variableName ]			and: [ each isRead ])				ifTrue: [ ^true ] ].	^false! !!ReflectiveMethod methodsFor: 'testing-legacy' stamp: 'pmm 10/4/2006 12:52'!writesField: varIndex	| variableName |	variableName := self nameForInstVarAt: varIndex.	self nodesDo: [ :each |		(each isVariable			and: [ each name = variableName ]			and: [ each isWrite ])				ifTrue: [ ^true ] ].	^false! !!ReflectiveMethod methodsFor: 'testing' stamp: 'pmm 8/11/2006 15:04'!hasCompiledMethod	^compiledMethod notNil! !!ReflectiveMethod methodsFor: 'testing' stamp: 'pmm 3/23/2006 10:06'!hasMethodClass	^self getMethodClass in: [ :class |		class notNil and: [ class ~= #unknown ] ]! !!ReflectiveMethod methodsFor: 'testing' stamp: 'md 3/26/2007 12:08'!hasReflectiveMethod	^true! !!ReflectiveMethod methodsFor: 'testing' stamp: 'md 4/21/2007 10:56'!isCoreMethod	| class |	class := self methodClass.	"strange bug..."	Morph == class ifTrue: [^true]. 	self methodNode isPrimitive ifTrue: [^true].	"from specialobj"	SmallInteger == class ifTrue: [^true].	LargePositiveInteger  == class ifTrue: [^true].	LargeNegativeInteger  == class ifTrue: [^true].	CompiledMethod  == class ifTrue: [^true].	MethodContext  == class ifTrue: [^true].	PseudoContext  == class ifTrue: [^true].	TranslatedMethod  == class ifTrue: [^true].	Process  == class ifTrue: [^true].	ByteString  == class ifTrue: [^true].	Array == class ifTrue: [^true].	Float == class ifTrue: [^true].	BlockContext == class ifTrue: [^true].	Point == class ifTrue: [^true].	Display == class ifTrue: [^true].	Message == class ifTrue: [^true].	Semaphore == class ifTrue: [^true].	Character == class ifTrue: [^true].	ByteArray == class ifTrue: [^true].	"misc"	Mutex  == class ifTrue: [^true].	Link  == class ifTrue: [^true].	InstructionStream == class ifTrue: [^true].	DisplayObject == class ifTrue: [^true].	DisplayMedium == class ifTrue: [^true].	Form == class ifTrue: [^true].	LinkedList == class ifTrue: [^true].	Number == class ifTrue: [^true].	Magnitude == class ifTrue: [^true].	Collection == class ifTrue: [^true].	ContextPart == class ifTrue: [^true].	Object == class ifTrue: [^true].	ProtoObject == class  ifTrue: [^true].	ReflectiveMethod == class ifTrue: [^true].	MethodDictionary == class ifTrue: [^true].	ArrayedCollection == class ifTrue: [^true].	WriteStream  == class ifTrue: [^true].	SequenceableCollection == class ifTrue: [^true].	Dictionary == class ifTrue: [^true].	IdentityDictionary == class ifTrue: [^true].	Set == class ifTrue: [^true].	Integer  == class ifTrue: [^true].	Behavior == class ifTrue: [^true].	BitBlt  == class ifTrue: [^true].	CharacterScanner  == class ifTrue: [^true].	MultiCharacterScanner  == class ifTrue: [^true].	BlockContext  == class ifTrue: [^true].	LookupKey  == class ifTrue: [^true].	ReadOnlyVariableBinding == class ifTrue: [^true].	MethodProperties  == class ifTrue: [^true].	^false.! !!ReflectiveMethod methodsFor: 'testing' stamp: 'md 3/1/2007 21:58'!isInvalid	"the cache is invalidated by installing the RM in the MethodDictionary.	 State of the compiledMethod is *not* the trigger!!"		^(self methodClass methodDict at: self selector) == self.		! !!ReflectiveMethod methodsFor: 'testing' stamp: 'md 3/1/2007 20:25'!isReflectiveMethod	^true! !!ReflectiveMethod methodsFor: 'testing' stamp: 'ms 10/29/2007 18:16'!isRequired	^self compiledMethod isRequired! !!ReflectiveMethod methodsFor: 'literals-legacy' stamp: 'md 4/15/2007 15:41'!hasLiteral: literal 	^self literals identityIncludes: literal.! !!ReflectiveMethod methodsFor: 'literals-legacy' stamp: 'md 4/15/2007 15:41'!hasLiteralSuchThat: aBlock	self pragmas do: [ :pragma |		(pragma hasLiteralSuchThat: aBlock)			ifTrue: [ ^ true ] ].	self literals do: [ :literal | 		(aBlock value: literal)			ifTrue: [ ^ true ].		(literal hasLiteralSuchThat: aBlock)			ifTrue: [ ^ true ] ].	^ false.! !!ReflectiveMethod methodsFor: 'literals-legacy' stamp: 'md 4/15/2007 15:42'!hasLiteralThorough: aLiteral	"Answer true if any literal in this method is literal, even if embedded in array structure or within its pragmas."	self pragmas do: [ :pragma |		(pragma hasLiteral: aLiteral) ifTrue: [ ^ true ] ].	self literals do: [ :literal | 		literal == aLiteral  ifTrue: [ ^ true ].		(literal hasLiteralThorough: aLiteral) ifTrue: [ ^ true ] ].	^ false.! !!ReflectiveMethod methodsFor: 'accessing-delegation' stamp: 'pmm 8/23/2006 14:11'!hasPragma: aSymbol	^self compiledMethod hasPragma: aSymbol! !!ReflectiveMethod methodsFor: 'file in/out' stamp: 'ms 10/4/2007 13:25'!hasReportableSlip	^self compiledMethod hasReportableSlip! !!ReflectiveMethod methodsFor: 'running' stamp: 'md 10/21/2007 20:43'!install: aMethod in: aClass		aClass methodDict at: aMethod selector put: aMethod.		aClass flushCache.	! !!ReflectiveMethod methodsFor: 'running' stamp: 'md 10/21/2007 20:47'!invalidate	self isInvalid ifTrue: [^self].	self isCoreMethod ifTrue: [		compiledMethod := self generateCompiledMethod.		self install: compiledMethod in: self methodClass.		^compiledMethod.	].	self install: self in: self methodClass.	self assert: self selector notNil.	self assert: self compiledMethod selector = self selector.	self assert: self compiledMethod methodClass = self methodClass.	! !!ReflectiveMethod methodsFor: 'running' stamp: 'md 4/23/2007 14:42'!run: selector with: arguments in: aReceiver     "for the following recompile, install the old method again... it will be overrridden	as soon as we have generated a new one. Maybe this needs to block other threads..."					self install: compiledMethod in: self methodClass.	compiledMethod := self generateCompiledMethod.	self install: compiledMethod in: self methodClass.		^aReceiver withArgs: arguments executeMethod: compiledMethod! !!ReflectiveMethod methodsFor: 'running' stamp: 'Y.-G.G. 4/3/2014 16:21'!valueWithReceiver: aReceiver arguments: anArray 	"Execute this reflective method on the receiver with some arguments"	^self compiledMethod valueWithReceiver: aReceiver arguments: anArray.! !!ReflectiveMethod methodsFor: 'initialize-release' stamp: 'pmm 7/15/2005 13:47'!needsFrameSize: newFrameSize	"Set the largeFrameBit to accomodate the newFrameSize"		^self compiledMethod needsFrameSize: newFrameSize! !!ReflectiveMethod methodsFor: 'enumeration' stamp: 'md 3/28/2007 15:52'!nodesDo: aBlock	(PEMethodBodyInstrumentationVisitor block: aBlock)		visitNode: self methodNode! !!ReflectiveMethod methodsFor: 'copying' stamp: 'md 4/14/2007 10:48'!postCopy	super postCopy.	compiledMethod := nil.	methodNode := methodNode copy.! !!ReflectiveMethod methodsFor: 'printing' stamp: 'md 3/20/2007 12:14'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self selector;		nextPut: $)! !!ReflectiveMethod methodsFor: 'scanning-legacy' stamp: 'pmm 7/17/2005 14:14'!scanFor: byte	^self compiledMethod scanFor: byte ! !!ReflectiveMethod methodsFor: 'scanning-legacy' stamp: 'md 3/27/2007 15:39'!sendsToSuper	^self compiledMethod sendsToSuper.! !!ReflectiveMethod methodsFor: 'printing-legacy' stamp: 'pmm 9/8/2005 20:15'!symbolic	^self compiledMethod symbolic! !!ReflectiveMethod methodsFor: '*geppetto2' stamp: 'md 2/10/2007 09:30'!assignments	^self nodes select: [:each | each isAssignment].! !!ReflectiveMethod methodsFor: '*geppetto2' stamp: 'md 2/27/2007 21:04'!blocks	^self nodes select: [:each | each isBlock].! !!ReflectiveMethod methodsFor: '*geppetto2' stamp: 'md 8/24/2007 00:03'!globalAssignments	^self nodes select: [:each | each isAssignment and: [each isGlobal]].! !!ReflectiveMethod methodsFor: '*geppetto2' stamp: 'md 8/24/2007 00:02'!instanceAssignments	^self nodes select: [:each | each isAssignment and: [each isInstance]].! !!ReflectiveMethod methodsFor: '*geppetto2' stamp: 'md 10/22/2007 22:20'!instanceVariableReads		^self variablesReads select: [:each | each isInstance]! !!ReflectiveMethod methodsFor: '*geppetto2' stamp: 'md 2/24/2007 19:13'!isMethod	^true! !!ReflectiveMethod methodsFor: '*geppetto2' stamp: 'md 9/25/2007 15:30'!nodes	| nodes |	nodes := IdentitySet new.	self methodNode nodesDo: [:node | nodes add: node].	^nodes.! !!ReflectiveMethod methodsFor: '*geppetto2' stamp: 'md 3/9/2007 18:44'!replaceNode: aNode withNode: anotherNode 	methodNode == aNode ifTrue: [self methodNode: anotherNode].! !!ReflectiveMethod methodsFor: '*geppetto2' stamp: 'md 2/10/2007 09:31'!sends	^self nodes select: [:each | each isMessage].! !!ReflectiveMethod methodsFor: '*geppetto2' stamp: 'md 2/10/2007 16:36'!statements	^(GPStatementCollector new visitNode: self methodNode) statements! !!ReflectiveMethod methodsFor: '*geppetto2' stamp: 'md 8/24/2007 00:02'!tempAssignments	^self nodes select: [:each | each isAssignment and: [each isTemp]].! !!ReflectiveMethod methodsFor: '*geppetto2' stamp: 'md 10/22/2007 22:20'!tempVariableReads		^self variableReads select: [:each | each isTemp]! !!ReflectiveMethod methodsFor: '*geppetto2' stamp: 'md 8/22/2007 07:43'!variableReads		^self nodes select: [:each | 			each isVariable and: [each isRead] and: [each isVariableDefinition not]]! !!ReflectiveMethod methodsFor: '*geppetto2' stamp: 'md 10/25/2007 17:06'!variableWrites		^self nodes select: [:each | 			each isVariable and: [each isWrite] and: [each isVariableDefinition not]]! !!ReflectiveMethod methodsFor: '*geppetto2' stamp: 'md 10/22/2007 14:35'!variables		^self nodes select: [:each | 			each isVariable and: [each isVariableDefinition not]].! !!ReflectiveMethod methodsFor: '*colorer' stamp: 'md 8/10/2007 15:56'!pretyPrintExecution	^ CLExecutionFormatter new format: self methodNode! !!ReflectiveMethod methodsFor: '*colorer' stamp: 'md 7/25/2007 14:43'!resetExecutionCount	CLExecutionRemover new visitNode: self methodNode! !!ReflectiveMethod class methodsFor: 'instance creation' stamp: 'md 10/25/2007 15:46'!blockNode: aBlockNode compiledMethod: aCompiledMethod	| inst |	inst := self new.	inst methodNode: aBlockNode.	inst compiledMethod: aCompiledMethod.	inst literals: (PELiteralCollector new visitNode: aBlockNode) literals.	inst properties: aCompiledMethod properties.	aCompiledMethod reflectiveMethod: inst.	^inst.! !!ReflectiveMethod class methodsFor: 'instance creation' stamp: 'md 4/15/2007 14:43'!methodNode: aMethodNode compiledMethod: aCompiledMethod	| inst |	inst := self new.	inst methodNode: aMethodNode.	inst methodNode prepareForStorage.	inst compiledMethod: aCompiledMethod.	inst literals: (PELiteralCollector new visitNode: aMethodNode) literals.	inst properties: aCompiledMethod properties.	aCompiledMethod reflectiveMethod: inst.	^inst.! !!ReflectiveMethodTest methodsFor: 'as yet unclassified' stamp: 'ms 10/29/2007 18:17'!testIsRequired	self assert: (Object>>#allInstVars) compiledMethod isRequired  = (Object>>#allInstVars) reflectiveMethod isRequired.! !!ReflectivityLoader methodsFor: 'initialize-release' stamp: 'md 8/19/2007 19:05'!initialize	super initialize.! !!ReflectivityLoader methodsFor: 'loading' stamp: 'ms 11/8/2007 13:51'!loadLatestPackage: aString from: aPath		self loadPackage: [:repository | (repository allVersionNames select: [ :each |		each beginsWith: aString ])		asSortedCollection: [ :a :b |			(a copyAfterLast: $.) asNumber <= (b copyAfterLast: $.) asNumber ] ] fixTemps from: aPath! !!ReflectivityLoader methodsFor: 'loading' stamp: 'ms 11/8/2007 14:12'!loadPackage: aBlock from: aPath	| repository versions tries version |	repository := MCHttpRepository		location: aPath		user:  ''		password: ''.		versions := aBlock value: repository.		tries := 0.	[ versions isEmpty and: [ tries < 3 ] ] whileTrue: [		versions := aBlock value: repository.		tries := tries + 1 ].	versions isEmpty ifTrue: [ self error: 'problems when accessing squeaksource' ].		version := (repository versionReaderForFileNamed: versions last , '.mcz') version.	version load.	repository := MCRepositoryGroup default repositories 		detect: [:each | (each isKindOf: MCHttpRepository) 							and:[each locationWithTrailingSlash = repository locationWithTrailingSlash]] 		ifNone: [repository].			version workingCopy repositoryGroup addRepository: repository.	"version workingCopy modified: false"! !!ReflectivityLoader methodsFor: 'loading' stamp: 'md 11/11/2007 19:02'!loadPackage: aString from: aPath version: versNumber	self loadPackage:   [:repository  | 		(repository allVersionNames select: [ :each |			each beginsWith: aString ]) 				select:[:name | (name copyAfterLast: $-)  = versNumber ]] fixTemps from: aPath.! !!ReflectivityLoader methodsFor: 'loading' stamp: 'md 8/23/2007 15:04'!loadPackages	self loadLatestPackage: 'Toothpick-' from: 'http://www.squeaksource.com/Toothpick/'.		self loadLatestPackage: 'ProcessSpecific-' from: 'http://www.squeaksource.com/ProcessLocalStorage/'.	self loadLatestPackage: 'AST-' from: 'http://www.squeaksource.com/AST/'.	self loadLatestPackage: 'NewParser-' from: 'http://www.squeaksource.com/AST/'.	self loadLatestPackage: 'RefactoringEngine-' from:  'http://www.squeaksource.com/RefactoringEngine/'.	self loadLatestPackage: 'SmaCC-' from: 'http://www.squeaksource.com/SmaccDevelopment/'.	self loadLatestPackage: 'NewCompiler-' from: 'http://www.squeaksource.com/NewCompiler/'.	self loadLatestPackage: 'Persephone' from: 'http://www.squeaksource.com/Persephone/'.	self loadLatestPackage: 'Context' from: 'http://www.squeaksource.com/Reflectivity/'.	self loadLatestPackage: 'Geppetto2' from: 'http://www.squeaksource.com/Geppetto/'.	self loadLatestPackage: 'Colorer' from: 'http://www.squeaksource.com/Reflectivity/'.	self loadLatestPackage: 'Features' from: 'http://www.squeaksource.com/Reflectivity/'.	self loadLatestPackage: 'Network-IRC' from: 'http://www.squeaksource.com/Reflectivity/'.		Preferences setPreference: #compileUseNewCompiler toValue: true.	Preferences setPreference: #compileReflectiveMethods toValue: true.	"self loadLatestPackage: 'JCompiledMethodsTest-' from: 'http://www.squeaksource.com/JCompiledMethods/'."! !!ReflectivityLoader methodsFor: 'loading' stamp: 'md 12/11/2007 11:45'!loadStablePackages	self loadLatestPackage: 'Toothpick-' from: 'http://www.squeaksource.com/Toothpick/'.		self loadLatestPackage: 'ProcessSpecific-' from: 'http://www.squeaksource.com/ProcessLocalStorage/'.	self loadLatestPackage: 'AST-' from: 'http://www.squeaksource.com/AST/'.	self loadLatestPackage: 'NewParser-' from: 'http://www.squeaksource.com/AST/'.	self loadLatestPackage: 'RefactoringEngine-' from:  'http://www.squeaksource.com/RefactoringEngine/'.	self loadLatestPackage: 'SmaCC-' from: 'http://www.squeaksource.com/SmaccDevelopment/'.	self loadLatestPackage: 'NewCompiler-' from: 'http://www.squeaksource.com/NewCompiler/'.	self loadPackage: 'Persephone' from: 'http://www.squeaksource.com/Persephone/' version: 'md.112'.	self loadPackage: 'Context' from: 'http://www.squeaksource.com/Reflectivity/' version: 'ms.6'.	self loadPackage: 'Geppetto2' from: 'http://www.squeaksource.com/Geppetto/' version: 'md.152'.	self loadLatestPackage: 'Colorer' from: 'http://www.squeaksource.com/Reflectivity/'.	self loadLatestPackage: 'Features' from: 'http://www.squeaksource.com/Reflectivity/'.	self loadLatestPackage: 'Network-IRC' from: 'http://www.squeaksource.com/Reflectivity/'.		Preferences setPreference: #compileUseNewCompiler toValue: true.	Preferences setPreference: #compileReflectiveMethods toValue: true.	"self loadLatestPackage: 'JCompiledMethodsTest-' from: 'http://www.squeaksource.com/JCompiledMethods/'."! !!ReflectivityLoader commentStamp: 'md 11/11/2007 19:16' prior: 0!Loads Persephone and the required packages into your image.Usage:ReflectivityLoader new loadStablePackagesRequirements:Squeak 3.9 + md Patches!!RemoveClassChange methodsFor: 'converting'!asUndoOperation	| classChanges |	classChanges := CompositeRefactoryChange new.	self changeClass withAllSubclasses do: 			[:each | 			classChanges defineClass: each definition.			each class instVarNames 				do: [:varName | classChanges addInstanceVariable: varName to: each class].			each selectors 				do: [:selector | classChanges compile: (each sourceCodeAt: selector) in: each].			each class selectors 				do: [:selector | classChanges compile: (each class sourceCodeAt: selector) in: each class]].	^classChanges! !!RemoveClassChange methodsFor: 'printing'!changeString	^'Remove class ', self displayClassName! !!RemoveClassChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' removeFromSystem';		nextPut: $!!! !!RemoveClassChange methodsFor: 'private'!primitiveExecute	self changeClass removeFromSystem! !!RemoveClassChange class methodsFor: 'instance creation'!remove: aClass 	^self new changeClass: aClass! !!RemoveClassChange class methodsFor: 'instance creation'!removeClassName: aSymbol 	^self new changeClassName: aSymbol! !!RemoveClassRefactoring methodsFor: 'initialize-release'!classNames: aClassNameCollection 	classNames := aClassNameCollection! !!RemoveClassRefactoring methodsFor: 'preconditions'!hasReferencesTo: aSymbol 	| literal |	literal := Smalltalk associationAt: aSymbol.	BrowserEnvironment new classesDo: 			[:each | 			(classNames 				includes: (each isMeta ifTrue: [each soleInstance] ifFalse: [each]) name) 					ifFalse: 						[(each whichSelectorsReferTo: literal) isEmpty ifFalse: [^true].						(each whichSelectorsReferTo: aSymbol) isEmpty ifFalse: [^true]]].	^false! !!RemoveClassRefactoring methodsFor: 'preconditions'!preconditions	^classNames inject: RBCondition empty		into: 			[:sum :each | 			| aClass |			aClass := self model classNamed: each asSymbol.			aClass isNil ifTrue: [self refactoringError: 'No such class'].			sum 				& (((RBCondition isMetaclass: aClass) 						errorMacro: 'Cannot remove just the metaclass') not 						& ((RBCondition withBlock: [(self hasReferencesTo: each asSymbol) not])								errorMacro: each , ' is referenced.<n>Browse references?';								errorBlock: 										[self openBrowserOn: (BrowserEnvironment new 													referencesTo: (Smalltalk associationAt: each ifAbsent: [each]))];								yourself) 							& ((RBCondition hasSubclasses: aClass) not 									| ((RBCondition isEmptyClass: aClass) 											& ((RBCondition withBlock: [aClass superclass notNil])													errorMacro: 'Cannot remove top level class<n>when it has subclasses';													yourself))))]! !!RemoveClassRefactoring methodsFor: 'transforming'!removeClasses	classNames do: [:each | self model removeClassNamed: each]! !!RemoveClassRefactoring methodsFor: 'transforming'!reparentSubclasses	classNames do: 			[:each | 			| class |			class := self model classNamed: each.			self model reparentClasses: class subclasses copy to: class superclass]! !!RemoveClassRefactoring methodsFor: 'transforming'!transform	self		reparentSubclasses;		removeClasses! !!RemoveClassRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' classNames: '.	classNames asArray storeOn: aStream.	aStream nextPut: $)! !!RemoveClassRefactoring class methodsFor: 'instance creation'!classNames: aClassNameCollection 	^self new classNames: aClassNameCollection! !!RemoveClassRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk classNames: aClassNameCollection 	^(self new)		model: aRBSmalltalk;		classNames: aClassNameCollection;		yourself! !!RemoveClassTest methodsFor: 'failure tests'!testBadName	self 		shouldFail: (RemoveClassRefactoring classNames: #(#RecursiveSelfRule))! !!RemoveClassTest methodsFor: 'failure tests'!testRemoveReferenced	self 		shouldFail: (RemoveClassRefactoring classNames: #(#BasicLintRuleTest))! !!RemoveClassTest methodsFor: 'tests'!testRemoveClass	| refactoring |	refactoring := RemoveClassRefactoring 				classNames: (Array with: ('Foo' , 'LintRuleTest') asSymbol).	self executeRefactoring: refactoring.	self 		assert: (refactoring model classNamed: ('Foo' , 'LintRuleTest') asSymbol) 				isNil.	self 		assert: (refactoring model classNamed: #TransformationRuleTest) superclass 				= (refactoring model classNamed: #LintRuleTest)! !!RemoveClassVariableChange methodsFor: 'converting'!asUndoOperation	^AddClassVariableChange add: variable to: self changeClass! !!RemoveClassVariableChange methodsFor: 'printing'!changeString	^'Remove class variable named, <1s>, from <2s>' 		expandMacrosWith: variable		with: self displayClassName! !!RemoveClassVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' removeClassVarNamed: ';		nextPutAll: variable;		nextPut: $!!! !!RemoveClassVariableChange methodsFor: 'private'!changeSymbol	^#removeClassVarName:! !!RemoveClassVariableChange methodsFor: 'private' stamp: 'md 8/2/2005 23:36'!primitiveExecute	[super primitiveExecute] on: Notification do: [:ex | ex resume] ! !!RemoveClassVariableChange methodsFor: 'private'!variable	^variable asSymbol! !!RemoveClassVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isMetaclass: class) not 		& (RBCondition definesClassVariable: variableName in: class) 			& (RBCondition withBlock: 						[| block |						block := 								[:each | 								(each whichSelectorsReferToClassVariable: variableName) isEmpty 									ifFalse: 										[class realClass isNil 											ifTrue: 												[self 													refactoringError: ('<1s> is referenced.' expandMacrosWith: variableName)]											ifFalse: 												[self refactoringError: ('<1s> is referenced.<n>Browse references?' 															expandMacrosWith: variableName)													with: 														[self 															openBrowserOn: (VariableEnvironment referencesToClassVariable: variableName																	in: class realClass)]]]].						class withAllSubclasses do: block.						class metaclass withAllSubclasses do: block.						true])! !!RemoveClassVariableRefactoring methodsFor: 'transforming'!transform	class removeClassVariable: variableName! !!RemoveClassVariableTest methodsFor: 'failure tests'!testNonExistantName	self 		shouldFail: (RemoveClassVariableRefactoring variable: #RecursiveSelfRule1				class: TransformationRuleTest)! !!RemoveClassVariableTest methodsFor: 'failure tests'!testReferencedVariable	self 		shouldFail: (RemoveClassVariableRefactoring variable: #RecursiveSelfRule				class: TransformationRuleTest)! !!RemoveClassVariableTest methodsFor: 'tests'!testRemoveClassVar	| refactoring class |	refactoring := RemoveClassVariableRefactoring variable: 'Foo1'				class: LintRuleTest.	class := refactoring model classNamed: #LintRuleTest.	self assert: (class definesClassVariable: 'Foo1').	self executeRefactoring: refactoring.	self deny: (class definesClassVariable: 'Foo1')! !!RemoveInstanceVariableChange methodsFor: 'converting'!asUndoOperation	^AddInstanceVariableChange add: variable to: self changeClass! !!RemoveInstanceVariableChange methodsFor: 'printing'!changeString	^'Remove instance variable named, <1s>, from <2s>' 		expandMacrosWith: variable		with: self displayClassName! !!RemoveInstanceVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' removeInstVarNamed: ';		nextPutAll: variable;		nextPut: $!!! !!RemoveInstanceVariableChange methodsFor: 'private'!changeSymbol	^#removeInstVarName:! !!RemoveInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	| references |	references := RBCondition hierarchyOf: class				referencesInstanceVariable: variableName.	class realClass isNil 		ifTrue: 			[references 				errorMacro: ('<1s> is referenced.' expandMacrosWith: variableName)]		ifFalse: 			[references				errorMacro: ('<1s> is referenced.<n>Browse references?' 							expandMacrosWith: variableName);				errorBlock: 						[self openBrowserOn: (BrowserEnvironment new instVarRefsTo: variableName									in: class realClass)]].	^(RBCondition definesInstanceVariable: variableName asString in: class) 		& references not! !!RemoveInstanceVariableRefactoring methodsFor: 'transforming'!transform	class removeInstanceVariable: variableName! !!RemoveInstanceVariableRefactoring class methodsFor: 'as yet unclassified' stamp: 'rr 3/11/2004 11:06'!remove: variable from: class	^ self variable: variable class:  class! !!RemoveInstanceVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:13'!testModelRemoveInstanceVariable	| class |	model 		defineClass: 'nil subclass: #Object instanceVariableNames: ''foo1'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model classNamed: #Object.	self assert: (class definesInstanceVariable: 'foo1').	self executeRefactoring: (RemoveInstanceVariableRefactoring 				model: model				variable: 'foo1'				class: class).	self deny: (class definesInstanceVariable: 'foo1')! !!RemoveInstanceVariableTest methodsFor: 'tests'!testRemoveInstVar	| refactoring class |	refactoring := RemoveInstanceVariableRefactoring variable: 'foo1'				class: LintRuleTest.	class := refactoring model classNamed: #LintRuleTest.	self assert: (class definesInstanceVariable: 'foo1').	self executeRefactoring: refactoring.	self deny: (class definesInstanceVariable: 'foo1')! !!RemoveInstanceVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (RemoveInstanceVariableRefactoring variable: 'name1'				class: LintRuleTest)! !!RemoveInstanceVariableTest methodsFor: 'failure tests'!testReferencedVariable	self shouldFail: (RemoveInstanceVariableRefactoring variable: 'name'				class: LintRuleTest)! !!RemoveMethodChange methodsFor: 'comparing'!= aRemoveMethodChange 	super = aRemoveMethodChange ifFalse: [^false].	^selector = aRemoveMethodChange selector! !!RemoveMethodChange methodsFor: 'comparing'!hash	^selector hash! !!RemoveMethodChange methodsFor: 'converting'!asUndoOperation	^AddMethodChange compile: (self methodSourceFor: selector)		in: self changeClass! !!RemoveMethodChange methodsFor: 'printing'!changeString	^'Remove method, #<1s>, from: <2s>' expandMacrosWith: selector		with: self displayClassName! !!RemoveMethodChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' removeSelector: ';		nextPutAll: selector;		nextPut: $!!! !!RemoveMethodChange methodsFor: 'private'!primitiveExecute	^self changeClass removeSelector: selector! !!RemoveMethodChange methodsFor: 'private'!selector	^selector! !!RemoveMethodChange methodsFor: 'initialize-release'!selector: aSymbol 	selector := aSymbol! !!RemoveMethodChange class methodsFor: 'instance creation'!remove: aSymbol from: aClass 	^(self new)		changeClass: aClass;		selector: aSymbol;		yourself! !!RemoveMethodRefactoring methodsFor: 'preconditions'!checkReferencesToAnyOf: aSelectorCollection 	aSelectorCollection do: 			[:each | 			self model allReferencesTo: each				do: 					[:aRBMethod | 					(aSelectorCollection includes: aRBMethod selector) 						ifFalse: 							[self 								refactoringError: ('Possible call to <2s> in <1p><n>Browse references?' 										expandMacrosWith: aRBMethod modelClass										with: each)								with: [self openBrowserOn: (BrowserEnvironment new referencesTo: each)]]]]! !!RemoveMethodRefactoring methodsFor: 'preconditions'!checkReferencesToSuperSendsToAnyOf: superMessages 	[superMessages isEmpty] whileFalse: 			[self 				refactoringWarning: ('Although <1s> is equivalent to a superclass method,<n>it contains a super send so it might modify behavior.' 						expandMacrosWith: superMessages first).			superMessages remove: superMessages first]! !!RemoveMethodRefactoring methodsFor: 'preconditions'!checkSuperMethods	| superMessages nonSupers |	nonSupers := OrderedCollection new.	superMessages := OrderedCollection new.	(selectors reject: [:each | self justSendsSuper: each]) do: 			[:each | 			(self superclassEquivalentlyDefines: each) 				ifTrue: 					[(class parseTreeFor: each) superMessages isEmpty 						ifFalse: [superMessages add: each]]				ifFalse: [nonSupers add: each]].	nonSupers isEmpty & superMessages isEmpty ifTrue: [^self].	self checkReferencesToAnyOf: nonSupers.	self checkReferencesToSuperSendsToAnyOf: superMessages! !!RemoveMethodRefactoring methodsFor: 'preconditions'!justSendsSuper: aSelector 	| matcher parseTree superclass |	matcher := ParseTreeSearcher justSendsSuper.	parseTree := class parseTreeFor: aSelector.	(matcher executeTree: parseTree initialAnswer: false) ifFalse: [^false].	parseTree lastIsReturn ifTrue: [^true].	superclass := class superclass whichClassIncludesSelector: aSelector.	superclass isNil ifTrue: [^true].	"Since there isn't a superclass that implements the message, we can 								 delete it since it would be an error anyway."	parseTree := superclass parseTreeFor: aSelector.	matcher := ParseTreeSearcher new.	matcher matches: '^``@object'		do: 			[:aNode :answer | 			answer				add: aNode value;				yourself].	matcher executeTree: parseTree initialAnswer: Set new.	^(matcher answer 		detect: [:each | (each isVariable and: [each name = 'self']) not]		ifNone: [nil]) isNil! !!RemoveMethodRefactoring methodsFor: 'preconditions'!preconditions	^(selectors inject: RBCondition empty		into: [:cond :each | cond & (RBCondition definesSelector: each in: class)]) 			& (RBCondition withBlock: 						[self checkSuperMethods.						true])! !!RemoveMethodRefactoring methodsFor: 'preconditions'!superclassEquivalentlyDefines: aSelector 	| superTree myTree |	class superclass isNil ifTrue: [^false].	superTree := class superclass parseTreeFor: aSelector.	myTree := class parseTreeFor: aSelector.	(superTree isNil or: [myTree isNil]) ifTrue: [^false].	^superTree equalTo: myTree exceptForVariables: #()! !!RemoveMethodRefactoring methodsFor: 'initialize-release'!removeMethods: selectorCollection from: aClass 	class := self classObjectFor: aClass.	selectors := selectorCollection! !!RemoveMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' removeMethods: '.	selectors asArray storeOn: aStream.	aStream nextPutAll: ' from: '.	class storeOn: aStream.	aStream nextPut: $)! !!RemoveMethodRefactoring methodsFor: 'transforming'!transform	selectors do: [:each | class removeMethod: each]! !!RemoveMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk removeMethods: selectorCollection from: aClass 	^(self new)		model: aRBSmalltalk;		removeMethods: selectorCollection from: aClass;		yourself! !!RemoveMethodRefactoring class methodsFor: 'instance creation'!removeMethods: selectorCollection from: aClass	^self new removeMethods: selectorCollection from: aClass! !!RemoveMethodTest methodsFor: 'tests'!testModelRecursiveMethodThatIsNotReferencedFromOtherMethods	| class otherClass |	class := model classNamed: #Object.	class compile: 'someMethodThatIsNotReferenced ^2' classified: #(#accessing).	self assert: (class definesMethod: #someMethodThatIsNotReferenced).	otherClass := model metaclassNamed: self class superclass name.	otherClass 		compile: 'someMethodThatIsNotReferenced ^3 someMethodThatIsNotReferenced'		classified: #(#accessing).	model removeClassNamed: self class name.	self executeRefactoring: (RemoveMethodRefactoring 				model: model				removeMethods: #(#someMethodThatIsNotReferenced)				from: class).	self deny: (class definesMethod: #someMethodThatIsNotReferenced)! !!RemoveMethodTest methodsFor: 'tests'!testRemoveMethod	| refactoring selectors |	selectors := Array with: ('selectorNot' , 'Referenced') asSymbol.	refactoring := RemoveMethodRefactoring removeMethods: selectors				from: RefactoryTestDataApp.	self assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				directlyDefinesMethod: selectors first).	self executeRefactoring: refactoring.	self deny: ((refactoring model classNamed: #RefactoryTestDataApp) 				directlyDefinesMethod: selectors first)! !!RemoveMethodTest methodsFor: 'failure tests'!testRemoveReferenced	self shouldFail: (RemoveMethodRefactoring removeMethods: #(#checkClass:)				from: BasicLintRuleTest)! !!RemoveMethodTest methodsFor: 'failure tests'!testRemoveSameMethodButSendsSuper	self shouldWarn: (RemoveMethodRefactoring removeMethods: #(#new)				from: BasicLintRuleTest class)! !!RemoveParameterRefactoring methodsFor: 'private' stamp: 'md 8/2/2005 22:25'!computeNewSelector	| keywords stream |	oldSelector numArgs == 0 		ifTrue: [self refactoringError: 'This method contains no arguments'].	oldSelector isInfix 		ifTrue: [self refactoringError: 'Cannot remove parameters of infix selectors'].	keywords := oldSelector keywords asOrderedCollection.	keywords size = 1 ifTrue: [^(keywords first copyWithout: $:) asSymbol].	keywords removeAt: parameterIndex.	stream := WriteStream on: ''.	keywords do: [:each | stream nextPutAll: each].	^stream contents asSymbol! !!RemoveParameterRefactoring methodsFor: 'transforming'!getNewSelector	| tree |	(class directlyDefinesMethod: oldSelector)		ifFalse: [self refactoringError: 'Method doesn''t exist'].	tree := class parseTreeFor: oldSelector.	tree isNil ifTrue: [self refactoringError: 'Cannot parse sources'].	parameterIndex := tree argumentNames indexOf: argument ifAbsent: [self refactoringError: 'Select a parameter!!!!'].	permutation := (1 to: oldSelector numArgs)				copyWithout: parameterIndex.	newSelector := self computeNewSelector! !!RemoveParameterRefactoring methodsFor: 'transforming'!hasReferencesToTemporaryIn: each 	| tree |	tree := each parseTreeFor: oldSelector.	tree isNil ifTrue: [self refactoringError: 'Cannot parse sources.'].	^tree references: (tree argumentNames at: parameterIndex)! !!RemoveParameterRefactoring methodsFor: 'preconditions'!myConditions	| imps |	imps := self model allImplementorsOf: oldSelector.	self getNewSelector.	^imps inject: (RBCondition definesSelector: oldSelector in: class)		into: 			[:cond :each | 			cond 				& (RBCondition withBlock: [(self hasReferencesToTemporaryIn: each) not]						errorString: 'This argument is still referenced in atleast one implementor!!!!')]! !!RemoveParameterRefactoring methodsFor: 'initialize-release'!removeParameter: aString in: aClass selector: aSelector 	oldSelector := aSelector.	class := self classObjectFor: aClass.	argument := aString! !!RemoveParameterRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' removeParameter: ''';		nextPutAll: argument;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: oldSelector.	aStream nextPut: $)! !!RemoveParameterRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk removeParameter: aString in: aClass selector: aSelector 	^(self new)		model: aRBSmalltalk;		removeParameter: aString			in: aClass			selector: aSelector;		yourself! !!RemoveParameterRefactoring class methodsFor: 'instance creation'!removeParameter: aString in: aClass selector: aSelector	^self new removeParameter: aString in: aClass selector: aSelector! !!RemoveParameterTest methodsFor: 'failure tests'!testNonExistantName	self		shouldFail: (RemoveParameterRefactoring 					removeParameter: 'asdf'					in: BasicLintRuleTest					selector: #checkClass:);		shouldFail: (RemoveParameterRefactoring 					removeParameter: 'aSmalllintContext'					in: BasicLintRuleTest					selector: #checkClass1:)! !!RemoveParameterTest methodsFor: 'failure tests'!testPrimitiveMethods	| refactoring |	(model classNamed: #Object) 		compile: 'foo123: a <primitive: 100> ^#() primitiveFailed'		classified: #(#accessing).	refactoring := RemoveParameterRefactoring 				model: model				removeParameter: 'a'				in: Object				selector: #foo123:.	self shouldFail: refactoring! !!RemoveParameterTest methodsFor: 'tests'!testRemoveParameter	| refactoring class |	refactoring := RemoveParameterRefactoring 				removeParameter: 'anArg'				in: RefactoryTestDataApp				selector: ('rename' , 'ThisMethod:') asSymbol.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self assert: (class parseTreeFor: #renameThisMethod) 				= (RBParser parseMethod: 'renameThisMethod								^self').	self assert: (class parseTreeFor: #callMethod) 				= (RBParser parseMethod: 'callMethod								^(self renameThisMethod)').	self 		deny: (class directlyDefinesMethod: ('rename' , 'ThisMethod:') asSymbol)! !!RemovePoolVariableChange methodsFor: 'converting'!asUndoOperation	^AddPoolVariableChange add: variable to: self changeClass! !!RemovePoolVariableChange methodsFor: 'private'!changeObject	| dictionary |	dictionary := variable isString 				ifTrue: [Smalltalk at: variable asSymbol]				ifFalse: [variable].	^dictionary! !!RemovePoolVariableChange methodsFor: 'private'!changeSymbol	^#removeSharedPool:! !!RemovePoolVariableChange methodsFor: 'private'!changesFileTemplate	^'<1p> <2s> <3s>'! !!RemovePoolVariableChange methodsFor: 'private'!variable	^variable isString 		ifTrue: [variable]		ifFalse: 			[Smalltalk keyAtValue: variable ifAbsent: [self error: 'Cannot find value']]! !!RemovePoolVariableChange methodsFor: 'printing'!changeString	^'Remove pool variable named, <1s>, from <2s>' 		expandMacrosWith: self variable		with: self displayClassName! !!RemovePoolVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' removeSharedPool: ';		nextPutAll: self variable;		nextPut: $!!! !!RenameClassChange methodsFor: 'comparing'!= aRenameClassChange 	super = aRenameClassChange ifFalse: [^false].	^oldName = aRenameClassChange oldName 		and: [newName = aRenameClassChange newName]! !!RenameClassChange methodsFor: 'accessing'!changeClass	^Smalltalk at: oldName asSymbol ifAbsent: [Smalltalk at: newName asSymbol]! !!RenameClassChange methodsFor: 'accessing'!renameChangesForClass: aClassName to: newClassName 	| change |	change := super renameChangesForClass: aClassName to: newClassName.	oldName asSymbol == aClassName 		ifTrue: [change rename: newClassName to: newName].	^change! !!RenameClassChange methodsFor: 'private'!executeNotifying: aBlock 	| undos |	self changeClass rename: newName.	undos := changes collect: 					[:each | 					(each renameChangesForClass: oldName asSymbol to: newName asSymbol) 						executeNotifying: aBlock].	^(self copy)		changes: undos reverse;		rename: newName to: oldName;		yourself! !!RenameClassChange methodsFor: 'private'!flattenOnto: aCollection 	aCollection 		add: (self copy changes: (changes inject: OrderedCollection new						into: 							[:sum :each | 							each flattenOnto: sum.							sum]))! !!RenameClassChange methodsFor: 'private'!newName	^newName! !!RenameClassChange methodsFor: 'private'!oldName	^oldName! !!RenameClassChange methodsFor: 'initialize-release'!rename: oldString to: newString 	oldName := oldString.	newName := newString! !!RenameClassChange class methodsFor: 'instance creation'!rename: oldString to: newString 	^(self new)		rename: oldString to: newString;		yourself! !!RenameClassRefactoring methodsFor: 'initialize-release'!className: aName newName: aNewName 	className := aName asSymbol.	class := self model classNamed: className.	newName := aNewName asSymbol! !!RenameClassRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition withBlock: [class notNil and: [class isMeta not]]		errorString: className , ' is not a valid class name') 			& (RBCondition isValidClassName: newName) 			& (RBCondition isGlobal: newName in: self model) not! !!RenameClassRefactoring methodsFor: 'transforming'!renameReferences	| replacer |	replacer := (ParseTreeRewriter replaceLiteral: className with: newName)				replace: className with: newName;				replaceArgument: newName					withValueFrom: 						[:aNode | 						self 							refactoringError: newName , ' already exists within the reference scope'];				yourself.	self model allReferencesToClass: class		do: 			[:method | 			(method modelClass hierarchyDefinesVariable: newName) 				ifTrue: 					[self refactoringError: newName , ' is already defined in hierarchy of ' 								, method modelClass printString].			self 				convertMethod: method selector				for: method modelClass				using: replacer]! !!RenameClassRefactoring methodsFor: 'transforming'!transform	self model 		renameClass: class		to: newName		around: [self renameReferences]! !!RenameClassRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' rename: '.	class storeOn: aStream.	aStream		nextPutAll: ' to: #';		nextPutAll: newName;		nextPut: $)! !!RenameClassRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk rename: aClass to: aNewName 	^(self new)		model: aRBSmalltalk;		className: aClass name newName: aNewName;		yourself! !!RenameClassRefactoring class methodsFor: 'instance creation'!rename: aClass to: aNewName	^self new className: aClass name newName: aNewName! !!RenameClassTest methodsFor: 'failure tests'!testBadName	self		shouldFail: (RenameClassRefactoring rename: LintRuleTest					to: self objectClassVariable);		shouldFail: (RenameClassRefactoring rename: LintRuleTest to: #'Ob ject')! !!RenameClassTest methodsFor: 'failure tests'!testExistingName	self shouldFail: (RenameClassRefactoring rename: self class to: #Object)! !!RenameClassTest methodsFor: 'failure tests'!testMetaClassFailure	self 		shouldFail: (RenameClassRefactoring rename: self class class to: #Foo)! !!RenameClassTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:13'!testModelRenameClass	| refactoring class |	model 		defineClass: 'Object subclass: #Foo instanceVariableNames: ''a'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model classNamed: #Foo.	class		compile: 'foo	^Object' classified: #(#accessing);		compile: 'objectName ^#(Object)' classified: #(#accessing).	refactoring := RenameClassRefactoring 				model: model				rename: Object				to: #Thing.	self executeRefactoring: refactoring.	self assert: (model includesClassNamed: #Thing).	self deny: (model includesClassNamed: #Object).	self 		assert: (class parseTreeFor: #foo) = (RBParser parseMethod: 'foo ^Thing').	self assert: (class parseTreeFor: #objectName) 				= (RBParser parseMethod: 'objectName ^#(Thing)').	self assert: class superclass name = #Thing! !!RenameClassTest methodsFor: 'tests'!testRenameClass	| refactoring class |	refactoring := RenameClassRefactoring 				rename: (Smalltalk at: ('Class' , 'ToRename') asSymbol)				to: 'New' , 'ClassName' asSymbol.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: ('New' , 'ClassName') asSymbol) 				parseTreeFor: #method1) = (RBParser parseMethod: 'method1	^self method2').	self deny: (refactoring model 				includesClassNamed: ('Class' , 'ToRename') asSymbol).	class := refactoring model 				classNamed: ('Subclass' , 'OfClassToRename') asSymbol.	self assert: class superclass 				= (refactoring model classNamed: ('New' , 'ClassName') asSymbol).	self assert: (class parseTreeFor: #symbolReference) 				= (RBParser parseMethod: 'symbolReference								^#NewClassName').	self assert: (class parseTreeFor: #reference) 				= (RBParser parseMethod: 'reference								^NewClassName new')! !!RenameClassVariableChange methodsFor: 'private'!addNewVariable	(AddClassVariableChange add: newName to: self changeClass) execute! !!RenameClassVariableChange methodsFor: 'private'!copyOldValuesToNewVariable	| oldValue |	oldValue := self changeClass classPool at: oldName ifAbsent: [].	self changeClass classPool at: newName asSymbol put: oldValue! !!RenameClassVariableChange methodsFor: 'private'!removeOldVariable	(RemoveClassVariableChange remove: oldName from: self changeClass) execute! !!RenameClassVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isMetaclass: class) not 		& (RBCondition isValidClassVarName: newName asString for: class) 			& (RBCondition definesClassVariable: variableName asString in: class) 			& (RBCondition hierarchyOf: class definesVariable: newName asString) not 			& (RBCondition isGlobal: newName asString in: self model) not! !!RenameClassVariableRefactoring methodsFor: 'initialize-release'!rename: aVarName to: aName in: aClass	self variable: aVarName class: aClass.	newName := aName! !!RenameClassVariableRefactoring methodsFor: 'transforming'!renameReferences	| replacer subclasses |	replacer := ParseTreeRewriter 				rename: variableName				to: newName				handler: 					[self 						refactoringError: ('<1s> is already defined as a method or block temporary <n> variable in this class or one of its subclasses' 								expandMacrosWith: newName)].	subclasses := class withAllSubclasses asSet.	subclasses addAll: class metaclass withAllSubclasses.	self 		convertClasses: subclasses		select: [:aClass | aClass whichSelectorsReferToClassVariable: variableName]		using: replacer! !!RenameClassVariableRefactoring methodsFor: 'transforming'!transform	class 		renameClassVariable: variableName		to: newName		around: [self renameReferences]! !!RenameClassVariableRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' rename: ''';		nextPutAll: variableName;		nextPutAll: ''' to: ''';		nextPutAll: newName;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!RenameClassVariableRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk rename: aVarName to: aName in: aClass 	^(self new)		model: aRBSmalltalk;		rename: aVarName			to: aName			in: aClass;		yourself! !!RenameClassVariableRefactoring class methodsFor: 'instance creation'!rename: aVarName to: aName in: aClass	^self new		rename: aVarName		to: aName		in: aClass! !!RenameClassVariableTest methodsFor: 'failure tests'!testAlreadyExistingName	self shouldFail: (RenameClassVariableRefactoring 				rename: #RecursiveSelfRule				to: self objectClassVariable				in: TransformationRuleTest)! !!RenameClassVariableTest methodsFor: 'failure tests'!testMetaClassFailure	self shouldFail: (RenameClassVariableRefactoring 				rename: #RecursiveSelfRule				to: #Foo				in: TransformationRuleTest class)! !!RenameClassVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (RenameClassVariableRefactoring 				rename: #foo				to: #newFoo				in: BasicLintRuleTest)! !!RenameClassVariableTest methodsFor: 'tests'!testRenameClassVar	| refactoring class |	refactoring := RenameClassVariableRefactoring 				rename: #RecursiveSelfRule				to: #RSR				in: TransformationRuleTest.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #TransformationRuleTest.	self assert: (class directlyDefinesClassVariable: #RSR).	self deny: (class directlyDefinesClassVariable: #RecursiveSelfRule).	self 		assert: (class metaclass parseTreeFor: #initializeAfterLoad1) = (RBParser 						parseMethod: 'initializeAfterLoad1								RSR := ParseTreeSearcher new.								RSR									addMethodSearches: #(''`@methodName: `@args | `@temps | self `@methodName: `@args'' ''`@methodName: `@args | `@temps | ^self `@methodName: `@args'')											-> [:aNode :answer | true]').	self assert: (class metaclass parseTreeFor: #nuke) 				= (RBParser parseMethod: 'nuke								RSR := nil').	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext 								class := aSmalllintContext selectedClass.								(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 										[(RSR executeTree: rewriteRule tree initialAnswer: false)											ifFalse: 												[builder compile: rewriteRule tree printString													in: class													classified: aSmalllintContext protocols]]')! !!RenameInstanceVariableChange methodsFor: 'private'!addNewVariable	(AddInstanceVariableChange add: newName to: self changeClass) execute! !!RenameInstanceVariableChange methodsFor: 'private'!copyOldValuesToNewVariable	| newIndex oldIndex |	oldIndex := self changeClass allInstVarNames indexOf: oldName asString.	newIndex := self changeClass allInstVarNames indexOf: newName asString.	self changeClass withAllSubclasses do: 			[:each | 			each allInstances 				do: [:inst | inst instVarAt: newIndex put: (inst instVarAt: oldIndex)]]! !!RenameInstanceVariableChange methodsFor: 'private'!removeOldVariable	(RemoveInstanceVariableChange remove: oldName from: self changeClass) 		execute! !!RenameInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isValidInstanceVariableName: newName for: class) 		& (RBCondition definesInstanceVariable: variableName in: class) 			& (RBCondition hierarchyOf: class definesVariable: newName) not 			& (RBCondition isGlobal: newName in: self model) not! !!RenameInstanceVariableRefactoring methodsFor: 'initialize-release'!rename: aVarName to: aName in: aClass	self variable: aVarName class: aClass.	newName := aName! !!RenameInstanceVariableRefactoring methodsFor: 'transforming'!renameReferences	| replacer |	replacer := ParseTreeRewriter 				rename: variableName				to: newName				handler: 					[self 						refactoringError: ('<1s> is already defined as a method or block temporary <n> variable in this class or one of its subclasses' 								expandMacrosWith: newName)].	self 		convertClasses: class withAllSubclasses		select: [:aClass | aClass whichSelectorsReferToInstanceVariable: variableName]		using: replacer! !!RenameInstanceVariableRefactoring methodsFor: 'transforming'!transform	class 		renameInstanceVariable: variableName		to: newName		around: [self renameReferences]! !!RenameInstanceVariableRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' rename: ''';		nextPutAll: variableName;		nextPutAll: ''' to: ''';		nextPutAll: newName;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!RenameInstanceVariableRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk rename: aVarName to: aName in: aClass 	^(self new)		model: aRBSmalltalk;		rename: aVarName			to: aName			in: aClass;		yourself! !!RenameInstanceVariableRefactoring class methodsFor: 'instance creation'!rename: aVarName to: aName in: aClass	^self new		rename: aVarName		to: aName		in: aClass! !!RenameInstanceVariableTest methodsFor: 'failure tests'!testAlreadyExistingName	self shouldFail: (RenameInstanceVariableRefactoring 				rename: 'classBlock'				to: 'name'				in: BasicLintRuleTest)! !!RenameInstanceVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (RenameInstanceVariableRefactoring 				rename: 'foo'				to: 'newFoo'				in: BasicLintRuleTest)! !!RenameInstanceVariableTest methodsFor: 'tests'!testRenameInstVar	| refactoring class |	refactoring := RenameInstanceVariableRefactoring 				rename: 'classBlock'				to: 'asdf'				in: BasicLintRuleTest.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #BasicLintRuleTest.	self assert: (class directlyDefinesInstanceVariable: 'asdf').	self deny: (class directlyDefinesInstanceVariable: 'classBlock').	self 		assert: (class parseTreeFor: #checkClass:) = (RBParser 						parseMethod: 'checkClass: aSmalllintContext 								^asdf value: aSmalllintContext value: result').	self 		assert: (class parseTreeFor: #classBlock:) = (RBParser 						parseMethod: 'classBlock: aBlock								asdf := aBlock testMethod1').	self 		assert: (class parseTreeFor: #initialize) = (RBParser 						parseMethod: 'initialize								super initialize.								asdf := [:context :aResult | ].								methodBlock := [:context :aResult | ].								self resultClass: SelectorEnvironment.')! !!RenameMethodRefactoring methodsFor: 'testing'!hasPermutedArguments	^hasPermutedArguments isNil 		ifTrue: [hasPermutedArguments := super hasPermutedArguments]		ifFalse: [hasPermutedArguments]! !!RenameMethodRefactoring methodsFor: 'testing'!implementorsCanBePrimitives	^self hasPermutedArguments not! !!RenameMethodRefactoring methodsFor: 'preconditions'!myConditions	^RBCondition withBlock: [oldSelector numArgs = newSelector numArgs]		errorString: newSelector printString 				, ' doesn''t have the correct number of arguments.'! !!RenameMethodRefactoring methodsFor: 'preconditions'!preconditions	| newCondition |	newCondition := (RBCondition withBlock: [newSelector = oldSelector]				errorString: 'The selectors are <1?:not >equivalent') & (RBCondition 							withBlock: [permutation asArray ~= (1 to: oldSelector numArgs) asArray]							errorString: 'The arguments are <1?:not >permuted').	^newCondition | super preconditions! !!RenameMethodRefactoring methodsFor: 'transforming'!parseTreeRewriter	| rewriteRule oldString newString |	oldString := self buildSelectorString: oldSelector.	newString := self buildSelectorString: newSelector				withPermuteMap: permutation.	rewriteRule := self hasPermutedArguments 				ifTrue: [ParseTreeRewriter new]				ifFalse: [ParseTreeRewriter replaceLiteral: oldSelector with: newSelector].	rewriteRule replace: '``@object ' , oldString		with: '``@object ' , newString.	^rewriteRule! !!RenameMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' renameMethod: #';		nextPutAll: oldSelector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' to: #';		nextPutAll: newSelector;		nextPutAll: ' permuation: '.	permutation storeOn: aStream.	aStream nextPut: $)! !!RenameMethodRefactoring class methodsFor: 'instance creation' stamp: 'md 3/15/2006 17:29'!model: aRBSmalltalk renameMethod: aSelector in: aClass to: newSelector permutation: aMap 	^(self new)		model: aRBSmalltalk;		renameMethod: aSelector			in: aClass			to: newSelector			permutation: aMap;		yourself! !!RenameMethodRefactoring class methodsFor: 'instance creation' stamp: 'md 3/15/2006 17:26'!renameMethod: aSelector in: aClass to: newSelector permutation: aMap 	^self new renameMethod: aSelector		in: aClass		to: newSelector		permutation: aMap! !!RenameMethodTest methodsFor: 'failure tests' stamp: 'md 3/15/2006 17:28'!testExistingSelector	self shouldFail: (RenameMethodRefactoring 				renameMethod: #checkClass:				in: BasicLintRuleTest				to: #runOnEnvironment:				permutation: (1 to: 1))! !!RenameMethodTest methodsFor: 'failure tests' stamp: 'md 3/15/2006 17:28'!testMultipleSelectors	self shouldWarn: (RenameMethodRefactoring 				renameMethod: #checkClass:				in: BasicLintRuleTest				to: #foo:				permutation: (1 to: 1))! !!RenameMethodTest methodsFor: 'tests' stamp: 'md 3/15/2006 17:28'!testRenamePermuteArgs	| refactoring class |	refactoring := RenameMethodRefactoring 				renameMethod: ('rename:' , 'two:') asSymbol				in: RefactoryTestDataApp				to: ('rename:' , 'two:') asSymbol				permutation: #(2 1).	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: ('rename:' , 'two:') asSymbol) = (RBParser 						parseMethod: 'rename: argumentMethod two: this ^self printString, this, argumentMethod').	self assert: (class parseTreeFor: #exampleCall) 				= (RBParser parseMethod: 'exampleCall ^self rename: 2 two: 1')! !!RenameMethodTest methodsFor: 'tests' stamp: 'md 3/15/2006 17:29'!testRenamePrimitive	| refactoring count |	count := 0.	model allReferencesTo: #basicAt:put: do: [:method | count := count + 1].	refactoring := RenameMethodRefactoring 				model: model				renameMethod: #basicAt:put:				in: Object				to: ('at:' , 'bar:') asSymbol				permutation: (1 to: 2).	self proceedThroughWarning: [self executeRefactoring: refactoring].	model allReferencesTo: #basicAt:put:		do: 			[:method | 			count := count - 1.			self assert: method source isNil].	model allReferencesTo: ('at:' , 'bar:') asSymbol		do: [:method | count := count - 1].	self assert: count = 0! !!RenameMethodTest methodsFor: 'tests' stamp: 'md 3/15/2006 17:28'!testRenameTestMethod	| refactoring class |	refactoring := RenameMethodRefactoring 				renameMethod: ('rename' , 'ThisMethod:') asSymbol				in: RefactoryTestDataApp				to: #renameThisMethod2:				permutation: (1 to: 1).	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self assert: (class parseTreeFor: #renameThisMethod2:) 				= (RBParser parseMethod: 'renameThisMethod2: anArg	^self').	self assert: (class parseTreeFor: #callMethod) 				= (RBParser parseMethod: 'callMethod	^(self renameThisMethod2: 5)').	self 		assert: (class parseTreeFor: #symbolReference) = (RBParser 						parseMethod: 'symbolReference		^ #(#renameThisMethod2: #(4 #renameThisMethod2:))').	self 		deny: (class directlyDefinesMethod: ('rename' , 'ThisMethod:') asSymbol)! !!RenameMethodTest methodsFor: 'tests' stamp: 'md 3/15/2006 17:29'!testRenameTestMethod1	| refactoring class |	refactoring := RenameMethodRefactoring 				renameMethod: ('test' , 'Method1') asSymbol				in: RefactoryTestDataApp				to: #testMethod2				permutation: (1 to: 0).	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: #testMethod2) = (RBParser 						parseMethod: 'testMethod2	^self testMethod2 , ([:each | each testMethod2] value: #(#(#testMethod2) 2 #testMethod2))').	self 		assert: ((refactoring model classNamed: #BasicLintRuleTest) 				parseTreeFor: #classBlock:) = (RBParser 							parseMethod: 'classBlock: aBlock	classBlock := aBlock testMethod2').	self deny: (class directlyDefinesMethod: ('test' , 'Method1') asSymbol)! !!RenameTemporaryRefactoring methodsFor: 'initialize-release'!class: aClass selector: aSelector interval: anInterval newName: aString 	class := self classObjectFor: aClass.	selector := aSelector.	interval := anInterval.	newName := aString! !!RenameTemporaryRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition isValidInstanceVariableName: newName for: class) 			& (RBCondition definesInstanceVariable: newName in: class) not 			& (RBCondition definesClassVariable: newName in: class) not 			& (RBCondition withBlock: 						[| methodSource |						interval first > interval last 							ifTrue: [self refactoringError: 'Invalid variable name'].						methodSource := class sourceCodeFor: selector.						methodSource size >= interval last 							ifFalse: [self refactoringError: 'Invalid range for variable'].						oldName := methodSource copyFrom: interval first to: interval last.						true])! !!RenameTemporaryRefactoring methodsFor: 'tranforming'!renameNode: aParseTree 	(aParseTree whoDefines: newName) notNil 		ifTrue: [self refactoringError: newName , ' is already defined'].	(aParseTree allDefinedVariables includes: newName) 		ifTrue: [self refactoringError: newName , ' is already defined'].	(ParseTreeRewriter rename: oldName to: newName) executeTree: aParseTree! !!RenameTemporaryRefactoring methodsFor: 'tranforming'!transform	| definingNode variableNode |	parseTree := class parseTreeFor: selector.	variableNode := self 				whichVariableNode: parseTree				inInterval: interval				name: oldName.	(variableNode isNil or: [variableNode isVariable not]) 		ifTrue: [self refactoringError: oldName , ' isn''t a valid variable'].	variableNode name = oldName 		ifFalse: [self refactoringError: 'Invalid selection'].	definingNode := variableNode whoDefines: oldName.	definingNode isNil 		ifTrue: [self refactoringError: oldName , ' isn''t defined by the method'].	self renameNode: definingNode.	class compileTree: parseTree! !!RenameTemporaryRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' renameTemporaryFrom: '.	interval storeOn: aStream.	aStream		nextPutAll: ' to: ''';		nextPutAll: newName;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: selector.	aStream nextPut: $)! !!RenameTemporaryRefactoring methodsFor: '*persephone' stamp: 'pmm 8/1/2005 11:43'!newName: aString	newName := aString! !!RenameTemporaryRefactoring methodsFor: '*persephone' stamp: 'pmm 8/1/2005 11:43'!oldName: aString	oldName := aString! !!RenameTemporaryRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk renameTemporaryFrom: anInterval to: newName in: aClass selector: aSelector 	^(self new)		model: aRBSmalltalk;		class: aClass			selector: aSelector			interval: anInterval			newName: newName;		yourself! !!RenameTemporaryRefactoring class methodsFor: 'instance creation'!renameTemporaryFrom: anInterval to: newName in: aClass selector: aSelector 	^self new		class: aClass		selector: aSelector		interval: anInterval		newName: newName! !!RenameTemporaryTest methodsFor: 'failure tests'!testBadInterval	self shouldFail: (RenameTemporaryRefactoring 				renameTemporaryFrom: (self convertInterval: (14 to: 17)						for: (RefactoryTestDataApp sourceCodeAt: #testMethod))				to: 'asdf'				in: RefactoryTestDataApp				selector: #testMethod)! !!RenameTemporaryTest methodsFor: 'failure tests'!testBadName	self		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (self convertInterval: (15 to: 19)							for: (LintRuleTest sourceCodeAt: #openEditor))					to: 'name'					in: LintRuleTest					selector: #openEditor);		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (self convertInterval: (15 to: 19)							for: (LintRuleTest sourceCodeAt: #openEditor))					to: 'rules'					in: LintRuleTest					selector: #openEditor);		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (self convertInterval: (15 to: 19)							for: (LintRuleTest sourceCodeAt: #openEditor))					to: 'DependentFields'					in: LintRuleTest					selector: #openEditor);		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (self convertInterval: (15 to: 19)							for: (LintRuleTest sourceCodeAt: #openEditor))					to: 'a b'					in: LintRuleTest					selector: #openEditor)! !!RenameTemporaryTest methodsFor: 'failure tests'!testModelBadName	| class |	model := RBNamespace new.	class := model classNamed: #Object.	class 		compile: 'aMethod: temp1 ^[| temp2 | temp2 := [:temp3 | temp3 = 5] value: 5. temp2] value'		classified: #(#accessing).	self		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (20 to: 24)					to: 'temp3'					in: class					selector: #aMethod:);		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (20 to: 24)					to: 'temp1'					in: class					selector: #aMethod:)! !!RenameTemporaryTest methodsFor: 'tests' stamp: 'bh 4/29/2000 21:21'!testRenameTemporary	| refactoring |	refactoring := RenameTemporaryRefactoring 				renameTemporaryFrom: (self convertInterval: (15 to: 19)						for: (LintRuleTest sourceCodeAt: #openEditor))				to: 'asdf'				in: LintRuleTest				selector: #openEditor.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #LintRuleTest) 				parseTreeFor: #openEditor) = (RBParser 							parseMethod: 'openEditor								| asdf |								asdf := self failedRules.								asdf isEmpty ifTrue: [^self].								asdf size == 1 ifTrue: [^asdf first viewResults].								SmalllintResultEditor openOn: self label: name')! !!RenameVariableChange methodsFor: 'comparing'!= aRenameVariableChange 	self class = aRenameVariableChange class ifFalse: [^false].	^className = aRenameVariableChange changeClassName and: 			[isMeta = aRenameVariableChange isMeta and: 					[oldName = aRenameVariableChange oldName 						and: [newName = aRenameVariableChange newName]]]! !!RenameVariableChange methodsFor: 'comparing'!hash	^(self changeClassName hash bitXor: self oldName hash) 		bitXor: self newName hash! !!RenameVariableChange methodsFor: 'private'!addNewVariable	self subclassResponsibility! !!RenameVariableChange methodsFor: 'private'!copyOldValuesToNewVariable	self subclassResponsibility! !!RenameVariableChange methodsFor: 'private'!executeNotifying: aBlock 	| undo |	self addNewVariable.	self copyOldValuesToNewVariable.	undo := super executeNotifying: aBlock.	undo		oldName: newName;		newName: oldName.	self removeOldVariable.	^undo! !!RenameVariableChange methodsFor: 'private'!isMeta	^isMeta! !!RenameVariableChange methodsFor: 'private'!newName: aString 	newName := aString! !!RenameVariableChange methodsFor: 'private'!oldName: aString	oldName := aString! !!RenameVariableChange methodsFor: 'private'!removeOldVariable	self subclassResponsibility! !!RenameVariableChange methodsFor: 'accessing'!changeClass	| class |	class := Smalltalk at: self changeClassName ifAbsent: [^nil].	^isMeta ifTrue: [class class] ifFalse: [class]! !!RenameVariableChange methodsFor: 'accessing'!changeClass: aBehavior 	isMeta := aBehavior isMeta.	className := isMeta 				ifTrue: [aBehavior soleInstance name]				ifFalse: [aBehavior name]! !!RenameVariableChange methodsFor: 'accessing'!changeClassName	^className! !!RenameVariableChange methodsFor: 'accessing'!changeClassName: aSymbol 	className := aSymbol.	isMeta isNil ifTrue: [isMeta := false]! !!RenameVariableChange methodsFor: 'accessing'!newName	^newName! !!RenameVariableChange methodsFor: 'accessing'!oldName	^oldName! !!RenameVariableChange methodsFor: 'printing'!changeString	^'Rename ' , oldName , ' to ' , newName! !!RenameVariableChange methodsFor: 'printing'!displayClassName	^isMeta 		ifTrue: [self changeClassName , ' class']		ifFalse: [self changeClassName asString]! !!RenameVariableChange methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self displayString! !!RenameVariableChange class methodsFor: 'instance creation'!rename: oldName to: newName in: aClass 	^(self new)		oldName: oldName;		newName: newName;		changeClass: aClass;		yourself! !!RequiredSelectors methodsFor: 'access to cache' stamp: 'dvf 9/18/2006 22:04'!calculateForClass: aClass 	| rscc |	self clearOut: aClass.	rscc := RequiredSelectorsChangesCalculator onModificationOf: { aClass }				withTargets: { aClass }.	rscc doWork! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:06'!commentPaneFrame	^0 @ 0.4 corner: 1 @ 0.7! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:03'!conditionsPaneFrame	^0 @ 0.2 corner: 1.0 @ 0.4! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 3/1/2005 07:36'!createMorphicWindow	| window replacementPane |	window := super createMorphicWindow.	replacementPane := PluggableTextMorph 				on: self				text: #replacementString				accept: #replacementString:				readSelection: nil				menu: #codePaneMenu:shifted:.	window addMorph: replacementPane frame: self replacementPaneFrame.	window addMorph: ((PluggableButtonMorph 				on: self				getState: nil				action: #replace)				label: 'Replace';				onColor: Color white offColor: Color lightGray)		frame: self replaceButtonFrame.	^window! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 2/23/2005 17:55'!fileOutSource: source onStream: stream forMethodNamed: methodName inCategory: protocol forClassNamed: className 	stream		nextPut: $!!;		nextPutAll: className;		nextPutAll: ' methodsFor: ''';		nextPutAll: protocol;		nextPutAll: ''' stamp: ';		print: Utilities changeStamp;		nextPut: $!!;		cr;		nextPutAll: (source copyReplaceAll: '!!' with: '!!!!');		nextPutAll: '!! !!'! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:31'!methodCheckBoxFrame	^0.6 @ 0.9 corner: 1 @ 1! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 3/1/2005 07:33'!replace	| rewriteRule compiledMethod changes organizer |	self foundEnvironment ifNil: [ self search ].	rewriteRule := ParseTreeRewriter new.	rewriteRule replace: self searchPatternString asString		with: self replacementString asString.	changes := String streamContents: 					[:stream | 					stream						header;						timeStamp;						nextPutAll: '"This is the result of replacing';						cr;						nextPutAll: self searchString asString;						cr;						nextPutAll: 'with';						cr;						nextPutAll: self replacementString asString;						nextPutAll: '"!!'.					self foundEnvironment classesAndSelectorsDo: 							[:cls :sel | 							organizer := cls organization.							compiledMethod := cls compiledMethodAt: sel.							(rewriteRule canMatchMethod: compiledMethod) 								ifTrue: 									[(rewriteRule executeTree: compiledMethod parseTree) 										ifTrue: 											[stream cr.											self 												fileOutSource: rewriteRule tree printString												onStream: stream												forMethodNamed: sel												inCategory: (organizer categoryOfElement: sel)												forClassNamed: cls name]]]].	FileContentsBrowser browseStream: changes readStream		named: 'Prospective replacements'! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:31'!replaceButtonFrame	^0.3 @ 0.9 corner: 0.6 @ 1! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 2/23/2005 11:48'!replaceEnabled	^foundEnvironment notNil! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:06'!replacementPaneFrame	^0 @ 0.7 corner: 1.0 @ 0.9! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:32'!searchButtonFrame	^0 @ 0.9 corner: 0.3 @ 1! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:03'!searchStringPaneFrame	^0 @ 0 corner: 1.0 @ 0.2! !!RewriteTool methodsFor: 'initialization' stamp: 'nk 3/1/2005 07:33'!initialize	super initialize.	replacementString := self searchPatternString.! !!RewriteTool methodsFor: 'accessing' stamp: 'nk 1/6/2004 13:07'!replacementString	^replacementString! !!RewriteTool methodsFor: 'accessing' stamp: 'nk 2/23/2005 13:35'!replacementString: anObject	replacementString := anObject.	self changed: #replacementString.	^true! !!RewriteTool commentStamp: 'nk 2/25/2005 10:59' prior: 0!This tool searches for code matching the pattern in the top pane that satisfies the condition in the second pane, and lets you replace the found code patterns with the replacement pattern in the bottom pane.You will be shown the potential changes to the code, and you can choose which of them to actually use.You may use Jokers (explained below) defined in the top pane in the replacement text in the bottom pane. These will refer to whatever the corresponding Joker matched.So if you search for:	`@something foo: `@argsand replace it with:	`@something bar: `@argsthen every call to #foo: will be replaced by a call to #bar:.!!RewriteTool class methodsFor: 'class initialization' stamp: 'nk 2/25/2005 10:10'!initialize	TheWorldMenu registerOpenCommand: {'Rewrite Tool'. {self. #open}}.	self registerInFlapsRegistry.! !!RewriteTool class methodsFor: 'class initialization' stamp: 'nk 2/25/2005 10:10'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(#RewriteTool #prototypicalToolWindow 'Rewrite Tool' 'For doing advanced edits to code' ) 						forFlapNamed: 'Tools']! !!RewriteTool class methodsFor: 'instance creation' stamp: 'nk 2/25/2005 10:59'!jokerHelp	^self comment, FinderTool comment! !!RewriteTool class methodsFor: 'initialize-release' stamp: 'nk 2/25/2005 10:19'!unload	TheWorldMenu unregisterOpenCommandWithReceiver: self.	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:14'!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := model isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(model directory directoryEntryFor: model lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:12'!loadUpdates	[Cursor wait showWhile: [		model loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/26/2006 00:40'!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 9/25/2006 23:13'!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('display only auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('display only new available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('display only new safely available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('display only installed packages' #filterInstalled 'display only packages that are installed.')	#('display only published packages' #filterPublished 'display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'display only packages in ', (model object: catId) name. catId. 'display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'gui building' stamp: 'gk 9/25/2006 23:13'!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease.	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'initialization' stamp: 'gk 9/25/2006 23:12'!on: aSqueakMap 	"Initialize instance."	model := aSqueakMap.	model synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:12'!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	 	| list first |	list := (((model categories select:[:each | each parent == nil]) asArray 		sort:[:c1 :c2 | c1 name <= c2 name])).	first := list detect:[:any | any name = 'Squeak versions'] ifNone:[nil].	first ifNotNil:[		list := list copyWithout: first.		list := {first}, list].	^list collect:[:cat | SMCategoryWrapper with: cat model: self].! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13'!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				filters allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNil:[self updateLabel: list. ^list].	selectedCategory := selectedCategoryWrapper category.	list := list select: [:each | self package: each filteredByCategory: selectedCategory].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13'!updateLabel: packagesShown	"Update the label of the window."	self setLabel: 'SqueakMap Package Loader (', packagesShown size printString,			'/', model packages size printString, ')'! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:25'!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:41'!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 01:02'!noteChanged	filters ifNil: [^self reOpen].	model ifNotNil: [		packagesList := nil.		selectedCategoryWrapper := nil.		self changed: #categoryWrapperList.		self changed: #packageWrapperList.		self changed: #packagesListIndex.	"update my selection"		self contentsChanged]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/25/2006 23:12'!packages	"We request the packages as sorted by name by default."	^model packagesByName asArray! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:40'!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader commentStamp: '<historical>' prior: 0!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance), you can open one with:	SMLoader open!!ScopeVar methodsFor: 'accessing' stamp: 'ajh 3/16/2003 20:08'!asString	^ self name! !!ScopeVar methodsFor: 'accessing' stamp: 'ajh 6/23/2004 22:47'!name	^ self subclassResponsibility! !!ScopeVar methodsFor: 'accessing' stamp: 'ajh 2/27/2003 00:38'!printOn: stream	stream nextPutAll: self name! !!ScopeVar methodsFor: 'accessing' stamp: 'ajh 6/23/2004 22:52'!scope	^ scope! !!ScopeVar methodsFor: 'emitting' stamp: 'ajh 7/8/2004 10:47'!emitStore: methodBuilder from: refScope	self subclassResponsibility! !!ScopeVar methodsFor: 'emitting' stamp: 'ajh 7/8/2004 10:47'!emitValue: methodBuilder from: refScope	self subclassResponsibility! !!ScopeVar methodsFor: 'testing' stamp: 'ajh 6/23/2004 22:44'!isCaptured	^ false! !!ScopeVar methodsFor: 'testing' stamp: 'ms 7/10/2007 12:04'!isContextVar	^false! !!ScopeVar methodsFor: 'testing' stamp: 'ms 7/3/2007 21:10'!isEnv	^ false! !!ScopeVar methodsFor: 'testing' stamp: 'ajh 7/8/2004 16:25'!isGlobal	^ false! !!ScopeVar methodsFor: 'testing' stamp: 'md 11/22/2005 16:29'!isInstance	^self scope isInstanceScope! !!ScopeVar methodsFor: 'testing' stamp: 'ms 7/31/2007 00:42'!isLocal	^false! !!ScopeVar methodsFor: 'testing' stamp: 'md 11/22/2005 16:29'!isRead	^usage = #read! !!ScopeVar methodsFor: 'testing' stamp: 'ajh 3/18/2003 11:13'!isTemp	^ false! !!ScopeVar methodsFor: 'testing' stamp: 'md 11/22/2005 16:29'!isWrite	^usage = #write! !!ScopeVar methodsFor: 'read/write usage' stamp: 'ajh 6/25/2004 11:58'!isUndefined	^ false! !!ScopeVar methodsFor: 'read/write usage' stamp: 'ajh 7/8/2004 16:18'!isUnused	^ usage isNil! !!ScopeVar methodsFor: 'read/write usage' stamp: 'ajh 7/8/2004 16:18'!markGiven	usage ifNil: [usage _ #arg].! !!ScopeVar methodsFor: 'read/write usage' stamp: 'ajh 7/8/2004 16:19'!markRead	(usage isNil or: [usage = #arg]) ifTrue: [usage _ #read]! !!ScopeVar methodsFor: 'read/write usage' stamp: 'ajh 7/8/2004 16:19'!markWrite	usage _ #write! !!ScopeVar methodsFor: 'read/write usage' stamp: 'ajh 6/28/2004 10:13'!privUsage	^ usage! !!ScopeVar methodsFor: 'read/write usage' stamp: 'ajh 6/28/2004 10:13'!privUsage: usageSymbol	usage _ usageSymbol! !!ScopeVar methodsFor: 'initializing' stamp: 'ajh 7/8/2004 16:17'!scope: aLexicalScope	scope _ aLexicalScope! !!ScopeVar commentStamp: 'ajh 3/24/2003 22:38' prior: 0!I am an entry in a SemScope that gets associated with variable nodes of the same name.  There a three different subclasses of vars: temp vars, field vars, and pool/global vars.!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/8/2006 21:06'!script84	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.96.mczSystemChangeNotification-Tests-sd.5.mczTests-md.17.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-al.224.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/8/2006 20:55'!script84Log	"adding way to reset current CS"! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/14/2006 20:33'!script85	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.97.mczSystemChangeNotification-Tests-sd.5.mczTests-md.17.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-al.224.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/22/2006 13:46'!script86	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.99.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/13/2006 19:11'!script87	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-lr.56.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.113.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/13/2006 19:11'!script87Log	"Name: KernelTests-lr.49Author: lrTime: 5 October 2006, 10:16:34 amUUID: 762d5c23-0364-4c26-ba13-129327ea7f39Ancestors: KernelTests-lr.48- merged code to fix unknown pragma selectors and binary selectors in pragmas- don't allow class names in pragmas (to be consistent)- use pragmas to define primitive-pragmas- added some testsName: Compiler-lr.56Author: lrTime: 5 October 2006, 10:14:04 amUUID: f429f722-c39f-4acf-9d8c-c8a38320eaa8Ancestors: Compiler-lr.55- merged code to fix unknown pragma selectors- don't allow class names in pragmas (to be consistent)- use pragmas to define primitive-pragmasMorphic fix duplicateChange Set:		ToggleBreakFix39Date:			26 September 2006Author:			tim@rowledge.orgPutative fix for Mantis http://bugs.impara.de/view.php?id=5123Fix Squeakmap"! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/15/2006 11:11'!script88	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-lr.56.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.113.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/18/2006 11:37'!script89	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.114.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/20/2006 21:30'!script90	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.149.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.114.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.101.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 11/6/2006 20:38'!script91	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.150.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.115.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.101.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/8/2006 20:53'!updateFrom7056	"self new updateFrom7056"			self script84.	"include changeset extension"	self cleaningCS.		self flushCaches.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/14/2006 21:10'!updateFrom7057	"self new updateFrom7057"			self script85.	"fix windowColorRegistry"	ServicePreferences wipe.	ServiceRegistry rebuild.	WindowColorRegistry refresh.	self cleaningCS.		self flushCaches.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/22/2006 13:46'!updateFrom7058	"self new updateFrom7058"	self script86.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/13/2006 19:19'!updateFrom7061	"self new updateFrom7061"	self script87.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/15/2006 11:11'!updateFrom7063	"self new updateFrom7063"		self script88.	SMSqueakMap default noteInstalledPackageNamed: 'SqueakMap2 loader'autoVersion: '10'.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/18/2006 11:37'!updateFrom7064	"self new updateFrom7064"		self script89.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/20/2006 21:31'!updateFrom7065	"self new updateFrom7065"		self script90.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 11/7/2006 11:50'!updateFrom7066	"self new updateFrom7066"		self script91.	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	SystemVersion newVersion: 'Squeak3.9'.	self flushCaches.	! !!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/8/2006 20:59'!cleaningCS	"self new cleaningCS" 	 	ChangeSorter removeChangeSetsNamedSuchThat: [:each | true].	ChangeSet resetCurrentToNewUnnamedChangeSet ! !!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/8/2006 20:59'!currentPackages	"ScriptLoader new currentPackages" 			| copies |	copies := MCWorkingCopy allManagers asSortedCollection:		[ :a :b | a package name <= b package name ].	^ copies select: [:each | '*Plus*' match: each package name ].! !!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/14/2006 20:33'!generateCS: extensionAndNumber fromUpdate: updateNumber on: st		st nextPutAll:'"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: ''http://source.squeakfoundation.org/39a''                user: ''''                password: ''''.(repository loadVersionFromFileNamed:' .	st nextPut: $' ; nextPutAll: 'ScriptLoader', extensionAndNumber, '.mcz'') load.'; cr.	st nextPutAll: 'ScriptLoader new updateFrom', (updateNumber-1) asString; nextPutAll: '.' ; cr.	st nextPutAll: '!!'.	^ st contents! !!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:12'!cleanOldRepositories	"self new cleanOldRepositories"	"does not work since the interface of the repository group is not made for removing a repository only based on name"		MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			removeRepository: (MCHttpRepository new location: 'http://kilana.unibe.ch:8888/Monticello');			removeRepository: (MCHttpRepository new location: 'http://modules.squeakfoundation.org/People/gk/')].	! !!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:08'!installInBoxAnd39	"self new installInBoxAnd39"		MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			addRepository: (MCHttpRepository new location: 'http://source.squeakfoundation.org/39a' ; user: ''; password: '');			addRepository: (MCHttpRepository new location: 'http://source.squeakfoundation.org/inbox' ; user: '' ; password: '')].		! !!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:07'!installRepository: aString for: packageName	(MCWorkingCopy allManagers select: [:each | each package name = packageName])		first repositoryGroup		addRepository: (MCHttpRepository new location: aString ; user: 'squeak' ; password: 'squeak')		! !!SelectSqueakTokenStream methodsFor: 'accessing' stamp: 'ms 9/17/2006 19:27'!atEnd     ^atEnd! !!SelectSqueakTokenStream methodsFor: 'accessing' stamp: 'ms 9/19/2006 00:44'!contents     | temp tempStream |     temp := OrderedCollection with: nextValue.	tempStream := stream contents.     tempStream do: [:each | (selectBlock value: each)                ifTrue: [temp add: each]].     ^temp! !!SelectSqueakTokenStream methodsFor: 'accessing' stamp: 'ms 10/14/2006 15:38'!next     | temp |     temp := nextValue.     stream do: [:each | (selectBlock value: each)                ifTrue: [nextValue := each.  ^temp]].     atEnd := true.	nextValue := nil.     ^temp! !!SelectSqueakTokenStream methodsFor: 'accessing' stamp: 'ms 9/19/2006 15:16'!peek   	^nextValue! !!SelectSqueakTokenStream methodsFor: 'private' stamp: 'ms 9/19/2006 12:54'!select: aBlock on: aStream       selectBlock := aBlock.       stream := aStream.       atEnd := false.       self next! !!SelectSqueakTokenStream commentStamp: 'ms 9/17/2006 19:24' prior: 0!A SelectSqueakTokenStream is Decorator of stream to select token expected.Instance Variables	atEnd:		<Object>	nextValue:		<Object>	selectBlock:		<Object>	stream:		<Object>atEnd	- xxxxxnextValue	- xxxxxselectBlock	- xxxxxstream	- xxxxx!!SelectSqueakTokenStream class methodsFor: 'instance creation' stamp: 'ms 9/19/2006 01:14'!selectComment: aTokenStream	^self basicNew initialize; select: [:each | each notEaten and: [each isComment]] on: aTokenStream; yourself		! !!SelectSqueakTokenStream class methodsFor: 'instance creation' stamp: 'ms 9/17/2006 20:00'!selectCommentNewLineOn: aTokenStream	^self basicNew initialize; select: [:each | each notEaten and: [each isComment or: [each isNewLine]]] on: aTokenStream; yourself		! !!SelectSqueakTokenStream class methodsFor: 'instance creation' stamp: 'ms 5/28/2007 14:01'!selectCommentNewLineWithPipeOn: aTokenStream	^self basicNew initialize; select: [:each | each notEaten and: [each isComment or: [each isNewLine] or: [each value = '|']]] on: aTokenStream; yourself		! !!SelectorEnvironment methodsFor: 'adding'!addClass: aClass 	aClass isMeta 		ifTrue: 			[metaClassSelectors at: aClass soleInstance name put: aClass selectors]		ifFalse: [classSelectors at: aClass name put: aClass selectors]! !!SelectorEnvironment methodsFor: 'adding'!addClass: aClass selector: aSymbol 	(aClass isMeta 		ifTrue: 			[metaClassSelectors at: aClass soleInstance name ifAbsentPut: [Set new]]		ifFalse: [classSelectors at: aClass name ifAbsentPut: [Set new]]) add: aSymbol! !!SelectorEnvironment methodsFor: 'adding' stamp: 'bh 4/29/2000 18:09'!logOrInspect	Transcript cr; cr; show:self name.	searchStrings ifNotNil:		[Transcript cr;show:'     ( '.		searchStrings do:[:string| Transcript show:string asString,' '].		Transcript show:')'.].	self logOrInspectDictionary:classSelectors.	self logOrInspectDictionary:metaClassSelectors.! !!SelectorEnvironment methodsFor: 'adding' stamp: 'bh 4/29/2000 18:09'!logOrInspectDictionary:aDictionary	aDictionary keysAndValuesDo: 		[:class :selectors | 		selectors do: 			[:sel |			Transcript cr; show: '     ',class name asString , '>>' , sel asString]].! !!SelectorEnvironment methodsFor: 'accessing' stamp: 'rr 4/19/2004 16:06'!asSelectorEnvironment	^ self! !!SelectorEnvironment methodsFor: 'accessing'!numberSelectors	"This doesn't compute the correct result when a method that is included in our method list is not in the	environment we are wrapping. It is implemented this way for efficiency."	^(classSelectors inject: 0 into: [:sum :each | sum + each size]) 		+ (metaClassSelectors inject: 0 into: [:sum :each | sum + each size])! !!SelectorEnvironment methodsFor: 'accessing'!selectorsForClass: aClass do: aBlock 	^(self privateSelectorsForClass: aClass) 		do: [:each | (aClass includesSelector: each) ifTrue: [aBlock value: each]]! !!SelectorEnvironment methodsFor: 'accessing-classes'!classNames	| names |	names := Set new: classSelectors size + metaClassSelectors size.	names		addAll: classSelectors keys;		addAll: metaClassSelectors keys.	^names asOrderedCollection! !!SelectorEnvironment methodsFor: 'accessing-classes'!classesDo: aBlock 	classSelectors keysDo: 			[:each | 			| class |			class := Smalltalk at: each ifAbsent: [nil].			class notNil 				ifTrue: [(self includesClass: class) ifTrue: [aBlock value: class]]].	metaClassSelectors keysDo: 			[:each | 			| class |			class := Smalltalk at: each ifAbsent: [nil].			class notNil 				ifTrue: 					[(self includesClass: class class) ifTrue: [aBlock value: class class]]]! !!SelectorEnvironment methodsFor: 'initialize-release'!classSelectors: classSelectorDictionary metaClassSelectors: metaClassSelectorDictionary 	classSelectors := classSelectorDictionary.	metaClassSelectors := metaClassSelectorDictionary! !!SelectorEnvironment methodsFor: 'initialize-release'!classes: classArray metaClasses: metaArray 	"Used to recreate an environment from its storeString"	classSelectors := Dictionary new.	metaClassSelectors := Dictionary new.	classArray 		do: [:each | classSelectors at: each first put: each last asSet].	metaArray 		do: [:each | metaClassSelectors at: each first put: each last asSet]! !!SelectorEnvironment methodsFor: 'initialize-release'!initialize	super initialize.	classSelectors := IdentityDictionary new.	metaClassSelectors := IdentityDictionary new! !!SelectorEnvironment methodsFor: 'initialize-release'!on: aDict 	aDict keysAndValuesDo: 			[:class :selectors | 			class isMeta 				ifTrue: [metaClassSelectors at: class soleInstance name put: selectors]				ifFalse: [classSelectors at: class name put: selectors]]! !!SelectorEnvironment methodsFor: 'private'!defaultLabel	^'some methods'! !!SelectorEnvironment methodsFor: 'private'!privateIncludesSelector: aSelector inClass: aClass 	^(self privateSelectorsForClass: aClass) includes: aSelector! !!SelectorEnvironment methodsFor: 'private'!privateSelectorsForClass: aClass 	^aClass isMeta 		ifTrue: [metaClassSelectors at: aClass soleInstance name ifAbsent: [#()]]		ifFalse: [classSelectors at: aClass name ifAbsent: [#()]]! !!SelectorEnvironment methodsFor: 'testing'!includesCategory: aCategory 	^(super includesCategory: aCategory) and: 			[(self classNamesFor: aCategory) contains: 					[:className | 					(classSelectors includesKey: className) 						or: [metaClassSelectors includesKey: className]]]! !!SelectorEnvironment methodsFor: 'testing'!includesClass: aClass 	^(self privateSelectorsForClass: aClass) isEmpty not 		and: [super includesClass: aClass]! !!SelectorEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass 	^(super includesProtocol: aProtocol in: aClass)		and: [(environment selectorsFor: aProtocol in: aClass)				contains: [:aSelector | self privateIncludesSelector: aSelector inClass: aClass]]! !!SelectorEnvironment methodsFor: 'testing'!includesSelector: aSelector in: aClass 	^(environment includesSelector: aSelector in: aClass)		and: [self privateIncludesSelector: aSelector inClass: aClass]! !!SelectorEnvironment methodsFor: 'testing'!isEmpty	^classSelectors isEmpty and: [metaClassSelectors isEmpty]! !!SelectorEnvironment methodsFor: 'testing'!isSelector	^true! !!SelectorEnvironment methodsFor: '*RefactoringEngine' stamp: 'dvf 10/3/2001 01:32'!openEditor	^(SelectorEnvironmentBrowser openOnEnvironment: self) openInWorld.! !!SelectorEnvironment methodsFor: 'copying'!postCopy	| newDict |	newDict := classSelectors copy.	newDict keysAndValuesDo: [:key :value | newDict at: key put: value copy].	classSelectors := newDict.	newDict := metaClassSelectors copy.	newDict keysAndValuesDo: [:key :value | newDict at: key put: value copy].	metaClassSelectors := newDict.	^super postCopy! !!SelectorEnvironment methodsFor: 'removing'!removeClass: aClass 	aClass isMeta 		ifTrue: [metaClassSelectors removeKey: aClass soleInstance name ifAbsent: []]		ifFalse: [classSelectors removeKey: aClass name ifAbsent: []]! !!SelectorEnvironment methodsFor: 'removing'!removeClass: aClass selector: aSelector 	(aClass isMeta 		ifTrue: [metaClassSelectors at: aClass soleInstance name ifAbsent: [^self]]		ifFalse: [classSelectors at: aClass name ifAbsent: [^self]]) 			remove: aSelector			ifAbsent: []! !!SelectorEnvironment methodsFor: 'printing'!storeOn: aStream 	| classBlock |	aStream		nextPutAll: '((';		nextPutAll: self class name;		nextPutAll: ' onEnvironment: '.	environment storeOn: aStream.	aStream		nextPut: $);		nextPutAll: ' classes: #('.	classBlock := 			[:key :value | 			aStream				nextPutAll: '#(';				nextPutAll: key;				nextPutAll: ' #('.			value do: 					[:each | 					aStream						nextPutAll: each;						nextPut: $ ].			aStream				nextPutAll: '))';				cr].	classSelectors keysAndValuesDo: classBlock.	aStream nextPutAll: ') metaClasses: #('.	metaClassSelectors keysAndValuesDo: classBlock.	aStream nextPutAll: '))'! !!SelectorEnvironment class methodsFor: 'instance creation'!implementorsMatching: aString in: anEnvironment 	| classDict metaDict |	classDict := IdentityDictionary new.	metaDict := IdentityDictionary new.	anEnvironment classesDo: 			[:class | 			| selectors |			selectors := Set new.			anEnvironment selectorsForClass: class				do: [:each | (aString match: each) ifTrue: [selectors add: each]].			selectors isEmpty 				ifFalse: 					[class isMeta 						ifTrue: [metaDict at: class soleInstance name put: selectors]						ifFalse: [classDict at: class name put: selectors]]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: 'Implementors of ' , aString;		yourself! !!SelectorEnvironment class methodsFor: 'instance creation'!implementorsOf: aSelector in: anEnvironment 	| classDict metaDict selectors |	classDict := IdentityDictionary new.	metaDict := IdentityDictionary new.	selectors := Array with: aSelector.	anEnvironment classesDo: 			[:class | 			((class includesSelector: aSelector) 				and: [anEnvironment includesSelector: aSelector in: class]) 					ifTrue: 						[class isMeta 							ifTrue: [metaDict at: class soleInstance name put: selectors]							ifFalse: [classDict at: class name put: selectors]]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: 'Implementors of ' , aSelector;		yourself! !!SelectorEnvironment class methodsFor: 'instance creation'!matches: aString in: anEnvironment 	| newEnvironment |	newEnvironment := (self onEnvironment: anEnvironment)				label: 'Matching: ' , aString;				searchStrings: (Array with: aString);				yourself.	anEnvironment classesAndSelectorsDo: 			[:each :sel | 			| method |			method := each compiledMethodAt: sel.			method allLiterals do: 					[:lit | 					lit isString 						ifTrue: 							[(aString match: lit) ifTrue: [newEnvironment addClass: each selector: sel]]]].	^newEnvironment! !!SelectorEnvironment class methodsFor: 'instance creation'!onMethods: selectorCollection forClass: aClass in: anEnvironment 	| env |	env := self onEnvironment: anEnvironment.	selectorCollection do: [:each | env addClass: aClass selector: each].	^env! !!SelectorEnvironment class methodsFor: 'instance creation'!referencesTo: aLiteral in: anEnvironment 	| classDict literalPrintString |	literalPrintString := aLiteral isVariableBinding				ifTrue: [aLiteral key asString]				ifFalse: 					[aLiteral isString ifTrue: [aLiteral] ifFalse: [aLiteral printString]].	classDict := Dictionary new.	anEnvironment classesDo: 			[:class | 			| selectors |			selectors := (class whichSelectorsReferTo: aLiteral)						select: [:aSelector | anEnvironment includesSelector: aSelector in: class].			selectors isEmpty ifFalse: [classDict at: class put: selectors]].	^(self onEnvironment: anEnvironment) on: classDict;		label: 'References to: ' , literalPrintString;		searchStrings: (Array with: literalPrintString);		yourself! !!SelectorEnvironmentBrowser methodsFor: 'user interface' stamp: 'nk 2/27/2005 13:16'!addModelItemsToWindowMenu: aMenu	super addModelItemsToWindowMenu: aMenu.	^aMenu addLine;	add: 'find code in methods...' target: self action: #finderForSelectors;	add: 'rewrite code in methods...' target: self action: #rewriteToolForSelectors;	add: 'run lint on methods...' target: self action: #lintForSelectors;	yourself.! !!SelectorEnvironmentBrowser methodsFor: 'user interface' stamp: 'bh 5/14/2000 20:30'!open	World ifNotNil: [^ self openAsMorph].	self error: self class name asString, ' only works in Morphic so far.'.! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 3/4/2005 10:21'!addMorphicSwitchesTo: aListMorph 	| switches pane divider dividerFrame |	pane := (BorderedMorph new)				color: Color transparent;				borderWidth: 2;				yourself.	pane layoutPolicy: ProportionalLayout new.	switches := self buildMorphicSwitches.	switches borderWidth: 0.	pane addMorph: switches fullFrame: self morphicSwitchesFrame.	divider := (BorderedSubpaneDividerMorph forTopEdge)				height: 2;				yourself.	Preferences alternativeWindowLook 		ifTrue: 			[| aColor |			aColor := (Color colorFrom: self defaultBackgroundColor) darker.			divider				borderRaised;				borderWidth: 4;				borderColor: aColor darker.			pane				borderRaised;				borderColor: aColor.			aListMorph borderInset].	dividerFrame := self morphicSwitchesFrame.	dividerFrame bottomOffset: dividerFrame topOffset.	dividerFrame topOffset: dividerFrame topOffset - divider height.	pane addMorph: divider fullFrame: dividerFrame.	aListMorph borderWidth: 0.	pane addMorph: aListMorph		fullFrame: (LayoutFrame fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ dividerFrame topOffset)).	^pane! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 3/4/2005 09:42'!classListFrame	^LayoutFrame fractions: (0 @ 0 extent: 0.5 @ 0.4) offsets: (0@0 corner: 0@0)! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 2/26/2005 09:17'!lowerPanesFrame	^0 @ 0.4 corner: 1 @ 1! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 2/26/2005 09:16'!messageListFrame	^0.5 @ 0 extent: 0.5 @ 0.4! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 3/4/2005 08:17'!morphicSwitchesFrame	"Frame for switches *within* the message list"	^LayoutFrame fractions: (0@1 corner: 1@1)		offsets: (0 @ -25 corner: 0 @ 0)! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 3/4/2005 09:06'!openAsMorph	| window aListMorph pane |	window := (SystemWindow labelled: self browserEnvironment label) 				model: self.	aListMorph := PluggableListMorph 				on: self				list: #classList				selected: #classListIndex				changeSelected: #classListIndex:				menu: #classListMenu:shifted:				keystroke: #classListKey:from:.	pane := self addMorphicSwitchesTo: aListMorph.	window addMorph: pane fullFrame: self classListFrame.	aListMorph := PluggableListMorph 				on: self				list: #messageList				selected: #messageListIndex				changeSelected: #messageListIndex:				menu: #messageListMenu:shifted:				keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph frame: self messageListFrame.	self 		addLowerPanesTo: window		at: self lowerPanesFrame		with: nil.	window setUpdatablePanesFrom: #(#classList #messageList).	^window! !!SelectorEnvironmentBrowser methodsFor: 'accessing' stamp: 'nk 3/2/2005 14:06'!browserEnvironment	^browserEnvironment! !!SelectorEnvironmentBrowser methodsFor: 'accessing' stamp: 'nk 3/2/2005 14:06'!browserEnvironment: anObject	browserEnvironment := anObject! !!SelectorEnvironmentBrowser methodsFor: 'accessing' stamp: 'nk 3/2/2005 14:06'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	^(self browserEnvironment selectionIntervalFor: self contents) 		ifNil: [1 to: 0]! !!SelectorEnvironmentBrowser methodsFor: 'accessing' stamp: 'nk 8/31/2004 08:45'!selectedMethod	| nonMetaClass selector class |	(nonMetaClass := self selectedClass) ifNil:[ ^nil ].	(selector := self selectedMessageName) ifNil:[ ^nil ].	class := self classMessagesIndicated ifTrue:[ nonMetaClass class ] ifFalse:[ nonMetaClass ].	^class compiledMethodAt: selector ifAbsent: [].! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/2/2005 14:06'!classList	^self browserEnvironment classNames asSortedCollection! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/2/2005 14:06'!finderForSelectors	(FinderTool onBrowserEnvironment: self browserEnvironment) openAsMorph 		setLabel: 'FinderTool for ' , self browserEnvironment printString! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/2/2005 14:06'!lintForSelectors	LintDialog runOnEnvironment: self browserEnvironment! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/2/2005 14:06'!rewriteToolForSelectors	(RewriteTool onBrowserEnvironment: self browserEnvironment) openAsMorph 		setLabel: 'RewriteTool for ' , self browserEnvironment printString! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/4/2005 10:45'!selectedClass	| cls envt |	cls := self classList at: classListIndex ifAbsent: [^nil].	envt := self selectedEnvironment.	^envt classNamed: cls.! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/4/2005 10:42'!selectedClassName	^(self selectedClass ifNil: [ ^nil ]) name! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/4/2005 10:46'!selectedClassOrMetaClass	| cls |	cls := self selectedClass ifNil: [ ^nil ].	^self metaClassIndicated ifTrue: [ cls class ] ifFalse: [ cls ]! !!SelectorEnvironmentBrowser methodsFor: 'initialize-release' stamp: 'nk 3/4/2005 10:51'!initializeOnEnvironment: aBrowserEnvironment 	self browserEnvironment: aBrowserEnvironment.	self classListIndex: 1! !!SelectorEnvironmentBrowser methodsFor: 'initialize-release' stamp: 'nk 3/2/2005 14:06'!labelString	| theLabel |	theLabel := self browserEnvironment printStringLimitedTo: 60.	theLabel isEmpty ifTrue: [^super labelString].	^theLabel! !!SelectorEnvironmentBrowser methodsFor: 'message list' stamp: 'nk 3/2/2005 14:06'!messageList	self selectedClass ifNil: [^Array new].	^(self instanceMessagesIndicated 		ifTrue: [self browserEnvironment privateSelectorsForClass: self selectedClass]		ifFalse: 			[self browserEnvironment privateSelectorsForClass: self selectedClass class]) 			asSortedCollection! !!SelectorEnvironmentBrowser methodsFor: 'system category list' stamp: 'nk 2/26/2005 12:39'!selectCategoryForClass: theClass	self systemCategoryListIndex: 1! !!SelectorEnvironmentBrowser methodsFor: 'system category list' stamp: 'nk 3/4/2005 10:52'!selectedEnvironment	^Smalltalk! !!SelectorEnvironmentBrowser methodsFor: 'system category list' stamp: 'nk 3/7/2005 13:24'!selectedSystemCategoryName	"Answer the name of the selected system category or nil."	^self selectedClass ifNotNilDo: [ :cls | cls category ] ! !!SelectorEnvironmentBrowser methodsFor: 'message category list' stamp: 'bh 5/17/2000 18:47'!selectedMessageCategoryName 	"Answer the name of the selected message category or nil."	messageListIndex = 0 ifTrue: [^ nil].	^ self selectedClassOrMetaClass organization categoryOfElement: self selectedMessageName! !!SelectorEnvironmentBrowser class methodsFor: 'instance creation' stamp: 'bh 5/14/2000 20:27'!newOnEnvironment: aBrowserEnvironment	^self new initializeOnEnvironment: aBrowserEnvironment.! !!SelectorEnvironmentBrowser class methodsFor: 'instance creation' stamp: 'bh 5/14/2000 20:27'!openOnEnvironment: aBrowserEnvironment		^(self newOnEnvironment: aBrowserEnvironment) open.! !!SemanticWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/12/2003 14:28'!correctIn: compiler	self subclassResponsibility! !!SemanticWarning methodsFor: 'testing' stamp: 'ajh 3/11/2003 14:54'!isResumable	^ true! !!SemanticWarning commentStamp: 'ajh 7/7/2004 17:36' prior: 0!If a variable is not found or some other problem occurs during checking (ASTChecker) than a particular subclass instance of me is signal, usually causing a notification to the user. If not handled, the default handling is done, and compiling continues.!!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 4/29/2000 21:41'!checker	"^ self checkerForAllRules"	"^ self checkerForSentNotImplemented"	^ CompositeLintRule rules: (OrderedCollection new add: BlockLintRule utilityMethods;		 yourself)! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'dvf 9/28/2001 22:40'!checkerForAllRules	^ CompositeLintRule rules: (OrderedCollection new addAll: 	(((BlockLintRule class methodDictionary keys asArray select: [:sel | sel 	numArgs == 0]) 	collect: [:sel | BlockLintRule perform: sel]) 	select: [:each | each isKindOf: LintRule]); 	 addAll: (((ParseTreeLintRule class methodDictionary keys asArray 	select: [:sel | sel numArgs == 0]) 	collect: [:sel | ParseTreeLintRule perform: sel]) 	select: [:each | each isKindOf: LintRule]); 	 yourself)! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:38'!checkerForBugs	^CompositeLintRule ruleFor:BasicLintRule protocol:'bugs'.! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:40'!checkerForSentNotImplemented	^ CompositeLintRule rules: (OrderedCollection new add: BlockLintRule sentNotImplemented;		 yourself)! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:39'!checkerForSpecific	^CompositeLintRule rules:(OrderedCollection new       	        add:BlockLintRule sentNotImplemented;      	        add:BlockLintRule subclassResponsibilityNotDefined;      	        add:BlockLintRule usesTrue ;      	        add:BlockLintRule overridesSpecialMessage;      	        add:ParseTreeLintRule booleanPrecedence ;      	        add:BlockLintRule definesEqualNotHash ;      	        add:BlockLintRule undeclaredReference ;      	        yourself).! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 9/16/2001 22:06'!classes	self needsWork. "for complete testing, be sure to uncomment classesForAllClasses line.  This is very slow though."	^ self classesForAllClasses."	^ self classesForObject.	^ self classesForRefactoryClasses"! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:41'!classesForAllClasses	^ Object withAllSubclasses! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:41'!classesForObject	^ {Object}! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:41'!classesForRefactoryClasses	^ Object withAllSubclasses select: [:class | class theNonMetaClass category asString beginsWith: 'Refactory']! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/12/2000 13:35'!setUp	! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'md 2/27/2006 00:26'!test	| checker context |	checker := self checker.	context := SmalllintContext newNoCache.	checker resetResult.	self classes do: 		[:aClass | 		Transcript show: aClass printString;		 cr.		context selectedClass: aClass.		checker checkClass: context.		aClass methodDictionary keys do: [:each | (ExtraParsingAndFormattingTests methodsNotToTest includes: aClass >> each)				| (each = #DoIt)				ifFalse: 					[context selector: each.					checker checkMethod: context]]].	checker isEmpty ifTrue: ["'Nobody' inspect"].	Transcript cr;cr;cr.	(checker rules select: [:rule | rule result isEmpty not])		do: [:rule | rule result logOrInspect]! !!SequenceableCollection methodsFor: '*newcompiler' stamp: 'kwl 6/25/2006 19:07'!literalIndexOf: anElement ifAbsent: exceptionBlock	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer the result of evaluating the argument, 	exceptionBlock."	1 to: self size do:		[:i | ((self at: i) literalEqual: anElement) ifTrue: [^ i]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: '*persephone' stamp: 'pmm 8/21/2006 10:28'!asSequenceNode	^RBSequenceNode statements: self! !!SequenceableCollection methodsFor: '*persephone' stamp: 'pmm 8/11/2006 10:29'!literalIndexOf: anElement	^self		literalIndexOf: anElement		ifAbsent: [ self errorNotFound: anElement ]! !!Set methodsFor: '*context' stamp: 'ms 11/1/2007 13:09'!ctxtAtNewIndex: index put: anObject	"Only for context awar link of geppetto."	array ctxtAt: index put: anObject.	tally := tally + 1.	self ctxtFullCheck! !!Set methodsFor: '*context' stamp: 'ms 11/1/2007 16:55'!ctxtFullCheck	"Only for context awar link of geppetto.	Keep array at least 1/4 free for decent hash behavior"	array size - tally < (array size // 4 max: 1)		ifTrue: [self ctxtGrow]! !!Set methodsFor: '*context' stamp: 'ms 10/31/2007 16:27'!ctxtGrow	"Only for context awar link of geppetto.	Grow the elements array and reinsert the old elements"	| oldElements |	oldElements := array.	array := Array new: array size + self growSize.	tally := 0.	oldElements do:		[:each | each == nil ifFalse: [self ctxtNoCheckAdd: each]]! !!ShadowVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/19/2003 16:42'!correctIn: compiler	self resume: (compiler variable: self variableNode shadows: self shadowedVar)! !!ShadowVariableWarning methodsFor: 'defaults' stamp: 'ajh 3/19/2003 13:34'!defaultAction	"allow variable to shadow previous/inst var of the same name"	^ nil! !!ShadowVariableWarning methodsFor: 'accessing' stamp: 'ajh 3/19/2003 13:32'!shadowedVar	^ shadowedVar! !!ShadowVariableWarning methodsFor: 'accessing' stamp: 'ajh 3/19/2003 13:32'!shadowedVar: semVar	shadowedVar _ semVar! !!ShadowVariableWarning methodsFor: 'accessing' stamp: 'ajh 3/19/2003 13:19'!variableNode	^ variableNode! !!ShadowVariableWarning methodsFor: 'accessing' stamp: 'ajh 3/19/2003 13:24'!variableNode: aVariableNode	variableNode _ aVariableNode.	messageText _ 'Temp shadows: ', aVariableNode name.! !!ShadowVariableWarning commentStamp: 'ajh 3/24/2003 22:21' prior: 0!I get signalled when a variable in a block or method scope shadows a variable of the same name in an outer scope.  The default action is to allow it.!!SharedPool class methodsFor: '*RefactoringEngine' stamp: 'dvf 9/17/2003 03:10'!keys	^self classPool keys! !!SimpleLoggingFormatter methodsFor: 'printing'!formatEvent: anEvent on: aStream from: anObject 	anEvent printBasicsOn: aStream			! !!SimpleLoggingFormatter methodsFor: 'printing' stamp: 'jp 10/19/2006 13:07'!outputFooterOn: aStream 	aStream 		nextPutAll: 'Stopped logging ';		nextPutAll: LoggingEvent timestampClass now toothpickPrintString;		cr			! !!SimpleLoggingFormatter methodsFor: 'printing' stamp: 'jp 10/19/2006 13:07'!outputHeaderOn: aStream 	aStream 		nextPutAll: 'Started logging ';		nextPutAll: LoggingEvent timestampClass now toothpickPrintString;		cr			! !!SimpleLoggingFormatter class methodsFor: '*Toothpick-Configuration'!mappingKey	^'simple'			! !!SingleValuedAnnotation methodsFor: 'adding' stamp: 'pmm 10/9/2005 20:19'!addValue: anObject	self value: anObject.	^anObject! !!SingleValuedAnnotation methodsFor: 'adding' stamp: 'pmm 6/11/2006 15:07'!mergeValueOf: anAnnotation	self value: anAnnotation value! !!SingleValuedAnnotation methodsFor: 'enumerating' stamp: 'pmm 10/9/2005 20:17'!do: aBlock	aBlock value: self value! !!SingleValuedAnnotation methodsFor: 'testing' stamp: 'pmm 10/9/2005 22:43'!hasValue	^true! !!SingleValuedAnnotation methodsFor: 'testing' stamp: 'pmm 6/5/2006 10:20'!isMultivalued	^false! !!SingleValuedAnnotation methodsFor: 'accessing' stamp: 'pmm 10/9/2005 20:16'!size	^1! !!SingleValuedAnnotation methodsFor: 'accessing' stamp: 'pmm 10/9/2005 20:16'!value	^value! !!SingleValuedAnnotation methodsFor: 'accessing' stamp: 'pmm 10/9/2005 20:16'!value: anObject	value := anObject! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!columnNumber	^self columnNumberFor: self position! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!columnNumberFor: anInteger 	^anInteger - (eolPositions at: (self lineNumberFor: anInteger)) + 1! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!contents	^sourceStream contents! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!flush	^sourceStream flush! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!lineNumber	^self lineNumberFor: self position! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!lineNumberFor: anInteger	| index start stop pos |	pos := anInteger.	pos >= eolPositions last ifTrue: [^eolPositions size].	start := 1.	stop := eolPositions size.	[start + 1 < stop] whileTrue: 			[index := (start + stop) // 2.			(eolPositions at: index) <= pos 				ifTrue: [start := index]				ifFalse: [stop := index]].	^start! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!next	| character streamPosition |	character := sourceStream next.	streamPosition := sourceStream position.	streamPosition - 1 >= lastPosition 		ifTrue: 			[lastPosition := streamPosition.			character == Character cr 				ifTrue: 					[eolPositions add: lastPosition.					previousWasCR := true]				ifFalse: 					[character == Character lf 						ifTrue: 							[previousWasCR 								ifTrue: [eolPositions at: eolPositions size put: lastPosition]								ifFalse: [eolPositions add: lastPosition]].					previousWasCR := false]].	^character! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!nextPut: anObject 	^sourceStream nextPut: anObject! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!peek	^sourceStream peek! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!position	^sourceStream position! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!position: anInteger 	anInteger > lastPosition 		ifTrue: 			[sourceStream position: lastPosition.			[sourceStream position < anInteger and: [sourceStream atEnd not]] 				whileTrue: [self next]]		ifFalse: [sourceStream position: anInteger]! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!skip: anInteger	^self position: self position + anInteger! !!SmaCCLineNumberStream methodsFor: 'accessing' stamp: 'lr 1/6/2007 20:56'!upTo: aCharacter 	| stream char |	stream := WriteStream on: String new.	[self atEnd or: [ (char := self next) = aCharacter]] 		whileFalse: [stream nextPut: char].	^ stream contents! !!SmaCCLineNumberStream methodsFor: 'error handling' stamp: ' 6/1/07 20:34'!doesNotUnderstand: aMessage 	^sourceStream perform: aMessage selector withArguments: aMessage arguments! !!SmaCCLineNumberStream methodsFor: 'initialize-release' stamp: ' 6/1/07 20:34'!on: aReadStream 	sourceStream := aReadStream.	eolPositions := OrderedCollection with: aReadStream position.	lastPosition := aReadStream position.	previousWasCR := false! !!SmaCCLineNumberStream methodsFor: 'testing' stamp: ' 6/1/07 20:34'!atEnd	^sourceStream atEnd! !!SmaCCLineNumberStream methodsFor: 'testing' stamp: ' 6/1/07 20:34'!isReadable	^sourceStream isReadable! !!SmaCCLineNumberStream methodsFor: 'testing' stamp: ' 6/1/07 20:34'!isWritable	^sourceStream isWritable! !!SmaCCLineNumberStream class methodsFor: 'instance creation' stamp: ' 6/1/07 20:34'!on: aReadStream 	^(self basicNew)		on: aReadStream;		yourself! !!SmaCCParser methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!emptySymbolTokenId	^scanner emptySymbolTokenId! !!SmaCCParser methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!errorTable	^#()! !!SmaCCParser methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!errorTokenId	^scanner errorTokenId! !!SmaCCParser methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!parse	self setDefaultStartingStateIfNone.	self performParsingLoop.	^nodeStack last! !!SmaCCParser methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!position	^currentToken isNil 		ifTrue: [scanner position]		ifFalse: [currentToken startPosition]! !!SmaCCParser methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!reduceTable	^self subclassResponsibility! !!SmaCCParser methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!scanner	^scanner! !!SmaCCParser methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!transitionTable	^self subclassResponsibility! !!SmaCCParser methodsFor: 'initialize-release' stamp: ' 6/1/07 20:34'!initialize	nodeStack := OrderedCollection new! !!SmaCCParser methodsFor: 'initialize-release' stamp: ' 6/1/07 20:34'!scanner: aScanner 	scanner := aScanner! !!SmaCCParser methodsFor: 'initialize-release' stamp: ' 6/1/07 20:34'!setStartingState: startingState 	stateStack := OrderedCollection with: startingState! !!SmaCCParser methodsFor: 'testing' stamp: ' 6/1/07 20:34'!isEOFToken	^currentToken id first = self emptySymbolTokenId! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!acceptAction	^0! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!actionFor: aSymbolIndex 	^self actionForState: self currentState and: aSymbolIndex! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!actionForCurrentToken	^self actionFor: currentToken id first! !!SmaCCParser methodsFor: 'private' stamp: 'lr 1/8/2007 11:19'!actionForState: stateIndex and: aSymbolIndex 	| index row |	row := self transitionTable at: stateIndex.	^(row at: 1) == 2 		ifTrue: 			[index := self 						binarySearchIn: row						for: aSymbolIndex						size: 1.			index == 0 ifTrue: [^self errorAction] ifFalse: [^row at: 2]]		ifFalse: 			[index := self 						binarySearchIn: row						for: aSymbolIndex						size: 2.			index == 0 ifTrue: [^self errorAction] ifFalse: [^row at: index - 1]]! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!actionMask	^2r11! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!currentState	^stateStack last! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!errorAction	^3! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!findErrorHandlerIfNoneUseErrorNumber: anInteger 	| handlerStates index startingErrorToken newStack |	handlerStates := self errorHandlerStates reverse.	startingErrorToken := currentToken.		[index := (1 to: handlerStates size) detect: 					[:each | 					| state |					state := handlerStates at: each.					state ~= 0 and: 							[newStack := stateStack copyFrom: 1 to: handlerStates size - each + 1.							newStack add: state.							self willShift: newStack]]				ifNone: [nil].	index isNil] 			whileTrue: 				[self dismissErrorToken.				self isEOFToken 					ifTrue: 						[currentToken := startingErrorToken.						self reportError: anInteger]].	index - 1 timesRepeat: [self dismissStackTopForErrorRecovery].	stateStack addLast: (handlerStates at: index).	nodeStack addLast: startingErrorToken! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!getNextToken	currentToken isNil ifTrue: [currentToken := scanner next]! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!performAction: action 	| value actionType |	actionType := action bitAnd: self actionMask.	value := action bitShift: -2.	actionType == self shiftAction 		ifTrue: [self shift: value]		ifFalse: 			[actionType == self reduceAction 				ifTrue: [self reduce: value]				ifFalse: [self handleError: value]]! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!performParsingLoop	| action |		[self getNextToken.	action := self actionForCurrentToken.	action = self acceptAction] 			whileFalse: [self performAction: action].	self checkForErrors! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!performReduceMethod: aSymbol with: items 	^aSymbol last == $: 		ifTrue: [self perform: aSymbol with: items]		ifFalse: [self perform: aSymbol]! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!reduce: anInteger 	| reduceEntry items size |	reduceEntry := self reduceTable at: anInteger.	items := OrderedCollection new: (size := reduceEntry at: 2).	size timesRepeat: 			[items addFirst: nodeStack removeLast.			stateStack removeLast].	nodeStack add: (self performReduceMethod: (reduceEntry at: 3) with: items).	stateStack add: ((self actionFor: (reduceEntry at: 1)) bitShift: -2)! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!reduceAction	^2r10! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!reduceFor: aCollection 	| newCollection item |	(aCollection allSatisfy: [:each | each class ~~ OrderedCollection]) 		ifTrue: [^aCollection].	aCollection first class == OrderedCollection 		ifTrue: 			[newCollection := aCollection first.			2 to: aCollection size				do: 					[:i | 					item := aCollection at: i.					item class = OrderedCollection 						ifTrue: [newCollection addAll: item]						ifFalse: [newCollection add: item]].			^newCollection].	newCollection := OrderedCollection new.	aCollection do: 			[:each | 			each class == OrderedCollection 				ifTrue: [newCollection addAll: each]				ifFalse: [newCollection add: each]].	^newCollection! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!setDefaultStartingStateIfNone	stateStack isNil 		ifTrue: [self setStartingState: self class defaultStartingState]! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!shift: stateIndex 	stateStack add: stateIndex.	nodeStack add: currentToken.	currentToken := nil! !!SmaCCParser methodsFor: 'private' stamp: ' 6/1/07 20:34'!shiftAction	^2r01! !!SmaCCParser methodsFor: 'private-error handling' stamp: ' 6/1/07 20:34'!checkForErrors	"If we have an error correction installed, we might have handled the errors. If we did, we don't 	want to return the result, so we raise a final exception that can't be proceeded."	errorToken isNil ifTrue: [^self].	currentToken := errorToken.	self reportErrorMessage: 'Token not expected'! !!SmaCCParser methodsFor: 'private-error handling' stamp: ' 6/1/07 20:34'!dismissErrorToken	currentToken := nil.	self getNextToken! !!SmaCCParser methodsFor: 'private-error handling' stamp: ' 6/1/07 20:34'!dismissStackTopForErrorRecovery	stateStack removeLast.	^nodeStack removeLast! !!SmaCCParser methodsFor: 'private-error handling' stamp: ' 6/1/07 20:34'!errorHandlerStates	^stateStack collect: 			[:each | 			| action |			action := self actionForState: each and: self errorTokenId.			(action bitAnd: self actionMask) = 1 				ifTrue: [action bitShift: -2]				ifFalse: [0]]! !!SmaCCParser methodsFor: 'private-error handling' stamp: ' 6/1/07 20:34'!handleError: anInteger 	errorToken isNil ifTrue: [errorToken := currentToken].	(self isEOFToken or: [self hasErrorHandler not]) 		ifTrue: [self reportError: anInteger].	self findErrorHandlerIfNoneUseErrorNumber: anInteger! !!SmaCCParser methodsFor: 'private-error handling' stamp: ' 6/1/07 20:34'!hasErrorHandler	^self errorHandlerStates anySatisfy: [:each | each ~~ 0]! !!SmaCCParser methodsFor: 'private-error handling' stamp: ' 6/1/07 20:34'!reportError: anInteger 	self reportErrorMessage: (anInteger = 0 				ifTrue: ['Token not expected']				ifFalse: [self errorTable at: anInteger])! !!SmaCCParser methodsFor: 'private-error handling' stamp: 'lr 1/6/2007 22:43'!reportErrorMessage: aString 	SmaCCParserError new 		tag: self;		signal: aString! !!SmaCCParser methodsFor: 'private-error handling' stamp: ' 6/1/07 20:34'!willShift: potentialStateStack 	| action compoundAction reduceEntry size |	compoundAction := self actionForState: potentialStateStack last				and: currentToken id first.	action := compoundAction bitAnd: self actionMask.	action == self shiftAction ifTrue: [^true].	action == self reduceAction 		ifTrue: 			[reduceEntry := self reduceTable at: (compoundAction bitShift: -2).			size := reduceEntry at: 2.			size timesRepeat: [potentialStateStack removeLast].			potentialStateStack 				add: ((self actionForState: potentialStateStack last						and: (reduceEntry at: 1)) bitShift: -2).			^self willShift: potentialStateStack].	^false! !!SmaCCParser methodsFor: 'standard reduction rules' stamp: ' 6/1/07 20:34'!liftFirstValue: aCollection 	^aCollection first! !!SmaCCParser methodsFor: 'standard reduction rules' stamp: ' 6/1/07 20:34'!liftLastValue: aCollection 	^aCollection last! !!SmaCCParser methodsFor: 'standard reduction rules' stamp: ' 6/1/07 20:34'!liftSecondValue: aCollection 	^aCollection at: 2! !!SmaCCParser methodsFor: 'standard reduction rules' stamp: ' 6/1/07 20:34'!nil	^nil! !!SmaCCParser methodsFor: 'standard reduction rules' stamp: ' 6/1/07 20:34'!stringValue: anOrderedCollection 	^anOrderedCollection first value! !!SmaCCParser class methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!parse: aString 	^self parse: aString startingAt: self defaultStartingState! !!SmaCCParser class methodsFor: 'accessing' stamp: 'lr 1/6/2007 22:39'!parse: aString onError: aBlock 	^[self parse: aString] on: SmaCCParserError		do: [:ex | ex return: (aBlock value: ex description value: ex tag position)]! !!SmaCCParser class methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!parse: aString startingAt: anInteger 	^self parseStream: (ReadStream on: aString) startingAt: anInteger! !!SmaCCParser class methodsFor: 'accessing' stamp: 'lr 1/6/2007 22:39'!parse: aString startingAt: anInteger onError: aBlock 	^[self parse: aString startingAt: anInteger] on: SmaCCParserError		do: [:ex | ex return: (aBlock value: ex description value: ex tag position)]! !!SmaCCParser class methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!parseStream: aStream 	^self parseStream: aStream startingAt: self defaultStartingState! !!SmaCCParser class methodsFor: 'accessing' stamp: 'lr 1/6/2007 22:39'!parseStream: aStream onError: aBlock 	^[self parseStream: aStream] on: SmaCCParserError		do: [:ex | ex return: (aBlock value: ex description value: ex tag position)]! !!SmaCCParser class methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!parseStream: aStream startingAt: anInteger 	| parser |	parser := self on: aStream.	parser setStartingState: anInteger.	^parser parse! !!SmaCCParser class methodsFor: 'accessing' stamp: 'lr 1/6/2007 22:39'!parseStream: aStream startingAt: anInteger onError: aBlock 	^[self parseStream: aStream startingAt: anInteger] 		on: SmaCCParserError		do: [:ex | ex return: (aBlock value: ex description value: ex tag position)]! !!SmaCCParser class methodsFor: 'instance creation' stamp: ' 6/1/07 20:34'!on: aStream 	| parser scanner |	scanner := self scannerClass on: aStream.	parser := self new.	parser scanner: scanner.	^parser! !!SmaCCParser class methodsFor: 'private' stamp: ' 6/1/07 20:34'!defaultStartingState	^1! !!SmaCCParser class methodsFor: 'private' stamp: ' 6/1/07 20:34'!scannerClass	^self subclassResponsibility! !!SmaCCParserError methodsFor: '*newcompiler' stamp: 'ms 10/6/2006 15:21'!description	"Return a textual description of the exception."	| desc mt |	desc := self class name asString.	^(mt := self messageText) == nil		ifTrue: [desc]		ifFalse: [mt]! !!SmaCCParserError methodsFor: '*newcompiler' stamp: 'sbw 5/27/2004 19:19'!rForChannelsListOnServerAddress: connection server.	fName := 'channel.list.txt'.	[fStream := dir forceNewFileNamed: fName.	self saveChannelListOn: fStream named: fName]		ensure: [fStream close]! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!contents	| writeStream token |	writeStream := WriteStream with: Array new.	[self atEnd] whileFalse: 			[token := self next.			token notNil ifTrue: [writeStream nextPut: token]].	^writeStream contents! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!emptySymbolTokenId	^self subclassResponsibility! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!errorTokenId	^self subclassResponsibility! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!lineNumber	"This requires the stream to be a line number stream (see the #needsLineNumbers class method)."	^stream lineNumber! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!next	self resetScanner.	returnMatchBlock := [:match | ^match].	^self scanForToken! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!position	^stream position! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!position: anInteger	^stream position: anInteger! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!scanForToken	^self subclassResponsibility! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!state	^state! !!SmaCCScanner methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!state: aSymbol	state := aSymbol! !!SmaCCScanner methodsFor: 'default token handling' stamp: ' 6/1/07 20:34'!comment	"In case someone wants to record the comments"	^self whitespace! !!SmaCCScanner methodsFor: 'default token handling' stamp: ' 6/1/07 20:34'!whitespace	"By default, eat the whitespace"	self resetScanner.	^self scanForToken! !!SmaCCScanner methodsFor: 'initialize-release' stamp: ' 6/1/07 20:34'!initialize	outputStream := WriteStream with: String new.	lastMatchWasEmpty := true.	state := #default! !!SmaCCScanner methodsFor: 'initialize-release' stamp: ' 6/1/07 20:34'!on: aStream 	stream := aStream.	start := stream position! !!SmaCCScanner methodsFor: 'testing' stamp: ' 6/1/07 20:34'!atEnd	^stream atEnd! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!checkForKeyword: aString 	| stateMap action |	action := matchActions isSymbol 				ifTrue: [matchActions]				ifFalse: [matchActions first].	stateMap := self class keywordMap at: action ifAbsent: [nil].	stateMap isNil ifTrue: [^self].	matchActions := stateMap at: (self keywordFor: aString)				ifAbsent: [matchActions].	matchActions isInteger 		ifTrue: [matchActions := Array with: matchActions with: action]! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!checkForValidMatch	matchActions isNil ifTrue: [self scannerError]! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!createTokenFor: string 	| token |	token := self tokenClass 				value: string				start: start + 1				id: matchActions.	outputStream reset.	^token! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!eofTokenId	^Array with: self emptySymbolTokenId! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!recordAndReportMatch: aCollection 	^self		recordMatch: aCollection;		reportLastMatch! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!recordMatch: aCollection 	matchActions := aCollection.	matchEnd := stream position.	lastOutputStreamMatchPosition := outputStream position! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!reportLastMatch	"The scanner has found the end of a token and must report it"	| string token |	self checkForValidMatch.	self resetOutputToLastMatch.	stream position: matchEnd.	string := outputStream contents.	self checkForKeyword: string.	token := matchActions isSymbol 				ifTrue: [self perform: matchActions]				ifFalse: [self createTokenFor: string].	matchActions := nil.	^token! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!resetOutputToLastMatch	outputStream position: lastOutputStreamMatchPosition.	lastOutputStreamMatchPosition == 0 		ifTrue: 			[lastMatchWasEmpty ifTrue: [self scannerError].			lastMatchWasEmpty := true]		ifFalse: [lastMatchWasEmpty := false]! !!SmaCCScanner methodsFor: 'private' stamp: 'lr 1/7/2007 02:23'!resetScanner	start := stream position.	outputStream reset.	lastOutputStreamMatchPosition := 0! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!scannerError	| string |	(stream atEnd and: [start == stream position]) 		ifTrue: 			[string := ''.			matchActions := self eofTokenId]		ifFalse: 			[stream position: start.			string := String with: stream next.			matchActions := #(0)].	returnMatchBlock value: (self createTokenFor: string)! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!step	stream atEnd ifTrue: [^returnMatchBlock value: self reportLastMatch].	currentCharacter := stream next.	outputStream nextPut: currentCharacter! !!SmaCCScanner methodsFor: 'private' stamp: ' 6/1/07 20:34'!tokenClass	^SmaCCToken! !!SmaCCScanner methodsFor: 'private-utility' stamp: ' 6/1/07 20:34'!keywordFor: aString 	"Subclasses can override this to ignore case"	^aString! !!SmaCCScanner commentStamp: '<historical>' prior: 0!SmaCCScanner is an abstract class that represents a scanner for the parser. The scanner converts its string input into SmaCCToken objects that the parser then uses for its parsing.Subclasses must implement the following messages:	accessing		scanForTokenInstance Variables:	currentCharacter	<Character>	the current character we are scanning	lastMatchWasEmpty	<Boolean>	was our last scanning match an empty string -- don't allow two empty matches in a row	lastOutputStreamMatchPosition	<Integer>	the position in the outputStream of the last match	matchActions	<Array | Symbol>	the actions for the last match (a symbol means that the action should be performed on the scanner)	matchEnd	<Integer>	the position of the last match in the stream (our input stream)	outputStream	<PositionableStream>	the matched characters go in this stream. After a match is made, we take this stream's contents and create a token object.	returnMatchBlock	<BlockClosure>	when we match a token evaluate this block with the token (hack to return from multiple levels)	start	<Integer>	the starting position of a match in the stream	stream	<Stream>	our input!!SmaCCScanner class methodsFor: 'accessing' stamp: ' 6/1/07 21:19'!frequencyTable	^#(1)! !!SmaCCScanner class methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!keywordMap	keywordMap isNil ifTrue: [self initializeKeywordMap].	^keywordMap! !!SmaCCScanner class methodsFor: 'class initialization' stamp: ' 6/1/07 20:34'!initialize	self initializeKeywordMap! !!SmaCCScanner class methodsFor: 'class initialization' stamp: ' 6/1/07 20:34'!initializeKeywordMap	keywordMap := Dictionary new! !!SmaCCScanner class methodsFor: 'instance creation' stamp: ' 6/1/07 20:34'!on: aStream 	^(self new)		on: (self needsLineNumbers 					ifTrue: [SmaCCLineNumberStream on: aStream]					ifFalse: [aStream]);		yourself! !!SmaCCScanner class methodsFor: 'testing' stamp: ' 6/1/07 20:34'!needsLineNumbers	"Redefine to return true, if you need line number information"	^false! !!SmaCCToken methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!id	^id! !!SmaCCToken methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!startPosition	^start! !!SmaCCToken methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!stopPosition	^start + value size - 1! !!SmaCCToken methodsFor: 'accessing' stamp: ' 6/1/07 20:34'!value	^value! !!SmaCCToken methodsFor: 'initialize-release' stamp: ' 6/1/07 20:34'!value: anObject start: startPositionInteger id: anInteger 	value := anObject.	start := startPositionInteger.	id := anInteger! !!SmaCCToken methodsFor: 'printing' stamp: ' 6/1/07 20:34'!printOn: aStream 	aStream		nextPut: ${;		nextPutAll: self value;		nextPut: $(;		nextPutAll: self startPosition printString;		nextPut: $,;		nextPutAll: self stopPosition printString;		nextPut: $,;		nextPutAll: self id printString;		nextPutAll: ')}'! !!SmaCCToken class methodsFor: 'instance creation' stamp: ' 6/1/07 20:34'!value: aString start: anInteger id: anObject 	^(self new)		value: aString			start: anInteger			id: anObject;		yourself! !!SmalllintChecker methodsFor: 'private'!checkClass: aClass 	context selectedClass: aClass.	(environment definesClass: aClass) ifTrue: [rule checkClass: context]! !!SmalllintChecker methodsFor: 'private'!checkMethodsForClass: aClass 	^environment selectorsForClass: aClass		do: 			[:each | 			context selector: each.			rule checkMethod: context.			methodBlock value]! !!SmalllintChecker methodsFor: 'accessing'!context: aSmalllintContext 	context := aSmalllintContext! !!SmalllintChecker methodsFor: 'accessing'!environment: aBrowserEnvironment 	environment := aBrowserEnvironment! !!SmalllintChecker methodsFor: 'accessing'!methodBlock: aBlock 	methodBlock := aBlock! !!SmalllintChecker methodsFor: 'accessing'!rule: aLintRule 	rule := aLintRule! !!SmalllintChecker methodsFor: 'initialize-release'!initialize	methodBlock := [].	environment := SelectorEnvironment new.	context := SmalllintContext newNoCache! !!SmalllintChecker methodsFor: 'initialize-release'!release	context release.	super release! !!SmalllintChecker methodsFor: 'actions'!run	rule resetResult.	environment classesDo: 			[:aClass | 			self checkClass: aClass.			self checkMethodsForClass: aClass]! !!SmalllintChecker class methodsFor: 'instance creation'!newWithContext	^(self new)		context: SmalllintContext new;		yourself! !!SmalllintChecker class methodsFor: 'instance creation' stamp: 'nk 11/12/2002 13:12'!runRule: aLintRule	(self new)		rule: aLintRule;		run.	^aLintRule! !!SmalllintChecker class methodsFor: 'instance creation'!runRule: aLintRule onEnvironment: aBrowserEnvironment 	(self new)		rule: aLintRule;		environment: aBrowserEnvironment;		run.	^aLintRule! !!SmalllintContext methodsFor: 'private' stamp: 'md 8/2/2005 23:19'!addLiteralsFor: aCompiledMethod 	aCompiledMethod literalsDo: [:literal | self checkLiteral: literal]! !!SmalllintContext methodsFor: 'private'!buildParseTree	| tree |	tree := self selectedClass parseTreeFor: self selector.	tree isNil ifTrue: [^RBParser parseMethod: 'method'].	^tree! !!SmalllintContext methodsFor: 'private'!checkLiteral: aLiteral 	(aLiteral isSymbol or: [aLiteral isVariableBinding])		ifTrue: [literals add: aLiteral]		ifFalse: 			[aLiteral class == Array				ifTrue: [aLiteral do: [:each | self checkLiteral: each]]]! !!SmalllintContext methodsFor: 'private'!computeLiterals	literalSemaphore := Semaphore new.	literalProcess := [self primitiveComputeLiterals] fork! !!SmalllintContext methodsFor: 'private'!computeLiteralsForClass: aClass 	(selectors addAll: aClass selectors) do: 			[:sel | 			self computeLiteralsForSelector: sel in: aClass.			Processor yield]! !!SmalllintContext methodsFor: 'private'!computeLiteralsForSelector: aSelector in: aClass 	| method |	method := aClass compiledMethodAt: aSelector ifAbsent: [nil].	method isNil ifTrue: [^self].	self addLiteralsFor: method! !!SmalllintContext methodsFor: 'private'!computeMessages	| searcher |	selfMessages := Set new.	superMessages := Set new.	messages := Set new.	searcher := ParseTreeSearcher new.	searcher		matches: 'self `@message: ``@args'			do: [:aNode :answer | selfMessages add: aNode selector];		matches: 'super `@message: ``@args'			do: [:aNode :answer | superMessages add: aNode selector];		matches: '``@receiver `@message: ``@args'			do: [:aNode :answer | messages add: aNode selector].	searcher executeTree: self parseTree initialAnswer: nil! !!SmalllintContext methodsFor: 'private' stamp: 'dvf 8/27/2003 14:35'!primitiveComputeLiterals	| semaphore |	literals := IdentitySet new: 25000.	literals addAll: self specialSelectors keys.	selectors := IdentitySet new.	SystemNavigation new allBehaviorsDo: [:aClass | self computeLiteralsForClass: aClass].	semaphore := literalSemaphore.	literalSemaphore := nil.	self signalProcesses: semaphore.	^literalProcess := nil! !!SmalllintContext methodsFor: 'private'!signalProcesses: aSemaphore 	aSemaphore isNil ifTrue: [^self].	[aSemaphore isEmpty] whileFalse: [aSemaphore signal]! !!SmalllintContext methodsFor: 'private' stamp: 'dvf 9/15/2001 17:39'!specialSelectors	| answer |	answer := IdentityDictionary new.	(Smalltalk specialSelectors select: [:sel | sel isSymbol]) do:		[:sel | answer at: sel put: nil.].	^answer.! !!SmalllintContext methodsFor: 'accessing'!compiledMethod	^compiledMethod notNil		ifTrue: [compiledMethod]		ifFalse: [compiledMethod := class compiledMethodAt: selector]! !!SmalllintContext methodsFor: 'accessing'!instVarNames	^self selectedClass allInstVarNames! !!SmalllintContext methodsFor: 'accessing'!literals	literalSemaphore isNil		ifTrue: 			[literals isNil ifTrue: 					[self computeLiterals.					literalSemaphore wait]]		ifFalse: [literalSemaphore wait].	^literals! !!SmalllintContext methodsFor: 'accessing'!messages	messages isNil ifTrue: [self computeMessages].	^messages! !!SmalllintContext methodsFor: 'accessing'!parseTree	^parseTree isNil		ifTrue: [parseTree := self buildParseTree]		ifFalse: [parseTree]! !!SmalllintContext methodsFor: 'accessing'!protocol	^self selectedClass whichCategoryIncludesSelector: self selector! !!SmalllintContext methodsFor: 'accessing'!protocols	^Array with: self protocol! !!SmalllintContext methodsFor: 'accessing'!selectedClass	^class! !!SmalllintContext methodsFor: 'accessing'!selectedClass: anObject 	class := anObject.	self selector: nil! !!SmalllintContext methodsFor: 'accessing'!selector	^selector! !!SmalllintContext methodsFor: 'accessing'!selector: anObject 	selector := anObject.	parseTree := compiledMethod := selfMessages := superMessages := messages := nil! !!SmalllintContext methodsFor: 'accessing'!selectors	literalSemaphore isNil		ifTrue: 			[selectors isNil ifTrue: 					[self computeLiterals.					literalSemaphore wait]]		ifFalse: [literalSemaphore wait].	^selectors! !!SmalllintContext methodsFor: 'accessing'!selfMessages	selfMessages isNil ifTrue: [self computeMessages].	^selfMessages! !!SmalllintContext methodsFor: 'accessing' stamp: 'nk 2/26/2005 10:19'!sourceCode	^self selectedClass sourceCodeAt: self selector ifAbsent: [ '' ].! !!SmalllintContext methodsFor: 'accessing'!superMessages	superMessages isNil ifTrue: [self computeMessages].	^superMessages! !!SmalllintContext methodsFor: 'testing'!implements: aSelector 	^self selectors includes: aSelector! !!SmalllintContext methodsFor: 'testing'!isAbstract: aClass 	^(aClass isMeta or: 			[(self literals includes: aClass name)				or: [self literals includes: (Smalltalk associationAt: aClass name)]])		not! !!SmalllintContext methodsFor: 'testing'!uses: anObject 	^self literals includes: anObject! !!SmalllintContext methodsFor: 'initialize-release'!initialize	self computeLiterals! !!SmalllintContext methodsFor: 'initialize-release'!release	literalProcess notNil ifTrue: [literalProcess terminate].	super release! !!SmalllintContext class methodsFor: 'instance creation'!newNoCache	^self basicNew! !!SmalllintTest methodsFor: 'set up'!blockRuleFor: aSelector 	self blockRuleFor: aSelector plusSelectors: #()! !!SmalllintTest methodsFor: 'set up' stamp: 'nk 2/22/2005 21:20'!blockRuleFor: aSelector plusSelectors: symbolCollection 	| rule returnedEnvironment testSel |	testSel := aSelector asString copyFrom: 5 to: aSelector size.	testSel at: 1 put: testSel first asLowercase.	testSel := testSel asSymbol.	(BlockLintRule class includesSelector: testSel) ifFalse: [^self].	SmalllintChecker runRule: (rule := BlockLintRule perform: testSel)		onEnvironment: self refactoryTestAppEnvironment.	returnedEnvironment := SelectorEnvironment new.	returnedEnvironment addClass: RefactoryTestDataApp selector: testSel.	symbolCollection 		do: [:each | returnedEnvironment addClass: RefactoryTestDataApp selector: each].	self checkRule: rule isEqualTo: returnedEnvironment! !!SmalllintTest methodsFor: 'set up'!checkRule: aLintRule isEqualTo: anEnvironment 	| returnedEnvironment |	returnedEnvironment := aLintRule result.	self compare: returnedEnvironment to: anEnvironment.	self compare: anEnvironment to: returnedEnvironment! !!SmalllintTest methodsFor: 'set up'!compare: subEnvironment to: superEnvironment 	subEnvironment classesDo: 			[:each | 			(subEnvironment selectorsForClass: each) 				do: [:sel | self assert: (superEnvironment includesSelector: sel in: each)]]! !!SmalllintTest methodsFor: 'set up'!currentSelector	^thisContext sender selector! !!SmalllintTest methodsFor: 'set up'!parseTreeRuleFor: aSelector 	self parseTreeRuleFor: aSelector plusSelectors: #()! !!SmalllintTest methodsFor: 'set up' stamp: 'nk 2/22/2005 21:20'!parseTreeRuleFor: aSelector plusSelectors: symbolCollection 	| returnedEnvironment testSel rule |	testSel := aSelector asString copyFrom: 5 to: aSelector size.	testSel at: 1 put: testSel first asLowercase.	testSel := testSel asSymbol.	SmalllintChecker 		runRule: (rule := ParseTreeLintRule perform: testSel)		onEnvironment: self refactoryTestAppEnvironment.	returnedEnvironment := SelectorEnvironment new.	returnedEnvironment addClass: RefactoryTestDataApp selector: testSel.	symbolCollection 		do: [:each | returnedEnvironment addClass: RefactoryTestDataApp selector: each].	self checkRule: rule isEqualTo: returnedEnvironment! !!SmalllintTest methodsFor: 'set up'!refactoryTestAppEnvironment	| classEnvironment |	classEnvironment := ClassEnvironment new.	classEnvironment addClass: RefactoryTestDataApp.	^classEnvironment! !!SmalllintTest methodsFor: 'tests'!testAsOrderedCollectionNotNeeded	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testAssignmentInBlock	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testAssignmentInIfTrue	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testAtIfAbsent	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testBadMessage	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testBooleanPrecedence	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testCollectSelectNotUsed	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testCollectionMessagesToExternalObject	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testCollectionProtocol	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testConsistencyCheck	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testContains	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testDetectContains	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testEndTrueFalse	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testEqualNotUsed	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testEqualsTrue	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testEquivalentSuperclassMethods	| returnedEnvironment rule |	SmalllintChecker 		runRule: (rule := BlockLintRule equivalentSuperclassMethods)		onEnvironment: self refactoryTestAppEnvironment.	returnedEnvironment := SelectorEnvironment new.	returnedEnvironment addClass: RefactoryTestDataApp selector: #isLiteral.	self checkRule: rule isEqualTo: returnedEnvironment! !!SmalllintTest methodsFor: 'tests'!testExtraBlock	self parseTreeRuleFor: self currentSelector plusSelectors: #(#testMethod1)! !!SmalllintTest methodsFor: 'tests'!testFileBlocks	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests' stamp: 'bh 4/8/2000 19:06'!testFullBlocks	"skip this test in squeak""	self blockRuleFor: self currentSelector		plusSelectors: #(#caller1 #fullBlocks #detectContains #fileBlocks #moveDefinition #caller #assignmentInBlock #equalNotUsed #stringConcatenation #noMoveDefinition #referencesConditionFor: #returnInEnsure)"! !!SmalllintTest methodsFor: 'tests'!testGuardingClause	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testIfTrueBlocks	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testIfTrueReturns	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testJustSendsSuper	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testLiteralArrayCharacters	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testLongMethods	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testMinMax	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testMissingYourself	self parseTreeRuleFor: self currentSelector plusSelectors: #(#inlineMethod)! !!SmalllintTest methodsFor: 'tests'!testModifiesCollection	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testPrecedence	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testRefersToClass	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testReturnInEnsure	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testReturnsBooleanAndOther	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testReturnsIfTrue	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testSearchingLiteral	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testSendsDifferentSuper	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testSizeCheck	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testStringConcatenation	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testSuperSends	| rule returnedEnvironment |	SmalllintChecker runRule: (rule := BlockLintRule superSends)		onEnvironment: self refactoryTestAppEnvironment.	returnedEnvironment := SelectorEnvironment new.	returnedEnvironment addClass: RefactoryTestDataApp selector: #release.	self checkRule: rule isEqualTo: returnedEnvironment! !!SmalllintTest methodsFor: 'tests'!testTempVarOverridesInstVar	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testTempsReadBeforeWritten	self blockRuleFor: self currentSelector		plusSelectors: #(#inlineTemporary #noMoveDefinition #tempsReadBeforeWritten #equalNotUsed #fileBlocks #referencesConditionFor:)! !!SmalllintTest methodsFor: 'tests'!testThreeElementPoint	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testToDo	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testToDoCollect	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testToDoWithIncrement	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testUsesAdd	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testWhileTrue	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testYourselfNotUsed	self parseTreeRuleFor: self currentSelector! !!SourceCode2BytecodeTest methodsFor: 'compiling' stamp: 'kwl 10/14/2006 13:52'!compile2methodNode: sourceStream 	"Compile code without logging the source in the changes file"	| methodNode |	methodNode := ClosureCompiler new				from: sourceStream				class: self class				classified: nil				context: nil				notifying: nil;								translate: sourceStream				noPattern: false				ifFail: [^ nil].	^ CompiledMethodWithNode generateMethodFromNode: methodNode trailer: #(0 0 0 0 )! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 13:53'!testDoDup	| selector methodNode scanner |	selector := (methodNode := self compile2methodNode: 'duplicateTopBytecode 3 + 4; yourself') selector.	scanner := InstructionStream on: methodNode method.	1		timesRepeat: [scanner nextInstruction].	self assert: scanner peekInstruction selector == #doDup description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:01'!testDoPop	| selector methodNode scanner |	selector := (methodNode := self compile2methodNode: 'popStackBytecode 3 + 4') selector.	scanner := InstructionStream on: methodNode method.	3		timesRepeat: [scanner nextInstruction].	self assert: scanner peekInstruction selector == #doPop description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:11'!testPrimAdd	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimAdd 3 + 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#+. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:32'!testPrimAt	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimAt self at: 3') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#at:. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:38'!testPrimAtEnd	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimSize self atEnd') selector.	scanner := InstructionStream on: methodNode method.	1		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#atEnd. false. 0}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:30'!testPrimAtPut	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimAtPut self at: 3 put: 4') selector.	scanner := InstructionStream on: methodNode method.	3		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#at:put:. false. 2}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:27'!testPrimBitAnd	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimBitAnd 3 bitAnd: 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#bitAnd:. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:28'!testPrimBitOr	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimBitOr 3 bitOr: 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#bitOr:. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:24'!testPrimBitShift	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimBitShift 3 bitShift: 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#bitShift:. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'ms 5/18/2007 09:34'!testPrimBlockCopy	| selector methodNode scanner did aBoolean |	aBoolean := Preferences compileBlocksAsClosures.	Preferences setPreference: #compileBlocksAsClosures toValue: false.	[selector := (methodNode := self compile2methodNode: 'bytecodePrimBlockCopy [nil] value') selector.	scanner := InstructionStream on: methodNode method.]		ensure:[Preferences setPreference: #compileBlocksAsClosures toValue: aBoolean].			2 timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#blockCopy:. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:44'!testPrimClass	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimClass self class') selector.	scanner := InstructionStream on: methodNode method.	1		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#class. false. 0}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:17'!testPrimDivide	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimDivide 3 / 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#/. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:57'!testPrimDoWith	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodeDoWith self do: #something') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#do:. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:16'!testPrimEqual	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimEqual 3 = 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#'='. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:15'!testPrimGreaterOrEqual	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimGreaterOrEqual 3 >= 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#'>='. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:14'!testPrimGreaterThan	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimGreaterThan 3 > 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#>. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:39'!testPrimIdentity	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimIdentity 3 == 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#==. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:14'!testPrimLessOrEqual	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimLessOrEqual 3 <= 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#<=. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:13'!testPrimLessThan	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimLessThan 3 < 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#<. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:21'!testPrimMakePoint	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimMakePoint 3 @ 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#'@'. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:19'!testPrimMod	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimMod 3 \\ 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#\\. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:17'!testPrimMultiply	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimMultiply 3 * 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#'*'. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:59'!testPrimNew	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimNew super new') selector.	scanner := InstructionStream on: methodNode method.	1		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#new. true. 0}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 13:00'!testPrimNewWith	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodeNewWith self new: 3') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#new:. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:36'!testPrimNext	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimSize self next') selector.	scanner := InstructionStream on: methodNode method.	1		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#next. false. 0}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:38'!testPrimNextPut	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimNextPut self nextPut: 3') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#nextPut:. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:16'!testPrimNotEqual	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimNotEqual 3 ~= 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#~=. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 13:01'!testPrimPointX	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimPointX self x') selector.	scanner := InstructionStream on: methodNode method.	1		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#x. false. 0}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 13:01'!testPrimPointY	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimPointY self y') selector.	scanner := InstructionStream on: methodNode method.	1		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#y. false. 0}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:26'!testPrimQuo	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimQuo 3 // 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#//. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:32'!testPrimSize	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimSize self size') selector.	scanner := InstructionStream on: methodNode method.	1		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#size. false. 0}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:12'!testPrimSubtract	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimSubtract 3 - 4') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#-. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:55'!testPrimValue	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodePrimValue self value') selector.	scanner := InstructionStream on: methodNode method.	1		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#value. false. 0}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:57'!testPrimValueWith	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodeValueWith self value: 3') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#value:. false. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 12:03'!testPushActiveContextBytecode	| selector methodNode scanner |	selector := (methodNode := self compile2methodNode: 'pushActiveContextBytecode thisContext yourself') selector.	scanner := InstructionStream on: methodNode method.	self assert: scanner peekInstruction selector == #pushActiveContext		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/12/2006 19:35'!testPushConstantFalseBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'pushConstantFalseBytecode false yourself') selector.	scanner := InstructionStream on: methodNode method.	self		assert: ((did := scanner peekInstruction) selector == #pushConstant:				and: [did arguments first == false])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/12/2006 19:37'!testPushConstantMinusOneBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'pushConstantMinusOneBytecode -1 yourself') selector.	scanner := InstructionStream on: methodNode method.	self		assert: ((did := scanner peekInstruction) selector == #pushConstant:				and: [did arguments first == -1])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/12/2006 19:36'!testPushConstantNilBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'pushConstantNilBytecode nil yourself') selector.	scanner := InstructionStream on: methodNode method.	self		assert: ((did := scanner peekInstruction) selector == #pushConstant:				and: [did arguments first == nil])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/12/2006 19:39'!testPushConstantOneBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'pushConstantOneBytecode 1 yourself') selector.	scanner := InstructionStream on: methodNode method.	self		assert: ((did := scanner peekInstruction) selector == #pushConstant:				and: [did arguments first == 1])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/12/2006 19:33'!testPushConstantTrueBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'pushConstantTrueBytecode true yourself') selector.	scanner := InstructionStream on: methodNode method.	self assert: ((did := scanner peekInstruction) selector == #pushConstant:					and: [did arguments first == true])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/12/2006 19:39'!testPushConstantTwoBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'pushConstantTwoBytecode 2 yourself') selector.	scanner := InstructionStream on: methodNode method.	self		assert: ((did := scanner peekInstruction) selector == #pushConstant:				and: [did arguments first == 2])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/12/2006 19:38'!testPushConstantZeroBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'pushConstantZeroBytecode 0 yourself') selector.	scanner := InstructionStream on: methodNode method.	self		assert: ((did := scanner peekInstruction) selector == #pushConstant:				and: [did arguments first == 0])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/12/2006 19:33'!testPushLiteralConstantBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'pushLiteralConstantBytecode #() yourself') selector.	scanner := InstructionStream on: methodNode method.	self assert: ((did := scanner peekInstruction) selector == #pushConstant:					and: [did arguments first = #()])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 10:42'!testPushLiteralVariableBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'pushLiteralVariableBytecode ClassVar yourself') selector.	scanner := InstructionStream on: methodNode method.	self		assert: ((did := scanner peekInstruction) selector == #pushLiteralVariable:				and: [did arguments first = (#ClassVar -> nil)])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/12/2006 19:27'!testPushReceiverBytecode	| selector methodNode scanner |	selector := (methodNode := self compile2methodNode: 'pushReceiverBytecode ^ self yourself') selector.	scanner := InstructionStream on: methodNode method.	self assert: scanner peekInstruction selector == #pushReceiver		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 13:39'!testPushReceiverVariableBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'pushReceiverVariableBytecode instVar yourself') selector.	scanner := InstructionStream on: methodNode method.	self		assert: ((did := scanner peekInstruction) selector == #pushReceiverVariable:				and: [did arguments first == 1])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/12/2006 20:11'!testPushTemporaryVariableBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'pushTemporaryVariableBytecode: t0 t0 yourself') selector.	scanner := InstructionStream on: methodNode method.	self		assert: ((did := scanner peekInstruction) selector == #pushTemporaryVariable:				and: [did arguments first == 0])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/12/2006 19:48'!testReturnFalseBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'returnFalseBytecode 3 + 4. ^ false') selector.	scanner := InstructionStream on: methodNode method.	4		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #methodReturnConstant:				and: [did arguments first == false])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/12/2006 19:49'!testReturnNilBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'returnNilBytecode 3 + 4. ^ nil') selector.	scanner := InstructionStream on: methodNode method.	4		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #methodReturnConstant:				and: [did arguments first == nil])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/12/2006 19:47'!testReturnReceiver	| selector methodNode scanner |	selector := (methodNode := self compile2methodNode: 'returnReceiver 3 + 4. ^ self') selector.	scanner := InstructionStream on: methodNode method.	4		timesRepeat: [scanner nextInstruction].	self assert: scanner peekInstruction selector == #methodReturnReceiver		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'ms 5/18/2007 09:40'!testReturnTopFromBlock	| selector methodNode scanner aBoolean |	aBoolean := Preferences compileBlocksAsClosures.	Preferences setPreference: #compileBlocksAsClosures toValue: false.	[selector := (methodNode := self compile2methodNode: 'returnTopFromBlock ^[ia]') selector.	scanner := InstructionStream on: methodNode method.]		ensure:[Preferences setPreference: #compileBlocksAsClosures toValue: aBoolean].	5		timesRepeat: [scanner nextInstruction].	self assert: scanner peekInstruction selector == #blockReturnTop		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/12/2006 19:53'!testReturnTopFromMethod	| selector methodNode scanner |	selector := (methodNode := self compile2methodNode: 'returnTopFromMethod ^ 3 + 4') selector.	scanner := InstructionStream on: methodNode method.	3		timesRepeat: [scanner nextInstruction].	self assert: scanner peekInstruction selector == #methodReturnTop		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/12/2006 19:48'!testReturnTrueBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'returnTrueBytecode 3 + 4. ^ true') selector.	scanner := InstructionStream on: methodNode method.	4		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #methodReturnConstant:				and: [did arguments first == true])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 10:56'!testStoreAndPopLiteralVariableBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'storeAndPopLiteralVariableBytecode ClassVar := nil') selector.	scanner := InstructionStream on: methodNode method.	self		assert: ((did := scanner nextInstruction; peekInstruction) selector == #popIntoLiteralVariable:				and: [did arguments first = (#ClassVar -> nil)])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 13:39'!testStoreAndPopReceiverVariableBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'storeAndPopReceiverVariableBytecode instVar := self') selector.	scanner := InstructionStream on: methodNode method.	self		assert: ((did := scanner nextInstruction; peekInstruction) selector == #popIntoReceiverVariable:				and: [did arguments first == 1])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/12/2006 20:16'!testStoreAndPopTemporaryVariableBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'storeAndPopTemporaryVariableBytecode | t0 t1 | t1 := t0') selector.	scanner := InstructionStream on: methodNode method.	self		assert: ((did := scanner nextInstruction; peekInstruction) selector == #popIntoTemporaryVariable:				and: [did arguments first == 1])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 10:53'!testStoreIntoLiteralVariableBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'storeIntoLiteralVariableBytecode ^ (ClassVar := nil)') selector.	scanner := InstructionStream on: methodNode method.	self		assert: ((did := scanner nextInstruction; peekInstruction) selector == #storeIntoLiteralVariable:				and: [did arguments first = (#ClassVar -> nil)])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 13:40'!testStoreIntoReceiverVariableBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'storeIntoReceiverVariableBytecode ^ (instVar := self)') selector.	scanner := InstructionStream on: methodNode method.	self		assert: ((did := scanner nextInstruction; peekInstruction) selector == #storeIntoReceiverVariable:				and: [did arguments first == 1])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 10:51'!testStoreIntoTemporaryVariableBytecode	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'storeIntoTemporaryVariableBytecode | t0 t1 | ^ (t1 := t0)') selector.	scanner := InstructionStream on: methodNode method.	self		assert: ((did := scanner nextInstruction; peekInstruction) selector == #storeIntoTemporaryVariable:				and: [did arguments first == 1])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 13:04'!testSuperSend	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodeSuperSend super yourself') selector.	scanner := InstructionStream on: methodNode method.	1		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#yourself. true. 0}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest methodsFor: 'tests' stamp: 'kwl 10/14/2006 13:04'!testSuperSendWith	| selector methodNode scanner did |	selector := (methodNode := self compile2methodNode: 'bytecodeSuperSendWith super new: 0') selector.	scanner := InstructionStream on: methodNode method.	2		timesRepeat: [scanner nextInstruction].	self		assert: ((did := scanner peekInstruction) selector == #send:super:numArgs:				and: [did arguments = {#new:. true. 1}])		description: 'Failed ' , selector! !!SourceCode2BytecodeTest commentStamp: 'kwl 10/14/2006 10:43' prior: 0!I provide at least one test which corresponds to a message sent by InstructionStream>>#interpretNextInstructionFor: to its client.!!SplitClassRefactoring methodsFor: 'private-transforming'!abstractReferenceTo: each 	| setterMethod replacer accessorRef getterMethod |	accessorRef := CreateAccessorsForVariableRefactoring 				variable: each				class: newClass				classVariable: false.	self performComponentRefactoring: accessorRef.	getterMethod := accessorRef getterMethod.	setterMethod := accessorRef setterMethod.	replacer := ParseTreeRewriter 				variable: each				getter: getterMethod				setter: setterMethod				receiver: referenceVariableName.	self 		convertClasses: class withAllSubclasses		select: [:aClass | aClass whichSelectorsReferToInstanceVariable: each]		using: replacer.	self performComponentRefactoring: (RemoveInstanceVariableRefactoring 				remove: each				from: class)! !!SplitClassRefactoring methodsFor: 'private-transforming'!addClass	self performComponentRefactoring: (AddClassRefactoring 				model: self model				addClass: newClassName				superclass: Object				subclasses: #()				category: class category).	newClass := self model classNamed: newClassName! !!SplitClassRefactoring methodsFor: 'private-transforming'!addInstanceVariables	instanceVariables do: 			[:each | 			self performComponentRefactoring: (AddInstanceVariableRefactoring 						model: self model						variable: each						class: newClass)]! !!SplitClassRefactoring methodsFor: 'transforming'!abstractVariableReferences	instanceVariables do: [:each | self abstractReferenceTo: each]! !!SplitClassRefactoring methodsFor: 'transforming'!createNewClass	self		addClass;		addInstanceVariables! !!SplitClassRefactoring methodsFor: 'transforming'!createReference	self performComponentRefactoring: (AddInstanceVariableRefactoring 				variable: referenceVariableName				class: class)! !!SplitClassRefactoring methodsFor: 'transforming'!transform	self		createNewClass;		createReference;		abstractVariableReferences! !!SplitClassRefactoring methodsFor: 'initialize-release'!class: aClass instanceVariables: instVars newClassName: className referenceVariableName: newVariable 	class := self model classFor: aClass.	instanceVariables := instVars.	newClassName := className.	referenceVariableName := newVariable! !!SplitClassRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isValidClassName: newClassName) 		& (RBCondition isGlobal: newClassName in: self model) not 			& (RBCondition isValidInstanceVariableName: referenceVariableName for: class) 			& (RBCondition hierarchyOf: class definesVariable: referenceVariableName) 					not 			& (RBCondition isGlobal: referenceVariableName in: self model) not 			& (RBCondition definesTemporaryVariable: referenceVariableName in: class) 					not! !!SplitClassRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' class: '.	class storeOn: aStream.	aStream nextPutAll: ' instanceVariables: '.	instanceVariables asArray storeOn: aStream.	aStream		nextPutAll: ' newClassName: #';		nextPutAll: newClassName;		nextPutAll: ' referenceVariableName: ''';		nextPutAll: referenceVariableName;		nextPutAll: ''')'! !!SplitClassRefactoring class methodsFor: 'instance creation'!class: class instanceVariables: instVars newClassName: className referenceVariableName: newVariable 	^(self new)		class: class			instanceVariables: instVars			newClassName: className			referenceVariableName: newVariable;		yourself! !!SplitClassRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk class: class instanceVariables: instVars newClassName: className referenceVariableName: newVariable 	^(self new)		model: aRBSmalltalk;		class: class			instanceVariables: instVars			newClassName: className			referenceVariableName: newVariable;		yourself! !!SqueakMethodPatternParser methodsFor: 'reduction actions' stamp: 'ms 11/19/2006 17:14'!method: nodes	^RBMethodNode new		selectorParts: nodes first first arguments: nodes first second; body: (RBSequenceNode statements: #())		! !!SqueakMethodPatternParser methodsFor: 'generated-tables' stamp: 'ms 11/21/2006 08:27'!reduceTable	^#(#(29 0 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(29 2 #reduceFor:)#(30 1 #variable:)#(31 1 #reduceFor:)#(32 2 #method:)#(33 2 #messagePart:)#(33 2 #argumentNameMissing:)#(33 3 #addMessagePart:)#(33 3 #argumentNameMissing:)#(34 1 #unaryMessage:)#(34 2 #messagePart:)#(34 2 #argumentNameMissing:)#(34 1 #first:))! !!SqueakMethodPatternParser methodsFor: 'generated-tables' stamp: 'ms 11/19/2006 17:05'!transitionTable	^#(#(3 13 12 17 13 21 15 25 32 29 33 33 34)#(3 13 12 17 13 21 15 29 33 37 34)#(2 150 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(3 41 12 45 30 49 36)#(3 41 12 53 30 57 36)#(2 0 35)#(3 162 1 162 2 162 3 162 4 162 5 162 6 162 7 162 8 162 9 162 10 162 11 162 12 61 13 162 14 162 15 162 16 162 17 162 18 162 19 162 20 162 21 162 22 162 23 162 24 162 25 162 26 162 27 162 28 162 35)#(3 6 1 6 2 6 3 6 4 6 5 6 6 6 7 6 8 6 9 6 10 6 11 6 12 6 13 6 14 6 15 6 16 6 17 6 18 6 19 6 20 6 21 6 22 6 23 6 24 6 25 6 26 6 27 6 28 65 29 6 35)#(2 0 35)#(2 122 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 134 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 138 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 154 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 158 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(3 41 12 69 30 73 36)#(3 77 1 81 2 85 3 89 4 93 5 97 6 101 7 105 8 109 9 113 10 117 11 121 12 125 13 129 14 133 15 137 16 141 17 145 18 149 19 153 20 157 21 161 22 165 23 169 24 173 25 177 26 181 27 185 28 130 35)#(2 142 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 146 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 106 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 110 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 118 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 114 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 14 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 18 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 22 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 26 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 30 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 34 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 38 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 42 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 46 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 50 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 54 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 58 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 62 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 66 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 70 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 74 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 78 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 82 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 90 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 94 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 98 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35)#(2 102 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 35))! !!SqueakMethodPatternParser class methodsFor: 'generated-comments' stamp: 'ms 11/19/2006 17:05'!parserDefinitionComment	"%id <name> <number> <negativeNumber> <binarySymbol> <period> <colon> <rightParentheses> <rightCurlyBrackets> <rightBoxBrackets> <string> <keyword> <multikeyword> <assignment> <character>;%start MethodPattern;Method:	MethodPattern Body 						{#method:};MethodPattern:	<name>										{#unaryMessage:}|	<binarySymbol> Variable						{#messagePart:}|	<binarySymbol> error						{#argumentNameMissing:}|	KeywordMethodPattern						{#first:};KeywordMethodPattern:	<keyword> Variable							{#messagePart:}|	<keyword> error								{#argumentNameMissing:}|	KeywordMethodPattern <keyword> Variable	{#addMessagePart:}|	KeywordMethodPattern <keyword> error		{#argumentNameMissing:};		Variable: 	<name>										{#variable:};												Body:|	Body <decimalNumber>|	Body <radixNumber>|	Body <scaledNumber>|	Body <exponentNumber>|	Body <number>|	Body <negativeNumber>|	Body <string>|	Body <name>|	Body <keyword>|	Body <multikeyword>|	Body <binarySymbol>|	Body <assignment>|	Body <alternateKeyword>|	Body <whitespace>|	Body <comment>|	Body <character>|	Body <period>|	Body <variableAssignment>|	Body <rightBoxBrackets>|	Body <rightCurlyBrackets>|	Body <rightParentheses>|	Body <colon>|	Body <semicolon>|	Body <anyChar>|	Body ""[""|	Body ""{""|	Body ""(""|	Body ""|"";"! !!SqueakMethodPatternParser class methodsFor: 'generated-accessing' stamp: 'ms 11/19/2006 17:05'!scannerClass	^SqueakMethodPatternScanner! !!SqueakMethodPatternParser class methodsFor: 'generated-starting states' stamp: 'ms 11/19/2006 17:05'!startingStateForMethod	^1! !!SqueakMethodPatternParser class methodsFor: 'generated-starting states' stamp: 'ms 11/19/2006 17:05'!startingStateForMethodPattern	^2! !!SqueakMethodPatternScanner methodsFor: 'generated-tokens' stamp: 'ms 11/19/2006 17:05'!assignmentId	^16! !!SqueakMethodPatternScanner methodsFor: 'generated-tokens' stamp: 'ms 11/19/2006 17:05'!binarySymbolId	^15! !!SqueakMethodPatternScanner methodsFor: 'generated-tokens' stamp: 'ms 11/19/2006 17:05'!characterId	^20! !!SqueakMethodPatternScanner methodsFor: 'generated-tokens' stamp: 'ms 11/19/2006 17:05'!colonId	^26! !!SqueakMethodPatternScanner methodsFor: 'generated-tokens' stamp: 'ms 11/19/2006 17:05'!emptySymbolTokenId	^35! !!SqueakMethodPatternScanner methodsFor: 'generated-tokens' stamp: 'ms 11/19/2006 17:05'!errorTokenId	^36! !!SqueakMethodPatternScanner methodsFor: 'generated-tokens' stamp: 'ms 11/19/2006 17:05'!keywordId	^13! !!SqueakMethodPatternScanner methodsFor: 'generated-tokens' stamp: 'ms 11/19/2006 17:05'!multikeywordId	^14! !!SqueakMethodPatternScanner methodsFor: 'generated-tokens' stamp: 'ms 11/19/2006 17:05'!nameId	^12! !!SqueakMethodPatternScanner methodsFor: 'generated-tokens' stamp: 'ms 11/19/2006 17:05'!negativeNumberId	^10! !!SqueakMethodPatternScanner methodsFor: 'generated-tokens' stamp: 'ms 11/19/2006 17:05'!numberId	^9! !!SqueakMethodPatternScanner methodsFor: 'generated-tokens' stamp: 'ms 11/19/2006 17:05'!periodId	^21! !!SqueakMethodPatternScanner methodsFor: 'generated-tokens' stamp: 'ms 11/19/2006 17:05'!rightBoxBracketsId	^23! !!SqueakMethodPatternScanner methodsFor: 'generated-tokens' stamp: 'ms 11/19/2006 17:05'!rightCurlyBracketsId	^24! !!SqueakMethodPatternScanner methodsFor: 'generated-tokens' stamp: 'ms 11/19/2006 17:05'!rightParenthesesId	^25! !!SqueakMethodPatternScanner methodsFor: 'generated-tokens' stamp: 'ms 11/19/2006 17:05'!stringId	^11! !!SqueakMethodPatternScanner methodsFor: 'token hanling' stamp: 'ms 11/25/2006 10:00'!binarySymbol	matchActions := {self binarySymbolId}.	^ self createTokenFor: outputStream contents! !!SqueakMethodPatternScanner methodsFor: 'generated-scanner' stamp: 'ms 11/19/2006 17:05'!scan1	self step.	currentCharacter isDigit 		ifTrue: 			[			[self recordMatch: #(10 ).			self step.			currentCharacter isDigit] 					whileTrue.			^ self reportLastMatch].	currentCharacter == $- ifTrue: [^ self scan2].	^ self reportLastMatch! !!SqueakMethodPatternScanner methodsFor: 'generated-scanner' stamp: 'ms 11/19/2006 17:05'!scan10	self step.	currentCharacter isDigit 		ifTrue: 			[			[self recordMatch: #(7 9 ).			self step.			currentCharacter isDigit] 					whileTrue.			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakMethodPatternScanner methodsFor: 'generated-scanner' stamp: 'ms 11/19/2006 17:05'!scan11	self recordMatch: #(13 ).	self step.	((currentCharacter between: $A and: $Z) 		or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan5].	currentCharacter == $= 		ifTrue: [^ self recordAndReportMatch: #variableAssignment].	^ self reportLastMatch! !!SqueakMethodPatternScanner methodsFor: 'generated-scanner' stamp: 'ms 11/19/2006 17:05'!scan2	self step.	currentCharacter isDigit 		ifTrue: 			[			[self recordMatch: #(10 ).			self step.			currentCharacter isDigit] 					whileTrue.			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakMethodPatternScanner methodsFor: 'generated-scanner' stamp: 'ms 11/19/2006 17:05'!scan3		[self step.	currentCharacter ~~ $'] whileTrue.	^ self scan4! !!SqueakMethodPatternScanner methodsFor: 'generated-scanner' stamp: 'ms 11/19/2006 17:05'!scan4	self recordMatch: #(11 ).	self step.	currentCharacter == $' ifTrue: [^ self scan3].	^ self reportLastMatch! !!SqueakMethodPatternScanner methodsFor: 'generated-scanner' stamp: 'ms 11/19/2006 17:05'!scan5		[self step.	(currentCharacter between: $0 and: $9) or: 			[(currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]]] 			whileTrue.	currentCharacter == $: 		ifTrue: 			[self recordMatch: #(14 ).			self step.			((currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan5].			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakMethodPatternScanner methodsFor: 'generated-scanner' stamp: 'ms 11/19/2006 17:05'!scan6		[self step.	(currentCharacter between: $0 and: $9) or: 			[(currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]]] 			whileTrue.	currentCharacter == $: 		ifTrue: 			[self recordMatch: #(17 ).			self step.			((currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan6].			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakMethodPatternScanner methodsFor: 'generated-scanner' stamp: 'ms 11/19/2006 17:05'!scan7	self step.	(currentCharacter isDigit or: [currentCharacter between: $A and: $Z]) 		ifTrue: 			[			[self recordMatch: #(6 9 ).			self step.			currentCharacter isDigit or: [currentCharacter between: $A and: $Z]] 					whileTrue.			currentCharacter == $. 				ifTrue: 					[self step.					(currentCharacter isDigit or: [currentCharacter between: $A and: $Z]) 						ifTrue: 							[							[self recordMatch: #(6 9 ).							self step.							currentCharacter isDigit or: [currentCharacter between: $A and: $Z]] 									whileTrue.							currentCharacter == $e ifTrue: [^ self scan8].							^ self reportLastMatch].					^ self reportLastMatch].			currentCharacter == $e ifTrue: [^ self scan8].			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakMethodPatternScanner methodsFor: 'generated-scanner' stamp: 'ms 11/19/2006 17:05'!scan8	self step.	currentCharacter isDigit 		ifTrue: 			[			[self recordMatch: #(8 9 ).			self step.			currentCharacter isDigit] 					whileTrue.			^ self reportLastMatch].	currentCharacter == $- 		ifTrue: 			[self step.			currentCharacter isDigit 				ifTrue: 					[					[self recordMatch: #(8 9 ).					self step.					currentCharacter isDigit] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakMethodPatternScanner methodsFor: 'generated-scanner' stamp: 'ms 11/19/2006 17:05'!scan9	self step.	currentCharacter isDigit 		ifTrue: 			[			[self recordMatch: #(5 9 ).			self step.			currentCharacter isDigit] 					whileTrue.			currentCharacter == $e ifTrue: [^ self scan8].			currentCharacter == $s ifTrue: [^ self scan10].			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakMethodPatternScanner methodsFor: 'generated-scanner' stamp: 'ms 11/19/2006 17:05'!scanForToken	self step.	(currentCharacter <= Character backspace or: 			[(currentCharacter between: (Character value: 14) and: (Character value: 31)) 				or: 					[currentCharacter == $# or: 							[currentCharacter == $^ 								or: [currentCharacter == $` or: [currentCharacter >= $]]]]]) 		ifTrue: [^ self recordAndReportMatch: #(28 )].	((currentCharacter between: $A and: $Z) 		or: [currentCharacter between: $a and: $z]) 			ifTrue: 				[self recordMatch: #(12 28 ).				self step.				((currentCharacter between: $0 and: $9) or: 						[(currentCharacter between: $A and: $Z) 							or: [currentCharacter between: $a and: $z]]) 					ifTrue: 						[						[self recordMatch: #(12 ).						self step.						(currentCharacter between: $0 and: $9) or: 								[(currentCharacter between: $A and: $Z) 									or: [currentCharacter between: $a and: $z]]] 								whileTrue.						currentCharacter == $: ifTrue: [^ self scan11].						^ self reportLastMatch].				currentCharacter == $: ifTrue: [^ self scan11].				^ self reportLastMatch].	(currentCharacter == $!! or: 			[(currentCharacter between: $% and: $&) or: 					[(currentCharacter between: $* and: $,) or: 							[currentCharacter == $/ or: 									[(currentCharacter between: $< and: $@) 										or: [currentCharacter == $\ or: [currentCharacter == $~]]]]]]) 		ifTrue: 			[self recordMatch: #binarySymbol.			self step.			currentCharacter isSpecial 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter isSpecial] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter isDigit 		ifTrue: 			[self recordMatch: #(5 9 28 ).			self step.			currentCharacter isDigit 				ifTrue: 					[					[self recordMatch: #(5 9 ).					self step.					currentCharacter isDigit] 							whileTrue.					currentCharacter == $. ifTrue: [^ self scan9].					currentCharacter == $e ifTrue: [^ self scan8].					currentCharacter == $r ifTrue: [^ self scan7].					currentCharacter == $s ifTrue: [^ self scan10].					^ self reportLastMatch].			currentCharacter == $. ifTrue: [^ self scan9].			currentCharacter == $e ifTrue: [^ self scan8].			currentCharacter == $r ifTrue: [^ self scan7].			currentCharacter == $s ifTrue: [^ self scan10].			^ self reportLastMatch].	(currentCharacter isSeparator 		or: [currentCharacter == (Character value: 11)]) 			ifTrue: 				[self recordMatch: #whitespace.				self step.				(currentCharacter isSeparator 					or: [currentCharacter == (Character value: 11)]) 						ifTrue: 							[							[self recordMatch: #whitespace.							self step.							currentCharacter isSeparator 								or: [currentCharacter == (Character value: 11)]] 									whileTrue.							^ self reportLastMatch].				^ self reportLastMatch].	currentCharacter == $" 		ifTrue: 			[self recordMatch: #(28 ).			self step.			currentCharacter ~~ $" 				ifTrue: 					[					[self step.					currentCharacter ~~ $"] whileTrue.					^ self recordAndReportMatch: #comment].			currentCharacter == $" ifTrue: [^ self recordAndReportMatch: #comment].			^ self reportLastMatch].	currentCharacter == $$ 		ifTrue: 			[self recordMatch: #(28 ).			self step.			^ self recordAndReportMatch: #(20 )].	currentCharacter == $' 		ifTrue: 			[self recordMatch: #(28 ).			self step.			currentCharacter ~~ $' ifTrue: [^ self scan3].			currentCharacter == $' ifTrue: [^ self scan4].			^ self reportLastMatch].	currentCharacter == $( ifTrue: [^ self recordAndReportMatch: #(4 28 )].	currentCharacter == $) ifTrue: [^ self recordAndReportMatch: #(25 28 )].	currentCharacter == $- 		ifTrue: 			[self recordMatch: #binarySymbol.			self step.			currentCharacter isSpecial 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter isSpecial] 							whileTrue.					^ self reportLastMatch].			currentCharacter isDigit 				ifTrue: 					[					[self recordMatch: #(10 ).					self step.					currentCharacter isDigit] 							whileTrue.					currentCharacter == $. 						ifTrue: 							[self step.							currentCharacter isDigit 								ifTrue: 									[									[self recordMatch: #(10 ).									self step.									currentCharacter isDigit] 											whileTrue.									currentCharacter == $e ifTrue: [^ self scan1].									currentCharacter == $s ifTrue: [^ self scan2].									^ self reportLastMatch].							^ self reportLastMatch].					currentCharacter == $e ifTrue: [^ self scan1].					currentCharacter == $r 						ifTrue: 							[self step.							(currentCharacter isDigit or: [currentCharacter between: $A and: $Z]) 								ifTrue: 									[									[self recordMatch: #(10 ).									self step.									currentCharacter isDigit or: [currentCharacter between: $A and: $Z]] 											whileTrue.									currentCharacter == $. 										ifTrue: 											[self step.											(currentCharacter isDigit or: [currentCharacter between: $A and: $Z]) 												ifTrue: 													[													[self recordMatch: #(10 ).													self step.													currentCharacter isDigit or: [currentCharacter between: $A and: $Z]] 															whileTrue.													currentCharacter == $e ifTrue: [^ self scan1].													^ self reportLastMatch].											^ self reportLastMatch].									currentCharacter == $e ifTrue: [^ self scan1].									^ self reportLastMatch].							^ self reportLastMatch].					currentCharacter == $s ifTrue: [^ self scan2].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter == $. ifTrue: [^ self recordAndReportMatch: #(21 28 )].	currentCharacter == $: 		ifTrue: 			[self recordMatch: #(26 28 ).			self step.			((currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan6].			currentCharacter == $= ifTrue: [^ self recordAndReportMatch: #(16 )].			^ self reportLastMatch].	currentCharacter == $; ifTrue: [^ self recordAndReportMatch: #(27 28 )].	currentCharacter == $[ ifTrue: [^ self recordAndReportMatch: #(1 28 )].	currentCharacter == $] ifTrue: [^ self recordAndReportMatch: #(23 28 )].	currentCharacter == $_ ifTrue: [^ self recordAndReportMatch: #(16 28 )].	currentCharacter == ${ ifTrue: [^ self recordAndReportMatch: #(2 28 )].	currentCharacter == $| 		ifTrue: 			[self recordMatch: #(3 15 28 ).			self step.			currentCharacter isSpecial 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter isSpecial] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter == $} ifTrue: [^ self recordAndReportMatch: #(24 28 )].	^ self reportLastMatch! !!SqueakMethodPatternScanner class methodsFor: 'generated-comments' stamp: 'ms 11/19/2006 17:05'!scannerDefinitionComment	"<decimalNumber>:	[0-9]+ (\. [0-9]+)? ;<radixNumber>:		[0-9]+ r [0-9A-Z]+ (\. [0-9A-Z]+)? ;<scaledNumber>:		<decimalNumber> s [0-9]+ ;<exponentNumber>:	(<decimalNumber> | <radixNumber>) e \-? [0-9]+ ;<number>:			<decimalNumber> | <radixNumber> | <exponentNumber> | <scaledNumber> ;<negativeNumber>:	\- <number> ;<string>:				\'  [^\']* \' (\' [^\']* \')* ;<name>:				[a-zA-Z] [a-zA-Z0-9]* ;<keyword>:			<name> \: ;<multikeyword>:		<name> \: (<name> \: )+ ;<binarySymbol>:		[\~\!!\@\%\&\*\-\+\=\\\|\?\/\>\<\,] [\~\!!\@\%\&\*\-\+\=\\\|\?\/\>\<\,]* ;<assignment>:		\: \= | \_ ;<alternateKeyword>:	\: <name> \: (<name> \:)* ;<whitespace>:		\s+ ;<comment>:			\"" [^\""]* \"" ;<character>:			\$ . ;<period>:				\. ;<variableAssignment>:	<name> \: \= ;<rightBoxBrackets>:	];<rightCurlyBrackets>:	};<rightParentheses>:	\);<colon>:				\:;<semicolon>:			\;;<anyChar>:			. ; # For VW literal arrays that handle #(;) -> #(#';');"! !!SqueakMethodPatternTest methodsFor: 'tests' stamp: 'ms 11/25/2006 10:08'!testParseMethodPattern		| ast  |	self shouldnt:[ast := SqueakParser parseMethodPattern: 'zork ^foo'] raise: Error.	self assert: ast selector = #zork! !!SqueakParser methodsFor: 'private' stamp: 'ms 7/13/2006 10:02'!actionForCurrentToken	| ids action |	ids := currentToken id.	1 to: ids size do: [:i | 		action := self actionFor: (ids at: i).		(action bitAnd: self actionMask) = self errorAction ifFalse: [^ action].		"Convert negative number to binarySymbol"		(self isNegativeNumberId:(ids at: i)) ifTrue: [			^self negativeNumberToBinaryString].		"Ignore repeating periods"		(self isEmptyStatementId: (ids at: i)) ifTrue: [			^ self ignoreEmptyStatement].	].	^ self errorAction! !!SqueakParser methodsFor: 'private' stamp: 'ms 9/4/2006 00:20'!externalTypeOn: aNode	| xType descriptorClass |	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent:[^nil].	xType := descriptorClass atomicTypeNamed: aNode first value.	xType == nil ifTrue:["Look up from class scope"		Symbol hasInterned: aNode first value ifTrue:[:sym|			xType := descriptorClass structTypeNamed: sym]].	xType == nil ifTrue:[		"Raise an error if user is there"		self interactive ifTrue:[^nil].		"otherwise go over it silently"		xType := descriptorClass forceTypeNamed: aNode first value].	^xType.! !!SqueakParser methodsFor: 'private' stamp: 'ms 7/13/2006 09:48'!ignoreEmptyStatement		currentToken _ nil.	self getNextToken.	^ self actionForCurrentToken! !!SqueakParser methodsFor: 'private' stamp: 'ms 7/13/2006 09:59'!isEmptyStatementId: id	^ ((id = scanner periodId) and: [nodeStack isEmpty]) 		or: [(id = scanner periodId) and: [(nodeStack last isKindOf: SmaCCToken) and: [nodeStack last id first = scanner periodId]]] ! !!SqueakParser methodsFor: 'private' stamp: 'ms 7/13/2006 09:58'!isNegativeNumberId: id	^ scanner negativeNumberId = id! !!SqueakParser methodsFor: 'private' stamp: 'ms 9/17/2006 15:27'!negativeNumberToBinaryString		currentToken := (SqueakToken 		value: '-'		start: currentToken startPosition		id: (Array with: scanner binarySymbolId)) substitueTo: currentToken; yourself.	scanner position: currentToken stopPosition.	^ self actionForCurrentToken! !!SqueakParser methodsFor: 'private' stamp: 'ajh 3/6/2003 00:02'!nodeStack	^ nodeStack! !!SqueakParser methodsFor: 'private' stamp: 'ajh 3/6/2003 00:19'!scanner	^ scanner! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:01'!add3: nodes	^ nodes first copyWith: nodes third! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:59'!add: nodes	^ nodes first copyWith: nodes second! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:54'!addMessagePart: nodes	^ {nodes first first copyWith: nodes second.	   nodes first second copyWith: nodes third}! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:58'!array	^ #()! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/18/2006 18:00'!array: nodes	^ (RBArrayNode		leftBrace: nodes first start		rightBrace: nodes third stop		statements: nodes second)			firstToken: nodes first;			lastToken: nodes last;			yourself.! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/18/2006 22:47'!arrayAddToken: nodes		^OrderedCollection with: #() with: nodes first with: nodes first! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:07'!assignment: nodes	^ RBAssignmentNode		variable: nodes first		value: nodes third! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/18/2006 18:43'!blockArgs: nodes	^ (RBBlockNode		arguments: nodes second		body: (RBSequenceNode statements: #()))		left: nodes first start;		right: nodes third stop;		firstToken: nodes first;		lastToken: nodes last;		yourself! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/18/2006 18:43'!blockNoArgs: nodes	^ (RBBlockNode		body: nodes second)		left: nodes first start;		right: nodes third stop;		firstToken: nodes first;		lastToken: nodes last;		yourself! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/18/2006 18:39'!blockWithArgs: nodes	^ (RBBlockNode		arguments: nodes second		body: nodes fourth)		left: nodes first start;		right: nodes fifth stop;		firstToken: nodes first;		lastToken: nodes last;		yourself! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/18/2006 23:07'!blockWithTemps: nodes	^ (RBBlockNode		arguments: nodes second		body: ((RBSequenceNode			temporaries: nodes fourth			statements: nodes sixth) firstToken: nodes third))		left: nodes first start;		right: nodes seventh stop;		firstToken: nodes first;		lastToken: nodes last;		yourself! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:23'!byteStream	^ ByteArray new writeStream! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:25'!byteStreamPut: nodes	^ nodes first		nextPut: nodes second value asNumber;		yourself! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/17/2006 01:01'!callConvention: nodes	| descriptorClass |	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent:[^nil].	^OrderedCollection with:(descriptorClass callingConventionFor: nodes first value) with: nodes first.! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:12'!cascade: nodes	^ (nodes first isKindOf: RBMessageNode)		ifTrue: [RBCascadeNode messages:			{nodes first.			 RBMessageNode new				receiver: nodes first receiver				selectorParts: nodes third first				arguments: nodes third last}]		ifFalse: [RBCascadeNode messages:			(nodes first messages copyWith:				(RBMessageNode new					receiver: nodes first messages first receiver					selectorParts: nodes third first					arguments: nodes third last))]! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:27'!contents2: nodes	^ nodes second contents! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/17/2006 01:40'!externalCall: nodes	| fn |	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|		fn := xfn name: nodes third				module: nil 				callType: nodes first first				returnType: nodes second first				argumentTypes: nodes fifth first contents.	].	^ OrderedCollection with: (Pragma keyword: #primitive: arguments: #(120)) with: fn with: 120  with: nodes first second with: nodes fifth second! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/25/2006 13:37'!externalFunction: nodes	^nodes first value withoutQuoting asSymbol.! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/25/2006 13:37'!externalIndex: nodes	^nodes first value.! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/17/2006 01:40'!externalModuleCall: nodes	| fn |	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|		fn := xfn name: nodes third 				module: nodes last value withoutQuoting asSymbol				callType: nodes first first				returnType: nodes second first				argumentTypes: nodes fifth first contents.	].	^ OrderedCollection with: (Pragma keyword: #primitive: arguments: #(120)) with: fn with: 120 with: nodes first second with: nodes last! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/17/2006 01:30'!externalType: nodes		^OrderedCollection with: (self externalTypeOn: nodes) with: nodes last	! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/17/2006 01:34'!externalTypePointer: nodes	| xType |	xType := self externalTypeOn: nodes.	xType ifNil:[^nodes].	^OrderedCollection with: xType asPointerType with: nodes last! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:53'!first: nodes	^ nodes first! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:01'!firstIn: nodes	^ {nodes first}! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/19/2006 16:25'!litArray: nodes	| litToken |	litToken := (SqueakToken			value: (String new: (nodes fourth stop - nodes second start + 1))			start: nodes second start).	litToken previous: nodes first previous.	litToken next: nodes last next.	^ (RBLiteralNode		literalToken: litToken		value: nodes third contents) 			firstToken: nodes first; 			lastToken: nodes last; 			yourself! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:16'!litChar: nodes	^ RBLiteralNode		literalToken: nodes first		value: (nodes first value at: 2)! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:14'!litFalse: nodes	^ RBLiteralNode		literalToken: nodes first		value: false! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:14'!litNil: nodes	^ RBLiteralNode		literalToken: nodes first		value: nil! !!SqueakParser methodsFor: 'reduction actions' stamp: 'md 10/18/2004 17:23'!litNumber: nodes	| str num |	str _ nodes first value readStream.	num _ Number readFrom: str.	str atEnd ifFalse: [		currentToken _ nil.		scanner position: scanner position - (str originalContents size - str position) + 1.		self reportErrorMessage: 'Digit out of range'].	^ RBLiteralNode		literalToken: nodes first		value: num! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:18'!litString: nodes	| s |	s _ nodes first value.	^ RBLiteralNode		literalToken: nodes first		value: ((s copyFrom: 2 to: s size - 1)				copyReplaceAll: '''''' with: '''')! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 3/31/2007 17:53'!litStringSymbol: nodes	| s |	s := nodes second value.	^ (RBLiteralNode		literalToken: nodes second		value: ((s copyFrom: 2 to: s size - 1)				copyReplaceAll: '''''' with: '''') asSymbol) firstToken: nodes first; yourself! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/18/2006 19:12'!litSymbol: nodes	^ (RBLiteralNode		literalToken: nodes second		value: nodes second value asSymbol) firstToken: nodes first; yourself! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:14'!litTrue: nodes	^ RBLiteralNode		literalToken: nodes first		value: true! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:52'!messagePart: nodes	^ {{nodes first}. {nodes second}}! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/17/2006 01:28'!messagePragma: nodes	"self haltIf: [(nodes first first isKindOf: Pragma) not]."	^nodes first! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:13'!messageSend: nodes	^ RBMessageNode new		receiver: nodes first		selectorParts: nodes second first		arguments: nodes second last! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:48'!method: nodes	^ RBMethodNode new		selectorParts: nodes first first		arguments: nodes first last;		body: nodes second! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/15/2006 19:07'!methodPragma: nodes	^RBMethodNode new		selectorParts: nodes first first		arguments: nodes first last;		body: nodes third;		pragmas:nodes second! !!SqueakParser methodsFor: 'reduction actions' stamp: 'pmm 11/11/2006 14:12'!methodPragmaTempsPragma: nodes	| sequence |	sequence := (RBSequenceNode		temporaries: nodes third first		statements: nodes fifth) 		firstToken: nodes third second; 		yourself.	nodes fifth isEmpty ifFalse: [		sequence lastToken: nodes third third ].	^ RBMethodNode new 		selectorParts: nodes first first		arguments: nodes first last;		body: sequence;		pragmas: (nodes second addAll: nodes fourth; yourself)! !!SqueakParser methodsFor: 'reduction actions' stamp: 'pmm 11/11/2006 14:15'!methodTempsPragma: nodes	| sequence |	sequence := (RBSequenceNode		temporaries: nodes second first		statements: nodes fourth)		firstToken: nodes second second; 		yourself.	nodes fourth isEmpty ifFalse: [			sequence lastToken: nodes second third ].	^ RBMethodNode new		selectorParts: nodes first first		arguments: nodes first last;		body: sequence;		pragmas: nodes third! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/17/2006 01:31'!parameterExtCall: nodes	| args |	args := WriteStream on: Array new.	args nextPut: nodes first first.	^OrderedCollection with: args with: nodes first second! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/17/2006 01:34'!parametersExtCall: nodes	| aCol |	aCol := nodes first.	aCol  first nextPut: (nodes second first).	aCol at: 2 put: nodes second second.	^aCol! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/18/2006 17:13'!pragma: nodes	"self haltIf: [nodes second first isKindOf: Pragma]."	"| pragmaNode |	pragmaNode := RBPragmasNode withPragma: nodes second first spec: nodes second second.	nodes second third ifNotNil: [pragmaNode primitiveNumber: nodes second third].	^pragmaNode"		| rbPragma |	rbPragma := RBPragmaNode pragma: nodes second first 								spec: nodes second second 								start: nodes first start 								stop: nodes third stop 								firstToken: nodes first								lastToken: nodes last.	nodes second third ifNotNil: [rbPragma primitiveNumber: nodes second third].	^OrderedCollection with: rbPragma! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 11/11/2006 17:42'!pragmaMessage: nodes	| arguments keyword |	keyword := String new.	arguments := (nodes first second collect: [:each | each value]).	nodes first first do: [:each | keyword := keyword, each value].	^OrderedCollection with:(Pragma keyword: keyword asSymbol arguments: arguments)					  with: nil					  with: nil					  with: nodes first first first					  with: nodes first second last token			! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/17/2006 01:47'!pragmaUnaryMessage: nodes	^OrderedCollection with:(Pragma keyword: nodes first first first value asSymbol arguments: nodes first second)					  with: nil					  with: nil					  with: nodes first first first					  with: nodes first first first			! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/18/2006 17:24'!pragmas: nodes	"nodes first addPragma: nodes third first withSpec: nodes third second.	nodes third third ifNotNil: [nodes first primitiveNumber: nodes third third].	^nodes first"		| rbPragma |	rbPragma := RBPragmaNode pragma: nodes third first 								spec: nodes third second 								start: nodes second start 								stop: nodes fourth stop 								firstToken: nodes second 								lastToken: nodes last.	nodes third third ifNotNil: [rbPragma primitiveNumber: nodes third third].	nodes first add: rbPragma.	^nodes first	! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/17/2006 00:54'!primitiveModule: nodes	^OrderedCollection with: (Pragma keyword: #primitive:module: 									 arguments: (Array with: nodes second value withoutQuoting asSymbol														with: nodes fourth value withoutQuoting asSymbol)) 					  with: (Array with: nodes fourth value withoutQuoting asSymbol 								    with: nodes second value withoutQuoting asSymbol 								    with: 0 with: 0)					  with: 117					  with: nodes first					  with: nodes last	! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/17/2006 00:54'!primitiveNumber: nodes	^OrderedCollection with: (Pragma keyword: #primitive: arguments: (Array with: nodes second value asInteger)) 					  with: nil					  with: nodes second value asInteger					  with: nodes first					  with: nodes second	! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/17/2006 00:53'!primitiveString: nodes	^OrderedCollection with: (Pragma keyword: #primitive: 									 arguments: (Array with: nodes second value withoutQuoting asSymbol)) 					   with: (Array with: nil 									with: nodes second value withoutQuoting asSymbol 									with: 0 with: 0)					   with: 117					   with: nodes first					   with: nodes second! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/18/2006 18:50'!return: nodes	^ {(RBReturnNode		return: nodes first start		value: nodes second) firstToken: nodes first; yourself}! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/19/2003 13:49'!returnAdd: nodes	^ nodes first copyWith: (RBReturnNode		return: nodes third start		value: nodes fourth)! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:58'!second: nodes	^ nodes second! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 3/31/2007 20:31'!secondAddToken: nodes		^OrderedCollection with: nodes second with: nodes first with: nodes last! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:06'!secondIn: nodes	^ {nodes second}! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/18/2006 17:47'!secondPutToken: nodes	nodes second firstToken: nodes first.	nodes second lastToken: nodes last.	^nodes second! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 3/31/2007 17:51'!secondWithParenthesis: nodes	nodes second addParenthesis: (nodes first start to: nodes last stop).	nodes second firstToken: nodes first.	nodes second lastToken: nodes last.	^nodes second! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:57'!sequence: nodes	^ RBSequenceNode		statements: nodes first! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/25/2006 12:55'!sequenceWithTemps: nodes	nodes second ifNotEmpty: [^ (RBSequenceNode					temporaries: nodes first first					statements: nodes second) firstToken: nodes first second; yourself]				ifEmpty:[^ (RBSequenceNode					temporaries: nodes first first					statements: nodes second) 						firstToken: nodes first second;						lastToken:nodes first third]! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:23'!stream	^ Array new writeStream! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:26'!streamPut: nodes	^ nodes first		nextPut: nodes second;		yourself! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:52'!unaryMessage: nodes	^ {{nodes first}. #()}! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:27'!value: nodes	^ nodes first value! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:27'!valueSymbol: nodes	^ nodes first value asSymbol! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:13'!variable: nodes	^ RBVariableNode new		identifierToken: nodes first! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 11/10/2006 22:39'!argumentMissing: nodes		messageError := 'Argument expected'.	^nodes! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 11/8/2007 13:52'!argumentNameMissing: nodes		messageError := 'Argument name or | expected'.	^nodes! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 11/10/2006 22:36'!cascadeMMissing: nodes		messageError := 'Cascade expected'.	^nodes! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 10/6/2006 15:14'!checkForErrors	"If we have an error correction installed, we might have handled the errors. If we did, we don't 	want to return the result, so we raise a final exception that can't be proceeded."	errorToken isNil ifTrue: [^self].	currentToken := errorToken.	self reportErrorMessage: (messageError ifNil:['Token not expected'])		! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 10/10/2006 22:23'!collectAcceptableToken		^self class tokensId select:[:each | (self actionFor: each) ~~ self errorAction]! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 10/20/2006 17:52'!expressionMissing: nodes		messageError := 'Expression expected'.	^nodes! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 11/11/2006 17:21'!findErrorHandlerIfNoneUseErrorNumber: anInteger	| state reduceEntry items reduceIndex |	state := self stateErrorShiftInto.	state = 0 		ifFalse:[reduceIndex := (self findReduceActionForState: state).				stateStack addLast: state.			     reduceEntry := self reduceTable at: reduceIndex.			     items := OrderedCollection new: (reduceEntry at: 2).			     self performReduceMethod: (reduceEntry at: 3) with: items].	self reportError: anInteger	! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 10/20/2006 17:33'!findReduceActionForState: state	1 to: self errorTokenId do: [:i |		| action |		action := self actionForState: state and: i.		(action bitAnd: self actionMask) = self reduceAction 			ifTrue: [^action bitShift: -2]].	^0! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 10/20/2006 18:00'!handleError: anInteger 	errorToken isNil ifTrue: [errorToken := currentToken].	self hasErrorHandler not ifTrue: [self reportError: anInteger].	self findErrorHandlerIfNoneUseErrorNumber: anInteger! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 11/11/2006 12:29'!literalMissing: nodes		messageError := 'Literal constant expected'.	^nodes! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 11/11/2006 12:12'!moduleArgMissing: nodes		messageError := 'Module name expected'.	^nodes! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 11/1/2006 01:34'!pragmaEndMissing: nodes		messageError := '> expected'.	^nodes! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 11/10/2006 22:32'!pragmaMissing: nodes	messageError := 'Pragma declaration expected'.	^ nodes! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 11/11/2006 12:10'!primitiveArgMissing: nodes		messageError := 'String or number primitive expected'.	^nodes! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 10/19/2006 22:15'!reportError: anInteger 	messageError ifNil:[		| acceptedToken |		messageError := ''.		acceptedToken := self collectAcceptableToken asArray.		acceptedToken 			do: [:each | acceptedToken last == each 							ifFalse:[messageError := messageError,  										(self class tokenDescription: each)]							ifTrue:[messageError := messageError, 										(self class tokenDescription: each), ' expected']]			separatedByNext:[:each | acceptedToken last == each 							ifFalse:[messageError := messageError, ', ']							ifTrue:[messageError := messageError, ' or ']].	messageError := messageError capitalized].	self reportErrorMessage: (anInteger = 0 				ifTrue: [messageError]				ifFalse: [self errorTable at: anInteger])		! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 11/10/2006 22:31'!stateErrorShiftInto	stateStack size to: 1		by: -1		do: 			[:i | 			| action |			action := self actionForState: (stateStack at: i) and: self errorTokenId.			(action bitAnd: self actionMask) = self reduceAction 				ifTrue:[self reduce:(action bitShift: -2).						^self stateErrorShiftInto].			(action bitAnd: self actionMask) = self shiftAction 				ifTrue: [^ action bitShift: -2].			stateStack removeLast].	^ 0! !!SqueakParser methodsFor: 'error handling' stamp: 'ms 10/20/2006 17:44'!verticalBarMissing: nodes		messageError := 'Vertical bar expected'.	^nodes! !!SqueakParser methodsFor: 'generated-reduction actions' stamp: 'ms 4/7/2007 03:32'!reduceActionForOptionalXXXperiodX1: nodes 	^ nil! !!SqueakParser methodsFor: 'generated-reduction actions' stamp: 'ms 4/7/2007 03:32'!reduceActionForOptionalXXXperiodX2: nodes 	^ nodes at: 1! !!SqueakParser methodsFor: 'generated-tables' stamp: 'ms 4/7/2007 03:32'!reduceTable	^#(#(39 1 #reduceFor:)#(40 1 #variable:)#(41 2 #messagePart:)#(41 2 #argumentNameMissing:)#(41 3 #addMessagePart:)#(41 3 #argumentNameMissing:)#(42 2 #method:)#(42 3 #methodPragma:)#(42 5 #methodPragmaTempsPragma:)#(42 4 #methodTempsPragma:)#(43 0 #array)#(43 2 #add:)#(44 1 #firstIn:)#(44 3 #add3:)#(45 0 #reduceActionForOptionalXXXperiodX1:)#(45 1 #reduceActionForOptionalXXXperiodX2:)#(46 1 #first:)#(46 1 #first:)#(46 1 #first:)#(47 2 #secondIn:)#(47 2 #argumentNameMissing:)#(47 3 #add3:)#(47 3 #argumentNameMissing:)#(48 5 #blockWithArgs:)#(48 3 #blockNoArgs:)#(48 3 #blockArgs:)#(48 7 #blockWithTemps:)#(49 3 #assignment:)#(49 3 #expressionMissing:)#(50 1 #first:)#(50 3 #cascade:)#(50 3 #cascadeMMissing:)#(51 0 #array)#(51 2 #first:)#(51 5 #returnAdd:)#(51 3 #return:)#(52 3 #array:)#(53 1 #litTrue:)#(53 1 #litFalse:)#(53 1 #litNil:)#(53 1 #litNumber:)#(53 1 #litNumber:)#(53 1 #litChar:)#(53 1 #litString:)#(53 2 #litStringSymbol:)#(53 2 #litSymbol:)#(53 2 #litSymbol:)#(53 2 #litSymbol:)#(53 2 #litSymbol:)#(53 2 #litSymbol:)#(53 4 #litArray:)#(53 4 #litArray:)#(53 1 #litString:)#(54 1 #first:)#(54 1 #first:)#(54 1 #first:)#(55 1 #arrayAddToken:)#(55 3 #secondAddToken:)#(55 3 #verticalBarMissing:)#(56 1 #sequence:)#(56 2 #sequenceWithTemps:)#(57 2 #messageSend:)#(57 2 #messageSend:)#(57 2 #messageSend:)#(58 2 #messageSend:)#(58 2 #messageSend:)#(58 2 #messageSend:)#(59 2 #messageSend:)#(59 2 #messageSend:)#(60 1 #unaryMessage:)#(61 2 #messagePart:)#(61 2 #argumentMissing:)#(62 2 #messagePart:)#(62 2 #argumentMissing:)#(62 3 #addMessagePart:)#(62 3 #argumentMissing:)#(63 1 #first:)#(63 1 #first:)#(63 1 #first:)#(64 1 #first:)#(64 1 #first:)#(65 3 #pragma:)#(65 3 #pragmaEndMissing:)#(65 2 #pragmaMissing:)#(65 4 #pragmas:)#(65 4 #pragmaEndMissing:)#(65 3 #pragmaMissing:)#(66 0 #byteStream)#(66 2 #byteStreamPut:)#(67 0 #stream)#(67 2 #streamPut:)#(68 1 #value:)#(68 1 #valueSymbol:)#(68 1 #valueSymbol:)#(68 1 #valueSymbol:)#(68 1 #valueSymbol:)#(68 1 #valueSymbol:)#(68 3 #contents2:)#(68 3 #contents2:)#(68 1 #valueSymbol:)#(69 3 #secondWithParenthesis:)#(69 1 #first:)#(69 1 #first:)#(69 1 #first:)#(69 1 #first:)#(70 6 #externalCall:)#(70 8 #externalModuleCall:)#(71 2 #primitiveString:)#(71 2 #primitiveNumber:)#(71 2 #primitiveArgMissing:)#(71 4 #primitiveModule:)#(71 4 #moduleArgMissing:)#(72 1 #pragmaMessage:)#(72 1 #pragmaMessage:)#(72 1 #pragmaUnaryMessage:)#(73 2 #messagePart:)#(73 2 #literalMissing:)#(73 3 #addMessagePart:)#(73 3 #literalMissing:)#(74 2 #messagePart:)#(74 2 #argumentMissing:)#(75 1 #first:)#(75 1 #first:)#(75 1 #first:)#(75 1 #first:)#(76 1 #callConvention:)#(76 1 #callConvention:)#(77 1 #externalType:)#(77 2 #externalTypePointer:)#(78 1 #externalFunction:)#(78 1 #externalIndex:)#(79 1 #parameterExtCall:)#(79 2 #parametersExtCall:)#(82 1 #unaryMessage:)#(82 2 #messagePart:)#(82 2 #argumentNameMissing:)#(82 1 #first:)#(83 1 #first:)#(83 1 #first:)#(83 1 #first:)#(84 1 #messagePragma:)#(84 1 #messagePragma:)#(84 1 #messagePragma:))! !!SqueakParser methodsFor: 'generated-tables' stamp: 'ms 4/7/2007 03:32'!transitionTable	^#(#(3 17 22 21 23 25 25 29 41 33 42 37 82)#(3 41 1 45 2 49 4 53 5 57 8 61 9 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 105 40 109 44 113 46 117 48 121 49 125 50 129 51 133 52 137 53 141 54 145 55 149 56 153 57 157 58 161 59 165 69 134 80)#(3 17 22 21 23 25 25 29 41 169 82)#(2 538 1 2 4 5 6 8 9 10 15 16 17 18 19 20 21 22 30 80)#(3 97 22 173 40 177 81)#(3 97 22 181 40 185 81)#(3 550 1 550 2 550 4 550 5 550 6 550 8 550 9 550 10 550 15 550 16 550 17 550 18 550 19 550 20 550 21 550 22 189 23 550 30 550 80)#(2 0 80)#(3 41 1 45 2 49 4 53 5 193 6 57 8 61 9 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 105 40 109 44 113 46 117 48 121 49 125 50 129 51 133 52 137 53 141 54 197 55 201 56 153 57 157 58 161 59 205 65 165 69 134 80)#(3 41 1 45 2 49 4 53 5 57 8 61 9 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 134 33 209 36 105 40 109 44 113 46 213 47 117 48 121 49 125 50 129 51 133 52 137 53 141 54 145 55 217 56 153 57 157 58 161 59 165 69)#(3 41 1 45 2 53 5 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 105 40 221 46 117 48 121 49 125 50 133 52 137 53 141 54 153 57 157 58 161 59 165 69)#(3 41 1 45 2 53 5 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 105 40 225 46 117 48 121 49 125 50 133 52 137 53 141 54 153 57 157 58 161 59 165 69)#(3 41 1 45 2 49 4 53 5 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 134 34 105 40 109 44 113 46 117 48 121 49 125 50 229 51 133 52 137 53 141 54 153 57 157 58 161 59 165 69)#(2 230 1 2 4 5 6 10 15 16 17 18 19 20 21 22 30 33 80)#(3 46 9 46 22 233 43 46 81)#(2 154 1 2 7 10 15 16 17 18 19 20 21 22 23 24 25 27 30 31 33 34 35 37 38 80 81)#(2 158 1 2 7 10 15 16 17 18 19 20 21 22 23 24 25 27 30 31 33 34 35 37 38 80 81)#(2 162 1 2 7 10 15 16 17 18 19 20 21 22 23 24 25 27 30 31 33 34 35 37 38 80 81)#(3 237 1 241 2 245 21 249 22 253 23 257 24 261 25 265 27)#(2 214 1 2 7 10 15 16 17 18 19 20 21 22 23 24 25 27 30 31 33 34 35 37 38 80 81)#(2 166 1 2 7 10 15 16 17 18 19 20 21 22 23 24 25 27 30 31 33 34 35 37 38 80 81)#(2 170 1 2 7 10 15 16 17 18 19 20 21 22 23 24 25 27 30 31 33 34 35 37 38 80 81)#(2 178 1 2 7 10 15 16 17 18 19 20 21 22 23 24 25 27 30 31 33 34 35 37 38 80 81)#(2 10 1 2 4 5 6 7 8 9 10 15 16 17 18 19 20 21 22 23 25 26 30 31 33 34 35 36 37 80 81)#(2 174 1 2 7 10 15 16 17 18 19 20 21 22 23 24 25 27 30 31 33 34 35 37 38 80 81)#(3 422 22 422 23 422 25 269 26 422 31 422 33 422 34 422 35 422 80)#(3 273 31 62 33 62 34 277 45 62 80)#(2 54 31 33 34 80)#(2 414 22 23 25 31 33 34 35 37 80)#(2 70 31 33 34 35 80)#(3 74 31 74 33 74 34 74 35 281 37 74 80)#(2 242 33 80)#(2 410 22 23 25 31 33 34 35 37 80)#(2 418 22 23 25 31 33 34 35 37 80)#(2 122 31 33 34 35 37 80)#(3 41 1 45 2 49 4 53 5 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 134 33 105 40 109 44 113 46 117 48 121 49 125 50 285 51 133 52 137 53 141 54 153 57 157 58 161 59 165 69 134 80)#(2 0 80)#(2 218 31 33 34 35 37 80)#(3 289 23 293 25 222 31 222 33 222 34 222 35 222 37 297 61 301 62 222 80)#(3 305 22 289 23 293 25 226 31 226 33 226 34 226 35 226 37 309 60 313 61 317 62 226 80)#(3 305 22 289 23 293 25 78 31 78 33 78 34 78 35 321 60 325 61 329 62 78 80)#(2 0 80)#(2 14 1 2 4 5 6 8 9 10 15 16 17 18 19 20 21 22 23 30 80)#(2 18 1 2 4 5 6 8 9 10 15 16 17 18 19 20 21 22 23 30 80)#(2 542 1 2 4 5 6 8 9 10 15 16 17 18 19 20 21 22 30 80)#(2 546 1 2 4 5 6 8 9 10 15 16 17 18 19 20 21 22 30 80)#(3 97 22 333 40 337 81)#(3 341 3 345 11 349 14 305 22 353 23 357 25 361 60 365 62 369 70 373 71 377 72 381 73 385 74 389 76 393 81 397 84)#(3 41 1 45 2 49 4 53 5 193 6 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 105 40 109 44 113 46 117 48 121 49 125 50 285 51 133 52 137 53 141 54 153 57 157 58 161 59 401 65 165 69 134 80)#(2 30 80)#(3 41 1 45 2 49 4 53 5 405 6 57 8 61 9 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 105 40 109 44 113 46 117 48 121 49 125 50 129 51 133 52 137 53 141 54 409 55 413 56 153 57 157 58 161 59 165 69 134 80)#(3 97 22 417 40 421 81)#(3 425 8 429 9 433 33 437 36)#(2 441 33)#(2 445 35)#(3 449 31 62 33 62 34 453 45 62 80)#(2 457 34)#(3 461 9 97 22 465 40 469 81)#(3 354 19 354 33 473 66)#(3 362 1 362 2 362 10 362 15 362 16 362 17 362 18 362 19 362 20 362 21 362 22 362 23 362 24 362 25 362 27 362 30 362 35 362 38 477 67)#(2 182 1 2 7 10 15 16 17 18 19 20 21 22 23 24 25 27 30 31 33 34 35 37 38 80 81)#(2 186 1 2 7 10 15 16 17 18 19 20 21 22 23 24 25 27 30 31 33 34 35 37 38 80 81)#(2 194 1 2 7 10 15 16 17 18 19 20 21 22 23 24 25 27 30 31 33 34 35 37 38 80 81)#(2 198 1 2 7 10 15 16 17 18 19 20 21 22 23 24 25 27 30 31 33 34 35 37 38 80 81)#(2 190 1 2 7 10 15 16 17 18 19 20 21 22 23 24 25 27 30 31 33 34 35 37 38 80 81)#(2 202 1 2 7 10 15 16 17 18 19 20 21 22 23 24 25 27 30 31 33 34 35 37 38 80 81)#(3 41 1 45 2 53 5 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 105 40 481 46 117 48 121 49 125 50 133 52 137 53 141 54 153 57 157 58 161 59 165 69 485 81)#(3 41 1 45 2 489 4 53 5 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 66 33 66 34 105 40 493 46 117 48 121 49 125 50 133 52 137 53 141 54 153 57 157 58 161 59 165 69 66 80)#(2 138 33 34 80)#(3 305 22 289 23 293 25 497 60 501 61 505 62 509 81 513 83)#(2 246 33 80)#(3 41 1 45 2 53 5 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 517 40 117 48 133 52 137 53 521 58 525 59 529 63 533 69 537 81)#(3 41 1 45 2 53 5 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 517 40 117 48 133 52 137 53 541 59 545 64 549 69 553 81)#(2 262 23 25 31 33 34 35 37 80)#(3 557 23 250 31 250 33 250 34 250 35 250 37 250 80)#(2 282 7 22 23 25 31 33 34 35 37 80 81)#(2 274 22 23 25 31 33 34 35 37 80)#(2 266 23 25 31 33 34 35 37 80)#(3 557 23 254 31 254 33 254 34 254 35 254 37 254 80)#(2 278 22 23 25 31 33 34 35 37 80)#(2 270 23 25 31 33 34 35 37 80)#(3 557 23 258 31 258 33 258 34 258 35 258 37 258 80)#(2 22 1 2 4 5 6 8 9 10 15 16 17 18 19 20 21 22 23 30 80)#(2 26 1 2 4 5 6 8 9 10 15 16 17 18 19 20 21 22 23 30 80)#(3 561 19 565 21 569 81)#(2 510 22)#(2 506 22)#(3 41 1 45 2 53 5 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 573 40 577 48 581 52 585 53 521 58 525 59 529 63 533 69 589 75 593 81)#(3 41 1 53 5 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 597 40 601 48 605 52 609 53 613 75 617 81)#(2 462 7 81)#(2 621 23)#(2 566 7 81)#(2 570 7 81)#(2 574 7 81)#(2 454 7 81)#(2 458 7 81)#(3 625 22 629 77)#(2 338 1 2 4 5 6 8 9 10 15 16 17 18 19 20 21 22 30 80)#(3 633 7 637 81)#(3 41 1 45 2 49 4 53 5 405 6 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 105 40 109 44 113 46 117 48 121 49 125 50 641 51 133 52 137 53 141 54 153 57 157 58 161 59 165 69 134 80)#(3 341 3 345 11 349 14 305 22 353 23 357 25 361 60 365 62 369 70 373 71 377 72 381 73 385 74 389 76 645 81 649 84)#(3 41 1 45 2 49 4 53 5 193 6 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 105 40 109 44 113 46 117 48 121 49 125 50 285 51 133 52 137 53 141 54 153 57 157 58 161 59 653 65 165 69 134 80)#(2 34 80)#(2 82 8 9 33 36)#(2 86 8 9 33 36)#(3 46 9 46 22 657 43)#(3 41 1 45 2 49 4 53 5 57 8 61 9 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 134 33 105 40 109 44 113 46 117 48 121 49 125 50 129 51 133 52 137 53 141 54 145 55 661 56 153 57 157 58 161 59 165 69)#(2 106 7 22 23 25 31 33 34 35 37 80 81)#(3 97 22 665 40 669 81)#(2 102 7 22 23 25 31 33 34 35 37 80 81)#(2 406 22 23 25 31 33 34 35 37 80)#(2 66 33 34 80)#(2 146 33 34 80)#(2 150 7 22 23 25 31 33 34 35 37 80 81)#(2 234 1 2 4 5 6 10 15 16 17 18 19 20 21 22 30 33 80)#(2 50 9 22 81)#(2 238 1 2 4 5 6 10 15 16 17 18 19 20 21 22 30 33 80)#(3 673 19 677 33)#(3 681 1 685 2 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 689 22 693 23 697 24 701 25 705 27 101 30 709 35 713 38 717 53 721 68)#(2 114 31 33 34 35 80)#(2 118 31 33 34 35 80)#(3 41 1 45 2 53 5 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 105 40 725 46 117 48 121 49 125 50 133 52 137 53 141 54 153 57 157 58 161 59 165 69)#(2 58 31 33 34 80)#(2 554 31 33 34 35 37 80)#(2 558 31 33 34 35 37 80)#(3 557 23 562 31 562 33 562 34 562 35 562 37 562 80)#(2 130 31 33 34 35 37 80)#(2 126 31 33 34 35 37 80)#(2 422 22 23 25 31 33 34 35 37 80)#(3 310 23 293 25 310 31 310 33 310 34 310 35 310 37 297 61 310 80)#(3 305 22 314 23 293 25 314 31 314 33 314 34 314 35 314 37 309 60 313 61 314 80)#(2 294 23 31 33 34 35 37 80)#(3 305 22 318 23 293 25 318 31 318 33 318 34 318 35 318 37 321 60 325 61 318 80)#(2 298 23 31 33 34 35 37 80)#(3 305 22 322 23 322 25 322 31 322 33 322 34 322 35 322 37 309 60 322 80)#(2 286 23 25 31 33 34 35 37 80)#(3 305 22 326 23 326 25 326 31 326 33 326 34 326 35 326 37 321 60 326 80)#(2 290 23 25 31 33 34 35 37 80)#(3 41 1 45 2 53 5 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 517 40 117 48 133 52 137 53 521 58 525 59 729 63 533 69 733 81)#(2 438 7 81)#(3 434 7 737 13 434 81)#(2 442 7 81)#(3 502 7 422 22 422 23 422 25 502 81)#(3 494 7 414 22 414 23 414 25 494 81)#(3 490 7 410 22 410 23 410 25 490 81)#(3 498 7 418 22 418 23 418 25 498 81)#(2 466 7 81)#(3 470 7 298 23 470 81)#(2 502 7 81)#(2 494 7 81)#(2 490 7 81)#(2 498 7 81)#(2 482 7 81)#(2 486 7 81)#(3 41 1 45 2 53 5 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 573 40 577 48 581 52 585 53 521 58 525 59 729 63 533 69 741 75 745 81)#(3 749 12 514 19 514 21 514 22 514 35)#(3 753 19 757 21 761 78)#(2 330 1 2 4 5 6 8 9 10 15 16 17 18 19 20 21 22 30 80)#(2 334 1 2 4 5 6 8 9 10 15 16 17 18 19 20 21 22 30 80)#(2 42 80)#(2 350 1 2 4 5 6 8 9 10 15 16 17 18 19 20 21 22 30 80)#(3 765 7 769 81)#(3 41 1 45 2 49 4 53 5 405 6 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 105 40 109 44 113 46 117 48 121 49 125 50 773 51 133 52 137 53 141 54 153 57 157 58 161 59 165 69 134 80)#(3 777 9 97 22 465 40)#(2 781 33)#(2 90 8 9 33 36)#(2 94 8 9 33 36)#(2 358 19 33)#(2 206 1 2 7 10 15 16 17 18 19 20 21 22 23 24 25 27 30 31 33 34 35 37 38 80 81)#(3 354 19 354 33 785 66)#(3 362 1 362 2 362 10 362 15 362 16 362 17 362 18 362 19 362 20 362 21 362 22 362 23 362 24 362 25 362 27 362 30 362 35 362 38 789 67)#(2 374 1 2 10 15 16 17 18 19 20 21 22 23 24 25 27 30 35 38)#(2 382 1 2 10 15 16 17 18 19 20 21 22 23 24 25 27 30 35 38)#(2 386 1 2 10 15 16 17 18 19 20 21 22 23 24 25 27 30 35 38)#(2 378 1 2 10 15 16 17 18 19 20 21 22 23 24 25 27 30 35 38)#(2 390 1 2 10 15 16 17 18 19 20 21 22 23 24 25 27 30 35 38)#(2 210 1 2 7 10 15 16 17 18 19 20 21 22 23 24 25 27 30 31 33 34 35 37 38 80 81)#(2 402 1 2 10 15 16 17 18 19 20 21 22 23 24 25 27 30 35 38)#(2 370 1 2 10 15 16 17 18 19 20 21 22 23 24 25 27 30 35 38)#(2 366 1 2 10 15 16 17 18 19 20 21 22 23 24 25 27 30 35 38)#(3 449 31 62 33 62 34 793 45 62 80)#(2 302 23 31 33 34 35 37 80)#(2 306 23 31 33 34 35 37 80)#(3 797 21 801 81)#(2 474 7 81)#(3 478 7 306 23 478 81)#(2 518 19 21 22 35)#(2 526 2)#(2 522 2)#(2 805 2)#(2 342 1 2 4 5 6 8 9 10 15 16 17 18 19 20 21 22 30 80)#(2 346 1 2 4 5 6 8 9 10 15 16 17 18 19 20 21 22 30 80)#(2 38 80)#(3 41 1 45 2 49 4 53 5 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 97 22 101 30 134 33 105 40 109 44 113 46 117 48 121 49 125 50 809 51 133 52 137 53 141 54 153 57 157 58 161 59 165 69)#(2 98 7 22 23 25 31 33 34 35 37 80 81)#(3 673 19 813 33)#(3 681 1 685 2 65 10 69 15 73 16 77 17 81 18 85 19 89 20 93 21 689 22 693 23 697 24 701 25 705 27 101 30 817 35 713 38 717 53 721 68)#(2 142 33 34 80)#(2 446 7 81)#(2 450 7 81)#(3 625 22 821 77 825 79)#(2 829 33)#(2 398 1 2 10 15 16 17 18 19 20 21 22 23 24 25 27 30 35 38)#(2 394 1 2 10 15 16 17 18 19 20 21 22 23 24 25 27 30 35 38)#(2 530 22 35)#(3 625 22 833 35 837 77)#(2 110 7 22 23 25 31 33 34 35 37 80 81)#(3 426 7 841 13 426 81)#(2 534 22 35)#(2 845 21)#(2 430 7 81))! !!SqueakParser commentStamp: 'ajh 3/24/2003 18:24' prior: 0!I parse Smalltalk text into a Refactory abstract syntax tree, whose root is RBMethodNode or RBDoItNode.  Methods under 'generated-*' categories were automatically generated using SmaCC.!!SqueakParser class methodsFor: 'initialize' stamp: 'ms 10/10/2006 23:28'!initialize	"self initialize"		| scanner |	super initialize.	scanner := SqueakScanner new.	DicTokens := Dictionary new.	DicTokens at: scanner colonId put: 'colon'.	DicTokens at: scanner binarySymbolId put: 'binary symbol'.	DicTokens at: scanner nameId put: 'variable'.	DicTokens at: scanner negativeNumberId put: 'negative number'.	DicTokens at: scanner periodId put: 'period'.	DicTokens at: scanner rightBoxBracketsId put: 'right box bracket'.	DicTokens at: scanner rightCurlyBracketsId put: 'right curly brackets'.	DicTokens at: scanner rightParenthesesId put: 'right parentheses'.	DicTokens at: scanner stringId put: 'string'.	DicTokens at: scanner multikeywordId put: 'multi keyword'.	DicTokens at: scanner keywordId put: 'keyword'.	DicTokens at: scanner characterId put: 'character'.	DicTokens at: scanner assignmentId put: 'assignment'! !!SqueakParser class methodsFor: 'parsing' stamp: 'ajh 2/27/2003 16:40'!parseDoIt: stringOrStream	| sequence |	sequence _ self		parseStream: stringOrStream readStream		startingAt: self startingStateForSequence.	^ (RBDoItNode body: sequence)		source: stringOrStream contents! !!SqueakParser class methodsFor: 'parsing' stamp: 'ms 12/2/2006 22:27'!parseMethod: stringOrStream 		^ (self parseStream: stringOrStream readStream startingAt: self startingStateForMethod)		source: stringOrStream contents! !!SqueakParser class methodsFor: 'parsing' stamp: 'ms 11/19/2006 17:16'!parseMethodPattern: stringOrStream 	^ SqueakMethodPatternParser parseMethod: stringOrStream! !!SqueakParser class methodsFor: 'generated-comments' stamp: 'ms 4/7/2007 03:32'!parserDefinitionComment	"%id <name> <number> <negativeNumber> <binarySymbol> <period> <colon> <rightParentheses> <rightCurlyBrackets> <rightBoxBrackets> <string> <keyword> <multikeyword> <assignment> <character>;%start Sequence MethodPattern;Method:	MethodPattern Sequence						{#method:}|	MethodPattern Pragmas Sequence			{#methodPragma:}|	MethodPattern Pragmas Temporaries Pragmas Statements {#methodPragmaTempsPragma:}|	MethodPattern Temporaries Pragmas Statements {#methodTempsPragma:};MethodPattern:	<name>										{#unaryMessage:}|	<binarySymbol> Variable						{#messagePart:}|	<binarySymbol> error						{#argumentNameMissing:}|	KeywordMethodPattern						{#first:};KeywordMethodPattern:	<keyword> Variable							{#messagePart:}|	<keyword> error								{#argumentNameMissing:}|	KeywordMethodPattern <keyword> Variable	{#addMessagePart:}|	KeywordMethodPattern <keyword> error		{#argumentNameMissing:};Pragmas:	""<"" PragmaMessage "">""							{#pragma:}|	""<"" PragmaMessage error							{#pragmaEndMissing:}|	""<"" error											{#pragmaMissing:}|	Pragmas ""<"" PragmaMessage "">""					{#pragmas:}|	Pragmas ""<"" PragmaMessage error				{#pragmaEndMissing:}|	Pragmas ""<"" error								{#pragmaMissing:};Sequence:	Statements									{#sequence:}|	Temporaries Statements						{#sequenceWithTemps:};Temporaries:	""||""											{#arrayAddToken:}|	""|"" TemporaryVariables ""|""					{#secondAddToken:}| 	""|"" TemporaryVariables error					{#verticalBarMissing:};TemporaryVariables:												{#array}|	TemporaryVariables Variable				{#add:};Statements:												{#array}|	StatementList <period>?						{#first:}|	StatementList <period> ""^"" Expression <period>?	{#returnAdd:}|	""^"" Expression <period>?						{#return:};StatementList:	Expression									{#firstIn:}|	StatementList <period> Expression				{#add3:};Block:	""["" BlockArgs ""|"" Sequence <rightBoxBrackets>	{#blockWithArgs:}|	""["" Sequence <rightBoxBrackets>				{#blockNoArgs:}|	""["" BlockArgs <rightBoxBrackets>				{#blockArgs:}|	""["" BlockArgs ""||"" TemporaryVariables ""|"" Statements <rightBoxBrackets> {#blockWithTemps:};BlockArgs:	<colon> Variable									{#secondIn:}|	<colon>	error									{#argumentNameMissing:}|	BlockArgs <colon> Variable						{#add3:}|	BlockArgs <colon> error							{#argumentNameMissing:};Expression:	Assignment									{#first:}|	Cascade										{#first:}|	Primary									{#first:};Primary:	""("" Expression <rightParentheses>				{#secondWithParenthesis:}|	Array										{#first:}|	Block										{#first:}|	Literal										{#first:}|	Variable									{#first:};Assignment:	Variable <assignment> Expression				{#assignment:}|	Variable <assignment> error					{#expressionMissing:};Cascade:	MessageSend								{#first:}|	Cascade <semicolon> Message					{#cascade:}|	Cascade <semicolon> error 					{#cascadeMMissing:};MessageSend:	KeywordMessageSend						{#first:}|	BinaryMessageSend							{#first:}|	UnaryMessageSend							{#first:};Message:	UnaryMessage								{#first:}|	BinaryMessage								{#first:}|	KeywordMessage							{#first:};KeywordMessageSend:	BinaryMessageSend KeywordMessage			{#messageSend:}|	UnaryMessageSend KeywordMessage			{#messageSend:}|	Primary KeywordMessage					{#messageSend:};KeywordMessage:	<keyword> KeywordArgument				{#messagePart:}|	<keyword> error 							{#argumentMissing:}|	KeywordMessage <keyword> KeywordArgument {#addMessagePart:}|	KeywordMessage <keyword> error 			{#argumentMissing:};KeywordArgument:	BinaryMessageSend							{#first:}|	UnaryMessageSend							{#first:}|	Primary									{#first:};BinaryMessageSend:	BinaryMessageSend BinaryMessage			{#messageSend:}|	UnaryMessageSend BinaryMessage			{#messageSend:}|	Primary BinaryMessage						{#messageSend:};BinaryMessage :	<binarySymbol> BinaryArgument				{#messagePart:}|	<binarySymbol> error 						{#argumentMissing:}; BinaryArgument:	UnaryMessageSend							{#first:}|	Primary									{#first:};UnaryMessageSend :	UnaryMessageSend UnaryMessage			{#messageSend:}|	Primary UnaryMessage						{#messageSend:};UnaryMessage :	<name>										{#unaryMessage:};Array:	""{"" Statements <rightCurlyBrackets>			{#array:};Variable:	<name>										{#variable:};Literal:	""true""										{#litTrue:}|	""false""										{#litFalse:}|	""nil""										{#litNil:}|	<number>									{#litNumber:}|	<negativeNumber>							{#litNumber:} |	<character>									{#litChar:}|	<string>										{#litString:}|	""#"" <string>									{#litStringSymbol:}|	""#"" <name>									{#litSymbol:}|	""#"" <binarySymbol>							{#litSymbol:}|	""#"" <keyword>								{#litSymbol:}|	""#"" <multikeyword>							{#litSymbol:}|	""#"" <alternateKeyword>						{#litSymbol:}|	""#"" ""["" ByteArray <rightBoxBrackets>			{#litArray:}|	""#"" ""("" LiteralArray <rightParentheses>		{#litArray:}|	""#:""											{#litString:};ByteArray:												{#byteStream}|	ByteArray <number>							{#byteStreamPut:};LiteralArray:												{#stream}|	LiteralArray ArrayLiteral					{#streamPut:};ArrayLiteral:	Literal										{#value:}|	<name>										{#valueSymbol:}|	<binarySymbol>								{#valueSymbol:}|	<keyword>									{#valueSymbol:}|	<multikeyword>								{#valueSymbol:}|	<alternateKeyword>							{#valueSymbol:}|	""("" LiteralArray <rightParentheses>			{#contents2:}|	""["" ByteArray <rightBoxBrackets>				{#contents2:}|	<anyChar>									{#valueSymbol:};PragmaMessage:	Apicall										{#messagePragma:}| 	Primitive 									{#messagePragma:} |	MessagePragma 								{#messagePragma:};MessagePragma:	KeyWordMessagePragma						{#pragmaMessage:}|	BinaryMessagePragma						{#pragmaMessage:}|	UnaryMessage 								{#pragmaUnaryMessage:};									BinaryMessagePragma:	<binarySymbol> PrimaryPragma				{#messagePart:}|	<binarySymbol> error 						{#argumentMissing:};										KeyWordMessagePragma:	<keyword> PrimaryPragma					{#messagePart:}|	<keyword> error 							{#literalMissing:}|	KeywordMessage <keyword> PrimaryPragma	{#addMessagePart:}|	KeywordMessage <keyword> error 			{#literalMissing:};PrimaryPragma:	Array										{#first:}|	Block										{#first:}|	Literal										{#first:}|	Variable									{#first:};Apicall:	TypeCall ExternalType IndexName ""("" ParameterApicall <rightParentheses>	{#externalCall:}|	TypeCall ExternalType IndexName ""("" ParameterApicall <rightParentheses> ""module:"" <string>	{#externalModuleCall:};IndexName:	<string>										{#externalFunction:}|	<number>									{#externalIndex:};TypeCall:	""apicall:""									{#callConvention:}|	""cdecl:""										{#callConvention:};ParameterApicall:	ExternalType 								{#parameterExtCall:}|	ParameterApicall ExternalType 				{#parametersExtCall:};ExternalType:	<name>										{#externalType:}	|	<name> ""*""									{#externalTypePointer:};Primitive:	""primitive:"" <string>							{#primitiveString:}|	""primitive:"" <number>						{#primitiveNumber:}|	""primitive:"" error 							{#primitiveArgMissing:}|	""primitive:"" <string> ""module:"" <string>		{#primitiveModule:}|	""primitive:"" <string> ""module:"" error 			{#moduleArgMissing:};"! !!SqueakParser class methodsFor: 'generated-accessing' stamp: 'ms 4/7/2007 03:32'!scannerClass	^SqueakScanner! !!SqueakParser class methodsFor: 'generated-starting states' stamp: 'ms 4/7/2007 03:32'!startingStateForMethod	^1! !!SqueakParser class methodsFor: 'generated-starting states' stamp: 'ms 4/7/2007 03:32'!startingStateForMethodPattern	^3! !!SqueakParser class methodsFor: 'generated-starting states' stamp: 'ms 4/7/2007 03:32'!startingStateForSequence	^2! !!SqueakParser class methodsFor: 'tokens' stamp: 'ms 10/10/2006 22:04'!tokenDescription: id		^DicTokens at: id! !!SqueakParser class methodsFor: 'tokens' stamp: 'ms 10/10/2006 22:24'!tokensId		^DicTokens keys! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 11/17/2006 16:54'!assertCommentOn: rbNode	rbNode peekInsideComment 		do: [:each | self assert: each value = '"0 remove"'].	rbNode peekBeforeComment do: 			[:each | 			self assert: each value ~= '"0 remove"'.			self assert: (each value indexOf: $b) > 0].	rbNode peekAfterComment do: 			[:each | 			self assert: each value ~= '"0 remove"'.			self assert: (each value indexOf: $a) > 0]! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 5/28/2007 11:48'!testCommentAtEnd	| rbNode |	rbNode := SqueakParser parseMethod: 'foo "foo"'.	rbNode addComment.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 1.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 0.	self assert: rbNode peekAfterComment size = 1.! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 9/20/2006 20:19'!testCommentOnAssignment	| rbNode |	rbNode := rbMethod body statements third.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 2.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 1.	self assert: rbNode peekAfterComment size = 1.	self assertCommentOn: rbNode! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 9/20/2006 20:19'!testCommentOnBlock	| rbNode |	rbNode := rbMethod body statements first.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 2.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 1.	self assert: rbNode peekAfterComment size = 1.	self assertCommentOn: rbNode.	rbNode := rbMethod body statements second arguments first.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 1.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 1.	self assert: rbNode peekAfterComment size = 0.	self assertCommentOn: rbNode.	rbNode := rbMethod body statements second.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 1.	self assert: rbNode peekInsideComment size = 1.	self assert: rbNode peekBeforeComment size = 0.	self assert: rbNode peekAfterComment size = 0.	self assertCommentOn: rbNode! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 5/28/2007 14:30'!testCommentOnCascade	| rbNode |	rbNode := rbMethod body statements seventh.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 2.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 1.	self assert: rbNode peekAfterComment size = 1.	self assertCommentOn: rbNode.	rbNode := rbMethod body statements seventh messages second arguments first.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 1.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 1.	self assert: rbNode peekAfterComment size = 0.	self assertCommentOn: rbNode.	rbNode := rbMethod body statements seventh messages second arguments first 				body statements 				first.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 2.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 1.	self assert: rbNode peekAfterComment size = 1.	self assertCommentOn: rbNode! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 9/20/2006 20:19'!testCommentOnLiteral	| rbNode |	rbNode := rbMethod body statements fourth.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 2.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 1.	self assert: rbNode peekAfterComment size = 1.	self assertCommentOn: rbNode.	rbNode := rbMethod body statements sixth.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 2.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 1.	self assert: rbNode peekAfterComment size = 1.	self assertCommentOn: rbNode! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 9/20/2006 20:19'!testCommentOnMessage	| rbNode |	rbNode := rbMethod body statements eighth.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 2.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 1.	self assert: rbNode peekAfterComment size = 1.	self assertCommentOn: rbNode! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 9/20/2006 20:19'!testCommentOnMethod	self assert: rbMethod comments notEmpty.	self assert: rbMethod comments size = 3.	self assert: rbMethod peekInsideComment size = 2.	self assert: rbMethod peekBeforeComment size = 0.	self assert: rbMethod peekAfterComment size = 1.	self assertCommentOn: rbMethod! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 9/20/2006 20:19'!testCommentOnMethodArguments	| rbNode |	rbNode := rbMethod arguments first.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 2.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 1.	self assert: rbNode peekAfterComment size = 1.	self assertCommentOn: rbNode.	rbNode := rbMethod arguments second.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 1.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 0.	self assert: rbNode peekAfterComment size = 1.	self assertCommentOn: rbNode! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 9/20/2006 20:19'!testCommentOnMethodSequence	| rbNode |	rbNode := rbMethod body.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 1.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 1.	self assert: rbNode peekAfterComment size = 0.	self assertCommentOn: rbNode.	rbNode := rbMethod body statements second body.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 1.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 1.	self assert: rbNode peekAfterComment size = 0.	self assertCommentOn: rbNode.	rbNode := rbMethod body statements second body temporaries first.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 1.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 0.	self assert: rbNode peekAfterComment size = 1.	self assertCommentOn: rbNode! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 9/20/2006 20:19'!testCommentOnPragmas	| rbNode |	rbNode := rbMethod pragmas first.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 4.	self assert: rbNode peekInsideComment size = 2.	self assert: rbNode peekBeforeComment size = 1.	self assert: rbNode peekAfterComment size = 1.	self assertCommentOn: rbNode! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 9/20/2006 20:19'!testCommentOnReturn	| rbNode |	rbNode := rbMethod body statements ninth.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 2.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 1.	self assert: rbNode peekAfterComment size = 1.	self assertCommentOn: rbNode! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 9/20/2006 20:19'!testCommentOnSequence	| rbNode |	rbNode := rbMethod body statements fifth body.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 2.	self assert: rbNode peekInsideComment size = 1.	self assert: rbNode peekBeforeComment size = 1.	self assert: rbNode peekAfterComment size = 0.	self assertCommentOn: rbNode.	rbNode := rbMethod body statements fifth.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 1.	self assert: rbNode peekInsideComment size = 1.	self assert: rbNode peekBeforeComment size = 0.	self assert: rbNode peekAfterComment size = 0.	self assertCommentOn: rbNode! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 9/20/2006 20:19'!testCommentOnTempStatement	| rbNode |	rbNode := rbMethod body statements fifth body temporaries first.	self assert: rbNode comments notEmpty.	self assert: rbNode comments size = 2.	self assert: rbNode peekInsideComment size = 0.	self assert: rbNode peekBeforeComment size = 1.	self assert: rbNode peekAfterComment size = 1.	self assertCommentOn: rbNode! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 7/13/2006 15:33'!testEmptyStatement	"self debug: #testEmptyStatement"	self shouldnt: [SqueakParser parseDoIt: 'Object new..' ] raise: Error.	self shouldnt: [SqueakParser parseDoIt: '..Object new' ] raise: Error.	self shouldnt: [SqueakParser parseDoIt: 'Object new..Object new' ] raise: Error.		self assert: ((SqueakParser parseDoIt: 'Object new..') class = RBDoItNode).	self assert: ((SqueakParser parseDoIt: '..Object new') class = RBDoItNode).	self assert: ((SqueakParser parseDoIt: 'Object new..Object new') class = RBDoItNode)! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 7/15/2006 10:51'!testMethodPattern	"self debug: #testEmptyStatement"	self shouldnt: [SqueakParser parseMethodPattern: (self class>>#keyword:) getSource ] raise: Error.! !!SqueakParserTest methodsFor: 'util' stamp: 'ms 7/15/2006 10:50'!keyword: anObject	"For test"	^anObject copy! !!SqueakParserTest methodsFor: 'util' stamp: 'ms 5/28/2007 14:06'!methodDescribeWithAllComment: "36b" anObject "34a" And: a "35a"	"This is a method to see where are comment	 Comment mark 0 remove tell you that nobody can contain it except the node 	 who contain the comment(e.g. between firstToken and lastToken	"		"21b"	<hello: "0 remove" 'you' "0 remove" > "22a"		"2b"	| ok |		"3b"	[		"4b"	^anObject copy "5a"		]. "6a"	[ 	"7b" 	 :each 	 "8b"	 || temp | "30a"		 "0 remove"	].		"9b"	(ok := 3). "10a"		"11b"	#( 3 4 5). "12a"		[	"13b"	| "14b" 	 temp "15a"	 "0 remove"	|		"16b"	self "17a" 		"0 remove"	].	"19b"	nil. "20a"		"23b"	true not; "37b" whileTrue: [				"31b"		-6 "32a".				^self				]. "25a"		"26b"	3 + 3. "27a"		"28b"	^Object new. "29a"		"0 remove"	"0 remove"				! !!SqueakParserTest methodsFor: 'runing' stamp: 'ms 9/19/2006 23:18'!setUp		rbMethod := SqueakParser parseMethod: (SqueakParserTest>>#methodDescribeWithAllComment:And:) getSource.	rbMethod addComment	! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 4/7/2007 03:32'!assignmentId	^26! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 4/7/2007 03:32'!binarySymbolId	^25! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 4/7/2007 03:32'!characterId	^30! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 4/7/2007 03:32'!colonId	^36! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 4/7/2007 03:32'!emptySymbolTokenId	^80! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 4/7/2007 03:32'!errorTokenId	^81! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 4/7/2007 03:32'!keywordId	^23! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 4/7/2007 03:32'!multikeywordId	^24! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 4/7/2007 03:32'!nameId	^22! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 4/7/2007 03:32'!negativeNumberId	^20! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 4/7/2007 03:32'!numberId	^19! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 4/7/2007 03:32'!periodId	^31! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 4/7/2007 03:32'!rightBoxBracketsId	^33! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 4/7/2007 03:32'!rightCurlyBracketsId	^34! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 4/7/2007 03:32'!rightParenthesesId	^35! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 4/7/2007 03:32'!stringId	^21! !!SqueakScanner methodsFor: 'token handling' stamp: 'ms 3/31/2007 21:31'!binarySymbol	"Negative number takes precedence over binary symbol, so for example, '0@-1' means '0 @ -1', rather than '0 @- 1', which is how the scanner reads it. If the symbol is just $- and the next char is a digit, then the negative number token takes precedence and SqueakParser>>actionForCurrentToken converts it to a binary symbol. If there is space between $- and the digit, then it reaches here and we convert it to a negativeNumber token (and let SqueakParser>>actionForCurrentToken deal with it)."	| string negPos prevReturnMatchBlock |	string _ outputStream contents.	string last = $- ifFalse: [		matchActions _ {self binarySymbolId}.		^ self createTokenFor: outputStream contents].	stream peek ifNil: [		matchActions _ {self binarySymbolId}.		^ self createTokenFor: outputStream contents].	stream peek isDigit ifTrue: [		"Back up one and let scanner find negativeNumber token"		outputStream skip: -1.		stream skip: -1.		matchActions _ {self binarySymbolId}.		^ self createTokenFor: outputStream contents].	(stream peek = $  and: [string size = 1]) ifFalse: [		matchActions _ {self binarySymbolId}.		^ self createTokenFor: outputStream contents].	"Allow space between negative sign and number (wierd, but allowed in Smalltalk ANSI standard)"	negPos _ stream position.	[stream peek = $ ] whileTrue: [stream next].	stream peek isDigit ifFalse: [		stream position: negPos.		matchActions _ {self binarySymbolId}.		^ self createTokenFor: outputStream contents].	"scan number but catch return and convert it to a negative number"	prevReturnMatchBlock _ returnMatchBlock.	returnMatchBlock _ [:token | 		returnMatchBlock _ prevReturnMatchBlock.		token id first = self numberId ifFalse: [self error: 'unexpected token'].		token value: '-', token value			start: token start - 1			id: {self negativeNumberId}.		returnMatchBlock value: token].	self whitespace.  "eats whitespace and scans next token"! !!SqueakScanner methodsFor: 'token handling' stamp: 'ms 5/10/2007 20:07'!comment	| value |	value := outputStream contents.	comments add: {value. start}.	previousToken :=  SqueakToken 		value: value 		start: start 		id: #comment 		prevToken: previousToken.	self resetScanner.	stream atEnd ifFalse: [^self scanForToken]		ifTrue:[^self scannerError]! !!SqueakScanner methodsFor: 'token handling' stamp: 'ajh 7/16/2004 10:57'!variableAssignment	outputStream skip: -2.	stream skip: -2.	matchActions _ {self nameId}.	self createTokenFor: outputStream contents.! !!SqueakScanner methodsFor: 'token handling' stamp: 'ms 5/10/2007 20:07'!whitespace	| value  |	value := outputStream contents.	previousToken := (SqueakToken 		value: value 		start: start 		id: #whitespace 		prevToken: previousToken).	^super whitespace. "eats the whitespace"! !!SqueakScanner methodsFor: 'private' stamp: 'ajh 3/6/2003 00:16'!comments	^ comments! !!SqueakScanner methodsFor: 'private' stamp: 'ms 4/7/2007 03:31'!createTokenFor: string		| token |	token := SqueakToken 				value: string				start: start + 1				id: matchActions				prevToken: previousToken.	previousToken := token.	outputStream reset.	matchActions := nil.	returnMatchBlock value: token! !!SqueakScanner methodsFor: 'private' stamp: 'ajh 3/6/2003 00:13'!initialize	super initialize.	comments _ OrderedCollection new.! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 4/7/2007 03:32'!scan1		[self step.	currentCharacter ~= $'] whileTrue.	currentCharacter = $' ifTrue: [^ self scan2].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 4/7/2007 03:32'!scan10	self step.	(currentCharacter between: $0 and: $9) 		ifTrue: 			[			[self recordMatch: #(20 ).			self step.			currentCharacter between: $0 and: $9] 					whileTrue.			^ self reportLastMatch].	currentCharacter = $- ifTrue: [^ self scan11].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 4/7/2007 03:32'!scan11	self step.	(currentCharacter between: $0 and: $9) 		ifTrue: 			[			[self recordMatch: #(20 ).			self step.			currentCharacter between: $0 and: $9] 					whileTrue.			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 4/7/2007 03:32'!scan2	self recordMatch: #(21 ).	self step.	currentCharacter = $' ifTrue: [^ self scan1].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 4/7/2007 03:32'!scan3	self step.	(currentCharacter between: $0 and: $9) 		ifTrue: 			[			[self recordMatch: #(19 ).			self step.			currentCharacter between: $0 and: $9] 					whileTrue.			currentCharacter = $e ifTrue: [^ self scan4].			currentCharacter = $s ifTrue: [^ self scan5].			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 4/7/2007 03:32'!scan4	self step.	(currentCharacter between: $0 and: $9) 		ifTrue: 			[			[self recordMatch: #(19 ).			self step.			currentCharacter between: $0 and: $9] 					whileTrue.			^ self reportLastMatch].	currentCharacter = $- ifTrue: [^ self scan5].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 4/7/2007 03:32'!scan5	self step.	(currentCharacter between: $0 and: $9) 		ifTrue: 			[			[self recordMatch: #(19 ).			self step.			currentCharacter between: $0 and: $9] 					whileTrue.			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 4/7/2007 03:32'!scan6	self step.	((currentCharacter between: $0 and: $9) 		or: [currentCharacter between: $A and: $Z]) 			ifTrue: 				[				[self recordMatch: #(19 ).				self step.				(currentCharacter between: $0 and: $9) 					or: [currentCharacter between: $A and: $Z]] 						whileTrue.				currentCharacter = $. 					ifTrue: 						[self step.						((currentCharacter between: $0 and: $9) 							or: [currentCharacter between: $A and: $Z]) 								ifTrue: 									[									[self recordMatch: #(19 ).									self step.									(currentCharacter between: $0 and: $9) 										or: [currentCharacter between: $A and: $Z]] 											whileTrue.									currentCharacter = $e ifTrue: [^ self scan4].									^ self reportLastMatch].						^ self reportLastMatch].				currentCharacter = $e ifTrue: [^ self scan4].				^ self reportLastMatch].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 4/7/2007 03:32'!scan7		[self step.	(currentCharacter between: $0 and: $9) or: 			[(currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]]] 			whileTrue.	currentCharacter = $: 		ifTrue: 			[self recordMatch: #(27 ).			self step.			((currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan7].			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 4/7/2007 03:32'!scan8	self recordMatch: #(23 ).	self step.	((currentCharacter between: $A and: $Z) 		or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan9].	currentCharacter = $= 		ifTrue: [^ self recordAndReportMatch: #variableAssignment].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 4/7/2007 03:32'!scan9		[self step.	(currentCharacter between: $0 and: $9) or: 			[(currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]]] 			whileTrue.	currentCharacter = $: 		ifTrue: 			[self recordMatch: #(24 ).			self step.			((currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan9].			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 4/7/2007 03:32'!scanForToken	self step.	(currentCharacter <= Character backspace or: 			[(currentCharacter between: (Character value: 14) and: (Character value: 31)) 				or: [currentCharacter = $` or: [currentCharacter >= $]]]) 		ifTrue: [^ self recordAndReportMatch: #(38 )].	((currentCharacter between: $A and: $Z) 		or: [currentCharacter between: $a and: $z]) 			ifTrue: 				[self recordMatch: #(22 38 ).				self step.				((currentCharacter between: $0 and: $9) or: 						[(currentCharacter between: $A and: $Z) 							or: [currentCharacter between: $a and: $z]]) 					ifTrue: 						[						[self recordMatch: #(22 ).						self step.						(currentCharacter between: $0 and: $9) or: 								[(currentCharacter between: $A and: $Z) 									or: [currentCharacter between: $a and: $z]]] 								whileTrue.						currentCharacter = $: ifTrue: [^ self scan8].						^ self reportLastMatch].				currentCharacter = $: ifTrue: [^ self scan8].				^ self reportLastMatch].	(currentCharacter = $!! or: 			[(currentCharacter between: $% and: $&) or: 					[(currentCharacter between: $+ and: $,) or: 							[currentCharacter = $/ or: 									[currentCharacter = $= or: 											[(currentCharacter between: $? and: $@) 												or: [currentCharacter = $\ or: [currentCharacter = $~]]]]]]]) 		ifTrue: 			[self recordMatch: #binarySymbol.			self step.			(currentCharacter = $!! or: 					[(currentCharacter between: $% and: $&) or: 							[(currentCharacter between: $* and: $-) or: 									[currentCharacter = $/ or: 											[(currentCharacter between: $< and: $@) or: 													[currentCharacter = $\ 														or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]) 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter = $!! or: 							[(currentCharacter between: $% and: $&) or: 									[(currentCharacter between: $* and: $-) or: 											[currentCharacter = $/ or: 													[(currentCharacter between: $< and: $@) or: 															[currentCharacter = $\ 																or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	(currentCharacter between: $0 and: $9) 		ifTrue: 			[self recordMatch: #(19 38 ).			self step.			(currentCharacter between: $0 and: $9) 				ifTrue: 					[					[self recordMatch: #(19 ).					self step.					currentCharacter between: $0 and: $9] 							whileTrue.					currentCharacter = $. ifTrue: [^ self scan3].					currentCharacter = $e ifTrue: [^ self scan4].					currentCharacter = $r ifTrue: [^ self scan6].					currentCharacter = $s ifTrue: [^ self scan5].					^ self reportLastMatch].			currentCharacter = $. ifTrue: [^ self scan3].			currentCharacter = $e ifTrue: [^ self scan4].			currentCharacter = $r ifTrue: [^ self scan6].			currentCharacter = $s ifTrue: [^ self scan5].			^ self reportLastMatch].	((currentCharacter between: Character tab and: Character cr) 		or: [currentCharacter = Character space]) 			ifTrue: 				[self recordMatch: #whitespace.				self step.				((currentCharacter between: Character tab and: Character cr) 					or: [currentCharacter = Character space]) 						ifTrue: 							[							[self recordMatch: #whitespace.							self step.							(currentCharacter between: Character tab and: Character cr) 								or: [currentCharacter = Character space]] 									whileTrue.							^ self reportLastMatch].				^ self reportLastMatch].	currentCharacter = $" 		ifTrue: 			[self recordMatch: #(38 ).			self step.			currentCharacter ~= $" 				ifTrue: 					[					[self step.					currentCharacter ~= $"] whileTrue.					currentCharacter = $" ifTrue: [^ self recordAndReportMatch: #comment].					^ self reportLastMatch].			currentCharacter = $" ifTrue: [^ self recordAndReportMatch: #comment].			^ self reportLastMatch].	currentCharacter = $# 		ifTrue: 			[self recordMatch: #(17 38 ).			self step.			currentCharacter = $: ifTrue: [^ self recordAndReportMatch: #(18 )].			^ self reportLastMatch].	currentCharacter = $$ 		ifTrue: 			[self recordMatch: #(38 ).			self step.			currentCharacter <= $ ifTrue: [^ self recordAndReportMatch: #(30 )].			^ self reportLastMatch].	currentCharacter = $' 		ifTrue: 			[self recordMatch: #(38 ).			self step.			currentCharacter ~= $' ifTrue: [^ self scan1].			currentCharacter = $' ifTrue: [^ self scan2].			^ self reportLastMatch].	currentCharacter = $( ifTrue: [^ self recordAndReportMatch: #(2 38 )].	currentCharacter = $) ifTrue: [^ self recordAndReportMatch: #(35 38 )].	currentCharacter = $* 		ifTrue: 			[self recordMatch: #(12 25 38 ).			self step.			(currentCharacter = $!! or: 					[(currentCharacter between: $% and: $&) or: 							[(currentCharacter between: $* and: $-) or: 									[currentCharacter = $/ or: 											[(currentCharacter between: $< and: $@) or: 													[currentCharacter = $\ 														or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]) 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter = $!! or: 							[(currentCharacter between: $% and: $&) or: 									[(currentCharacter between: $* and: $-) or: 											[currentCharacter = $/ or: 													[(currentCharacter between: $< and: $@) or: 															[currentCharacter = $\ 																or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $- 		ifTrue: 			[self recordMatch: #binarySymbol.			self step.			(currentCharacter = $!! or: 					[(currentCharacter between: $% and: $&) or: 							[(currentCharacter between: $* and: $-) or: 									[currentCharacter = $/ or: 											[(currentCharacter between: $< and: $@) or: 													[currentCharacter = $\ 														or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]) 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter = $!! or: 							[(currentCharacter between: $% and: $&) or: 									[(currentCharacter between: $* and: $-) or: 											[currentCharacter = $/ or: 													[(currentCharacter between: $< and: $@) or: 															[currentCharacter = $\ 																or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]] 							whileTrue.					^ self reportLastMatch].			(currentCharacter between: $0 and: $9) 				ifTrue: 					[					[self recordMatch: #(20 ).					self step.					currentCharacter between: $0 and: $9] 							whileTrue.					currentCharacter = $. 						ifTrue: 							[self step.							(currentCharacter between: $0 and: $9) 								ifTrue: 									[									[self recordMatch: #(20 ).									self step.									currentCharacter between: $0 and: $9] 											whileTrue.									currentCharacter = $e ifTrue: [^ self scan10].									currentCharacter = $s ifTrue: [^ self scan11].									^ self reportLastMatch].							^ self reportLastMatch].					currentCharacter = $e ifTrue: [^ self scan10].					currentCharacter = $r 						ifTrue: 							[self step.							((currentCharacter between: $0 and: $9) 								or: [currentCharacter between: $A and: $Z]) 									ifTrue: 										[										[self recordMatch: #(20 ).										self step.										(currentCharacter between: $0 and: $9) 											or: [currentCharacter between: $A and: $Z]] 												whileTrue.										currentCharacter = $. 											ifTrue: 												[self step.												((currentCharacter between: $0 and: $9) 													or: [currentCharacter between: $A and: $Z]) 														ifTrue: 															[															[self recordMatch: #(20 ).															self step.															(currentCharacter between: $0 and: $9) 																or: [currentCharacter between: $A and: $Z]] 																	whileTrue.															currentCharacter = $e ifTrue: [^ self scan10].															^ self reportLastMatch].												^ self reportLastMatch].										currentCharacter = $e ifTrue: [^ self scan10].										^ self reportLastMatch].							^ self reportLastMatch].					currentCharacter = $s ifTrue: [^ self scan11].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $. ifTrue: [^ self recordAndReportMatch: #(31 38 )].	currentCharacter = $: 		ifTrue: 			[self recordMatch: #(36 38 ).			self step.			((currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan7].			currentCharacter = $= ifTrue: [^ self recordAndReportMatch: #(26 )].			^ self reportLastMatch].	currentCharacter = $; ifTrue: [^ self recordAndReportMatch: #(37 38 )].	currentCharacter = $< 		ifTrue: 			[self recordMatch: #(6 25 38 ).			self step.			(currentCharacter = $!! or: 					[(currentCharacter between: $% and: $&) or: 							[(currentCharacter between: $* and: $-) or: 									[currentCharacter = $/ or: 											[(currentCharacter between: $< and: $@) or: 													[currentCharacter = $\ 														or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]) 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter = $!! or: 							[(currentCharacter between: $% and: $&) or: 									[(currentCharacter between: $* and: $-) or: 											[currentCharacter = $/ or: 													[(currentCharacter between: $< and: $@) or: 															[currentCharacter = $\ 																or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $> 		ifTrue: 			[self recordMatch: #(7 25 38 ).			self step.			(currentCharacter = $!! or: 					[(currentCharacter between: $% and: $&) or: 							[(currentCharacter between: $* and: $-) or: 									[currentCharacter = $/ or: 											[(currentCharacter between: $< and: $@) or: 													[currentCharacter = $\ 														or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]) 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter = $!! or: 							[(currentCharacter between: $% and: $&) or: 									[(currentCharacter between: $* and: $-) or: 											[currentCharacter = $/ or: 													[(currentCharacter between: $< and: $@) or: 															[currentCharacter = $\ 																or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $[ ifTrue: [^ self recordAndReportMatch: #(1 38 )].	currentCharacter = $] ifTrue: [^ self recordAndReportMatch: #(33 38 )].	currentCharacter = $^ ifTrue: [^ self recordAndReportMatch: #(4 38 )].	currentCharacter = $_ ifTrue: [^ self recordAndReportMatch: #(26 38 )].	currentCharacter = ${ ifTrue: [^ self recordAndReportMatch: #(5 38 )].	currentCharacter = $| 		ifTrue: 			[self recordMatch: #(9 25 38 ).			self step.			(currentCharacter = $!! or: 					[(currentCharacter between: $% and: $&) or: 							[(currentCharacter between: $* and: $-) or: 									[currentCharacter = $/ or: 											[(currentCharacter between: $< and: $@) or: 													[currentCharacter = $\ 														or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]) 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter = $!! or: 							[(currentCharacter between: $% and: $&) or: 									[(currentCharacter between: $* and: $-) or: 											[currentCharacter = $/ or: 													[(currentCharacter between: $< and: $@) or: 															[currentCharacter = $\ 																or: [currentCharacter = $| or: [currentCharacter = $~]]]]]]]] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter = $} ifTrue: [^ self recordAndReportMatch: #(34 38 )].	^ self reportLastMatch! !!SqueakScanner commentStamp: 'ajh 3/24/2003 21:31' prior: 0!I parse Smalltalk text into tokens which are used by the SqueakParser.  Methods under 'generated-*' categories were automatically generated using SmaCC.!!SqueakScanner class methodsFor: 'generated-initialization' stamp: 'ms 4/7/2007 03:32'!initializeKeywordMap	keywordMap := Dictionary new.	#(		#(#binarySymbol '||' 8 )		#(22 'false' 15 )		#(22 'nil' 16 )		#(22 'true' 10 )		#(23 'apicall:' 14 )		#(23 'cdecl:' 11 )		#(23 'module:' 13 )		#(23 'primitive:' 3 )	) do: 				[:each | 				(keywordMap at: each first ifAbsentPut: [Dictionary new]) at: (each at: 2)					put: each last].	^ keywordMap! !!SqueakScanner class methodsFor: 'generated-comments' stamp: 'ms 4/7/2007 03:32'!scannerDefinitionComment	"<decimalNumber>:	[0-9]+ (\. [0-9]+)? ;<radixNumber>:		[0-9]+ r [0-9A-Z]+ (\. [0-9A-Z]+)? ;<scaledNumber>:		<decimalNumber> s [0-9]+ ;<exponentNumber>:	(<decimalNumber> | <radixNumber>) e \-? [0-9]+ ;<number>:			<decimalNumber> | <radixNumber> | <exponentNumber> | <scaledNumber> ;<negativeNumber>:	\- <number> ;<string>:				\'  [^\']* \' (\' [^\']* \')* ;<name>:				[a-zA-Z] [a-zA-Z0-9]* ;<keyword>:			<name> \: ;<multikeyword>:		<name> \: (<name> \: )+ ;<binarySymbol>:		[\~\!!\@\%\&\*\-\+\=\\\|\?\/\>\<\,] [\~\!!\@\%\&\*\-\+\=\\\|\?\/\>\<\,]* ;<assignment>:		\: \= | \_ ;<alternateKeyword>:	\: <name> \: (<name> \:)* ;<whitespace>:		\s+ ;<comment>:			\"" [^\""]* \"" ;<character>:			\$ . ;<period>:				\. ;<variableAssignment>:	<name> \: \= ;<rightBoxBrackets>:	];<rightCurlyBrackets>:	};<rightParentheses>:	\);<colon>:				\:;<semicolon>:			\;;<anyChar>:			. ; # For VW literal arrays that handle #(;) -> #(#';');"! !!SqueakToken methodsFor: 'accessing' stamp: 'ms 9/19/2006 13:19'!eatToken		eat := true.	^self! !!SqueakToken methodsFor: 'accessing' stamp: 'ms 9/17/2006 19:57'!eatValue		eat := true.	^self value! !!SqueakToken methodsFor: 'accessing' stamp: 'ms 4/1/2007 13:43'!length	^(self stop - self start) + 1! !!SqueakToken methodsFor: 'accessing' stamp: 'ms 9/16/2006 17:18'!next		^next! !!SqueakToken methodsFor: 'accessing' stamp: 'ms 9/16/2006 23:24'!next: aToken		next := aToken! !!SqueakToken methodsFor: 'accessing' stamp: 'ms 9/17/2006 18:41'!nextSignificant	| nextSign |	nextSign := self next.	[nextSign isInsignificant] 		whileTrue: [nextSign := nextSign next.					nextSign ifNil:[^nil]].	^nextSign! !!SqueakToken methodsFor: 'accessing' stamp: 'ms 9/16/2006 17:19'!previous	^previous! !!SqueakToken methodsFor: 'accessing' stamp: 'ms 9/16/2006 17:29'!previous: aToken	aToken ifNotNil:[aToken next: self].	previous := aToken! !!SqueakToken methodsFor: 'accessing' stamp: 'ms 3/31/2007 22:01'!start	^self startPosition! !!SqueakToken methodsFor: 'accessing' stamp: 'ms 3/31/2007 21:18'!start: aSmallInteger 	start := aSmallInteger! !!SqueakToken methodsFor: 'accessing' stamp: 'ms 3/31/2007 22:02'!stop	^self stopPosition! !!SqueakToken methodsFor: 'accessing' stamp: 'ms 3/31/2007 21:17'!value: aValue 	value := aValue! !!SqueakToken methodsFor: 'initialize' stamp: 'ms 9/17/2006 19:56'!initialize		eat := false! !!SqueakToken methodsFor: 'add' stamp: 'ms 9/17/2006 14:47'!insertAfterMe: aToken		self next previous: aToken.	aToken previous: self! !!SqueakToken methodsFor: 'add' stamp: 'ms 9/17/2006 14:41'!insertBeforMe: aToken		aToken previous: self previous.	self previous: aToken! !!SqueakToken methodsFor: 'testing' stamp: 'ms 5/2/2007 11:48'!isComment	^id == #comment! !!SqueakToken methodsFor: 'testing' stamp: 'ms 9/17/2006 19:59'!isEaten		^eat! !!SqueakToken methodsFor: 'testing' stamp: 'ms 9/19/2006 15:32'!isInsignificant		^false! !!SqueakToken methodsFor: 'testing' stamp: 'ms 5/2/2007 11:51'!isNewLine		^self isWhitespace and:[(self value indexOf: Character cr) > 0 or: [(self value indexOf: Character lf) > 0]]! !!SqueakToken methodsFor: 'testing' stamp: 'ms 3/31/2007 21:16'!isRBToken	^false! !!SqueakToken methodsFor: 'testing' stamp: 'ms 4/1/2007 18:39'!isSignificant	^(self isComment or:[self isWhitespace] or: [self value = '|'] or: [self value = '.'] or: [self isWhitespace]) not! !!SqueakToken methodsFor: 'testing' stamp: 'ms 5/2/2007 11:49'!isWhitespace	^id == #whitespace! !!SqueakToken methodsFor: 'testing' stamp: 'ms 9/17/2006 19:59'!notEaten		^eat not! !!SqueakToken methodsFor: 'replace' stamp: 'ms 11/11/2006 19:13'!substitueTo: aToken		self previous: aToken previous.	aToken next ifNotNilDo:[:nextToken | nextToken previous: self]! !!SqueakToken class methodsFor: 'instance creation' stamp: 'ms 9/17/2006 14:43'!value: aString start: anInteger	^(self new)		value: aString;			start: anInteger;			yourself! !!SqueakToken class methodsFor: 'instance creation' stamp: 'ms 9/17/2006 15:25'!value: aString start: anInteger id: anObject	^(self new)		value: aString			start: anInteger			id: anObject;		yourself! !!SqueakToken class methodsFor: 'instance creation' stamp: 'ms 9/16/2006 17:26'!value: aString start: anInteger id: anObject prevToken: aToken	^(self new)		value: aString			start: anInteger			id: anObject;		previous: aToken;			yourself! !!SqueakToken class methodsFor: 'instance creation' stamp: 'ms 9/17/2006 14:33'!value: aString start: anInteger prevToken: aToken	^(self new)		value: aString;			start: anInteger;		previous: aToken;			yourself! !!SqueakTokenStream methodsFor: 'accessing' stamp: 'ms 9/17/2006 19:00'!atEnd		^token isNil! !!SqueakTokenStream methodsFor: 'accessing' stamp: 'ms 9/19/2006 00:42'!contents		| cont nextToken |	cont := OrderedCollection new.	nextToken := token.	[nextToken isNil] whileFalse: [cont add: nextToken. nextToken := nextToken perform: goNext].	^cont asArray! !!SqueakTokenStream methodsFor: 'accessing' stamp: 'ms 9/19/2006 02:09'!next		| next |	next := token.	self atEnd ifFalse:[token :=  token perform: goNext].	^next! !!SqueakTokenStream methodsFor: 'accessing' stamp: 'ms 9/19/2006 01:03'!peek		^token! !!SqueakTokenStream methodsFor: 'accessing' stamp: 'ms 9/19/2006 13:08'!selectCommentNewLine	^SelectSqueakTokenStream selectCommentNewLineOn: self! !!SqueakTokenStream methodsFor: 'accessing' stamp: 'ms 5/28/2007 14:03'!selectCommentNewLineWithPipe	^SelectSqueakTokenStream selectCommentNewLineWithPipeOn:  self! !!SqueakTokenStream methodsFor: 'initialize' stamp: 'ms 9/19/2006 00:41'!backwardOn: aToken		token := aToken.	goNext := #previous! !!SqueakTokenStream methodsFor: 'initialize' stamp: 'ms 9/19/2006 00:41'!forwardOn: aToken		token := aToken.	goNext := #next! !!SqueakTokenStream class methodsFor: 'instance creation' stamp: 'ms 9/17/2006 19:05'!backwardOn: aToken	^(self basicNew) initialize; backwardOn: aToken; yourself! !!SqueakTokenStream class methodsFor: 'instance creation' stamp: 'ms 9/19/2006 14:42'!forwardOn: aToken	^(self basicNew) initialize; forwardOn: aToken! !!SqueakTokenTest methodsFor: 'running' stamp: 'ms 11/17/2006 17:10'!setUp	| ast |	ast := SqueakParser parseMethod: 'zork "boo" | e | ', String cr, ' e := 3 + 4.', String cr, '^e'.	aToken := ast firstToken! !!SqueakTokenTest methodsFor: 'testing' stamp: 'ms 11/17/2006 18:17'!testIsComment		self assert: (aToken isComment not).	self assert: (aToken next isComment not).	self assert: (aToken next next isComment)! !!SqueakTokenTest methodsFor: 'testing' stamp: 'ms 11/17/2006 18:00'!testIsSignificant		self assert: (aToken isSignificant).	self assert: (aToken next isSignificant not).	self assert: (aToken next next isSignificant not)! !!SqueakTokenTest methodsFor: 'testing' stamp: 'ms 11/17/2006 18:07'!testNext		self assert: (aToken next isKindOf: SqueakToken).! !!SqueakTokenTest methodsFor: 'testing' stamp: 'ms 11/17/2006 18:25'!testPrevious		self assert: (aToken previous == nil).	self assert: (aToken next previous isKindOf: SqueakToken)! !!StackCount methodsFor: 'comparing' stamp: 'ajh 3/13/2003 01:39'!= other	^ self class == other class 	  and: [start = other start	  and: [position = other position	  and: [length = other size]]]! !!StackCount methodsFor: 'comparing' stamp: 'ajh 3/13/2003 01:51'!hash	^ position hash bitXor: (length hash bitXor: start hash)! !!StackCount methodsFor: 'error handling' stamp: 'md 7/18/2005 09:59'!errorStackOutOfSync: aStackCount 	self error: 'stack not in sync!!'.! !!StackCount methodsFor: 'results' stamp: 'ajh 3/13/2003 01:32'!length	^length! !!StackCount methodsFor: 'results' stamp: 'ajh 3/13/2003 18:37'!linkTo: stackOrNil	stackOrNil ifNil: [^ self class startAt: self position].	^ self position = stackOrNil start		ifTrue: [stackOrNil]		ifFalse: [self errorStackOutOfSync: stackOrNil]! !!StackCount methodsFor: 'results' stamp: 'ajh 3/13/2003 01:32'!position	^position! !!StackCount methodsFor: 'results' stamp: 'ajh 3/13/2003 01:32'!size	^length! !!StackCount methodsFor: 'results' stamp: 'ajh 3/13/2003 01:36'!start	^ start! !!StackCount methodsFor: 'affecting' stamp: 'ajh 3/13/2003 01:32'!pop	^ self pop: 1! !!StackCount methodsFor: 'affecting' stamp: 'ajh 3/13/2003 01:32'!pop: n	(position _ position - n) "< 0 		ifTrue: [self error: 'Parse stack underflow']"! !!StackCount methodsFor: 'affecting' stamp: 'ajh 3/13/2003 01:32'!push	^ self push: 1! !!StackCount methodsFor: 'affecting' stamp: 'ajh 3/13/2003 01:32'!push: n	(position _ position + n) > length 		ifTrue: [length _ position]! !!StackCount methodsFor: 'printing' stamp: 'ajh 3/13/2003 01:38'!printOn: aStream		super printOn: aStream.	aStream		nextPutAll: ' start '; print: start;		nextPutAll: ' stop '; print: position;		nextPutAll: ' max '; print: length.! !!StackCount methodsFor: 'initialize' stamp: 'ajh 3/13/2003 01:48'!startAt: pos	start _ position _ length _ pos! !!StackCount commentStamp: 'ajh 3/25/2003 00:34' prior: 0!This keeps track of the stack count for the BytecodeGenerator.!!StackCount class methodsFor: 'instance creation' stamp: 'ajh 3/13/2003 01:49'!new	^ super new startAt: 0! !!StackCount class methodsFor: 'as yet unclassified' stamp: 'ajh 3/13/2003 01:49'!startAt: pos	^ super new startAt: pos! !!String methodsFor: 'comparing' stamp: 'md 4/16/2007 10:53'!hash	"#hash is implemented, because #= is implemented"	"ar 4/10/2005: I had to change this to use ByteString hash as initial 	hash in order to avoid having to rehash everything and yet compute	the same hash for ByteString and WideString.	md 16/10/2006: use identityHash as initialHash"	^ self class stringHash: self initialHash: ByteString identityHash! !!String methodsFor: 'converting' stamp: 'dgd 11/26/2005 21:19'!zipped	| stream gzstream |	stream := RWBinaryOrTextStream on: String new.	gzstream := GZipWriteStream on: stream.	gzstream nextPutAll: self.	gzstream close.	stream reset.	^ stream contents.! !!String methodsFor: '*Toothpick-PatternFormat'!printWithFormat: aFormatString on: aStream 	| shouldPad leftPad formatStream width wantsPrecision precision outputString |	aFormatString isEmpty ifTrue: [ ^ aStream nextPutAll: self ].	formatStream := aFormatString readStream.	shouldPad := ( formatStream peekFor: $. ) not.	shouldPad ifTrue: 		[	leftPad := ( formatStream peekFor: $- ) not.			width := ( formatStream upTo: $. ) asNumber asInteger		].	wantsPrecision := formatStream atEnd not.	wantsPrecision 		ifTrue: 		[	precision := formatStream upToEnd asNumber asInteger.			outputString := self copyFrom: ((self size - precision) max: 0) + 1 to: self size		]		ifFalse: [ outputString := self ].	shouldPad 		ifTrue: 		[	leftPad 				ifTrue: 				[	width - outputString size timesRepeat: [ aStream nextPut: $ ].					aStream nextPutAll: outputString				]				ifFalse: 				[	aStream nextPutAll: outputString.					width - outputString size timesRepeat: [ aStream nextPut: $ ]				]		]		ifFalse: [ aStream nextPutAll: outputString ]			! !!String methodsFor: '*persephone' stamp: 'pmm 11/27/2006 16:18'!asVariableNode	^RBVariableNode named: self! !!String methodsFor: '*persephone' stamp: 'md 3/31/2007 18:48'!nodesForInstrumentation	^(PESqueakParser parseDoIt: self)		body statements! !!String methodsFor: '*network-IRC-Model' stamp: 'ls 9/5/1998 01:19'!asIRCLowercase	"Answer a String made up from the receiver whose characters are all 	lowercase, where 'lowercase' is by IRC's definition"	^self collect: [ :c | c asIRCLowercase ]! !!StringHolder methodsFor: '*refactoringengine' stamp: 'rr 4/12/2004 19:43'!findNode	| tree node interval |	interval := self selectedInterval.	interval isEmpty ifTrue: [^nil].	tree := RBParser parseMethod: self text				onError: [:str :err | ^self parseSelection].	node := tree whichNodeIsContainedBy: interval.	node isNil ifTrue: [node := tree bestNodeFor: interval].	^node! !!StringHolder methodsFor: '*refactoringengine' stamp: 'rr 4/12/2004 19:43'!findNodeUnderCaret	| tree node interval |	interval := self selectedInterval.	tree := RBParser parseMethod: self text				onError: [:str :err | ^self parseSelection].	node := tree whichNodeIsContainedBy: interval.	node isNil ifTrue: [node := tree bestNodeFor: interval].	^node! !!StringHolder methodsFor: '*refactoringengine' stamp: 'rr 4/12/2004 19:43'!findSelectionNode	| node |	node := self findNode.	^ node ifNil: [RBProgramNode new] ifNotNil: [node]! !!StringHolder methodsFor: '*refactoringengine' stamp: 'rr 4/12/2004 19:43'!parseSelection	^RBParser parseExpression: self selectedText onError: [:str :pos | ^nil]! !!StringHolder methodsFor: '*refactoringengine' stamp: 'rr 4/13/2004 21:51'!parseTree	^ RBParser parseMethod: self text				onError: [:str :err | ^ RBParser parseExpression: self selectedText onError: [:strr :pos | ^ nil]]! !!StringHolder methodsFor: '*refactoringengine' stamp: 'rr 4/12/2004 19:43'!selectedText	| interval |	interval := self selectedInterval.	interval isEmpty ifTrue: [^''].	^self codeTextMorph text asString copyFrom: interval first		to: interval last! !!StringHolder methodsFor: '*refactoringengine' stamp: 'rr 4/12/2004 19:43'!text	^self contents! !!StringMorph methodsFor: '*network-irc-gui' stamp: 'sbw 3/10/2005 22:37'!isStringMorph	^true! !!StringTest methodsFor: 'tests - converting' stamp: 'md 2/5/2007 15:21'!testZipped	| compressed |		compressed := 'hello' zipped.	self assert: (compressed unzipped = 'hello').! !!SubclassOfClassToRename methodsFor: 'accessing'!calls	^self rewriteRule1: self name , self rewriteRule1! !!SubclassOfClassToRename methodsFor: 'accessing'!calls1	^self rewriteRule1: (self rewriteRule1: self calls)! !!SubclassOfClassToRename methodsFor: 'accessing'!name	^rewriteRule1! !!SubclassOfClassToRename methodsFor: 'accessing'!rewriteRule1	^rewriteRule1! !!SubclassOfClassToRename methodsFor: 'accessing'!rewriteRule1: anObject	^rewriteRule1 := anObject! !!SubclassOfClassToRename methodsFor: 'performing'!reference	^ClassToRename new! !!SubclassOfClassToRename methodsFor: 'performing'!symbolReference	^#ClassToRename! !!SystemChangeNotifierTest methodsFor: 'Private' stamp: 'rw 10/19/2006 17:23'!systemChangeNotifier	"The notifier to use. Do not use the one in the system so that the fake events triggered in the tests perturb clients of the system's change notifier (e.g. the changes file then shows fake entries)."	^notifier! !!SystemChangeNotifierTest methodsFor: 'Running' stamp: 'rw 10/19/2006 17:21'!setUp	super setUp.	notifier := SystemChangeNotifier createInstance.! !!SystemChangeNotifierTest methodsFor: 'Running' stamp: 'rw 10/19/2006 17:23'!tearDown	super tearDown.	self capturedEvent: nil.	notifier releaseAll.	notifier := nil! !!SystemChangeNotifierTest methodsFor: 'Testing-system triggers' stamp: 'rw 10/19/2006 17:24'!testClassRenamedEvent	"self run: #testClassRenamedEvent"	self systemChangeNotifier notify: self ofAllSystemChangesUsing: #event:.	self systemChangeNotifier 		classRenamed: self class		from: #OldFooClass		to: #NewFooClass		inCategory: #FooCat.	self		checkEventForClass: self class		category: #FooCat		change: #Renamed."	self assert: capturedEvent oldName = #OldFooClass.	self assert: capturedEvent newName = #NewFooClass"! !!SystemChangeNotifierTest commentStamp: 'rw 4/3/2006 17:19' prior: 0!A SystemChangeNotifierTest is a test class that tests whether the triggering of changes indeed results in the intended changes to be sent to registered object. The basic mechanism for each test is fairly simple:	- register the receiver as the one to get the change notifier.	- manually trigger a change (so the system is not polluted just to see whether we get the needed event).	- the method #event: is invoked and remembers the change event.	- the change event is checked to see whether it was the intended one.Instance Variables	capturedEvent:		Remembers the captured event!!SystemDictionary methodsFor: 'class and trait names' stamp: 'rw 10/7/2006 08:34'!renameClass: aClass as: newName 	"Rename the class, aClass, to have the title newName."	"Original one I want to keep but needs to be fixed"		| oldref i oldName category |	oldName := aClass name.	category := aClass category.	SystemOrganization classify: newName under: aClass category.	SystemOrganization removeElement: aClass name.	oldref _ self associationAt: aClass name.	self removeKey: aClass name.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i _ list indexOf: aClass name ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SystemDictionary methodsFor: 'class names' stamp: 'rw 10/17/2006 23:07'!renameClass: aClass from: oldName 	"Rename the class, aClass, to have the title newName."	| oldref i newName category |	newName := aClass name.	category := SystemOrganization categoryOfElement: oldName.	SystemOrganization classify: newName under: category.	SystemOrganization removeElement: oldName.	oldref := self associationAt: oldName.	self removeKey: oldName.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i := list indexOf: oldName ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SystemDictionary methodsFor: '*newcompiler' stamp: 'md 7/24/2007 16:14'!allTraits	"Return all the classes and traits defined in the Smalltalk SystemDictionary"	^ self traitNames collect: [:each | self at: each]! !!SystemDictionary methodsFor: '*newcompiler' stamp: 'md 7/24/2007 16:15'!allTraitsDo: aBlock	^self allTraits do: aBlock! !!SystemWindow methodsFor: 'initialization' stamp: 'dew 10/14/2006 18:57'!initialize	"Initialize a system window. Add label, stripes, etc., if desired"	super initialize.	allowReframeHandles _ true.	labelString ifNil: [labelString _ 'Untitled Window'].	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	borderColor _ Color lightGray.	borderWidth _ 1.	self color: Color lightGray lighter lighter lighter.	self layoutPolicy: ProportionalLayout new.		self initializeLabelArea.					self addCornerGrips.	self extent: 300 @ 200.	mustNotClose _ false.	updatablePanes _ Array new.			Preferences menuAppearance3d		ifTrue: [			self				addDropShadow;				shadowColor: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.333);				shadowOffset: 1@1.		].					! !!SystemWindow methodsFor: 'initialization' stamp: 'dew 10/14/2006 18:57'!initializeLabelArea	"Initialize the label area (titlebar) for the window."	label _ StringMorph new contents: labelString;						 font: Preferences windowTitleFont emphasis: 0.			"Add collapse box so #labelHeight will work"			collapseBox _ self createCollapseBox.			stripes _ Array						with: (RectangleMorph newBounds: bounds)						with: (RectangleMorph newBounds: bounds).			"see extent:"			self addLabelArea.			self setLabelWidgetAllowance.			self addCloseBox.			self addMenuControl.			labelArea addMorphBack: (Morph new extent: self class borderWidth @ 0).			labelArea addMorphBack: label.			self wantsExpandBox				ifTrue: [self addExpandBox].			labelArea addMorphBack: collapseBox.			self setFramesForLabelArea.			Preferences clickOnLabelToEdit				ifTrue: [label						on: #mouseDown						send: #relabel						to: self].			Preferences noviceMode				ifTrue: [closeBox						ifNotNil: [closeBox setBalloonText: 'close window'].					menuBox						ifNotNil: [menuBox setBalloonText: 'window menu'].					collapseBox						ifNotNil: [collapseBox setBalloonText: 'collapse/expand window']].! !!TAccessingMethodDictDescription methodsFor: '*persephone-override' stamp: 'md 7/26/2007 21:31'!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: category notifying: requestor	| priorMethodOrNil method |	method := compiledMethod.	priorMethodOrNil _ self compiledMethodAt: selector ifAbsent: [nil].	(Preferences compileReflectiveMethods and:[priorMethodOrNil notNil]) ifTrue:[		(compiledMethod isReflectiveMethod and: [priorMethodOrNil isCoreMethod]) ifTrue: [			method := compiledMethod generateCompiledMethod.			].		].	self addSelectorSilently: selector withMethod: method.	SystemChangeNotifier uniqueInstance 		doSilently: [self organization classify: selector under: category].	priorMethodOrNil isNil		ifTrue: [SystemChangeNotifier uniqueInstance methodAdded: method selector: selector inProtocol: category class: self requestor: requestor]		ifFalse: [SystemChangeNotifier uniqueInstance methodChangedFrom: priorMethodOrNil to: method selector: selector inClass: self requestor: requestor].! !!TAccessingMethodDictDescription methodsFor: '*persephone-override' stamp: 'md 7/26/2007 21:31'!addSelector: selector withMethod: compiledMethod notifying: requestor	| priorMethodOrNil method |	priorMethodOrNil _ self compiledMethodAt: selector ifAbsent: [nil].	(Preferences compileReflectiveMethods and:[priorMethodOrNil notNil]) ifTrue:[		(compiledMethod isReflectiveMethod and: [priorMethodOrNil isCoreMethod]) ifTrue: [			method := compiledMethod generateCompiledMethod.			].		].	self addSelectorSilently: selector withMethod: method.	priorMethodOrNil isNil		ifTrue: [SystemChangeNotifier uniqueInstance methodAdded: method selector: selector inClass: self requestor: requestor]		ifFalse: [SystemChangeNotifier uniqueInstance methodChangedFrom: priorMethodOrNil to: method selector: selector inClass: self requestor: requestor].! !!TBlock methodsFor: 'exceptions' stamp: 'pmm 5/1/2006 12:33'!assert	self assert: self! !!TBlock methodsFor: 'exceptions' stamp: 'pmm 5/1/2006 12:33'!ensure: aBlock	"Evaluate a termination block after evaluating the receiver, regardless of whether the receiver's evaluation completes."	| returnValue b |	<primitive: 198>	returnValue := self value.	"aBlock wasn't nil when execution of this method began; it is nil'd out by the unwind machinery, and that's how we know it's already been evaluated ... otherwise, obviously, it needs to be evaluated"	aBlock == nil ifFalse: [		"nil out aBlock temp before evaluating aBlock so it is not executed again if aBlock remote returns"		b := aBlock.		thisContext tempAt: 1 put: nil.  "aBlock := nil"		b value.	].	^ returnValue! !!TBlock methodsFor: 'exceptions' stamp: 'pmm 5/1/2006 12:34'!ifCurtailed: aBlock	"Evaluate the receiver with an abnormal termination action."	<primitive: 198>	^ self value! !!TBlock methodsFor: 'exceptions' stamp: 'pmm 5/1/2006 12:34'!on: exception do: handlerAction	"Evaluate the receiver in the scope of an exception handler."	| handlerActive |	<primitive: 199>  "just a marker, fail and execute the following"	handlerActive := true.	^ self value! !!TBlock methodsFor: 'exceptions' stamp: 'pmm 5/1/2006 12:35'!onDNU: selector do: handleBlock	"Catch MessageNotUnderstood exceptions but only those of the given selector (DNU stands for doesNotUnderstand:)"	^ self on: MessageNotUnderstood do: [:exception |		exception message selector = selector			ifTrue: [handleBlock valueWithPossibleArgs: {exception}]			ifFalse: [exception pass]	  ]! !!TBlock methodsFor: 'exceptions' stamp: 'pmm 5/1/2006 12:35'!valueUninterruptably	"Prevent remote returns from escaping the sender.  Even attempts to terminate (unwind) this process will be halted and the process will resume here.  A terminate message is needed for every one of these in the sender chain to get the entire process unwound."	^ self ifCurtailed: [^ self]! !!TBlock methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:20'!bench	"See how many times I can value in 5 seconds.  I'll answer a meaningful description."	| startTime endTime count |	count := 0.	endTime := Time millisecondClockValue + 5000.	startTime := Time millisecondClockValue.	[ Time millisecondClockValue > endTime ] whileFalse: [ self value.  count := count + 1 ].	endTime := Time millisecondClockValue.	^count = 1		ifTrue: [ ((endTime - startTime) // 1000) printString, ' seconds.' ]		ifFalse:			[ ((count * 1000) / (endTime - startTime)) asFloat printString, ' per second.' ]! !!TBlock methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:21'!durationToRun	"Answer the duration taken to execute this block."	^ Duration milliSeconds: self timeToRun! !!TBlock methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:21'!ifError: errorHandlerBlock	"Evaluate the block represented by the receiver, and normally return it's value.  If an error occurs, the errorHandlerBlock is evaluated, and it's value is instead returned.  The errorHandlerBlock must accept zero, one, or two parameters (the error message and the receiver)."	"Examples:		[1 whatsUpDoc] ifError: [:err :rcvr | 'huh?'].		[1 / 0] ifError: [:err :rcvr |			'ZeroDivide' = err				ifTrue: [Float infinity]				ifFalse: [self error: err]]"	^ self on: Error do: [:ex |		errorHandlerBlock valueWithPossibleArgs: {ex description. ex receiver}]! !!TBlock methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:22'!timeToRun	"Answer the number of milliseconds taken to execute this block."	^ Time millisecondsToRun: self! !!TBlock methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:23'!value	"Evaluate the block represented by the receiver."	^self valueWithArguments: #()! !!TBlock methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:24'!value: arg	"Evaluate the block with the given argument. Fail if the block expects other than 1 arguments."	^self valueWithArguments: (Array with: arg)! !!TBlock methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:25'!value: arg1 value: arg2 	"Evaluate the block with the given arguments. Fail if the block expects other than 2 arguments."	^self valueWithArguments: (Array with: arg1 with: arg2)! !!TBlock methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:25'!value: arg1 value: arg2 value: arg3 	"Evaluate the block with the given arguments. Fail if the block expects other than 3 arguments."	^self valueWithArguments: 		(Array			with: arg1			with: arg2			with: arg3)! !!TBlock methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:26'!value: arg1 value: arg2 value: arg3 value: arg4	"Evaluate the block with the given arguments. Fail if the block expects other than 4 arguments."	^self valueWithArguments: 		(Array			with: arg1			with: arg2			with: arg3			with: arg4)! !!TBlock methodsFor: 'evaluating' stamp: 'pmm 6/19/2006 19:05'!valueWithArguments: anArray 	"Evaluate the block with given args. Fail if the block expects other than the given number of arguments."	self explicitRequirement! !!TBlock methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:32'!valueWithPossibleArgs: anArray	 "Evaluate the block represented by the receiver.      If the block requires arguments, take them from anArray. If anArray is too     large, the rest is ignored, if it is too small, use nil for the other arguments"	| numArgs |	numArgs := self numArgs.	numArgs = 0 ifTrue: [^ self value].	numArgs = anArray size ifTrue: [^ self valueWithArguments: anArray].	^ self valueWithArguments: (numArgs > anArray size		ifTrue: [anArray, (Array new: numArgs - anArray size)]		ifFalse: [anArray copyFrom: 1 to: numArgs])! !!TBlock methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:31'!valueWithPossibleArgument: anArg      "Evaluate the block represented by the receiver.      If the block requires one argument, use anArg, if it requires more than one,     fill up the rest with nils."	| numArgs |	numArgs := self numArgs.	numArgs = 0 ifTrue: [^self value].	numArgs = 1 ifTrue: [^self value: anArg].	numArgs  > 1 ifTrue: [^self valueWithArguments: {anArg}, (Array new: numArgs  - 1)]! !!TBlock methodsFor: 'evaluating' stamp: 'pmm 5/1/2006 12:32'!valueWithin: aDuration onTimeout: timeoutBlock	"Evaluate the receiver.	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"	| theProcess delay watchdog done result |	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := aDuration asDelay.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		done ifFalse: [ theProcess signalException: TimedOut ] 	] newProcess.	"watchdog needs to run at high priority to do its job"	watchdog priority: Processor timingPriority.	"catch the timeout signal"	^ [	done := false.		watchdog resume.				"start up the watchdog"		result := self value.				"evaluate the receiver"		done := true.						"it has completed, so ..."		delay delaySemaphore signal.	"arrange for the watchdog to exit"		result ]			on: TimedOut do: [ :e | timeoutBlock value ].! !!TBlock methodsFor: 'private' stamp: 'pmm 5/1/2006 12:36'!copyForSaving	"obsolete"! !!TBlock methodsFor: 'private' stamp: 'pmm 5/1/2006 12:36'!fixTemps	"obsolete"! !!TBlock methodsFor: 'private' stamp: 'pmm 5/1/2006 12:36'!valueError	self error: 'Incompatible number of args'! !!TBlock methodsFor: 'controlling' stamp: 'pmm 5/1/2006 12:16'!doWhileFalse: conditionBlock	"Evaluate the receiver once, then again as long the value of conditionBlock is false." 	| result |	[result := self value.	conditionBlock value] whileFalse.	^ result! !!TBlock methodsFor: 'controlling' stamp: 'pmm 5/1/2006 12:17'!doWhileTrue: conditionBlock	"Evaluate the receiver once, then again as long the value of conditionBlock is true." 	| result |	[result := self value.	conditionBlock value] whileTrue.	^ result! !!TBlock methodsFor: 'controlling' stamp: 'pmm 5/1/2006 12:17'!repeat	"Evaluate the receiver repeatedly, ending only if the block explicitly returns."	[self value. true] whileTrue! !!TBlock methodsFor: 'controlling' stamp: 'pmm 5/1/2006 12:18'!repeatWithGCIf: testBlock	| ans |	"run the receiver, and if testBlock returns true, garbage collect and run the receiver again"	ans := self value.	(testBlock value: ans) ifTrue: [ Smalltalk garbageCollect. ans := self value ].	^ans! !!TBlock methodsFor: 'controlling' stamp: 'pmm 5/1/2006 12:18'!whileFalse	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the receiver, as long as its value is false." 	^ [self value] whileFalse: []! !!TBlock methodsFor: 'controlling' stamp: 'pmm 5/1/2006 12:18'!whileFalse: aBlock 	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the argument, aBlock, as long as the value of the receiver is false."	^ [self value] whileFalse: [aBlock value]! !!TBlock methodsFor: 'controlling' stamp: 'pmm 5/1/2006 12:19'!whileTrue	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the receiver, as long as its value is true." 	^ [self value] whileTrue: []! !!TBlock methodsFor: 'controlling' stamp: 'pmm 5/1/2006 12:19'!whileTrue: aBlock 	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the argument, aBlock, as long as the value of the receiver is true."	^ [self value] whileTrue: [aBlock value]! !!TBlock methodsFor: 'scheduling' stamp: 'pmm 5/1/2006 12:37'!fork	"Create and schedule a Process running the code in the receiver."	^ self newProcess resume! !!TBlock methodsFor: 'scheduling' stamp: 'pmm 5/1/2006 12:37'!forkAndWait	"Suspend current process while self runs"	| semaphore |	semaphore := Semaphore new.	[self ensure: [semaphore signal]] fork.	semaphore wait.! !!TBlock methodsFor: 'scheduling' stamp: 'pmm 5/1/2006 12:38'!forkAt: priority 	"Create and schedule a Process running the code in the receiver at the given priority. Answer the newly created process."	^ self newProcess		priority: priority;		resume! !!TBlock methodsFor: 'scheduling' stamp: 'pmm 5/1/2006 12:38'!forkAt: priority named: name	"Create and schedule a Process running the code in the receiver at the	given priority and having the given name. Answer the newly created 	process."	| forkedProcess |	forkedProcess := self newProcess.	forkedProcess priority: priority.	forkedProcess name: name.	^ forkedProcess resume! !!TBlock methodsFor: 'scheduling' stamp: 'pmm 5/1/2006 12:38'!forkNamed: aString	"Create and schedule a Process running the code in the receiver and	having the given name."	^ self newProcess name: aString; resume! !!TBlock methodsFor: 'scheduling' stamp: 'pmm 5/1/2006 12:38'!newProcess	"Answer a Process running the code in the receiver. The process is not 	scheduled."	<primitive: 19> "Simulation guard"	^ Process		forContext: 			[self value.			Processor terminateActive] asContext		priority: Processor activePriority! !!TBlock methodsFor: 'scheduling' stamp: 'pmm 5/1/2006 12:39'!simulate	"Like run except interpret self using Smalltalk instead of VM.  It is much slower."	^ self newProcess simulate! !!TBlock methodsFor: 'accessing' stamp: 'pmm 5/1/2006 12:14'!isBlock	^ true! !!TBlock methodsFor: 'accessing' stamp: 'pmm 6/19/2006 19:05'!numArgs	self explicitRequirement! !!TBlock commentStamp: 'pmm 5/1/2006 12:17' prior: 0!I define the behavoir of blocks.!!TCLCodeInterpreter methodsFor: 'accessing' stamp: 'pmm 4/28/2006 19:57'!blockInterpreterClass	^CLBlockInterpreter! !!TCLCodeInterpreter methodsFor: 'visiting' stamp: 'pmm 4/28/2006 20:45'!visitNode: aNode	aNode markExecuted.	^super visitNode: aNode! !!TCLShouldInstrument methodsFor: 'testing' stamp: 'pmm 11/27/2006 09:22'!shouldInstrument: aNode	^(aNode isVariable and: [ aNode isRead ])		or: [ aNode isAssignment		or: [ aNode isMessage		or: [ aNode isLiteral		or: [ aNode isReturn		or: [ aNode isBlock		or: [ aNode isSequence ]]]]]]! !!TCompilingBehavior methodsFor: '*persephone-override' stamp: 'md 3/31/2007 19:14'!compilerClass	"Answer a compiler class appropriate for source methods of this class."	^(Preferences compileReflectiveMethods) ifTrue: [PECompiler] ifFalse: [Compiler]. ! !!TCompilingBehavior methodsFor: '*persephone-override' stamp: 'md 7/24/2007 14:51'!evaluatorClass	^self compilerClass! !!TCompilingBehavior methodsFor: '*persephone-override' stamp: 'md 3/21/2007 14:04'!recompile: selector from: oldClass	"Compile the method associated with selector in the receiver's method dictionary."	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"	| method trailer methodNode rMethod |		Preferences compileReflectiveMethods ifTrue: [		self flag: #FIXME. "This needs to be checked and removed".		rMethod := (oldClass >> selector) reflectiveMethodOrNil.		(rMethod notNil and: [ rMethod hasMethodClass not ]) 			ifTrue: [ rMethod methodClass: oldClass ].	].	method _ oldClass compiledMethodAt: selector.	trailer _ method trailer.	methodNode _ self compilerClass new				compile: (oldClass sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	self basicAddSelector: selector withMethod: (methodNode generate: trailer).! !!TJMethod commentStamp: 'pmm 6/19/2006 19:08' prior: 0!This trait makes sure you get JMethods in your class.!!TJMethod classTrait methodsFor: 'accessing' stamp: 'md 3/31/2007 19:14'!compilerClass	^PECompiler! !!TJMethod classTrait methodsFor: 'accessing' stamp: 'md 3/20/2007 17:24'!parseTreeFor: aSymbol	^(self compiledMethodAt: aSymbol) reflectiveMethod methodNode! !!TJMethod classTrait methodsFor: 'compiling' stamp: 'md 3/20/2007 17:28'!recompile: selector from: oldClass	| jMethod |	jMethod := (oldClass >> selector) reflectiveMethodOrNil.	(jMethod notNil and: [ jMethod hasMethodClass not ]) ifTrue: [ jMethod methodClass: oldClass ].	super recompile: selector from: oldClass.	! !!TPureBehavior methodsFor: '*ast' stamp: 'md 4/16/2007 10:41'!parseTreeFor: aSymbol		self flag: #FIXME.	"UGLY hack for beeing able to share AST package with Persephone... this	 needs to be fixed later".		Smalltalk at: #ReflectiveMethod ifPresent: [:cls | 	| method |		method := self compiledMethodAt: aSymbol.		method hasReflectiveMethod ifTrue: [^method reflectiveMethod methodNode].	].	^RBParser parseMethod: (self sourceCodeAt: aSymbol)		onError: [:aString :pos | ^nil]! !!TReflectiveMethods commentStamp: 'md 3/31/2007 19:11' prior: 0!This trait makes sure you get ReflectiveMethod in your class, even when the compiler option is turned off. Good for testing!!TReflectiveMethods classTrait methodsFor: 'compiling' stamp: 'md 3/31/2007 19:14'!compilerClass	^PECompiler! !!TReflectiveMethods classTrait methodsFor: 'compiling' stamp: 'md 3/31/2007 19:09'!parseTreeFor: aSymbol	^(self compiledMethodAt: aSymbol) reflectiveMethod methodNode! !!TReflectiveMethods classTrait methodsFor: 'compiling' stamp: 'md 3/31/2007 19:09'!recompile: selector from: oldClass	| jMethod |	jMethod := (oldClass >> selector) reflectiveMethodOrNil.	(jMethod notNil and: [ jMethod hasMethodClass not ]) ifTrue: [ jMethod methodClass: oldClass ].	super recompile: selector from: oldClass.	! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 2/28/2002 00:06'!addPane: swapPane named: aString hidden: hidden closeable: closeable swapModel: swapModel 	self addSwapPane: swapPane.	swapPane name: aString;		 setProperty: #closeable toValue: closeable;		 setProperty: #swapModel toValue: swapModel.	hidden		ifTrue: [self hidePaneNamed: aString]		ifFalse: [self showPaneNamed: aString]! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 3/1/2002 23:15'!allSwappedPaneNamesWithModels	| panes pane |	panes _ OrderedCollection new.	tabs		do: [:tabName | 			pane _ self findPaneNamed: tabName.			pane isNil				ifFalse: [(pane hasProperty: #swapModel)						ifTrue: [panes								add: (pane valueOfProperty: #swapModel)]]].	^panes! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 2/27/2002 18:34'!bringPaneToFrontNamed: aString 	self showPaneNamed: aString! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 2/27/2002 18:09'!closeAllPanes	"Close all the closeable tabs."	tabs		do: [:paneName | self closePaneNamed: paneName]! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 6/18/2004 22:12'!closeFrontPane	| nextPane |	nextPane _ self nameOfPaneToLeftOfFrontPane.	self closePane: frontMost.	nextPane isNil ifFalse: [self showPaneNamed: nextPane]! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 2/27/2002 18:07'!closePaneNamed: aString 	self closePane: (self findPaneNamed: aString)! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 2/27/2002 18:23'!defaultPaneName: aString 	defaultPaneName _ aString! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 3/1/2002 23:20'!frontMost	^frontMost! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 3/1/2002 23:17'!frontMostPaneIsCloseable	"Answers if the front most pane is closeable. Note if the front most pane 	is undefined we answer false."	frontMost isNil		ifFalse: [(frontMost hasProperty: #closeable)				ifTrue: [^ frontMost valueOfProperty: #closeable]].	^ false! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 2/27/2002 13:45'!okayToCloseAllPanes! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 2/27/2002 18:11'!paneFocusedColor: aColor 	paneFocusedColor _ aColor! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 2/27/2002 18:19'!possibleTabStateChange: paneName 	self indicateTabChanged: paneName! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 3/10/2002 15:40'!setMoverButtonColors: aColor 	| bName btn |	self moverButtonSpecs do: [:spec |		bName _ spec second.		btn _ self findPaneNamed: bName.		btn isNil ifFalse: [btn color: aColor]]! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 2/27/2002 18:34'!showDefaultPane	"Show a pane when there is no other pane to show."	defaultPaneName isNil		ifFalse: [self showPaneNamed: defaultPaneName]! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 2/28/2002 00:31'!showMover	showMover == nil ifTrue: [showMover _ true].	^showMover! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 2/28/2002 00:30'!showMover: boolean	showMover _ boolean! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 3/1/2002 23:24'!swappedPanesIncludePaneNamed: aString	^tabs includes: aString! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 2/27/2002 17:00'!tabFeedbackColor: aColor	tabFeedbackColor _ aColor! !!TabbedSwappingControl methodsFor: 'public API' stamp: 'sbw 2/27/2002 13:45'!updatePaneNamed: aString with: update! !!TabbedSwappingControl methodsFor: 'private' stamp: 'sbw 5/2/2004 22:52'!addPaneNameToTabs: aString 	"We're going to add the button too."	| swapper btn |	swapper := self findPaneNamed: 'swap'.	swapper isNil		ifTrue: [^ nil].	btn := PluggableButtonIRCeMorph				on: [self showPaneNamed: aString]				getState: nil				action: #value.	btn color: Color white;		 hResizing: #shrinkWrap;		 vResizing: #spaceFill;		 label: aString;		 onColor: Color white offColor: Color white;		 feedbackColor: self tabFeedbackColor.	swapper addMorphBack: btn.	tabs add: aString.	^ btn! !!TabbedSwappingControl methodsFor: 'private' stamp: 'sbw 3/1/2002 18:54'!addSwapPane: swapPane 	"private"	self		addSwapPane: swapPane		to: self		fractions: (0 @ 0 corner: 1 @ 1)		offsets: self swapPaneOffsets! !!TabbedSwappingControl methodsFor: 'private' stamp: 'sbw 2/27/2002 16:41'!addSwapPane: swapPane to: parentMorph fractions: fractions offsets: offsets 	"private"	parentMorph		addMorph: swapPane		fullFrame: (LayoutFrame fractions: fractions offsets: offsets)! !!TabbedSwappingControl methodsFor: 'private' stamp: 'sbw 5/12/2004 07:08'!addTabControlMoversToParent: morphParent layout: layout 	| alignMorph buttons |	buttons := self moverButtons.	Preferences alternativeWindowLook 	ifTrue: [buttons color: Color transparent. 	buttons 	submorphsDo: [:m | m borderWidth: 2; 	borderColor: #raised]].	alignMorph := AlignmentMorph newRow beSticky; clipSubmorphs: true; layoutInset: 0; cellInset: 0; borderWidth: 0; name: 'movers'; color: Color white.	alignMorph		addMorph: buttons		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ 0)).	morphParent addMorph: alignMorph fullFrame: layout! !!TabbedSwappingControl methodsFor: 'private' stamp: 'sbw 3/9/2002 21:59'!addTabControlPane	| alignMorph |	alignMorph _ AlignmentMorph newRow.	alignMorph beSticky; clipSubmorphs: true; layoutInset: self tabLayoutInset; cellInset: 2; borderWidth: 0; borderColor: Color transparent; name: 'swap'.	alignMorph color: Color transparent.	self addMorph: alignMorph fullFrame: self tabControlPaneLayout.	Preferences alternativeWindowLook		ifTrue: [alignMorph borderWidth: 2]		ifFalse: [alignMorph borderWidth: 0].	self showMover		ifTrue: [self addTabControlMoversToParent: self layout: self tabControlMoversLayout]! !!TabbedSwappingControl methodsFor: 'private' stamp: 'sbw 3/1/2002 19:01'!findPaneNamed: aString 	^ self		submorphNamed: aString		ifNone: []! !!TabbedSwappingControl methodsFor: 'private' stamp: 'sbw 3/1/2002 19:25'!initialize: orientation 	"private"	super initialize.	self layoutInset: 0@0;		 cellInset: 2;		 borderWidth: 0;		 borderColor: Color transparent;		 layoutPolicy: ProportionalLayout new.	tabs _ Set new.	self orientation: orientation.	self addTabControlPane! !!TabbedSwappingControl methodsFor: 'private' stamp: 'sbw 5/12/2004 07:01'!moverButtonSpecs	"button label, button name, selector, status, help text, on color, off color"	^{		{'<'. 'moveTabLeft'.	#moveTabLeft. 		#none.	'Moves the selected tab to the left'. 	#none. #none}.		{'>'. 'moveTabRight'.	#moveTabRight. 	#none. 	'Moves the selected tab to the right'.	#none. #none}.		{'x'. 'closeTab'. 		#closeFrontPane. 	#none. 	'Closes the selected tab'. 				#none. #none}		}! !!TabbedSwappingControl methodsFor: 'private' stamp: 'sbw 5/13/2004 11:03'!moverButtons	| aRow btn onColor offColor |	aRow := AlignmentMorph newRow beSticky; borderWidth: 0; borderColor: Color transparent.	aRow color: Color transparent.	aRow clipSubmorphs: true.	aRow layoutInset: 1 @ 2;		 cellInset: 1.	self moverButtonSpecs		do: [:spec | 			btn := PluggableButtonIRCeMorph						on: self						getState: (spec fourth = #none								ifFalse: [spec fourth])						action: spec third.			btn color: Color transparent;				 hResizing: #spaceFill;				 vResizing: #spaceFill;				 useRoundedCorners;				 name: spec second;				 label: spec first asString.			onColor := spec sixth = #none						ifTrue: [Color transparent]						ifFalse: [self perform: spec sixth].			offColor := spec seventh = #none						ifTrue: [Color transparent]						ifFalse: [self perform: spec seventh].			btn onColor: onColor offColor: offColor.			aRow addMorphBack: btn.			btn setBalloonText: spec fifth].	^ aRow! !!TabbedSwappingControl methodsFor: 'private' stamp: 'sbw 2/27/2002 16:50'!orientation	^tabQuadrant! !!TabbedSwappingControl methodsFor: 'private' stamp: 'sbw 2/27/2002 16:42'!orientation: aSymbol 	"private"	tabQuadrant _ (#(#top #bottom #left #right ) includes: aSymbol)				ifTrue: [aSymbol]				ifFalse: [#top]! !!TabbedSwappingControl methodsFor: 'private' stamp: 'sbw 2/27/2002 21:43'!pvtHidePaneNamed: paneName 	| pane |	pane _ self findPaneNamed: paneName.	(tabs includes: paneName)		ifFalse: [self addPaneNameToTabs: paneName].	pane hide! !!TabbedSwappingControl methodsFor: 'private' stamp: 'sbw 2/27/2002 16:53'!swapPaneOffsets	self orientation = #left ifTrue: [^ self swapControlsDimension @ 0 corner: 0 @ 0].	self orientation = #right ifTrue: [^ 0 @ 0 corner: self swapControlsDimension negated @ 0].	self orientation = #bottom ifTrue: [^ 0 @ 0 corner: 0 @ self swapControlsDimension negated].	^ 0 @ self swapControlsDimension corner: 0 @ 0! !!TabbedSwappingControl methodsFor: 'private' stamp: 'sbw 3/1/2002 22:17'!tabControlMoversLayout	self orientation = #left		ifTrue: [^ LayoutFrame				fractions: (0 @ 0 corner: 0 @ 0)				offsets: (0 @ 0 corner: self swapControlsDimension @ self controlMoversDimension)].	self orientation = #right		ifTrue: [^ LayoutFrame				fractions: (1 @ 1 corner: 1 @ 1)				offsets: (self swapControlsDimension negated @ self controlMoversDimension negated corner: 0 @ 0)].	self orientation = #bottom		ifTrue: [^ LayoutFrame				fractions: (1 @ 1 corner: 1 @ 1)				offsets: (self controlMoversDimension negated @ self swapControlsDimension negated corner: 0 @ 0)].	"top"	^ LayoutFrame		fractions: (1 @ 0 corner: 1 @ 0)		offsets: (self controlMoversDimension negated @ 0 corner: 0 @ self swapControlsDimension)! !!TabbedSwappingControl methodsFor: 'private' stamp: 'sbw 3/1/2002 19:30'!tabControlPaneLayout	self orientation = #left		ifTrue: [^ LayoutFrame				fractions: (0 @ 0 corner: 0 @ 1)				offsets: (0 @ 0 corner: self swapControlsDimension @ 0)].	self orientation = #right		ifTrue: [^ LayoutFrame				fractions: (1 @ 0 corner: 1 @ 1)				offsets: (self swapControlsDimension negated @ 0 corner: 0 @ 0)].	self orientation = #bottom		ifTrue: [^ LayoutFrame				fractions: (0 @ 1 corner: 1 @ 1)				offsets: (0 @ (self swapControlsDimension + 1) negated corner: 0 @ 0)].	"top"	^ LayoutFrame		fractions: (0 @ 0 corner: 1 @ 0)		offsets: (0 @ 0 corner: self controlMoversDimension negated @ self swapControlsDimension)! !!TabbedSwappingControl methodsFor: 'private' stamp: 'sbw 3/1/2002 19:27'!tabLayoutInset	self orientation = #left		ifTrue: [^ 1 @ 2].	self orientation = #right		ifTrue: [^ -1 @ 2].	self orientation = #bottom		ifTrue: [^ 2 @ -8].	"top"	^ 2 @ 1! !!TabbedSwappingControl methodsFor: 'pane operations' stamp: 'sbw 2/27/2002 18:06'!closePane: aPane 	"If the pane has the closeable property defined AND that  	property value allows closing, then close the pane."	aPane isNil		ifTrue: [^ nil].	(aPane hasProperty: #closeable)		ifTrue: [(aPane valueOfProperty: #closeable)				ifTrue: [self removeSwapPane: aPane]]! !!TabbedSwappingControl methodsFor: 'pane operations' stamp: 'sbw 2/27/2002 18:33'!hidePaneNamed: paneName 	| pane |	pane _ self findPaneNamed: paneName.	pane isNil		ifTrue: [^ nil].	pane = frontMost		ifTrue: [^ nil].	(tabs includes: paneName)		ifFalse: [self addPaneNameToTabs: paneName].	pane hide! !!TabbedSwappingControl methodsFor: 'pane operations' stamp: 'sbw 5/11/2004 21:43'!highlightPaneTabNamed: paneName 	| swapper btn coll pane btns |	pane := self findPaneNamed: paneName.	pane isNil		ifTrue: [^ nil].	pane = frontMost		ifTrue: [^ nil].	swapper := self findPaneNamed: 'swap'.	swapper isNil		ifTrue: [^ nil].	self resetPaneTabColors.	btns := swapper submorphs				select: [:m | m isKindOf: PluggableButtonIRCeMorph].	coll := btns				select: [:m | m label asString = paneName].	coll isEmpty		ifTrue: [^ nil].	btn := coll first.	btn offColor: self paneFocusedColor! !!TabbedSwappingControl methodsFor: 'pane operations' stamp: 'sbw 5/2/2004 22:52'!indicateTabChanged: paneName 	"<aString> is name of pane where something changed while we were on  	another pane."	| swapper coll btn pane btns |	pane := self findPaneNamed: paneName.	pane isNil		ifTrue: [^ nil].	pane = frontMost		ifTrue: [^ nil].	swapper := self findPaneNamed: 'swap'.	swapper isNil		ifTrue: [^ nil].	btns := swapper submorphs				select: [:m | m isKindOf: PluggableButtonIRCeMorph].	coll := btns				select: [:m | m label asString = paneName].	coll isEmpty		ifTrue: [^ nil].	btn := coll first.	btn showSelectionFeedback: true.	btn feedbackColor: self tabFeedbackColor! !!TabbedSwappingControl methodsFor: 'pane operations' stamp: 'sbw 5/2/2004 22:52'!moveTabLeft	| paneName swapper coll btn btns |	frontMost isNil		ifTrue: [^ nil].	paneName := frontMost externalName.	swapper := self findPaneNamed: 'swap'.	swapper isNil		ifTrue: [^ nil].	btns := swapper submorphs				select: [:m | m isKindOf: PluggableButtonIRCeMorph].	coll := btns				select: [:m | m label asString = paneName].	coll isEmpty		ifTrue: [^ nil].	btn := coll first.	swapper decrementIndexPositionOfSubmorph: btn! !!TabbedSwappingControl methodsFor: 'pane operations' stamp: 'sbw 5/2/2004 22:53'!moveTabRight	| paneName swapper coll btn btns |	frontMost isNil		ifTrue: [^ nil].	paneName := frontMost externalName.	swapper := self findPaneNamed: 'swap'.	swapper isNil		ifTrue: [^ nil].	btns := swapper submorphs				select: [:m | m isKindOf: PluggableButtonIRCeMorph].	coll := btns				select: [:m | m label asString = paneName].	coll isEmpty		ifTrue: [^ nil].	btn := coll first.	swapper incrementIndexPositionOfSubmorph: btn! !!TabbedSwappingControl methodsFor: 'pane operations' stamp: 'sbw 6/18/2004 22:11'!nameOfPaneToLeftOfFrontPane	| indexOfFrontPane indexOfLeftPane targetPane targetPaneName swapper subs |	frontMost isNil		ifTrue: [^ nil].	swapper _ self findPaneNamed: 'swap'.	swapper isNil		ifTrue: [^ nil].	subs _ swapper submorphs.	subs isSequenceable		ifFalse: [^ nil].	indexOfFrontPane _ (subs collect: [:each | each label]) indexOf: frontMost externalName.	indexOfFrontPane <= 1		ifTrue: [^ nil].	indexOfLeftPane _ indexOfFrontPane - 1.	targetPane _ subs at: indexOfLeftPane.	targetPaneName _ targetPane label.	(targetPaneName = 'console' or: [targetPaneName = 'private messages'] or: [targetPaneName = 'movers']) ifTrue: [^nil].	^ targetPaneName! !!TabbedSwappingControl methodsFor: 'pane operations' stamp: 'sbw 2/27/2002 18:31'!removeSwapPane: swapPane 	| paneName pane swapModel okayToClose |	paneName _ swapPane externalName.	pane _ self findPaneNamed: paneName.	pane isNil		ifTrue: [^ nil].	(tabs includes: paneName)		ifTrue: [(swapPane hasProperty: #swapModel)				ifTrue: [swapModel _ swapPane valueOfProperty: #swapModel.						okayToClose _ (swapModel respondsTo: #aboutToBeClosed)							ifTrue: [swapModel perform: #aboutToBeClosed]							ifFalse: [true].						okayToClose						ifTrue: [(self removeTabNamed: paneName)								ifTrue: [swapPane delete.									self showDefaultPane]]]]! !!TabbedSwappingControl methodsFor: 'pane operations' stamp: 'sbw 5/2/2004 22:53'!removeTabNamed: aString 	| swapper btn buttons candidateMorphs |	swapper := self findPaneNamed: 'swap'.	swapper isNil		ifTrue: [^ false].	buttons := swapper submorphs				select: [:m | m isKindOf: PluggableButtonIRCeMorph].	candidateMorphs := buttons				select: [:m | m label = aString].	candidateMorphs isEmpty		ifTrue: [^ false].	candidateMorphs size > 1		ifTrue: [^ false].	btn := candidateMorphs first.	tabs		remove: aString		ifAbsent: [^ false].	btn delete.	^ true! !!TabbedSwappingControl methodsFor: 'pane operations' stamp: 'sbw 5/2/2004 22:53'!resetPaneTabColors	| swapper |	swapper := self findPaneNamed: 'swap'.	swapper isNil		ifTrue: [^ nil].	(swapper submorphs		select: [:m | m isKindOf: PluggableButtonIRCeMorph])		do: [:btn | btn offColor: Color white]! !!TabbedSwappingControl methodsFor: 'pane operations' stamp: 'sbw 3/14/2005 21:52'!showPaneNamed: paneName 	| pane |	pane := self findPaneNamed: paneName.	pane isNil		ifTrue: [^ nil].	pane = frontMost		ifTrue: [^ nil].	frontMost isNil		ifFalse: [frontMost hide].	(tabs includes: paneName)		ifFalse: [self addPaneNameToTabs: paneName].	self highlightPaneTabNamed: paneName.	frontMost := pane.	frontMost show; changed.	self owner isNil		ifFalse: [self owner activate]! !!TabbedSwappingControl methodsFor: 'constants' stamp: 'sbw 2/28/2002 00:32'!controlMoversDimension	^self showMover		ifTrue: [60]		ifFalse: [0]! !!TabbedSwappingControl methodsFor: 'constants' stamp: 'sbw 2/27/2002 16:49'!swapControlsDimension	^20! !!TabbedSwappingControl methodsFor: 'colors' stamp: 'sbw 5/11/2004 21:53'!paneFocusedColor	paneFocusedColor == nil		ifTrue: [paneFocusedColor := Color lightYellow darker].	^ paneFocusedColor! !!TabbedSwappingControl methodsFor: 'colors' stamp: 'sbw 2/27/2002 17:01'!tabFeedbackColor	tabFeedbackColor == nil		ifTrue: [tabFeedbackColor _ Color lightRed].	^ tabFeedbackColor! !!TabbedSwappingControl commentStamp: '<historical>' prior: 0!Pluggable alignment pane that supports child morph panes swapped via tab bar.The "public-API" category show all methods available to the consumer of this morph.!!TabbedSwappingControl class methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 19:03'!newSwapControlPaneOrientation: orientation showMover: boolean 	^ self newColumn showMover: boolean;		 initialize: orientation! !!TempVar methodsFor: 'comparing' stamp: 'ms 6/15/2007 14:02'!= aTempVar	^aTempVar class = self class 		and: [aTempVar scope = self scope 			and:[aTempVar index = self index] 			and: [aTempVar isArg = self isArg] 			and: [aTempVar name = self name] 			and: [self privUsage = aTempVar privUsage]]	! !!TempVar methodsFor: 'comparing' stamp: 'ms 6/26/2007 03:04'!hash	^index! !!TempVar methodsFor: 'initializing' stamp: 'ajh 6/29/2004 17:05'!becomeCaptured	"TempVar has to become a captured var so parse tree var nodes will point to the captured var. Use change-class instead of become for speed. In order to do this both TempVar and CapturedVar has to have the same number of inst vars"	isArg "sourceTemp" _ nil.	self primitiveChangeClassTo: CapturedVar basicNew.! !!TempVar methodsFor: 'initializing' stamp: 'ms 7/28/2007 23:41'!initialize	canBeCapture := true! !!TempVar methodsFor: 'read/write usage' stamp: 'ms 7/28/2007 20:28'!cantBeCapture	canBeCapture := false! !!TempVar methodsFor: 'read/write usage' stamp: 'ajh 6/25/2004 22:11'!isArg	^ isArg = true! !!TempVar methodsFor: 'read/write usage' stamp: 'ms 7/5/2007 19:57'!isArg: aBool	isArg := aBool! !!TempVar methodsFor: 'read/write usage' stamp: 'ms 7/28/2007 20:30'!itCanBeCapture	^canBeCapture! !!TempVar methodsFor: 'read/write usage' stamp: 'ms 6/15/2007 13:40'!markArg	isArg := true.	usage := #arg! !!TempVar methodsFor: 'emitting' stamp: 'md 3/10/2006 16:27'!emitEnvStore: methodBuilder	(Preferences compileBlocksAsClosures or: [self scope isDoItScope])		ifTrue: [ self scope isDoItScope ifFalse: [self error: 'should have been captured'].				  methodBuilder storeInstVar: (MethodContext instSize + self index).]		ifFalse: [ self emitLocalStore: methodBuilder].! !!TempVar methodsFor: 'emitting' stamp: 'ms 7/1/2007 23:07'!emitEnvValue: methodBuilder	(Preferences compileBlocksAsClosures or: [self scope isDoItScope]) 		ifTrue: [			self scope isDoItScope ifFalse: [self error: 'should have been captured'].			methodBuilder pushInstVar: (MethodContext instSize + self index)]		ifFalse: [self emitLocalValue: methodBuilder].! !!TempVar methodsFor: 'emitting' stamp: 'ajh 7/8/2004 14:10'!emitLocalStore: methodBuilder	methodBuilder storeTemp: self.! !!TempVar methodsFor: 'emitting' stamp: 'ajh 7/8/2004 14:10'!emitLocalValue: methodBuilder	methodBuilder pushTemp: self.! !!TempVar methodsFor: 'accessing' stamp: 'ajh 6/23/2004 23:18'!isTemp	^ true! !!TemporaryToInstanceVariableRefactoring methodsFor: 'preconditions'!checkForValidTemporaryVariable	| parseTree |	parseTree := class parseTreeFor: selector.	(parseTree allTemporaryVariables includes: temporaryVariableName) 		ifFalse: 			[self refactoringError: temporaryVariableName 						, ' isn''t a valid temporary variable name'].	(parseTree allArgumentVariables includes: temporaryVariableName) 		ifTrue: 			[self refactoringError: temporaryVariableName , ' is a block parameter'].	(RBReadBeforeWrittenTester isVariable: temporaryVariableName		readBeforeWrittenIn: parseTree) 			ifTrue: 				[self 					refactoringWarning: ('<1s> is read before it is written.<n>Proceed anyway?' 							expandMacrosWith: temporaryVariableName)]! !!TemporaryToInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition hierarchyOf: class				definesVariable: temporaryVariableName asString) not 			& (RBCondition withBlock: 						[self checkForValidTemporaryVariable.						true])! !!TemporaryToInstanceVariableRefactoring methodsFor: 'initialize-release'!class: aClass selector: aSelector variable: aVariableName 	class := self classObjectFor: aClass.	selector := aSelector.	temporaryVariableName := aVariableName! !!TemporaryToInstanceVariableRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' class: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: selector;		nextPutAll: ' variable: ''';		nextPutAll: temporaryVariableName;		nextPut: $'.	aStream nextPut: $)! !!TemporaryToInstanceVariableRefactoring methodsFor: 'transforming'!transform	| parseTree matcher protocols |	parseTree := class parseTreeFor: selector.	parseTree isNil ifTrue: [self refactoringError: 'Could not parse method'].	protocols := class protocolsFor: selector.	class removeMethod: selector.	class addInstanceVariable: temporaryVariableName.	(matcher := ParseTreeRewriter removeTemporaryNamed: temporaryVariableName) 		executeTree: parseTree.	class compileTree: matcher tree classified: protocols! !!TemporaryToInstanceVariableRefactoring class methodsFor: 'instance creation'!class: aClass selector: aSelector variable: aVariableName 	^self new 		class: aClass		selector: aSelector		variable: aVariableName! !!TemporaryToInstanceVariableRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk class: aClass selector: aSelector variable: aVariableName 	^(self new)		model: aRBSmalltalk;		class: aClass			selector: aSelector			variable: aVariableName;		yourself! !!TemporaryToInstanceVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!TemporaryToInstanceVariableTest methodsFor: 'failure tests'!testNonExistantName	self		shouldFail: (TemporaryToInstanceVariableRefactoring 					class: BasicLintRuleTest					selector: #checkClass:					variable: 'asdf');		shouldFail: (TemporaryToInstanceVariableRefactoring 					class: BasicLintRuleTest					selector: #checkClass1:					variable: 'aSmalllintContext')! !!TemporaryToInstanceVariableTest methodsFor: 'failure tests'!testRedefinedTemporary	| class |	class := model classNamed: #Foo.	class 		compile: 'someMethod | instVarName1 | instVarName1 := 4. ^instVarName1'		classified: #(#accessing).	self shouldFail: (TemporaryToInstanceVariableRefactoring 				class: class				selector: #someMethod				variable: 'instVarName1')! !!TemporaryToInstanceVariableTest methodsFor: 'tests'!testTemporaryToInstanceVariable	| refactoring class |	refactoring := TemporaryToInstanceVariableRefactoring 				class: LintRuleTest				selector: #displayName				variable: 'nameStream'.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #LintRuleTest.	self 		assert: (class parseTreeFor: #displayName) = (RBParser 						parseMethod: 'displayName								nameStream := WriteStream on: (String new: 64).								nameStream									nextPutAll: self name;									nextPutAll: '' (''.								self problemCount printOn: nameStream.								nameStream nextPut: $).								^nameStream contents').	self assert: (class directlyDefinesInstanceVariable: 'nameStream')! !!TestCase methodsFor: '*Toothpick-Tests' stamp: 'jp 10/13/2006 12:32'!assert: expected equals: actual	expected = actual ifFalse: [self signalFailure: 'Assertion failed']			! !!TestDynamicVariable commentStamp: 'mvl 3/13/2007 13:51' prior: 0!TestDynamicVariable is a test class using in ProcessSpecificTest.!!TestLocalVariable commentStamp: 'mvl 3/13/2007 13:52' prior: 0!TestLocalVariable is a test class using in ProcessSpecificTest.!!TestLocalVariable class methodsFor: 'as yet unclassified' stamp: 'mvl 3/13/2007 14:54'!default	"My default value for a new process is 0."		^0! !!TestRunnerContext class methodsFor: 'as yet unclassified' stamp: 'md 7/26/2007 12:05'!isActive	^Preferences deploymentContext! !!TextMorphForInterceptingIRCEditView methodsFor: 'as yet unclassified' stamp: 'sbw 2/23/2002 12:49'!addIntercept: char 	self intercepts add: char! !!TextMorphForInterceptingIRCEditView methodsFor: 'as yet unclassified' stamp: 'sbw 2/23/2002 16:17'!clearInterceptActiveinterceptActive _ false! !!TextMorphForInterceptingIRCEditView methodsFor: 'as yet unclassified' stamp: 'sbw 2/23/2002 12:52'!flushIntercepts	self initializeIntercepts! !!TextMorphForInterceptingIRCEditView methodsFor: 'as yet unclassified' stamp: 'sbw 3/13/2002 15:35'!giveInterceptedEventToModel: evt 	"Give event to model. If model returns true then pass evt to super as  	keystroke."	| rcvr |	rcvr _ interceptor isNil		ifTrue: [self editView model ]		ifFalse: [interceptor].	(rcvr keyInterceptedEvent: evt morph: self editView)		ifTrue: [super keyStroke: evt]! !!TextMorphForInterceptingIRCEditView methodsFor: 'as yet unclassified' stamp: 'sbw 2/23/2002 12:48'!initialize	super initialize.	self initializeIntercepts! !!TextMorphForInterceptingIRCEditView methodsFor: 'as yet unclassified' stamp: 'sbw 2/23/2002 12:47'!initializeIntercepts	intercepts _ Set new! !!TextMorphForInterceptingIRCEditView methodsFor: 'as yet unclassified' stamp: 'sbw 2/23/2002 16:18'!interceptActive	interceptActive == nil		ifTrue: [self clearInterceptActive].	^ interceptActive! !!TextMorphForInterceptingIRCEditView methodsFor: 'as yet unclassified' stamp: 'sbw 2/23/2002 12:48'!intercepts	intercepts == nil ifTrue: [self initializeIntercepts].	^intercepts! !!TextMorphForInterceptingIRCEditView methodsFor: 'as yet unclassified' stamp: 'sbw 2/24/2002 13:56'!keyStroke: evt 	"We're not going to let the pane have intercepted keys unless the model  	says so."	self interceptActive		ifTrue: [^ self giveInterceptedEventToModel: evt].	(self intercepts includes: evt keyCharacter)		ifTrue: [self setInterceptActive.			^self giveInterceptedEventToModel: evt].	super keyStroke: evt! !!TextMorphForInterceptingIRCEditView methodsFor: 'as yet unclassified' stamp: 'sbw 2/23/2002 12:50'!removeIntercept: char 	self intercepts remove: char ifAbsent: [nil] ! !!TextMorphForInterceptingIRCEditView methodsFor: 'as yet unclassified' stamp: 'sbw 2/23/2002 16:18'!setInterceptActive	interceptActive _ true! !!TextMorphIRCEditView methodsFor: 'as yet unclassified' stamp: 'sbw 3/1/2002 00:13'!keyStroke: evt 	"Pass command keys to the original. UNLESS it's a paste operation. We  	send that one to the new recvr regardless."	| forParent |	forParent _ keysRecvr isNil.	forParent ifFalse: [		"Need to check if it's a command key..."		forParent _ evt commandKeyPressed.		forParent ifTrue: [			"Check for special $v PASTE condition."			forParent _ evt keyCharacter ~= $v].		forParent ifFalse: [^ keysRecvr keyStroke: evt]		].	super keyStroke: evt! !!TextMorphIRCEditView methodsFor: 'as yet unclassified' stamp: 'sbw 2/19/2002 22:41'!keysRecvr: obj	keysRecvr _ obj! !!TextStream methodsFor: '*Colorer' stamp: 'pmm 4/28/2006 23:26'!colorCodePiece: aCodePice	aCodePice attributes do: [ :each |		collection			addAttribute: each			from: aCodePice start			to: aCodePice end ]! !!ThisContextVar methodsFor: 'emitting' stamp: 'ajh 7/8/2004 14:12'!emitLocalValue: methodBuilder	methodBuilder pushThisContext.! !!ThisContextVar methodsFor: 'emitting' stamp: 'ms 7/10/2007 12:05'!isContextVar	^true! !!ThisContextVar methodsFor: 'accessing' stamp: 'ajh 6/25/2004 16:52'!isUndefined	^ false! !!ThisEnvVar methodsFor: 'emitting' stamp: 'ajh 7/8/2004 14:13'!emitEnvValue: methodBuilder	"do nothing, env is on top"! !!ThisEnvVar methodsFor: 'emitting' stamp: 'ajh 7/8/2004 14:14'!emitLocalStore: methodBuilder	methodBuilder storeThisEnv.! !!ThisEnvVar methodsFor: 'emitting' stamp: 'ajh 7/8/2004 14:14'!emitLocalValue: methodBuilder	methodBuilder pushThisEnv.! !!ThisEnvVar methodsFor: 'accessing' stamp: 'ms 7/3/2007 21:10'!isEnv	^true! !!ThisEnvVar methodsFor: 'accessing' stamp: 'ajh 6/25/2004 17:54'!isUndefined	^ false! !!TimeTimestampFormatter methodsFor: 'converting'!formatTimestamp: aTimestamp on: stream	self		print: aTimestamp hour			on: stream			followedBy: $:			width: 2;		print: aTimestamp minute			on: stream			followedBy: $:			width: 2;		print: aTimestamp second			on: stream			followedBy: $,			width: 2;		print: aTimestamp millisecond			on: stream			followedBy: nil			width: 3.	^stream contents			! !!TimeTimestampFormatter class methodsFor: '*Toothpick-Configuration'!mappingKey	^'time'			! !!TimestampFormatTestCase methodsFor: 'running'!assert: actual equals: expected	^self assert: (actual = expected) description: 'Expected ', expected printString, ' got ', actual printString			! !!TimestampFormatTestCase methodsFor: 'running'!testAbsoluteTimeDateFormat	"Formats a Date in the format 'HH:mm:ss,SSS' for example, '15:49:37,459'"	formatter := TimeTimestampFormatter new.	result := formatter formatTimestamp: self timestamp.	self assert: result equals: '11:04:45,123'			! !!TimestampFormatTestCase methodsFor: 'running'!testDateTimeFormat	"Formats a Date in the format 'dd MMM yyyy HH:mm:ss,SSS' 	for example, '06 Nov 1994 15:49:37,459'"	formatter := DateTimeTimestampFormatter new.	result := formatter formatTimestamp: self timestamp.	self assert: result equals: '18 Jan 2006 11:04:45,123'			! !!TimestampFormatTestCase methodsFor: 'running' stamp: 'jp 10/13/2006 12:57'!testISO8601TimeDateFormat	"Formats a Date in the format 'yyyy-MM-dd HH:mm:ss,SSS' 	for example, '1999-11-27 15:49:37,459'"	formatter := ISO8601TimestampFormatter new. 	result := formatter formatTimestamp: self timestamp.	self assert: result equals: '2006-01-18 11:04:45,123'			! !!TimestampFormatTestCase methodsFor: 'running' stamp: 'jp 10/13/2006 12:51'!testRelativeTimeDateFormat	"Formats a Date in the format SSSSS"	| ts date time newTs |	formatter := ElapsedTimestampFormatter new.	ts := DateAndTime now.	formatter ts: ts.	date := ts asDate.	time := ts asTime.	newTs := DateAndTime date: date time: (time addSeconds: 2).	result := formatter formatTimestamp: newTs.	self assert: result equals: '2000'			! !!TimestampFormatTestCase methodsFor: 'running' stamp: 'jp 10/13/2006 12:44'!timestamp	"Dialect-specific"	| time |	time := Time 				hour: 11				minute: 4				second: 45 nanoSecond: (123 * (10 raisedTo: 6)).	^DateAndTime date: (Date 				newDay: 18				month: 1				year: 2006)		time: time			! !!TimestampFormatter methodsFor: '*Toothpick-Configuration'!configureFromDictionary: aDictionary	^self			! !!TimestampFormatter methodsFor: 'converting'!formatTimestamp: aTimestamp	| stream |	stream := WriteStream on: String new.	self formatTimestamp: aTimestamp on: stream.	^stream contents			! !!TimestampFormatter methodsFor: 'converting'!print: anInteger on: aStream followedBy: spacer width: width 	| digitStream padding digits |	digitStream := WriteStream on: (String new: 10).	anInteger printOn: digitStream.	digits := digitStream contents.	padding := width - digits size.	padding > 0 		ifTrue: 			[padding := (String new: padding)						atAllPut: $0;						yourself.			aStream nextPutAll: padding].	aStream nextPutAll: digits.	spacer isNil ifTrue: [^self].	aStream nextPut: spacer			! !!TimestampFormatter methodsFor: 'subclass responsibility'!formatTimestamp: aTimestamp on: aStream	^self subclassResponsibility			! !!TimestampFormatter class methodsFor: '*Toothpick-Configuration'!configureFromDictionary: aDictionary	| formatClass |	formatClass := ( aDictionary includesKey: 'tsformat' ) 			ifTrue: [ self mappings at: ( aDictionary at: 'tsformat' ) ifAbsent: [self mappings at: 'time']]			ifFalse: [ self mappings at: 'time' ].	^formatClass new configureFromDictionary: aDictionary			! !!TimestampFormatter class methodsFor: '*Toothpick-Configuration'!mappingKey	^self subclassResponsibility			! !!TimestampFormatter class methodsFor: '*Toothpick-Configuration'!mappings	^self allSubclasses inject: Dictionary new into: [ :dict :subClass |		dict at: subClass mappingKey put: subClass. dict]			! !!TimestampLoggingFormatter methodsFor: '*Toothpick-Configuration'!configureFromDictionary: aDictionary	^self tsFormatter: (TimestampFormatter configureFromDictionary: aDictionary)			! !!TimestampLoggingFormatter methodsFor: 'printing'!formatEvent: anEvent on: aStream from: anObject 	self tsFormatter formatTimestamp: anEvent timeStamp on: aStream.	aStream space.	anEvent printBasicsOn: aStream			! !!TimestampLoggingFormatter methodsFor: 'accessing'!tsFormatter	^tsFormatter			! !!TimestampLoggingFormatter methodsFor: 'accessing'!tsFormatter: anObject	tsFormatter := anObject			! !!TimestampLoggingFormatter class methodsFor: 'instance creation'!dateTimeFormat	^self type: 'dateTime'			! !!TimestampLoggingFormatter class methodsFor: 'instance creation'!defaultFormat	^self timeFormat			! !!TimestampLoggingFormatter class methodsFor: 'instance creation'!elapsedTimeFormat	^self type: 'elapsed'			! !!TimestampLoggingFormatter class methodsFor: 'instance creation'!iso8601Format	^self type: 'iso'			! !!TimestampLoggingFormatter class methodsFor: 'instance creation'!timeFormat	^self type: 'time'			! !!TimestampLoggingFormatter class methodsFor: 'instance creation'!timestampFormatMappings	^(Dictionary new)		at: 'time' put: TimeTimestampFormatter;		at: 'dateTime' put: DateTimeTimestampFormatter;		at: 'iso' put: ISO8601TimestampFormatter;		at: 'elapsed' put: ElapsedTimestampFormatter;		yourself			! !!TimestampLoggingFormatter class methodsFor: 'instance creation'!type: tsType 	^(self new)		tsFormatter: (self timestampFormatMappings at: tsType) new;		yourself			! !!TimestampLoggingFormatter class methodsFor: '*Toothpick-Configuration'!mappingKey	^'timestamp'			! !!ToothpickConfigurator methodsFor: 'configuring'!configureFromFileNamed: aString 	| loggerList |	loggerList := self loggerListFrom: aString.	^self configureFromLoggerList: loggerList			! !!ToothpickConfigurator methodsFor: 'configuring'!configureFromIniFile	^self configureFromFileNamed: self fileName			! !!ToothpickConfigurator methodsFor: 'configuring'!configureFromLoggerList: loggerList 	| loggers |	loggers := loggerList collect: [:assoc | self loggerFromDictionary: assoc].	loggers do: [:logger | self multiplexer addLogger: logger].	^loggers			! !!ToothpickConfigurator methodsFor: 'configuring'!fileName	^'toothpick.ini'			! !!ToothpickConfigurator methodsFor: 'configuring'!loggerFromDictionary: aDictionary 	| logClass |	logClass := self loggerMappings at: ( aDictionary at: 'type' ifAbsent: [ ^ nil ]) ifAbsent: [ ^ nil ].	aDictionary at: 'formatter' put: (LoggingFormatter configureFromDictionary: aDictionary).	aDictionary at: 'policy' put: (LoggingPolicy configureFromDictionary: aDictionary).	^ logClass configureFromDictionary: aDictionary			! !!ToothpickConfigurator methodsFor: 'configuring'!loggerListFrom: aString 	| reader |	reader := ToothpickIniFileReader onFile: aString.	^reader collection			! !!ToothpickConfigurator methodsFor: 'configuring'!sampleIniString	^ '[LoggerName]name=TestFileLogtype=filecategory=debugthreshold=infoformat=simplefilename=foo.log[LoggerName2]name=TestXMLFileLogtype=filecategory=debugthreshold=errorformat=xmlfilename=foo.xml'			! !!ToothpickConfigurator methodsFor: 'mappings'!loggerMappings	^Logger mappings			! !!ToothpickConfigurator methodsFor: 'accessing'!multiplexer	^multiplexer			! !!ToothpickConfigurator methodsFor: 'accessing'!multiplexer: aLoggingMultiplexer	multiplexer := aLoggingMultiplexer			! !!ToothpickConfigurator class methodsFor: 'instance creation'!for: aLoggingMultiplexer	^super new		multiplexer: aLoggingMultiplexer;		yourself			! !!ToothpickConfiguratorTestCase methodsFor: 'setup' stamp: 'jp 10/12/2006 17:58'!sampleIniString	^ '[FirstLogger]name=TestFileLogtype=filecategory=debugthreshold=infoformat=simplefilename=foo.log[SecondLogger]name=TestXMLFileLogtype=filecategory=debugthreshold=errorformat=xmltsformat=isofilename=foo.xml[ThirdLogger]name=TestThirdFileLogtype=filecategory=debugthreshold=errorformat=patternpattern=%p - %mfilename=foo3.xml[FourthLogger]name=TestFourthFileLogtype=filecategory=debugthreshold=errorformat=timestampfilename=timestamp.txtpolicy=compositefilter1=perf.=debugfilter2=debug.infofilter3=ui.!!error'! !!ToothpickConfiguratorTestCase methodsFor: 'setup'!setUp	LoggingMultiplexer reset			! !!ToothpickConfiguratorTestCase methodsFor: 'testing' stamp: 'jp 10/13/2006 11:25'!testLoggerCreationFromIniFile	| logString iniFileReader dict loggers configurator |	logString := self sampleIniString.	iniFileReader := ToothpickIniFileReader new. 	iniFileReader parseTextFileStream: logString readStream.	dict := iniFileReader collection.	configurator := ToothpickConfigurator new.	loggers := dict keysAndValuesDo: [ :key :val | dict at: key put: (configurator loggerFromDictionary: val)].	self		validateFirstLogger: (loggers at: 'FirstLogger');		validateSecondLogger: (loggers at: 'SecondLogger');		validateThirdLogger: (loggers at: 'ThirdLogger');		validateFourthLogger: (loggers at: 'FourthLogger');		yourself			! !!ToothpickConfiguratorTestCase methodsFor: 'testing' stamp: 'jp 10/13/2006 11:27'!testLoggingEventPatternCreation	| pattern |	pattern := LoggingEventPattern fromString: 'perf.debug'.	self assert: pattern categories size = 1;		assert: (pattern categories includes: #perf);		assert: pattern level = (LoggingEvent allLevels indexOf: #debug);		assert: pattern comparator isNil.	pattern := LoggingEventPattern fromString: 'info,perf.=debug'.	self assert: pattern categories size = 2;		assert: (pattern categories includes: #perf);		assert: pattern level = (LoggingEvent allLevels indexOf: #debug);		assert: pattern comparator = #=.	pattern := LoggingEventPattern fromString: 'info,perf.!!debug'.	self assert: pattern categories size = 2;		assert: (pattern categories includes: #info);		assert: pattern level = (LoggingEvent allLevels indexOf: #debug);		assert: pattern comparator = #!!.! !!ToothpickConfiguratorTestCase methodsFor: 'testing' stamp: 'jp 10/12/2006 17:59'!testLoggingEventPatternValidation	| pattern event |	event := LoggingEvent logMessage: 'foo'.	pattern := LoggingEventPattern fromString: 'debug.debug'.	self assert: (pattern isInteresting: event).	pattern := LoggingEventPattern fromString: 'debug.=debug'.	self assert: (pattern isInteresting: event).	pattern := LoggingEventPattern fromString: 'perf,debug.=debug'.	self assert: (pattern isInteresting: event).	pattern := LoggingEventPattern fromString: 'perf,debug.!!debug'.	self deny: (pattern isInteresting: event).	pattern := LoggingEventPattern fromString: 'perf,debug.!!error'.	self assert: (pattern isInteresting: event).! !!ToothpickConfiguratorTestCase methodsFor: 'validation'!validateFirstLogger: aLogger	self assert: (aLogger name = 'TestFileLog');		assert: (aLogger class = FileLogger);		assert: (aLogger format class = SimpleLoggingFormatter);		assert: (aLogger policy class = LoggingPolicy);		assert: (aLogger policy category = #debug);		assert: (aLogger policy level = #info);		assert: (aLogger fileName = 'foo.log');		yourself.			! !!ToothpickConfiguratorTestCase methodsFor: 'validation'!validateFourthLogger: aLogger 	| policy |	self		assert: aLogger name = 'TestFourthFileLog';		assert: aLogger class = FileLogger;		assert: aLogger format class = TimestampLoggingFormatter;		assert: aLogger policy class = CompositeLoggingPolicy;		assert: aLogger fileName = 'timestamp.txt';		yourself.	policy := aLogger policy.	self		assert: (policy isInteresting: LoggingEvent uiWarning);		deny: (policy isInteresting: LoggingEvent uiFatal);		deny: (policy isInteresting: LoggingEvent debugDebug);		assert: (policy isInteresting: LoggingEvent debugInfo);		deny: (policy isInteresting: LoggingEvent performanceWarning);		yourself			! !!ToothpickConfiguratorTestCase methodsFor: 'validation'!validateSecondLogger: aLogger	self assert: (aLogger name = 'TestXMLFileLog');		assert: (aLogger class = FileLogger);		assert: (aLogger format class = XMLLoggingFormatter);		assert: (aLogger format tsFormatter class mappingKey = 'iso');		assert: (aLogger policy class = LoggingPolicy);		assert: (aLogger policy category = #debug);		assert: (aLogger policy level = #error);		assert: (aLogger fileName = 'foo.xml');		yourself.			! !!ToothpickConfiguratorTestCase methodsFor: 'validation'!validateThirdLogger: aLogger	self assert: (aLogger name = 'TestThirdFileLog');		assert: (aLogger class = FileLogger);		assert: (aLogger format class = PatternLoggingFormatter);		assert: (aLogger format formatString = '%p - %m');				assert: (aLogger policy class = LoggingPolicy);		assert: (aLogger policy category = #debug);		assert: (aLogger policy level = #error);		assert: (aLogger fileName = 'foo3.xml');		yourself.			! !!ToothpickIniFileReader methodsFor: 'accessing'!collection	^collection			! !!ToothpickIniFileReader methodsFor: 'accessing'!collection: aDictionary 	collection := aDictionary			! !!ToothpickIniFileReader methodsFor: 'accessing'!commentCharacter 	^commentChar			! !!ToothpickIniFileReader methodsFor: 'accessing'!commentCharacter: aCharacter	commentChar := aCharacter			! !!ToothpickIniFileReader methodsFor: 'accessing'!defaultCommentChar 	^$;			! !!ToothpickIniFileReader methodsFor: 'accessing'!defaultDelimiterChar	^$=			! !!ToothpickIniFileReader methodsFor: 'accessing'!delimiterCharacter 	^delimiterChar			! !!ToothpickIniFileReader methodsFor: 'accessing'!delimiterCharacter: aCharacter	delimiterChar := aCharacter			! !!ToothpickIniFileReader methodsFor: 'accessing'!fileName	^fileName			! !!ToothpickIniFileReader methodsFor: 'accessing'!fileName: aString	fileName := aString			! !!ToothpickIniFileReader methodsFor: 'accessing'!sections	^collection keys asSortedCollection			! !!ToothpickIniFileReader methodsFor: 'accessing'!textDictionaryForSection: aKey 	"(private)"	^self collection at: aKey ifAbsentPut: [Dictionary new]			! !!ToothpickIniFileReader methodsFor: 'accessing'!textForKey: aKey section: aSection	"Return the text in the current language dictionary	at <aKey>. If not there, return an empty string"	^(self textDictionaryForSection: aSection)		at: aKey 		ifAbsent: ['']			! !!ToothpickIniFileReader methodsFor: 'error strings'!fileFormatNotValidErrorString	^'Invalid File Format'			! !!ToothpickIniFileReader methodsFor: 'error strings'!fileNotFoundErrorString	^'File not found - '			! !!ToothpickIniFileReader methodsFor: 'error strings'!fileNotLoadableErrorString	^'Data could not be loaded from '			! !!ToothpickIniFileReader methodsFor: 'initialize-release'!initialize	commentChar := self defaultCommentChar.	delimiterChar := self defaultDelimiterChar.	collection := Dictionary new			! !!ToothpickIniFileReader methodsFor: 'parsing'!loadFromFile	"Load the text units from the config file"	| aStream |	[aStream := FileStream fileNamed: fileName]		on: Error 		do: [:sig | sig return: (self fileNotFoundErrorString, fileName)].	[self parseTextFileStream: aStream.	aStream close] 		on: Error 		do: [:sig | sig return: (self fileNotLoadableErrorString, fileName)]			! !!ToothpickIniFileReader methodsFor: 'parsing' stamp: 'jp 10/13/2006 11:20'!parseTextFileStream: aStream	"Parse <aStream> line for line. If the line begins with	a comment, skip over it. If the line is a language def,	fetch the dictionary for the language. Else, tokenize	the line and insert it into the dictionary"	| dict line | 	(self peekForSection: aStream)		ifTrue: [aStream reset]		ifFalse: [Error signalWith: self fileFormatNotValidErrorString].	[aStream atEnd] whileFalse: [ | text |		(text := aStream nextLine withBlanksTrimmed) isEmpty ifFalse: [			line := ReadStream on: text.			(self peekForComment: line) ifFalse: [				(self peekForSection: line)					ifTrue: [dict := self textDictionaryForSection: (line upTo: $])]					ifFalse: [dict 						at: (line upTo: self delimiterCharacter) withBlanksTrimmed						put: line upToEnd withBlanksTrimmed]]]].			! !!ToothpickIniFileReader methodsFor: 'parsing'!peekForComment: aStream	"(private)"	^aStream peekFor: self commentCharacter			! !!ToothpickIniFileReader methodsFor: 'parsing'!peekForSection: aStream	"(private)"	^aStream peekFor: self sectionOpenerChar			! !!ToothpickIniFileReader methodsFor: 'parsing'!sectionOpenerChar	"(private)"	^$[			! !!ToothpickIniFileReader class methodsFor: 'instance creation'!new	^super new initialize			! !!ToothpickIniFileReader class methodsFor: 'instance creation'!onFile: aString	^self new		fileName: aString;		loadFromFile;		yourself			! !!ToothpickIniFileReader class methodsFor: 'instance creation'!onFile: aString commentCharacter: commentCharacter delimiterCharacter: delimiterCharacter	^self new		fileName: aString;		commentCharacter: commentCharacter;		delimiterCharacter: delimiterCharacter;		loadFromFile;		yourself			! !!ToothpickIniFileReader class methodsFor: 'instance creation'!onFile: aString withDictionary: aDictionary 	^self new		fileName: aString;		collection: aDictionary;		yourself			! !!ToothpickPortTestCase methodsFor: 'testing'!testAllLevelStrings	self assert: LoggingEvent allLevels size = LoggingEvent new allLevelsStrings size			! !!ToothpickPortTestCase methodsFor: 'testing'!testTimestamp	| tsClass |	tsClass := LoggingEvent timestampClass.	self deny: tsClass = LoggingEvent.	tsClass := tsClass new.	self assert: (tsClass respondsTo: #year);		assert: (tsClass respondsTo: #month);		assert: (tsClass respondsTo: #day);		assert: (tsClass respondsTo: #hour);		assert: (tsClass respondsTo: #minute);		assert: (tsClass respondsTo: #second);		assert: (tsClass respondsTo: #millisecond);		yourself.			! !!Trait methodsFor: '*ast' stamp: 'md 4/6/2007 14:20'!isVariable	"hack for Lint"	^false! !!Trait methodsFor: '*ast' stamp: 'md 4/6/2007 14:20'!superclass	"hack for Lint"	^nil! !!Trait methodsFor: '*ast' stamp: 'md 4/6/2007 14:20'!withAllSubclasses	"hack for Lint"	^Array with: self! !!Trait methodsFor: '*RefactoringEngine' stamp: 'md 3/14/2006 16:44'!includesBehavior: aClass	^false! !!Trait methodsFor: '*persephone-override' stamp: 'md 3/31/2007 19:08'!parseTreeFor: aSymbol	| method |		method := self compiledMethodAt: aSymbol.	method hasReflectiveMethod ifTrue: [^method reflectiveMethod methodNode].	"should be moved to #TPureBehavior"	^RBParser parseMethod: (self sourceCodeAt: aSymbol)		onError: [:aString :pos | ^nil]! !!TraitBehavior methodsFor: '*ast' stamp: 'md 4/16/2007 10:41'!parseTreeFor: aSymbol		self flag: #FIXME.	"UGLY hack for beeing able to share AST package with Persephone... this	 needs to be fixed later".		Smalltalk at: #ReflectiveMethod ifPresent: [:cls | 	| method |		method := self compiledMethodAt: aSymbol.		method hasReflectiveMethod ifTrue: [^method reflectiveMethod methodNode].	].	^RBParser parseMethod: (self sourceCodeAt: aSymbol)		onError: [:aString :pos | ^nil]! !!TraitBehavior methodsFor: '*persephone-override' stamp: 'md 3/31/2007 19:13' prior: 31890399!compilerClass	"Answer a compiler class appropriate for source methods of this class."	^(Preferences compileReflectiveMethods) ifTrue: [PECompiler] ifFalse: [Compiler]. ! !!TranscriptLogger methodsFor: 'initialize'!initialize	format := SimpleLoggingFormatter defaultFormat.	stream := Transcript.	name := 'Transcript'			! !!TranscriptLogger class methodsFor: 'configuring'!defaultLogName	^ 'an unnamed Transcript logger'			! !!TranscriptLogger class methodsFor: '*Toothpick-Configuration'!mappingKey	^'transcript'			! !!TranscriptLogger class methodsFor: 'instance creation'!new	^super new initialize			! !!TransformationRule methodsFor: 'accessing' stamp: 'nk 3/5/2005 15:10'!changes	^builder changes! !!TransformationRule methodsFor: 'accessing'!checkMethod: aSmalllintContext 	(rewriteRule canMatchMethod: aSmalllintContext compiledMethod) 		ifFalse: [^self].	class := aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) 		ifTrue: 			[(self class recursiveSelfRule executeTree: rewriteRule tree				initialAnswer: false) 					ifFalse: 						[builder 							compile: rewriteRule tree printString							in: class							classified: aSmalllintContext protocol]]! !!TransformationRule methodsFor: 'accessing'!problemCount	^builder problemCount! !!TransformationRule methodsFor: 'accessing'!resetResult	builder := CompositeRefactoryChange named: 'Some transformations'! !!TransformationRule methodsFor: 'testing'!hasConflicts	^true! !!TransformationRule methodsFor: 'testing'!isEmpty	^builder changes isEmpty! !!TransformationRule methodsFor: 'initialize-release'!rewriteUsing: searchReplacer 	rewriteRule := searchReplacer.	self resetResult! !!TransformationRule methodsFor: 'rules'!superSends	| rule |	rule := ParseTreeRewriter new.	rule 		replace: 'super `@message: ``@args'		with: 'self `@message: ``@args'		when: 			[:aNode | 			(class withAllSubclasses 				detect: [:each | each includesSelector: aNode selector]				ifNone: [nil]) isNil].	self rewriteUsing: rule! !!TransformationRule methodsFor: 'private'!viewResults	"I reset the result so that we don't fill up memory with methods to compile in the builder."	builder inspect.	self resetResult! !!TransformationRule class methodsFor: 'transformations'!assignmentInIfTrue	^self rewrite: #(			#('``@Boolean ifTrue: [`variable := ``@true] ifFalse: [`variable := ``@false]'			"->"			'`variable := ``@Boolean ifTrue: [``@true] ifFalse: [``@false]')			#('``@Boolean ifFalse: [`variable := ``@true] ifTrue: [`variable := ``@false]'			"->"			'`variable := ``@Boolean ifFalse: [``@true] ifTrue: [``@false]'))		methods: false		name: 'Move variable assignment outside of single statement ifTrue:ifFalse: blocks'! !!TransformationRule class methodsFor: 'transformations'!atIfAbsent	^self rewrite: #(			#('``@dictionary at: ``@key 					ifAbsent: [| `@temps | 							``@.Statements1.							``@dictionary at: ``@key put: ``@object.							``@.Statements2.							``@object]'			"->"			'``@dictionary at: ``@key					ifAbsentPut: [| `@temps |							``@.Statements1.							``@.Statements2.							``@object]')			#('``@dictionary at: ``@key					ifAbsent: [| `@temps |							``@.Statements.							``@dictionary at: ``@key put: ``@object]'			"->"			'``@dictionary at: ``@key					ifAbsentPut: [| `@temps |							``@.Statements.							``@object]'))		methods: false		name: 'at:ifAbsent: -> at:ifAbsentPut:'! !!TransformationRule class methodsFor: 'transformations'!betweenAnd	^self rewrite: #(			#('``@a >= ``@b and: [``@a <= ``@c]' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b & (``@a <= ``@c)' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a and: [``@a <= ``@c]' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a & (``@a <= ``@c)' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c and: [``@a >= ``@b]' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c & (``@a >= ``@b)' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a and: [``@a >= ``@b]' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a & (``@a >= ``@b)' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b and: [``@c >= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b & (``@c >= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a and: [``@c >= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a & (``@c >= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c and: [``@b <= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c & (``@b <= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a and: [``@b <= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a & (``@b <= ``@a)' "->" '``@a between: ``@b and: ``@c'))		methods: false		name: '"a >= b and: [a <= c]" -> "a between: b and: c"'! !!TransformationRule class methodsFor: 'transformations'!cascadedNextPutAlls	^self		rewrite: #(			#('``@rcvr nextPutAll: ``@object1 , ``@object2'					"->"				'``@rcvr nextPutAll: ``@object1; nextPutAll: ``@object2')			#('``@rcvr show: ``@object1 , ``@object2'					"->"				'``@rcvr show: ``@object1; show: ``@object2'))		methods: false		name: 'Use cascaded nextPutAll:''s instead of #, in #nextPutAll:'! !!TransformationRule class methodsFor: 'transformations'!detectIfNone	^self rewrite: #(			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) isNil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) = nil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) == nil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) notNil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) ~= nil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) ~~ nil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]'))		methods: false		name: 'detect:ifNone: -> contains:'! !!TransformationRule class methodsFor: 'transformations'!equalNil	^self		rewrite: #(			#('``@object = nil'	"->"	'``@object isNil') 			#('``@object == nil'	"->"	'``@object isNil') 			#('``@object ~= nil'	"->"	'``@object notNil') 			#('``@object ~~ nil'	"->"	'``@object notNil'))		methods: false		name: '= nil -> isNil AND ~= nil -> notNil'! !!TransformationRule class methodsFor: 'transformations'!guardClause	^self		rewrite: #(			#('`@methodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifTrue: [| `@trueTemps | `.Statement1. `.Statement2. `@.Statements1]'			"->"			'`@methodName: `@args					| `@temps `@trueTemps |					`@.Statements.					`@condition ifFalse: [^self].					`.Statement1.					`.Statement2.					`@.Statements1') 			#('`@methodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifFalse: [| `@falseTemps | `.Statement1. `.Statement2. `@.Statements1]'			"->"			'`@methodName: `@args					| `@temps `@falseTemps |					`@.Statements.					`@condition ifTrue: [^self].					`.Statement1.					`.Statement2.					`@.Statements1'))		methods: true		name: 'Eliminate guarding clauses'! !!TransformationRule class methodsFor: 'transformations'!minMax	^self rewrite: #(			#('``@a < ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a min: ``@b')			#('``@a <= ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a min: ``@b')			#('``@a > ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a max: ``@b')			#('``@a >= ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a max: ``@b')			#('``@a < ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a max: ``@b')			#('``@a <= ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a max: ``@b')			#('``@a > ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a min: ``@b')			#('``@a >= ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a min: ``@b')			#('`a < ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a <= ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a < ``@b ifFalse: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a <= ``@b ifFalse: [`a := ``@b]'			"->"	'`a := `a min: ``@b')			#('`a > ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a >= ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a > ``@b ifFalse: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a >= ``@b ifFalse: [`a := ``@b]'			"->"	'`a := `a max: ``@b')			#('``@b < `a ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b <= `a ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b < `a ifFalse: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b <= `a ifFalse: [`a := ``@b]'			"->"	'`a := `a max: ``@b')			#('``@b > `a ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b >= `a ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b > `a ifFalse: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b >= `a ifFalse: [`a := ``@b]'			"->"	'`a := `a min: ``@b'))		methods: false		name: 'Rewrite ifTrue:ifFalse: using min:/max:'! !!TransformationRule class methodsFor: 'transformations'!notElimination	^self		rewrite: #(			#('``@object not not'	"->"	'``@object') 			#('``@object not ifTrue: ``@block' 	"->"	'``@object ifFalse: ``@block') 			#('``@object not ifFalse: ``@block'	"->"	'``@object ifTrue: ``@block') 			#('``@collection select: [:`each | | `@temps | ``@.Statements. ``@object not]'				"->"	'``@collection reject: [:`each | | `@temps | ``@.Statements. ``@object]')			#('``@collection reject: [:`each | | `@temps | ``@.Statements. ``@object not]'				"->"	'``@collection select: [:`each | | `@temps | ``@.Statements. ``@object]')			#('[| `@temps | ``@.Statements. ``@object not] whileTrue: ``@block'				"->"	'[| `@temps | ``@.Statements. ``@object] whileFalse: ``@block')			#('[| `@temps | ``@.Statements. ``@object not] whileFalse: ``@block'				"->"	'[| `@temps | ``@.Statements. ``@object] whileTrue: ``@block')			#('[| `@temps | ``@.Statements. ``@object not] whileTrue'				"->"	'[| `@temps | ``@.Statements. ``@object] whileFalse')			#('[| `@temps | ``@.Statements. ``@object not] whileFalse'				"->"	'[| `@temps | ``@.Statements. ``@object] whileTrue')			#('(``@a <= ``@b) not' "->" '``@a > ``@b')			#('(``@a < ``@b) not' "->" '``@a >= ``@b')			#('(``@a = ``@b) not' "->" '``@a ~= ``@b')			#('(``@a == ``@b) not' "->" '``@a ~~ ``@b')			#('(``@a ~= ``@b) not' "->" '``@a = ``@b')			#('(``@a ~~ ``@b) not' "->" '``@a == ``@b')			#('(``@a >= ``@b) not' "->" '``@a < ``@b')			#('(``@a > ``@b) not' "->" '``@a <= ``@b'))					methods: false		name: 'Eliminate unnecessary not''s'! !!TransformationRule class methodsFor: 'transformations'!showWhileBlocks	^self		rewrite: #(			#('``@cursor showWhile: [| `@temps | ``@.Statements. `var := ``@object]'				"->"	'`var := ``@cursor showWhile: [| `@temps | ``@.Statements. ``@object]') 			#('``@cursor showWhile: [| `@temps | ``@.Statements. ^``@object]'				"->"	'^``@cursor showWhile: [| `@temps | ``@.Statements. ``@object]'))		methods: false		name: 'Move assignment out of showWhile: blocks'! !!TransformationRule class methodsFor: 'transformations'!superSends	^(self new)		name: 'Rewrite super messages to self messages when both refer to same method';		superSends;		yourself! !!TransformationRule class methodsFor: 'transformations' stamp: 'nk 3/5/2005 16:06'!translateLiteralsInMenus	^self 		rewrite: {				{					'`@menu add: `#label action: `#sym'.					'`@menu add: `#label translated action: `#sym'				}.				{					'`@menu add: `#label selector: `#sym arguments: `@stuff'.					'`@menu add: `#label translated selector: `#sym arguments: `@stuff'				}.				{					'`@menu add: `#label subMenu: `@stuff'.					'`@menu add: `#label translated subMenu: `@stuff'				}.				{					'`@menu add: `#label subMenu: `@stuff target: `@targ selector: `#sel argumentList: `@args'.					'`@menu add: `#label translated subMenu: `@stuff target: `@targ selector: `#sel argumentList: `@args'				}.				{					'`@menu add: `#label target: `@targ action: `#sel'.					'`@menu add: `#label translated target: `@targ action: `#sel'				}.				{					'`@menu add: `#label target: `@targ selector `#sel'.					'`@menu add: `#label translated target: `@targ selector `#sel'				}.				{					'`@menu add: `#label target: `@targ selector `#sel argument: `@arg'.					'`@menu add: `#label translated target: `@targ selector `#sel argument: `@arg'				}.				{					'`@menu add: `#label target: `@targ selector `#sel arguments: `@arg'.					'`@menu add: `#label translated target: `@targ selector `#sel arguments: `@arg'				}.				{					'`@menu addList: `{ :n | n isLiteral and: [ n token realValue anySatisfy: [ :row | (row isKindOf: Array) and: [ row first isLiteral ]]] }'.					'`@menu addTranslatedList: `{ :n :c | n }'				}.				{					'`@menu addTitle: `#label'.					'`@menu addTitle: `#label translated'				}.				{					'`@menu addTitle: `#label updatingSelector: `#sel updateTarget: `@targ'.					'`@menu addTitle: `#label translated updatingSelector: `#sel updateTarget: `@targ'				}.				{					'`@menu addWithLabel: `#label enablement: `#esel action: `#sel'.					'`@menu addWithLabel: `#label translated enablement: `#esel action: `#sel'				}.				{					'`@menu addWithLabel: `#label enablementSelector: `#esel target: `@targ selector: `#sel argumentList: `@args'.					'`@menu addWithLabel: `#label translated enablementSelector: `#esel target: `@targ selector: `#sel argumentList: `@args'				}.				{					'`@menu balloonTextForLastItem: `#label'.					'`@menu balloonTextForLastItem: `#label translated'				}.				{					'`@menu labels: `#lit lines: `@lines selections: `@sels'.					'`@menu labels: (`#lit collect: [ :l | l translated ]) lines: `@lines selections: `@sels'				}.				{					'`@menu title: `#title'.					'`@menu title: `#title translated'				}			}		methods: false		name: 'add translations to strings in menus'! !!TransformationRule class methodsFor: 'transformations'!unwindBlocks	^self		rewrite: #(			#('[| `@temps | ``@.Statements. `var := ``@object] valueNowOrOnUnwindDo: ``@block'				"->"	'`var := [| `@temps | ``@.Statements. ``@object] valueNowOrOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. ^``@object] valueNowOrOnUnwindDo: ``@block'				"->"	'^[| `@temps | ``@.Statements. ``@object] valueNowOrOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. `var := ``@object] valueOnUnwindDo: ``@block'				"->"	'`var := [| `@temps | ``@.Statements. ``@object] valueOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. ^``@object] valueOnUnwindDo: ``@block'				"->"	'^[| `@temps | ``@.Statements. ``@object] valueOnUnwindDo: ``@block'))		methods: false		name: 'Move assignment out of valueNowOrUnwindDo: blocks'! !!TransformationRule class methodsFor: 'accessing'!initializeRecursiveSelfRule	RecursiveSelfRule := ParseTreeSearcher new.	RecursiveSelfRule 		matchesAnyMethodOf: 			#('`@methodName: `@args | `@temps | self `@methodName: `@args1' 			'`@methodName: `@args | `@temps | ^self `@methodName: `@args1')		do: [:aNode :answer | true].	^RecursiveSelfRule! !!TransformationRule class methodsFor: 'accessing'!recursiveSelfRule	^RecursiveSelfRule isNil 		ifTrue: [self initializeRecursiveSelfRule]		ifFalse: [RecursiveSelfRule]! !!TransformationRule class methodsFor: 'instance creation'!rewrite: stringArrays methods: aBoolean name: aName 	| rewriteRule |	rewriteRule := ParseTreeRewriter new.	stringArrays do: 			[:each | 			aBoolean 				ifTrue: [rewriteRule replaceMethod: each first with: each last]				ifFalse: [rewriteRule replace: each first with: each last]].	^(self new)		name: aName;		rewriteUsing: rewriteRule;		yourself! !!TransformationRuleTest methodsFor: 'accessing'!checkMethod: aSmalllintContext 	class := aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)				ifFalse: 					[builder compile: rewriteRule tree printString						in: class						classified: aSmalllintContext protocols]]! !!TransformationRuleTest methodsFor: 'accessing'!problemCount	^builder problemCount! !!TransformationRuleTest methodsFor: 'accessing'!resetResult	builder := CompositeRefactoryChange new! !!TransformationRuleTest methodsFor: 'testing'!hasConflicts	^true! !!TransformationRuleTest methodsFor: 'testing'!isEmpty	^builder changes isEmpty! !!TransformationRuleTest methodsFor: 'initialize-release'!rewriteUsing: searchReplacer 	rewriteRule := searchReplacer.	self resetResult! !!TransformationRuleTest methodsFor: 'rules'!superSends	| rule |	rule := ParseTreeRewriter new.	rule addSearch: 'super `@message: ``@args'				-> (					[:aNode | 					(class withAllSubclasses						detect: [:each | each includesSelector: aNode selector]						ifNone: [nil]) isNil]							-> 'self `@message: ``@args').	self rewriteUsing: rule! !!TransformationRuleTest methodsFor: 'private'!viewResults	"I reset the result so that we don't fill up memory with methods to compile in the builder."	builder inspect.	self resetResult! !!TransformationRuleTest class methodsFor: 'transformations'!assignmentInIfTrue	^self rewrite: #(			#('``@Boolean ifTrue: [`variable := ``@true] ifFalse: [`variable := ``@false]'			"->"			'`variable := ``@Boolean ifTrue: [``@true] ifFalse: [``@false]')			#('``@Boolean ifFalse: [`variable := ``@true] ifTrue: [`variable := ``@false]'			"->"			'`variable := ``@Boolean ifFalse: [``@true] ifTrue: [``@false]'))		methods: false		name: 'Move variable assignment outside of single statement ifTrue:ifFalse: blocks'! !!TransformationRuleTest class methodsFor: 'transformations'!atIfAbsent	^self rewrite: #(			#('``@dictionary at: ``@key 					ifAbsent: [| `@temps | 							``@.Statements1.							``@dictionary at: ``@key put: ``@object.							``@.Statements2.							``@object]'			"->"			'``@dictionary at: ``@key					ifAbsentPut: [| `@temps |							``@.Statements1.							``@.Statements2.							``@object]')			#('``@dictionary at: ``@key					ifAbsent: [| `@temps |							``@.Statements.							``@dictionary at: ``@key put: ``@object]'			"->"			'``@dictionary at: ``@key					ifAbsentPut: [| `@temps |							``@.Statements.							``@object]'))		methods: false		name: 'at:ifAbsent: -> at:ifAbsentPut:'! !!TransformationRuleTest class methodsFor: 'transformations'!betweenAnd	^self rewrite: #(			#('``@a >= ``@b and: [``@a <= ``@c]' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b & (``@a <= ``@c)' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a and: [``@a <= ``@c]' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a & (``@a <= ``@c)' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c and: [``@a >= ``@b]' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c & (``@a >= ``@b)' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a and: [``@a >= ``@b]' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a & (``@a >= ``@b)' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b and: [``@c >= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b & (``@c >= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a and: [``@c >= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a & (``@c >= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c and: [``@b <= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c & (``@b <= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a and: [``@b <= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a & (``@b <= ``@a)' "->" '``@a between: ``@b and: ``@c'))		methods: false		name: '"a >= b and: [a <= c]" -> "a between: b and: c"'! !!TransformationRuleTest class methodsFor: 'transformations'!detectIfNone	^self rewrite: #(			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) isNil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) = nil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) == nil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) notNil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) ~= nil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) ~~ nil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]'))		methods: false		name: 'detect:ifNone: -> contains:'! !!TransformationRuleTest class methodsFor: 'transformations'!equalNil	^self		rewrite: #(			#('``@object = nil'	"->"	'``@object isNil') 			#('``@object == nil'	"->"	'``@object isNil') 			#('``@object ~= nil'	"->"	'``@object notNil') 			#('``@object ~~ nil'	"->"	'``@object notNil'))		methods: false		name: '= nil -> isNil AND ~= nil -> notNil'! !!TransformationRuleTest class methodsFor: 'transformations'!guardClause	^self		rewrite: #(			#('`@methodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifTrue: [| `@trueTemps | `.Statement1. `.Statement2. `@.Statements1]'			"->"			'`@methodName: `@args					| `@temps `@trueTemps |					`@.Statements.					`@condition ifFalse: [^self].					`.Statement1.					`.Statement2.					`@.Statements1') 			#('`@methodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifFalse: [| `@falseTemps | `.Statement1. `.Statement2. `@.Statements1]'			"->"			'`@methodName: `@args					| `@temps `@falseTemps |					`@.Statements.					`@condition ifTrue: [^self].					`.Statement1.					`.Statement2.					`@.Statements1'))		methods: true		name: 'Eliminate guarding clauses'! !!TransformationRuleTest class methodsFor: 'transformations'!minMax	^self rewrite: #(			#('``@a < ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a min: ``@b')			#('``@a <= ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a min: ``@b')			#('``@a > ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a max: ``@b')			#('``@a >= ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a max: ``@b')			#('``@a < ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a max: ``@b')			#('``@a <= ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a max: ``@b')			#('``@a > ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a min: ``@b')			#('``@a >= ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a min: ``@b')			#('`a < ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a <= ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a < ``@b ifFalse: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a <= ``@b ifFalse: [`a := ``@b]'			"->"	'`a := `a min: ``@b')			#('`a > ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a >= ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a > ``@b ifFalse: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a >= ``@b ifFalse: [`a := ``@b]'			"->"	'`a := `a max: ``@b')			#('``@b < `a ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b <= `a ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b < `a ifFalse: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b <= `a ifFalse: [`a := ``@b]'			"->"	'`a := `a max: ``@b')			#('``@b > `a ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b >= `a ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b > `a ifFalse: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b >= `a ifFalse: [`a := ``@b]'			"->"	'`a := `a min: ``@b'))		methods: false		name: 'Rewrite ifTrue:ifFalse: using min:/max:'! !!TransformationRuleTest class methodsFor: 'transformations'!notElimination	^self		rewrite: #(			#('``@object not not'	"->"	'``@object') 			#('``@object not ifTrue: ``@block' 	"->"	'``@object ifFalse: ``@block') 			#('``@object not ifFalse: ``@block'	"->"	'``@object ifTrue: ``@block') 			#('``@collection select: [:`each | | `@temps | ``@.Statements. ``@object not]'				"->"	'``@collection reject: [:`each | | `@temps | ``@.Statements. ``@object]')			#('``@collection reject: [:`each | | `@temps | ``@.Statements. ``@object not]'				"->"	'``@collection select: [:`each | | `@temps | ``@.Statements. ``@object]')			#('[| `@temps | ``@.Statements. ``@object not] whileTrue: ``@block'				"->"	'[| `@temps | ``@.Statements. ``@object] whileFalse: ``@block')			#('[| `@temps | ``@.Statements. ``@object not] whileFalse: ``@block'				"->"	'[| `@temps | ``@.Statements. ``@object] whileTrue: ``@block')			#('[| `@temps | ``@.Statements. ``@object not] whileTrue'				"->"	'[| `@temps | ``@.Statements. ``@object] whileFalse')			#('[| `@temps | ``@.Statements. ``@object not] whileFalse'				"->"	'[| `@temps | ``@.Statements. ``@object] whileTrue')			#('(``@a <= ``@b) not' "->" '``@a > ``@b')			#('(``@a < ``@b) not' "->" '``@a >= ``@b')			#('(``@a = ``@b) not' "->" '``@a ~= ``@b')			#('(``@a == ``@b) not' "->" '``@a ~~ ``@b')			#('(``@a ~= ``@b) not' "->" '``@a = ``@b')			#('(``@a ~~ ``@b) not' "->" '``@a == ``@b')			#('(``@a >= ``@b) not' "->" '``@a < ``@b')			#('(``@a > ``@b) not' "->" '``@a <= ``@b'))					methods: false		name: 'Eliminate unnecessary not''s'! !!TransformationRuleTest class methodsFor: 'transformations'!showWhileBlocks	^self		rewrite: #(			#('``@cursor showWhile: [| `@temps | ``@.Statements. `var := ``@object]'				"->"	'`var := ``@cursor showWhile: [| `@temps | ``@.Statements. ``@object]') 			#('``@cursor showWhile: [| `@temps | ``@.Statements. ^``@object]'				"->"	'^``@cursor showWhile: [| `@temps | ``@.Statements. ``@object]'))		methods: false		name: 'Move assignment out of showWhile: blocks'! !!TransformationRuleTest class methodsFor: 'transformations'!superSends	^(self new)		name: 'Rewrite super messages to self messages when both refer to same method';		superSends;		yourself! !!TransformationRuleTest class methodsFor: 'transformations'!unwindBlocks	^self		rewrite: #(			#('[| `@temps | ``@.Statements. `var := ``@object] valueNowOrOnUnwindDo: ``@block'				"->"	'`var := [| `@temps | ``@.Statements. ``@object] valueNowOrOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. ^``@object] valueNowOrOnUnwindDo: ``@block'				"->"	'^[| `@temps | ``@.Statements. ``@object] valueNowOrOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. `var := ``@object] valueOnUnwindDo: ``@block'				"->"	'`var := [| `@temps | ``@.Statements. ``@object] valueOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. ^``@object] valueOnUnwindDo: ``@block'				"->"	'^[| `@temps | ``@.Statements. ``@object] valueOnUnwindDo: ``@block'))		methods: false		name: 'Move assignment out of valueNowOrUnwindDo: blocks'! !!TransformationRuleTest class methodsFor: 'class initialization'!initializeAfterLoad1	RecursiveSelfRule := ParseTreeSearcher new.	RecursiveSelfRule		addMethodSearches: #('`@methodName: `@args | `@temps | self `@methodName: `@args' '`@methodName: `@args | `@temps | ^self `@methodName: `@args')				-> [:aNode :answer | true]! !!TransformationRuleTest class methodsFor: 'class initialization'!nuke	RecursiveSelfRule := nil! !!TransformationRuleTest class methodsFor: 'instance creation'!rewrite: stringArrays methods: aBoolean name: aName 	| rewriteRule |	rewriteRule := ParseTreeRewriter new.	stringArrays do: 			[:each | 			aBoolean				ifTrue: [rewriteRule addMethodSearch: each first -> each last]				ifFalse: [rewriteRule addSearch: each first -> each last]].	^(self new) name: aName;		rewriteUsing: rewriteRule;		yourself! !!UndeclaredSelectorWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/12/2003 14:28'!correctIn: compiler	self resume: (compiler correctSelector: self messageNode)! !!UndeclaredSelectorWarning methodsFor: 'defaults' stamp: 'md 4/14/2007 00:37'!defaultAction	"create new selector"	^ messageNode selector! !!UndeclaredSelectorWarning methodsFor: 'accessing' stamp: 'ajh 3/11/2003 22:43'!messageNode	^ messageNode! !!UndeclaredSelectorWarning methodsFor: 'accessing' stamp: 'md 4/14/2007 00:37'!messageNode: aMessageNode	messageNode _ aMessageNode.	messageText _ 'Unknown selector: ', aMessageNode selector.! !!UndeclaredSelectorWarning commentStamp: 'ajh 3/24/2003 22:23' prior: 0!I get signalled when no selector is defined for a message send, indicating a possible mispelling.  My default action is to create a new selector.!!UndeclaredVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/12/2003 14:28'!correctIn: compiler	self resume: (compiler correctVariable: self variableNode)! !!UndeclaredVariableWarning methodsFor: 'accessing' stamp: 'ajh 3/11/2003 12:05'!variableNode	^ variableNode! !!UndeclaredVariableWarning methodsFor: 'accessing' stamp: 'ajh 3/11/2003 23:37'!variableNode: aVariableNode	variableNode _ aVariableNode.	messageText _ 'Undeclared variable: ', aVariableNode name.! !!UndeclaredVariableWarning commentStamp: 'ajh 3/24/2003 22:33' prior: 0!I get signalled when an unknown variable it references.  My default action is to raise an warning.!!UndefinedObject methodsFor: '*newcompiler' stamp: 'ajh 6/23/2004 20:40'!parseScope	^ GlobalScope new! !!UninitializedVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/12/2003 14:28'!correctIn: compiler	self resume: (compiler queryUninitializedTemp: self variableNode)! !!UninitializedVariableWarning methodsFor: 'defaults' stamp: 'ajh 3/12/2003 13:37'!defaultAction	"unitialized temp will be initialized to nil, so ignore this warning if not handled"	^ nil! !!UninitializedVariableWarning methodsFor: 'accessing' stamp: 'ajh 3/12/2003 13:25'!variableNode	^ variableNode! !!UninitializedVariableWarning methodsFor: 'accessing' stamp: 'ajh 3/12/2003 14:08'!variableNode: aVariableNode	variableNode _ aVariableNode.	messageText _ 'Uninitialized temp: ', aVariableNode name.! !!UninitializedVariableWarning commentStamp: 'ajh 3/24/2003 22:34' prior: 0!I get signalled when a temporary variable is used before it is assigned to.  My default action is to allow it since all temps get initialized to nil.!!UnusedVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/12/2003 14:28'!correctIn: compiler	self resume: (compiler removeUnusedTemp: self variableNode)! !!UnusedVariableWarning methodsFor: 'defaults' stamp: 'ajh 3/12/2003 14:07'!defaultAction	"unused temp will be ignored, so ignore this warning if not handled"	^ nil! !!UnusedVariableWarning methodsFor: 'accessing' stamp: 'ajh 3/12/2003 14:06'!variableNode	^ variableNode! !!UnusedVariableWarning methodsFor: 'accessing' stamp: 'ajh 3/12/2003 14:07'!variableNode: aVariableNode	variableNode _ aVariableNode.	messageText _ 'Unused temp: ', aVariableNode name.! !!UnusedVariableWarning commentStamp: 'ajh 3/24/2003 22:35' prior: 0!I get signalled when a temporary variable is declared but never used.  My default action is to allow it since it is benign.!!UpdatingThreePhaseButtonMorph methodsFor: '*network-irc-gui' stamp: 'sbw 3/3/2002 12:04'!getNewBoolean	^ target perform: getSelector! !!UpdatingThreePhaseButtonMorph methodsFor: '*network-irc-gui' stamp: 'sbw 3/3/2002 12:05'!step	| newBoolean |	super step.	state == #pressed		ifTrue: [^ self].	newBoolean _ self getNewBoolean.	newBoolean == self isOn		ifFalse: [self				state: (newBoolean == true						ifTrue: [#on]						ifFalse: [#off])]! !!UpdatingThreePhaseIRCButtonMorph methodsFor: 'as yet unclassified' stamp: 'sbw 3/3/2002 11:59'!getArgument: aSymbol	getArgument _ aSymbol! !!UpdatingThreePhaseIRCButtonMorph methodsFor: 'as yet unclassified' stamp: 'sbw 3/3/2002 12:06'!getNewBoolean	^ getArgument isNil		ifTrue: [target perform: getSelector]		ifFalse: [target perform: getSelector with: getArgument]! !!UpdatingThreePhaseIRCButtonMorph commentStamp: '<historical>' prior: 0!allows for the #getSelector to use the get argument value if needed.!!UpdatingThreePhaseIRCButtonMorph class methodsFor: 'as yet unclassified' stamp: 'sbw 5/21/2004 23:00'!checkBox	"Answer a button pre-initialized with checkbox images."	| f |	^ self new onImage: (f := ScriptingSystem formAtKey: 'IrcCheckBoxOn');				pressedImage: (ScriptingSystem formAtKey: 'IrcCheckBoxPressed');				offImage: (ScriptingSystem formAtKey: 'IrcCheckBoxOff');		 extent: f extent + (2 @ 0);		 yourself! !!UpdatingThreePhaseIRCButtonMorph class methodsFor: 'as yet unclassified' stamp: 'sbw 5/21/2004 23:22'!initialize	"UpdatingThreePhaseIRCButtonMorph initialize"	| extent inset ircControlColor |	extent := 12 @ 12.	inset := 3.	ircControlColor := Color lightGray.	#('IrcCheckBoxOff' 'IrcCheckBoxOn' 'IrcCheckBoxPressed' )		do: [:button | 			| f r | 			f := Form extent: extent depth: 16.			f borderWidth: 1 color: Color black.			r := f boundingBox insetBy: inset.			button = 'IrcCheckBoxPressed'				ifTrue: [f						border: r						width: 1						fillColor: ircControlColor].			button = 'IrcCheckBoxOn'				ifTrue: [f						fill: r						rule: Form over						fillColor: ircControlColor].			ScriptingSystem saveForm: f atKey: button].	#('IrcRadioButtonOff' 'IrcRadioButtonOn' 'IrcRadioButtonPressed' )		do: [:button | 			| f r c | 			f := Form extent: extent depth: 16.			r := f boundingBox.			c := f getCanvas.			c frameOval: r color: Color black.			r := r insetBy: inset.			button = 'IrcRadioButtonPressed'				ifTrue: [c frameOval: r color: ircControlColor].			button = 'IrcRadioButtonOn'				ifTrue: [c fillOval: r color: ircControlColor].			ScriptingSystem saveForm: f atKey: button]! !!UpdatingThreePhaseIRCButtonMorph class methodsFor: 'as yet unclassified' stamp: 'sbw 5/21/2004 23:01'!radioButton	"Answer a button pre-initialized with radiobutton images."	| f |	^ self new onImage: (f := ScriptingSystem formAtKey: 'IrcRadioButtonOn');				pressedImage: (ScriptingSystem formAtKey: 'IrcRadioButtonPressed');				offImage: (ScriptingSystem formAtKey: 'IrcRadioButtonOff');		 extent: f extent + (2 @ 0);		 yourself! !!VariableEnvironment methodsFor: 'private'!accessorMethods	^#(#instanceVariables #instanceVariableReaders #instanceVariableWriters #classVariables)! !!VariableEnvironment methodsFor: 'private'!allClassesDo: aBlock 	| classes instVarBlock |	classes := Set new.	instVarBlock := 			[:each | 			| class |			class := self classForName: each.			classes addAll: class withAllSubclasses].	instanceVariables keysDo: instVarBlock.	instanceVariableReaders keysDo: instVarBlock.	instanceVariableWriters keysDo: instVarBlock.	classVariables keysDo: 			[:each | 			| class |			class := self classForName: each.			class notNil 				ifTrue: 					[classes						addAll: class withAllSubclasses;						addAll: class class withAllSubclasses]].	classes do: aBlock! !!VariableEnvironment methodsFor: 'private'!classForName: aString 	| name isMeta class |	isMeta := aString includes: $ .	name := (isMeta 				ifTrue: [aString copyFrom: 1 to: (aString size - 6 max: 1)]				ifFalse: [aString]) asSymbol.	class := Smalltalk at: name ifAbsent: [nil].	^class notNil & isMeta ifTrue: [class class] ifFalse: [class]! !!VariableEnvironment methodsFor: 'private' stamp: 'md 1/17/2006 14:17'!classVariableSelectorsFor: aClass 	| selectors classVars nonMetaClass |	nonMetaClass := aClass isMeta 				ifTrue: [aClass soleInstance]				ifFalse: [aClass].	selectors := Set new.	classVars := Set new.	classVariables keysDo: 			[:each | 			| cls |			cls := self classForName: each.			(cls notNil and: [nonMetaClass includesBehavior: cls]) 				ifTrue: [classVars addAll: (classVariables at: each)]].	classVars do: 			[:each | 			| binding |			binding := aClass bindingOf: each.			binding notNil 				ifTrue: [selectors addAll: (aClass whichSelectorsReferTo: binding)]].	^selectors! !!VariableEnvironment methodsFor: 'private'!classVariables	^classVariables! !!VariableEnvironment methodsFor: 'private'!classVariables: anObject	classVariables := anObject! !!VariableEnvironment methodsFor: 'private'!computeSelectorCacheFor: aClass 	^(self instanceVariableSelectorsFor: aClass)		addAll: (self classVariableSelectorsFor: aClass);		yourself! !!VariableEnvironment methodsFor: 'private'!flushCachesFor: aClass 	| nonMetaClass |	selectorCache isNil ifTrue: [^self].	nonMetaClass := aClass isMeta 				ifTrue: [aClass soleInstance]				ifFalse: [aClass].	nonMetaClass withAllSubclasses do: 			[:each | 			selectorCache				removeKey: each ifAbsent: [];				removeKey: each class ifAbsent: []]! !!VariableEnvironment methodsFor: 'private'!instanceVariableReaders	^instanceVariableReaders! !!VariableEnvironment methodsFor: 'private'!instanceVariableReaders: anObject	instanceVariableReaders := anObject! !!VariableEnvironment methodsFor: 'private'!instanceVariableSelectorsFor: aClass 	| selectors |	selectors := Set new.	#(#instanceVariables #instanceVariableReaders #instanceVariableWriters) 		with: #(#whichSelectorsAccess: #whichSelectorsRead: #whichSelectorsAssign:)		do: 			[:var :sel | 			| instVars |			instVars := Set new.			(self perform: var) keysDo: 					[:each | 					| cls |					cls := self classForName: each.					(cls notNil and: [aClass includesBehavior: cls]) 						ifTrue: [instVars addAll: ((self perform: var) at: each)]].			instVars do: [:each | selectors addAll: (aClass perform: sel with: each)]].	^selectors! !!VariableEnvironment methodsFor: 'private'!instanceVariableWriters	^instanceVariableWriters! !!VariableEnvironment methodsFor: 'private'!instanceVariableWriters: anObject	instanceVariableWriters := anObject! !!VariableEnvironment methodsFor: 'private'!instanceVariables	^instanceVariables! !!VariableEnvironment methodsFor: 'private'!instanceVariables: anObject	instanceVariables := anObject! !!VariableEnvironment methodsFor: 'private'!selectorCache	^selectorCache isNil 		ifTrue: [selectorCache := Dictionary new]		ifFalse: [selectorCache]! !!VariableEnvironment methodsFor: 'private'!selectorCacheFor: aClass 	^self selectorCache at: aClass		ifAbsentPut: [self computeSelectorCacheFor: aClass]! !!VariableEnvironment methodsFor: 'accessing'!addClass: aClass classVariable: aSymbol 	(classVariables at: aClass name ifAbsentPut: [Set new]) add: aSymbol.	self flushCachesFor: aClass.	self addSearchString: aSymbol! !!VariableEnvironment methodsFor: 'accessing'!addClass: aClass instanceVariable: aString 	(instanceVariables at: aClass name ifAbsentPut: [Set new]) add: aString.	self flushCachesFor: aClass.	self addSearchString: aString! !!VariableEnvironment methodsFor: 'accessing'!addClass: aClass instanceVariableReader: aString 	(instanceVariableReaders at: aClass name ifAbsentPut: [Set new]) 		add: aString.	self flushCachesFor: aClass.	self addSearchString: aString! !!VariableEnvironment methodsFor: 'accessing'!addClass: aClass instanceVariableWriter: aString 	(instanceVariableWriters at: aClass name ifAbsentPut: [Set new]) 		add: aString.	self flushCachesFor: aClass.	self addSearchString: aString! !!VariableEnvironment methodsFor: 'accessing'!classNamesWithVariables	| classNames |	classNames := Set new.	classNames		addAll: instanceVariables keys;		addAll: instanceVariableReaders keys;		addAll: instanceVariableWriters keys;		addAll: classVariables keys.	^classNames! !!VariableEnvironment methodsFor: 'accessing'!classVariablesFor: aClass 	^classVariables at: aClass name ifAbsent: [#()]! !!VariableEnvironment methodsFor: 'accessing' stamp: 'md 1/17/2006 14:17'!environmentForClassVariable: aSymbol in: aClass 	| selectorEnvironment assoc block |	selectorEnvironment := SelectorEnvironment onEnvironment: self.	selectorEnvironment addSearchString: aSymbol.	((classVariables at: aClass name ifAbsent: [#()]) includes: aSymbol) 		ifFalse: [^selectorEnvironment].	assoc := aClass bindingOf: aSymbol.	block := 			[:each | 			(each whichSelectorsReferTo: assoc) 				do: [:sel | selectorEnvironment addClass: each selector: sel]].	aClass withAllSubAndSuperclassesDo: 			[:each | 			block				value: each;				value: each class].	^selectorEnvironment! !!VariableEnvironment methodsFor: 'accessing' stamp: 'nk 2/26/2005 07:24'!environmentForInstanceVariable: aString in: aClass 	| selectorEnvironment isReader isWriter |	selectorEnvironment := SelectorEnvironment onEnvironment: self.	selectorEnvironment addSearchString: aString.	isReader := isWriter := false.	((instanceVariables at: aClass name ifAbsent: [#()]) includes: aString) 		ifTrue: 			[isReader := true.			isWriter := true].	((instanceVariableWriters at: aClass name ifAbsent: [#()]) 		includes: aString) ifTrue: [isWriter := true].	((instanceVariableReaders at: aClass name ifAbsent: [#()]) 		includes: aString) ifTrue: [isReader := true].	aClass withAllSubAndSuperclassesDo:			[:each | 			isWriter 				ifTrue: 					[(each whichSelectorsAssign: aString) 						do: [:sel | selectorEnvironment addClass: each selector: sel]].			isReader 				ifTrue: 					[(each whichSelectorsRead: aString) 						do: [:sel | selectorEnvironment addClass: each selector: sel]]].	^selectorEnvironment! !!VariableEnvironment methodsFor: 'accessing'!instanceVariablesFor: aClass 	| vars name |	vars := Set new.	name := aClass name.	vars		addAll: (instanceVariables at: name ifAbsent: [#()]);		addAll: (instanceVariableReaders at: name ifAbsent: [#()]);		addAll: (instanceVariableWriters at: name ifAbsent: [#()]).	^vars! !!VariableEnvironment methodsFor: 'accessing'!numberVariables	^self accessorMethods inject: 0		into: [:sum :each | sum + ((self perform: each) inject: 0 into: [:s :e | s + e size])]! !!VariableEnvironment methodsFor: 'accessing'!problemCount	^self numberVariables! !!VariableEnvironment methodsFor: 'accessing'!removeClass: aClass classVariable: aSymbol 	| vars |	vars := classVariables at: aClass name ifAbsent: [Set new].	vars remove: aSymbol ifAbsent: [].	vars isEmpty ifTrue: [classVariables removeKey: aClass name ifAbsent: []].	self flushCachesFor: aClass! !!VariableEnvironment methodsFor: 'accessing'!removeClass: aClass instanceVariable: aString 	| vars |	vars := instanceVariables at: aClass name ifAbsent: [Set new].	vars remove: aString ifAbsent: [].	vars isEmpty 		ifTrue: [instanceVariables removeKey: aClass name ifAbsent: []].	self flushCachesFor: aClass! !!VariableEnvironment methodsFor: 'accessing'!removeClass: aClass instanceVariableReader: aString 	| vars |	vars := instanceVariableReaders at: aClass name ifAbsent: [Set new].	vars remove: aString ifAbsent: [].	vars isEmpty 		ifTrue: [instanceVariableReaders removeKey: aClass name ifAbsent: []].	self flushCachesFor: aClass! !!VariableEnvironment methodsFor: 'accessing'!removeClass: aClass instanceVariableWriter: aString 	| vars |	vars := instanceVariableWriters at: aClass name ifAbsent: [Set new].	vars remove: aString ifAbsent: [].	vars isEmpty 		ifTrue: [instanceVariableWriters removeKey: aClass name ifAbsent: []].	self flushCachesFor: aClass! !!VariableEnvironment methodsFor: 'copying'!copyDictionary: aDictionary 	| copy |	copy := Dictionary new: aDictionary size.	aDictionary keysAndValuesDo: [:key :value | copy at: key put: value].	^copy! !!VariableEnvironment methodsFor: 'copying'!postCopy	super postCopy.	instanceVariables := self copyDictionary: instanceVariables.	instanceVariableReaders := self copyDictionary: instanceVariableReaders.	instanceVariableWriters := self copyDictionary: instanceVariableWriters.	classVariables := self copyDictionary: classVariables.	selectorCache := nil! !!VariableEnvironment methodsFor: 'testing'!includesCategory: aCategory 	^(self classNamesFor: aCategory) isEmpty not! !!VariableEnvironment methodsFor: 'testing'!includesClass: aClass 	(super includesClass: aClass) ifFalse: [^false].	(instanceVariables includesKey: aClass) ifTrue: [^true].	(classVariables includesKey: aClass) ifTrue: [^true].	^((self selectorCacheFor: aClass) 		detect: [:each | self includesSelector: each in: aClass]		ifNone: [nil]) notNil! !!VariableEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass 	^(self selectorsFor: aProtocol in: aClass) isEmpty not! !!VariableEnvironment methodsFor: 'testing'!includesSelector: aSymbol in: aClass 	^(environment includesSelector: aSymbol in: aClass) 		and: [(self selectorCacheFor: aClass) includes: aSymbol]! !!VariableEnvironment methodsFor: 'testing'!isEmpty	self accessorMethods 		do: [:each | (self perform: each) isEmpty ifFalse: [^false]].	^true! !!VariableEnvironment methodsFor: 'initialize-release'!initialize	super initialize.	instanceVariables := Dictionary new.	classVariables := Dictionary new.	instanceVariableReaders := Dictionary new.	instanceVariableWriters := Dictionary new! !!VariableEnvironment methodsFor: 'printing' stamp: 'bh 4/29/2000 18:10'!logOrInspect	Transcript cr; cr; show:self name.	instanceVariables keysAndValuesDo: 		[:class :variables | 		variables do: 			[:variable |			Transcript cr; show: '     ',class name asString , '->' , variable asString]].	classVariables keysAndValuesDo: 		[:class :variables | 		variables do: 			[:variable |			Transcript cr; show: '     ',class name asString , ' (cvar) ' , variable asString]].! !!VariableEnvironment methodsFor: 'printing'!storeOn: aStream 	aStream		nextPut: $(;		nextPutAll: self class name;		nextPutAll: ' new '.	#(#instanceVariables #instanceVariableReaders #instanceVariableWriters #classVariables) 		do: 			[:each | 			aStream				nextPutAll: each;				nextPutAll: ': '.			(self perform: each) storeOn: aStream.			aStream nextPutAll: '; '].	aStream nextPutAll: ' yourself)'! !!VariableEnvironment methodsFor: '*RefactoringEngine' stamp: 'dvf 10/3/2001 01:32'!openEditor	^(VariableEnvironmentBrowser openOnEnvironment: self) openInWorld.! !!VariableEnvironment class methodsFor: 'instance creation' stamp: 'nk 3/4/2005 13:20'!on: anEnvironment readersOfInstanceVariable: aString in: aClass 	| newEnv |	newEnv := (self onEnvironment: anEnvironment)				label: 'Readers of ''' , aString , ''' in ' , aClass name;				yourself.	(aClass whichClassDefinesInstVar: aString) withAllSubclassesDo: 			[:cls | 			(cls whichSelectorsRead: aString) isEmpty				ifFalse: [newEnv addClass: cls instanceVariableReader: aString]].	^newEnv! !!VariableEnvironment class methodsFor: 'instance creation' stamp: 'md 1/17/2006 14:17'!on: anEnvironment referencesToClassVariable: aSymbol in: aClass 	| newEnv definingClass assoc |	newEnv := (self onEnvironment: anEnvironment)				label: 'References to ''' , aSymbol , ''' in ' , aClass name;				yourself.	definingClass := aClass whichClassDefinesClassVar: aSymbol.	assoc := definingClass bindingOf: aSymbol.	definingClass withAllSubclassesDo: 			[:cls | 			(cls whichSelectorsReferTo: assoc) isEmpty 				ifFalse: [newEnv addClass: cls classVariable: aSymbol]].	^newEnv! !!VariableEnvironment class methodsFor: 'instance creation' stamp: 'nk 3/4/2005 13:23'!on: anEnvironment referencesToInstanceVariable: aString in: aClass 	| newEnv |	newEnv := (self onEnvironment: anEnvironment)				label: 'References to ''' , aString , ''' in ' , aClass name;				yourself.	(aClass whichClassDefinesInstVar: aString) withAllSubclassesDo: 			[:cls | 			((cls whichSelectorsRead: aString) isEmpty not 				or: [(cls whichSelectorsAssign: aString) isEmpty not]) 					ifTrue: [newEnv addClass: cls instanceVariable: aString]].	^newEnv! !!VariableEnvironment class methodsFor: 'instance creation' stamp: 'nk 3/4/2005 13:17'!on: anEnvironment writersOfInstanceVariable: aString in: aClass 	| newEnv |	newEnv := (self onEnvironment: anEnvironment)				label: 'Writers of ''' , aString , ''' in ' , aClass name;				yourself.	(aClass whichClassDefinesInstVar: aString) withAllSubclassesDo: 			[:cls | 			(cls whichSelectorsAssign: aString) isEmpty				ifFalse: [newEnv addClass: cls instanceVariableWriter: aString]].	^newEnv! !!VariableEnvironment class methodsFor: 'instance creation'!readersOfInstanceVariable: aString in: aClass 	^self 		on: BrowserEnvironment new		readersOfInstanceVariable: aString		in: aClass! !!VariableEnvironment class methodsFor: 'instance creation'!referencesToClassVariable: aSymbol in: aClass 	^self 		on: BrowserEnvironment new		referencesToClassVariable: aSymbol		in: aClass! !!VariableEnvironment class methodsFor: 'instance creation'!referencesToInstanceVariable: aString in: aClass 	^self 		on: BrowserEnvironment new		referencesToInstanceVariable: aString		in: aClass! !!VariableEnvironment class methodsFor: 'instance creation'!writersOfInstanceVariable: aString in: aClass 	^self 		on: BrowserEnvironment new		writersOfInstanceVariable: aString		in: aClass! !!VariableEnvironmentBrowser methodsFor: 'metaclass' stamp: 'nk 3/4/2005 11:04'!addMorphicSwitchesTo: window 	^window! !!VariableEnvironmentBrowser methodsFor: 'metaclass' stamp: 'nk 2/25/2005 16:39'!indicateClassMessages! !!VariableEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/2/2005 14:06'!classList	^self browserEnvironment classNamesWithVariables asSortedCollection! !!VariableEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 2/26/2005 12:04'!classListFrame	^LayoutFrame fractions: (0 @ 0 extent: 0.5 @ 0.4)! !!VariableEnvironmentBrowser methodsFor: 'accessing' stamp: 'nk 3/2/2005 14:06'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	| cls variables ranges firstRange firstQuote |	(cls := self selectedClassOrMetaClass) ifNil: [^1 to: 0].	variables := OrderedCollection 				withAll: (self browserEnvironment instanceVariablesFor: cls).	variables addAll: (self browserEnvironment classVariablesFor: cls).	firstQuote := self contents indexOf: $'.	firstQuote isZero ifTrue: [firstQuote := 1].	ranges := SortedCollection sortBlock: [:a :b | a first < b first].	ranges 		addAll: (variables collect: 					[:var | 					{ 						self contents 							indexOfSubCollection: var							startingAt: firstQuote							ifAbsent: self contents size.						var size}]).	firstRange := ranges at: 1 ifAbsent: [^1 to: 0].	^firstRange first to: firstRange first + firstRange second - 1! !!VariableEnvironmentBrowser methodsFor: 'nil' stamp: 'nk 3/2/2005 14:36'!instanceMessagesIndicated	^true! !!VariableEnvironmentBrowser methodsFor: 'message list' stamp: 'nk 3/2/2005 14:38'!messageList	self selectedClass ifNil: [^Array new].	^(self instanceMessagesIndicated 		ifTrue: 			[self browserEnvironment instanceVariableSelectorsFor: self selectedClassOrMetaClass]		ifFalse: 			[self browserEnvironment classVariableSelectorsFor: self selectedClassOrMetaClass]) 			asSortedCollection! !!VariableEnvironmentBrowser class methodsFor: 'as yet unclassified' stamp: 'bh 5/16/2000 22:52'!newOnEnvironment: aBrowserEnvironment	^self new initializeOnEnvironment: aBrowserEnvironment.! !!VariableEnvironmentBrowser class methodsFor: 'as yet unclassified' stamp: 'bh 5/16/2000 22:52'!openOnEnvironment: aBrowserEnvironment		^(self newOnEnvironment: aBrowserEnvironment) open.! !!VariableEnvironmentTest methodsFor: 'tests'!testAddRemove	| refs |	refs := VariableEnvironment new.	refs addClass: RefactoringManager instanceVariable: 'refactorings'.	self assert: refs numberSelectors > 0.	self assert: refs numberClasses = 1.	refs removeClass: RefactoringManager instanceVariable: 'refactorings'.	self assert: refs numberSelectors = 0.	self assert: refs numberClasses = 0.	refs addClass: RefactoringManager instanceVariableReader: 'refactorings'.	self assert: refs numberSelectors > 0.	self assert: refs numberClasses = 1.	refs removeClass: RefactoringManager instanceVariableReader: 'refactorings'.	self assert: refs numberSelectors = 0.	self assert: refs numberClasses = 0.	refs addClass: RefactoringManager instanceVariableWriter: 'refactorings'.	self assert: refs numberSelectors > 0.	self assert: refs numberClasses = 1.	refs removeClass: RefactoringManager instanceVariableWriter: 'refactorings'.	self assert: refs numberSelectors = 0.	self assert: refs numberClasses = 0! !!VariableEnvironmentTest methodsFor: 'tests'!testInstVars	| refs writers readers |	refs := VariableEnvironment referencesToInstanceVariable: 'refactorings'				in: RefactoringManager.	writers := VariableEnvironment writersOfInstanceVariable: 'refactorings'				in: RefactoringManager.	readers := VariableEnvironment readersOfInstanceVariable: 'refactorings'				in: RefactoringManager.	self universalTestFor: refs.	self universalTestFor: writers.	self universalTestFor: readers.	self assert: refs numberSelectors = (writers | readers) numberSelectors! !!VariableRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' variable: '.	variableName storeOn: aStream.	aStream nextPutAll: ' class: '.	class storeOn: aStream.	aStream nextPut: $)! !!VariableRefactoring methodsFor: 'initialize-release'!variable: aVarName class: aClass 	class := self classObjectFor: aClass.	variableName := aVarName! !!VariableRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk variable: aVarName class: aClass 	^(self new)		model: aRBSmalltalk;		variable: aVarName class: aClass;		yourself! !!VariableRefactoring class methodsFor: 'instance creation'!variable: aVarName class: aClass	^self new variable: aVarName class: aClass! !!VariableTypeTest methodsFor: 'tests'!testBasicLintRuleTypes	| typer types |	typer := RefactoryTyper new.	types := typer guessTypesFor: 'classBlock' in: BasicLintRuleTest.	"self assert: types size = 1."	self 		assert: ([] class withAllSuperclasses 				detect: [:each | types includes: (typer model classFor: each)]				ifNone: [nil]) notNil.	types := typer typesFor: 'methodBlock' in: (typer model classFor: BasicLintRuleTest).	"self should: [types size = 2]."	self 		assert: ([] class withAllSuperclasses 				detect: [:each | types includes: (typer model classFor: each)]				ifNone: [nil]) notNil.	"self should: [types includes: MessageChannel]."	typer printString! !!VariableTypeTest methodsFor: 'tests' stamp: 'bh 4/4/2000 09:32'!testCompositeLintRuleTypes	| typer types |	typer := RefactoryTyper new runOn: CompositeLintRuleTest.	types := typer guessTypesFor: 'rules'.	self assert: types size = 1.	self assert: (types includes: (typer model classFor: Collection)).	types := typer typesFor: '-rules-'.	self assert: types size = 2.	self assert: (types includes: (typer model classFor: LintRule)).	self assert: (types includes: (typer model classFor: LintRuleTest)).	self assert: (typer guessTypesFor: 'asdf') isEmpty.	typer printString! !!VariableTypeTest methodsFor: 'tests'!testLintRuleTypes	| typer types |	typer := RefactoryTyper new.	types := typer guessTypesFor: 'name' in: LintRuleTest.	self assert: types size = 1.	self assert: (types includes: (typer model classFor: String))! !!VariableTypeTest methodsFor: 'tests'!testParseTreeTypes	| types model |	model := RBNamespace new.	types := RefactoryTyper 				typesFor: 'foo'				in: (RBParser 						parseExpression: 'foo printString; testBasicLintRuleTypes; testParseTreeTypes')				model: model.	self assert: types size = 1.	self assert: (types includes: (model classFor: self class))! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:07'!refresh	"This is a one-time only method for bootstraping the new registry. Here we will scan all classes for #windowColorSpecification methods and register those to the registry"	registry := nil.	((self systemNavigation allClassesImplementing: #windowColorSpecification)		collect: [:aClass | aClass theNonMetaClass windowColorSpecification])		do: [:spec | self registerColorSpecification: spec toClassNamed: spec classSymbol ].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:11'!registry	^registry ifNil: [registry := Dictionary new].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:11'!unregisterColorSpecificationForClassNamed: aClassName		self registry removeKey: aClassName asSymbol ! !!WrapperForC methodsFor: 'very few messages' stamp: 'Y.-G.G. 4/4/2014 14:59'!doesNotUnderstand: aMessage	"Intercept the selector foo:"	| sel arg newArg |	sel := aMessage selector.	sel = 'foo:' ifTrue: [		arg := (aMessage arguments) at: 1.		newArg := arg asUppercase.		Transcript show: 'Intercepting message send: ' ; show: sel ; cr.		Transcript tab ; show: 'Original arguments: ' ; show: arg ; cr.		Transcript tab ; show: 'New arguments: ' ; show: newArg ; cr.			aMessage argument: newArg.		aMessage sendTo: (self xxxViewedObject)	]	ifFalse: [		"Transcript show: aMessage."	]! !!XMLLoggingFormatter methodsFor: 'printing'!formatEvent: anEvent on: aStream from: aLogger 	aStream		nextPutAll: '<LoggingEvent loggerName=''';		nextPutAll: aLogger name;		nextPutAll: ''' category=''';		nextPutAll: anEvent categoryString;		nextPutAll: ''' level=''';		nextPutAll: anEvent levelString;		nextPutAll: ''' timestamp='''.	self tsFormatter formatTimestamp: anEvent timeStamp on: aStream.	aStream		nextPutAll: '''>';		cr;		tab;		nextPutAll: '	<Message>';		nextPutAll: anEvent messageString;		nextPutAll: '</Message>'.	anEvent context isNil 		ifFalse: 			[aStream				cr;				tab;				nextPutAll: '	<Context>';				nextPutAll: anEvent context;				nextPutAll: '</Context>'].	aStream		cr;		nextPutAll: '</LoggingEvent>'			! !!XMLLoggingFormatter class methodsFor: 'instance creation'!defaultFormat	^self iso8601Format			! !!XMLLoggingFormatter class methodsFor: '*Toothpick-Configuration'!mappingKey	^'xml'			! !----QUIT----an Array(14 April 2014 5:09:44 pm) Demo.image priorSource: 2619949!----STARTUP----an Array(14 April 2014 5:12:39 pm) as D:\Software\Smalltalk Environments\Reflection in Smalltalk - Copy\Demo.image!Smalltalk compressSources! !----QUIT----an Array(14 April 2014 5:14:43 pm) Demo.image priorSource: 2619949!----STARTUP----an Array(14 April 2014 5:14:55 pm) as D:\Software\Smalltalk Environments\Reflection in Smalltalk - Copy\Demo.image!----QUIT----an Array(14 April 2014 5:15:21 pm) Demo.image priorSource: 2620192!